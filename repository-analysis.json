{
  "timestamp": "2024-12-16T10:13:11.490Z",
  "analysis": {
    "files": [
      {
        "path": "App.js",
        "content": "import React, { useState, useCallback, useEffect, useRef } from 'react';\nimport 'leaflet/dist/leaflet.css';\nimport { ThemeProvider } from '@mui/material/styles';\nimport { CssBaseline, Toolbar, IconButton, Box, useMediaQuery } from '@mui/material';\nimport MenuIcon from '@mui/icons-material/Menu';\nimport { styled } from '@mui/material/styles';\nimport AppBar from '@mui/material/AppBar';\nimport { toggleDarkMode } from './slices/themeSlice';\nimport { fetchFlowData } from './slices/flowSlice';\nimport Header from './components/common/Header';\nimport { Sidebar } from './components/common/Navigation';\nimport Dashboard from './Dashboard';\nimport LoadingSpinner from './components/common/LoadingSpinner';\nimport ErrorDisplay from './components/common/ErrorDisplay';\nimport EnhancedErrorBoundary from './components/common/EnhancedErrorBoundary';\nimport MethodologyModal from './components/methodology/MethodologyModal';\nimport { WelcomeModal } from './components/common/WelcomeModal';\nimport StateExporter from './components/utils/StateExporter';\nimport { setHasSeenWelcome } from './store/welcomeModalSlice';\nimport { useWindowSize } from './hooks';\nimport { backgroundMonitor, MetricTypes } from './utils/backgroundMonitor';\nimport { fetchAllSpatialData } from './slices/spatialSlice';\nimport { useAppState } from './hooks/useAppState';\nimport { initializeStore } from './store';\n\nconst DRAWER_WIDTH = 240;\nconst DEFAULT_DATE = '2020-10-01';\n\nconst StyledAppBar = styled(AppBar, {\n  shouldForwardProp: (prop) => prop !== 'open',\n})(({ theme, open }) => ({\n  zIndex: theme.zIndex.drawer + 1,\n  transition: theme.transitions.create(['margin-left', 'width'], {\n    easing: theme.transitions.easing.sharp,\n    duration: theme.transitions.duration.leavingScreen,\n  }),\n  [theme.breakpoints.up('sm')]: {\n    width: `calc(100% - ${open ? DRAWER_WIDTH : 0}px)`,\n    marginLeft: open ? `${DRAWER_WIDTH}px` : 0,\n  },\n}));\n\nconst App = () => {\n  const {\n    dispatch,\n    data,\n    loading,\n    error,\n    hasSeenWelcome,\n    isDarkMode,\n    commodities,\n    theme,\n  } = useAppState();\n\n  const appInitialized = useRef(false);\n  const storeInitialized = useRef(false);\n  const abortController = useRef(null);\n\n  const isSmUp = useMediaQuery(theme.breakpoints.up('sm'));\n  const windowSize = useWindowSize();\n\n  const [sidebarOpen, setSidebarOpen] = useState(isSmUp);\n  const [selectedCommodity, setSelectedCommodity] = useState('');\n  const [selectedDate, setSelectedDate] = useState(DEFAULT_DATE);\n  const [selectedAnalysis, setSelectedAnalysis] = useState('spatial');\n  const [selectedGraphRegimes, setSelectedGraphRegimes] = useState(['unified']);\n  const [spatialViewConfig, setSpatialViewConfig] = useState({\n    center: [15.3694, 44.191],\n    zoom: 6,\n  });\n  const [modalStates, setModalStates] = useState({\n    methodology: false,\n  });\n\n  // Initialize store first\n  useEffect(() => {\n    const initStore = async () => {\n      if (storeInitialized.current) return;\n      try {\n        await initializeStore();\n        storeInitialized.current = true;\n      } catch (error) {\n        console.error('Failed to initialize store:', error);\n      }\n    };\n    initStore();\n  }, []);\n\n  // Then initialize app data after store is ready\n  useEffect(() => {\n    const initializeApp = async () => {\n      if (!storeInitialized.current || appInitialized.current || loading) return;\n\n      const initMetric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n        component: 'app',\n        startTime: performance.now()\n      });\n\n      try {\n        // Create new abort controller if needed\n        if (!abortController.current) {\n          abortController.current = new AbortController();\n        }\n\n        // Initial data load\n        await dispatch(fetchAllSpatialData({ \n          commodity: '', \n          date: DEFAULT_DATE,\n          signal: abortController.current?.signal\n        }));\n\n        // Set initial commodity after data load\n        if (commodities.length > 0) {\n          const initialCommodity = commodities[0]?.toLowerCase();\n          if (initialCommodity && !selectedCommodity) {\n            setSelectedCommodity(initialCommodity);\n            await dispatch(fetchAllSpatialData({ \n              commodity: initialCommodity, \n              date: DEFAULT_DATE,\n              signal: abortController.current?.signal\n            }));\n          }\n        }\n\n        appInitialized.current = true;\n        initMetric.finish({ \n          status: 'success',\n          initTime: performance.now() - initMetric.startTime\n        });\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          console.error('Error initializing app:', err);\n          initMetric.finish({ \n            status: 'error',\n            error: err.message\n          });\n        }\n      }\n    };\n\n    initializeApp();\n\n    // Cleanup function\n    return () => {\n      if (abortController.current) {\n        abortController.current.abort();\n        abortController.current = null;\n      }\n    };\n  }, [loading, dispatch, commodities, selectedCommodity, storeInitialized]);\n\n  const handleCommodityChange = useCallback((newCommodity) => {\n    if (!newCommodity || newCommodity === selectedCommodity || loading) return;\n\n    // Cancel any existing request\n    if (abortController.current) {\n      abortController.current.abort();\n    }\n\n    setSelectedCommodity(newCommodity);\n    \n    // Create new abort controller\n    abortController.current = new AbortController();\n    \n    const metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.PERFORMANCE, {\n      action: 'commodity-change',\n      commodity: newCommodity\n    });\n    \n    Promise.all([\n      dispatch(fetchAllSpatialData({ \n        commodity: newCommodity, \n        date: selectedDate,\n        signal: abortController.current?.signal\n      })),\n      dispatch(fetchFlowData({ \n        commodity: newCommodity, \n        date: selectedDate,\n        signal: abortController.current?.signal\n      }))\n    ]).then(() => {\n      metric.finish({ status: 'success' });\n    }).catch((error) => {\n      if (error.name !== 'AbortError') {\n        metric.finish({ status: 'error', error: error.message });\n        console.error('Error loading commodity data:', error);\n      }\n    });\n  }, [selectedCommodity, selectedDate, loading, dispatch]);\n\n  const handleDateChange = useCallback((newDate) => {\n    if (newDate && newDate !== selectedDate) {\n      setSelectedDate(newDate);\n      if (selectedCommodity) {\n        const metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.PERFORMANCE, {\n          action: 'date-change',\n          date: newDate\n        });\n        \n        // Create new abort controller for date change\n        if (abortController.current) {\n          abortController.current.abort();\n        }\n        abortController.current = new AbortController();\n\n        Promise.all([\n          dispatch(fetchAllSpatialData({ \n            commodity: selectedCommodity, \n            date: newDate,\n            signal: abortController.current?.signal\n          })),\n          dispatch(fetchFlowData({ \n            commodity: selectedCommodity, \n            date: newDate,\n            signal: abortController.current?.signal\n          }))\n        ]).then(() => {\n          metric.finish({ status: 'success' });\n        }).catch((error) => {\n          if (error.name !== 'AbortError') {\n            metric.finish({ status: 'error', error: error.message });\n            console.error('Error loading date data:', error);\n          }\n        });\n      }\n    }\n  }, [selectedCommodity, selectedDate, dispatch]);\n\n  const handleToggleDarkMode = useCallback(() => {\n    dispatch(toggleDarkMode());\n  }, [dispatch]);\n\n  const handleDrawerToggle = useCallback(() => {\n    setSidebarOpen((prev) => !prev);\n  }, []);\n\n  const handleModalToggle = useCallback((modalName, isOpen) => {\n    if (modalName === 'welcome') return;\n    setModalStates((prev) => ({ ...prev, [modalName]: isOpen }));\n  }, []);\n\n  const handleWelcomeModalClose = useCallback((dontShowAgain) => {\n    dispatch(setHasSeenWelcome(dontShowAgain));\n  }, [dispatch]);\n\n  if (error) {\n    return (\n      <ErrorDisplay\n        error={error}\n        title=\"Application Error\"\n        showDetails={process.env.NODE_ENV === 'development'}\n        onRetry={() => window.location.reload()}\n      />\n    );\n  }\n\n  if (!storeInitialized.current) {\n    return (\n      <Box sx={{ \n        display: 'flex', \n        justifyContent: 'center', \n        alignItems: 'center', \n        height: '100vh' \n      }}>\n        <LoadingSpinner message=\"Initializing application...\" />\n      </Box>\n    );\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <CssBaseline />\n      <EnhancedErrorBoundary>\n        <Box \n          sx={{ display: 'flex', minHeight: '100vh' }}\n          className={isDarkMode ? 'mui-dark-mode' : ''}\n        >\n          <StyledAppBar position=\"fixed\" open={sidebarOpen && isSmUp}>\n            <Toolbar>\n              <IconButton\n                color=\"inherit\"\n                aria-label=\"toggle drawer\"\n                edge=\"start\"\n                onClick={handleDrawerToggle}\n                sx={{ marginRight: 2 }}\n              >\n                <MenuIcon />\n              </IconButton>\n              <Header\n                isDarkMode={isDarkMode}\n                toggleDarkMode={handleToggleDarkMode}\n              />\n            </Toolbar>\n          </StyledAppBar>\n\n          <Sidebar\n            commodities={commodities.map((c) => c.toLowerCase())}\n            regimes={data?.regimes || ['unified', 'north', 'south']}\n            selectedCommodity={selectedCommodity.toLowerCase()}\n            setSelectedCommodity={handleCommodityChange}\n            selectedDate={selectedDate}\n            setSelectedDate={handleDateChange}\n            selectedAnalysis={selectedAnalysis}\n            setSelectedAnalysis={setSelectedAnalysis}\n            sidebarOpen={sidebarOpen}\n            setSidebarOpen={setSidebarOpen}\n            isSmUp={isSmUp}\n            onMethodologyClick={() => handleModalToggle('methodology', true)}\n            selectedRegimes={selectedGraphRegimes}\n            setSelectedRegimes={setSelectedGraphRegimes}\n            onOpenWelcomeModal={() => handleModalToggle('welcome', true)}\n            handleDrawerToggle={handleDrawerToggle}\n          />\n\n          <Box\n            component=\"main\"\n            sx={{\n              flexGrow: 1,\n              p: 3,\n              width: { sm: `calc(100% - ${DRAWER_WIDTH}px)` },\n              ml: { sm: `${DRAWER_WIDTH}px` },\n            }}\n          >\n            <Toolbar />\n            {loading ? (\n              <Box sx={{ \n                display: 'flex', \n                justifyContent: 'center', \n                alignItems: 'center', \n                height: '100%' \n              }}>\n                <LoadingSpinner />\n              </Box>\n            ) : (\n              <Dashboard\n                spatialData={data}\n                selectedCommodity={selectedCommodity}\n                selectedDate={selectedDate}\n                selectedRegimes={selectedGraphRegimes}\n                selectedAnalysis={selectedAnalysis}\n                windowWidth={windowSize.width}\n                spatialViewConfig={spatialViewConfig}\n                onSpatialViewChange={setSpatialViewConfig}\n              />\n            )}\n          </Box>\n\n          <StateExporter />\n\n          <MethodologyModal\n            open={modalStates.methodology}\n            onClose={() => handleModalToggle('methodology', false)}\n          />\n          <WelcomeModal\n            open={!hasSeenWelcome}\n            onClose={handleWelcomeModalClose}\n          />\n        </Box>\n      </EnhancedErrorBoundary>\n    </ThemeProvider>\n  );\n};\n\nexport default App;\n",
        "imports": [
          "react",
          "leaflet/dist/leaflet.css",
          "@mui/material/styles",
          "@mui/material",
          "@mui/icons-material/Menu",
          "@mui/material/styles",
          "@mui/material/AppBar",
          "./slices/themeSlice",
          "./slices/flowSlice",
          "./components/common/Header",
          "./components/common/Navigation",
          "./Dashboard",
          "./components/common/LoadingSpinner",
          "./components/common/ErrorDisplay",
          "./components/common/EnhancedErrorBoundary",
          "./components/methodology/MethodologyModal",
          "./components/common/WelcomeModal",
          "./components/utils/StateExporter",
          "./store/welcomeModalSlice",
          "./hooks",
          "./utils/backgroundMonitor",
          "./slices/spatialSlice",
          "./hooks/useAppState",
          "./store"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "leaflet/dist/leaflet.css",
          "@mui/material/styles",
          "@mui/material",
          "@mui/icons-material/Menu",
          "@mui/material/AppBar",
          "./slices/themeSlice",
          "./slices/flowSlice",
          "./components/common/Header",
          "./components/common/Navigation",
          "./Dashboard",
          "./components/common/LoadingSpinner",
          "./components/common/ErrorDisplay",
          "./components/common/EnhancedErrorBoundary",
          "./components/methodology/MethodologyModal",
          "./components/common/WelcomeModal",
          "./components/utils/StateExporter",
          "./store/welcomeModalSlice",
          "./hooks",
          "./utils/backgroundMonitor",
          "./slices/spatialSlice",
          "./hooks/useAppState",
          "./store"
        ]
      },
      {
        "path": "App.test.js",
        "content": "import React from 'react';\nimport { render } from '@testing-library/react';\n\ndescribe('Basic React Test', () => {\n  test('can render a basic component', () => {\n    const TestComponent = () => <div>Test Component</div>;\n    const { container } = render(<TestComponent />);\n    expect(container).toBeTruthy();\n  });\n});\n",
        "imports": [
          "react",
          "@testing-library/react"
        ],
        "exports": [],
        "dependencies": [
          "react",
          "@testing-library/react"
        ]
      },
      {
        "path": "Dashboard.js",
        "content": "// src/Dashboard.js\n\nimport React, { Suspense, useMemo, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, Grid, useTheme, useMediaQuery } from '@mui/material';\nimport { useUnifiedData } from './hooks/useUnifiedData';\nimport InteractiveChart from './components/interactive_graph/InteractiveChart';\nimport LoadingSpinner from './components/common/LoadingSpinner';\nimport ErrorMessage from './components/common/ErrorMessage';\nimport AnalysisWrapper from './components/common/AnalysisWrapper';\nimport { SpatialAnalysis } from './components/spatialAnalysis';\nimport { backgroundMonitor, MetricTypes } from './utils/backgroundMonitor';\nimport _ from 'lodash';\n\nimport {\n  Chart as ChartJS,\n  CategoryScale,\n  LinearScale,\n  PointElement,\n  LineElement,\n  TimeScale,\n  Tooltip,\n  Legend,\n  Filler,\n} from 'chart.js';\nimport 'chartjs-adapter-date-fns';\n\n// Register ChartJS components\nChartJS.register(\n  CategoryScale,\n  LinearScale,\n  PointElement,\n  LineElement,\n  TimeScale,\n  Tooltip,\n  Legend,\n  Filler\n);\n\n// Lazy load analysis components with error handling\nconst loadComponent = async (importFn, componentName) => {\n  const metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.PERFORMANCE, {\n    action: 'load-component',\n    component: componentName\n  });\n\n  try {\n    const module = await importFn();\n    if (!module.default) {\n      throw new Error(`${componentName} component not found`);\n    }\n    metric?.finish({ status: 'success' });\n    return module;\n  } catch (error) {\n    metric?.finish({ \n      status: 'error',\n      error: error.message \n    });\n    backgroundMonitor.logError(MetricTypes.SYSTEM.ERROR, {\n      component: componentName,\n      error: error.message,\n      stack: error.stack\n    });\n    throw error;\n  }\n};\n\nconst ECMAnalysisLazy = React.lazy(() =>\n  loadComponent(\n    () => import('./components/analysis/ecm/ECMAnalysis'),\n    'ECMAnalysis'\n  )\n);\n\nconst PriceDifferentialAnalysisLazy = React.lazy(() =>\n  loadComponent(\n    () => import('./components/analysis/price-differential/PriceDifferentialAnalysis'),\n    'PriceDifferentialAnalysis'\n  )\n);\n\nconst TVMIIAnalysisLazy = React.lazy(() =>\n  loadComponent(\n    () => import('./components/analysis/tvmii/TVMIIAnalysis'),\n    'TVMIIAnalysis'\n  )\n);\n\nconst SpatialModelAnalysis = React.lazy(() =>\n  loadComponent(\n    () => import('./components/analysis/spatial/SpatialAnalysis'),\n    'SpatialAnalysis'\n  )\n);\n\nconst Dashboard = React.memo(({\n  selectedAnalysis = 'spatial',\n  selectedCommodity,\n  selectedRegimes,\n  windowWidth,\n  spatialViewConfig,\n  onSpatialViewChange,\n}) => {\n  const theme = useTheme();\n  const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm')); // MUI's breakpoint for small screens\n\n  const { data, loading, error, getFilteredData } = useUnifiedData();\n  \n  const chartData = useMemo(() => {\n    const metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.PERFORMANCE, {\n      action: 'filter-data',\n      commodity: selectedCommodity\n    });\n\n    try {\n      const filtered = getFilteredData(selectedCommodity, selectedRegimes);\n      metric?.finish({ \n        status: 'success',\n        dataPoints: filtered?.length || 0\n      });\n      return filtered;\n    } catch (err) {\n      metric?.finish({ \n        status: 'error',\n        error: err.message \n      });\n      backgroundMonitor.logError(MetricTypes.SYSTEM.ERROR, {\n        component: 'dashboard-filter',\n        error: err.message,\n        stack: err.stack\n      });\n      return [];\n    }\n  }, [getFilteredData, selectedCommodity, selectedRegimes]);\n\n  // Analysis components registry\n  const analysisComponents = useMemo(() => ({\n    spatial: SpatialAnalysis,\n    ecm: ECMAnalysisLazy,\n    priceDiff: PriceDifferentialAnalysisLazy,\n    spatial_model: SpatialModelAnalysis,\n    tvmii: TVMIIAnalysisLazy\n  }), []);\n\n  // Get analysis component with monitoring\n  const getAnalysisComponent = useCallback((type) => {\n    try {\n      const component = analysisComponents[type];\n      if (!component) {\n        backgroundMonitor.logError(MetricTypes.SYSTEM.ERROR, {\n          component: 'analysis-loader',\n          error: `Unknown analysis type: ${type}`\n        });\n      }\n      return component;\n    } catch (error) {\n      backgroundMonitor.logError(MetricTypes.SYSTEM.ERROR, {\n        component: 'analysis-loader',\n        error: error.message,\n        stack: error.stack\n      });\n      return null;\n    }\n  }, [analysisComponents]);\n\n  // Render interactive chart with monitoring\n  const renderInteractiveChart = useCallback(() => {\n    const metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.PERFORMANCE, {\n      action: 'render-chart',\n      commodity: selectedCommodity\n    });\n\n    try {\n      if (!selectedCommodity || !selectedRegimes?.length) {\n        metric?.finish({ status: 'skipped', reason: 'missing-selection' });\n        return (\n          <ErrorMessage \n            message=\"Please select at least one regime and a commodity from the sidebar.\" \n          />\n        );\n      }\n\n      if (!chartData?.length) {\n        metric?.finish({ status: 'skipped', reason: 'no-data' });\n        return <ErrorMessage message=\"No data available for the selected criteria.\" />;\n      }\n\n      metric?.finish({ \n        status: 'success',\n        dataPoints: chartData.length\n      });\n\n      return (\n        <InteractiveChart\n          data={chartData}\n          selectedCommodity={selectedCommodity}\n          selectedRegimes={selectedRegimes}\n        />\n      );\n    } catch (error) {\n      metric?.finish({ \n        status: 'error',\n        error: error.message \n      });\n      return <ErrorMessage message={error.message} />;\n    }\n  }, [chartData, selectedCommodity, selectedRegimes]);\n\n  // Render analysis component with monitoring\n  const renderAnalysisComponent = useCallback(() => {\n    const metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.PERFORMANCE, {\n      action: 'render-analysis',\n      type: selectedAnalysis\n    });\n\n    try {\n      if (!selectedAnalysis) {\n        metric?.finish({ status: 'skipped', reason: 'no-selection' });\n        return null;\n      }\n\n      const AnalysisComponent = getAnalysisComponent(selectedAnalysis);\n      if (!AnalysisComponent) {\n        metric?.finish({ status: 'error', reason: 'component-not-found' });\n        return <ErrorMessage message=\"Selected analysis type is not available.\" />;\n      }\n\n      const analysisProps = (selectedAnalysis === 'spatial' || selectedAnalysis === 'spatial_model') \n        ? {\n            timeSeriesData: data,\n            selectedCommodity,\n            windowWidth,\n            spatialViewConfig,\n            onSpatialViewChange,\n            mode: selectedAnalysis === 'spatial_model' ? 'model' : 'analysis'\n          } \n        : {\n            data,\n            selectedCommodity,\n            windowWidth\n          };\n\n      metric?.finish({ status: 'success' });\n\n      return (\n        <Suspense fallback={<LoadingSpinner />}>\n          <AnalysisWrapper>\n            <AnalysisComponent {...analysisProps} />\n          </AnalysisWrapper>\n        </Suspense>\n      );\n    } catch (error) {\n      metric?.finish({ \n        status: 'error',\n        error: error.message \n      });\n      return <ErrorMessage message={error.message} />;\n    }\n  }, [\n    selectedAnalysis,\n    data,\n    selectedCommodity,\n    windowWidth,\n    spatialViewConfig,\n    onSpatialViewChange,\n    getAnalysisComponent\n  ]);\n\n  if (loading) {\n    return (\n      <Box \n        sx={{ \n          display: 'flex', \n          justifyContent: 'center', \n          alignItems: 'center', \n          height: '100%' \n        }}\n      >\n        <LoadingSpinner />\n      </Box>\n    );\n  }\n\n  if (error) {\n    return <ErrorMessage message={error} />;\n  }\n\n  return (\n    <Box\n      sx={{\n        display: 'flex',\n        flexDirection: 'column',\n        height: '100%',\n        overflow: 'hidden',\n        p: isSmallScreen ? 1 : 2, // Adjust padding based on screen size\n      }}\n    >\n      <Grid container spacing={2} sx={{ flexGrow: 1, overflow: 'auto' }}>\n        {/* Interactive Chart Section */}\n        <Grid item xs={12} md={selectedAnalysis ? 12 : 12}>\n          <Box\n            sx={{\n              width: '100%',\n              height: isSmallScreen ? '250px' : { xs: '300px', sm: '400px', md: '400px' }, // Dynamic height\n              position: 'relative',\n              mb: 2,\n            }}\n          >\n            {renderInteractiveChart()}\n          </Box>\n        </Grid>\n\n        {/* Analysis Component Section */}\n        {selectedAnalysis && (\n          <Grid item xs={12}>\n            {renderAnalysisComponent()}\n          </Grid>\n        )}\n      </Grid>\n    </Box>\n  );\n});\n\nDashboard.displayName = 'Dashboard';\n\nDashboard.propTypes = {\n  selectedAnalysis: PropTypes.string,\n  selectedCommodity: PropTypes.string.isRequired,\n  selectedRegimes: PropTypes.arrayOf(PropTypes.string).isRequired,\n  windowWidth: PropTypes.number.isRequired,\n  spatialViewConfig: PropTypes.shape({\n    center: PropTypes.arrayOf(PropTypes.number).isRequired,\n    zoom: PropTypes.number.isRequired,\n  }),\n  onSpatialViewChange: PropTypes.func\n};\n\nexport default Dashboard;",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "./hooks/useUnifiedData",
          "./components/interactive_graph/InteractiveChart",
          "./components/common/LoadingSpinner",
          "./components/common/ErrorMessage",
          "./components/common/AnalysisWrapper",
          "./components/spatialAnalysis",
          "./utils/backgroundMonitor",
          "lodash",
          "chart.js",
          "chartjs-adapter-date-fns"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "./hooks/useUnifiedData",
          "./components/interactive_graph/InteractiveChart",
          "./components/common/LoadingSpinner",
          "./components/common/ErrorMessage",
          "./components/common/AnalysisWrapper",
          "./components/spatialAnalysis",
          "./utils/backgroundMonitor",
          "lodash",
          "chart.js",
          "chartjs-adapter-date-fns"
        ]
      },
      {
        "path": "components/analysis/ecm/ACFPlot.js",
        "content": "// src/components/analysis/ecm/ACFPlot.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  ResponsiveContainer,\n  BarChart,\n  Bar,\n  XAxis,\n  YAxis,\n  ReferenceLine,\n  Tooltip\n} from 'recharts';\nimport { Typography, Box, Paper, useTheme } from '@mui/material';\n\nconst ACFPlot = ({ data, significance }) => {\n  const theme = useTheme();\n  const confidenceBound = Math.abs(1.96 / Math.sqrt(data?.length || 1));\n\n  const getCorrelationInterpretation = (value) => {\n    const absValue = Math.abs(value);\n    if (absValue < confidenceBound) {\n      return {\n        strength: 'Insignificant',\n        interpretation: 'No significant price memory at this lag',\n        economic: 'Markets show efficient price discovery'\n      };\n    } else if (absValue < 0.3) {\n      return {\n        strength: 'Weak',\n        interpretation: 'Mild price persistence',\n        economic: 'Markets show some inefficiencies'\n      };\n    } else if (absValue < 0.7) {\n      return {\n        strength: 'Moderate',\n        interpretation: 'Notable price memory effects',\n        economic: 'Markets exhibit significant frictions'\n      };\n    } else {\n      return {\n        strength: 'Strong',\n        interpretation: 'High price persistence',\n        economic: 'Markets show substantial inefficiencies'\n      };\n    }\n  };\n\n  const formattedData = useMemo(() => {\n    if (!data || data.length === 0) return [];\n    return data.map((value, index) => ({\n      lag: index + 1,\n      correlation: value,\n      significanceUpper: confidenceBound,\n      significanceLower: -confidenceBound,\n      ...getCorrelationInterpretation(value)\n    }));\n  }, [data, confidenceBound]);\n\n  const CustomTooltip = ({ active, payload, label }) => {\n    if (!active || !payload || !payload.length) return null;\n\n    const { correlation, strength, interpretation, economic } = payload[0].payload;\n    const isSignificant = Math.abs(correlation) > confidenceBound;\n\n    return (\n      <Paper \n        sx={{ \n          p: 2, \n          bgcolor: theme.palette.background.paper,\n          border: `1px solid ${theme.palette.divider}`,\n          boxShadow: theme.shadows[2]\n        }}\n      >\n        <Typography variant=\"subtitle2\" color=\"primary\" gutterBottom>\n          Lag {label}\n        </Typography>\n        <Typography variant=\"body2\" gutterBottom>\n          Correlation: {correlation.toFixed(4)}\n        </Typography>\n        <Typography \n          variant=\"body2\" \n          color={isSignificant ? theme.palette.error.main : theme.palette.success.main}\n          gutterBottom\n        >\n          {isSignificant ? 'Statistically Significant' : 'Not Significant'}\n        </Typography>\n        <Box sx={{ mt: 1, pt: 1, borderTop: `1px solid ${theme.palette.divider}` }}>\n          <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n            Strength: {strength}\n          </Typography>\n          <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n            {interpretation}\n          </Typography>\n          <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n            {economic}\n          </Typography>\n        </Box>\n      </Paper>\n    );\n  };\n\n  if (formattedData.length === 0) {\n    return (\n      <Typography variant=\"body2\" color=\"text.secondary\">\n        No ACF data available to display.\n      </Typography>\n    );\n  }\n\n  return (\n    <Box sx={{ width: '100%', height: '100%', p: 2 }}>\n      <ResponsiveContainer width=\"100%\" height=\"100%\">\n        <BarChart \n          data={formattedData} \n          margin={{ top: 20, right: 30, left: 20, bottom: 20 }}\n        >\n          <XAxis \n            dataKey=\"lag\" \n            stroke={theme.palette.text.primary}\n            tick={{ fill: theme.palette.text.primary }}\n            label={{ \n              value: 'Time Lag (Periods)', \n              position: 'insideBottom', \n              offset: -10,\n              fill: theme.palette.text.primary,\n              fontSize: 12,\n              fontWeight: 500\n            }} \n          />\n          <YAxis \n            stroke={theme.palette.text.primary}\n            tick={{ fill: theme.palette.text.primary }}\n            label={{ \n              value: 'Price Memory Effect', \n              angle: -90, \n              position: 'insideLeft',\n              fill: theme.palette.text.primary,\n              fontSize: 12,\n              fontWeight: 500\n            }}\n            domain={[-1, 1]}\n            tickFormatter={(value) => value.toFixed(2)}\n          />\n          <Tooltip content={<CustomTooltip />} />\n          <ReferenceLine \n            y={confidenceBound} \n            stroke={theme.palette.error.main}\n            strokeDasharray=\"3 3\"\n            strokeWidth={2}\n            label={{\n              value: 'Statistical Significance',\n              fill: theme.palette.error.main,\n              fontSize: 10,\n              position: 'right'\n            }}\n          />\n          <ReferenceLine \n            y={-confidenceBound} \n            stroke={theme.palette.error.main}\n            strokeDasharray=\"3 3\"\n            strokeWidth={2}\n          />\n          <ReferenceLine \n            y={0} \n            stroke={theme.palette.divider}\n            strokeWidth={1}\n          />\n          <Bar \n            dataKey=\"correlation\" \n            fill={theme.palette.secondary.main}\n            stroke={theme.palette.secondary.dark}\n            strokeWidth={1}\n            radius={[2, 2, 0, 0]}\n            maxBarSize={50}\n          />\n        </BarChart>\n      </ResponsiveContainer>\n      <Typography \n        variant=\"caption\" \n        color=\"text.secondary\"\n        sx={{ \n          display: 'block', \n          textAlign: 'center',\n          mt: 2\n        }}\n      >\n        Bars outside dashed lines indicate significant price memory effects\n      </Typography>\n    </Box>\n  );\n};\n\nACFPlot.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.number).isRequired,\n  significance: PropTypes.number.isRequired\n};\n\nexport default React.memo(ACFPlot);\n",
        "imports": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material"
        ]
      },
      {
        "path": "components/analysis/ecm/ECMAnalysis.js",
        "content": "// src/components/analysis/ecm/ECMAnalysis.js\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Button,\n  ToggleButton,\n  ToggleButtonGroup,\n  useTheme,\n  CircularProgress,\n  Alert,\n  Typography,\n  Snackbar,\n  Paper,\n  Grid,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails,\n  IconButton,\n  Tooltip,\n  Divider\n} from '@mui/material';\nimport { Download, ExpandMore, Info } from '@mui/icons-material';\nimport { saveAs } from 'file-saver';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport 'katex/dist/katex.min.css';\nimport { useECMData } from '../../../hooks/dataHooks';\nimport IRFChart from './IRFChart';\nimport ACFPlot from './ACFPlot';\nimport PACFPlot from './PACFPlot';\nimport InterpretationSection from './InterpretationSection';\n\nconst ECMAnalysis = ({ selectedCommodity, windowWidth }) => {\n  const theme = useTheme();\n  const isMobile = windowWidth < theme.breakpoints.values.sm;\n\n  const [analysisType, setAnalysisType] = useState('unified');\n  const [direction, setDirection] = useState('northToSouth');\n  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });\n  const [equationExpanded, setEquationExpanded] = useState(false);\n  const [interpretationExpanded, setInterpretationExpanded] = useState(false);\n\n  const {\n    unifiedData,\n    directionalData,\n    unifiedError,\n    directionalError,\n    isLoading\n  } = useECMData(selectedCommodity);\n\n  const selectedData = analysisType === 'unified' \n    ? unifiedData \n    : directionalData[direction];\n\n  const handleAnalysisTypeChange = useCallback((event, newType) => {\n    if (newType) setAnalysisType(newType);\n  }, []);\n\n  const handleDirectionChange = useCallback((event, newDirection) => {\n    if (newDirection) setDirection(newDirection);\n  }, []);\n\n  const handleDownloadData = useCallback(() => {\n    if (!selectedData) return;\n    try {\n      const blob = new Blob(\n        [JSON.stringify(selectedData, null, 2)], \n        { type: 'application/json' }\n      );\n      saveAs(blob, `ecm_analysis_${selectedCommodity}_${analysisType}.json`);\n      setSnackbar({\n        open: true,\n        message: 'Data downloaded successfully',\n        severity: 'success'\n      });\n    } catch (error) {\n      setSnackbar({\n        open: true,\n        message: 'Failed to download data',\n        severity: 'error'\n      });\n    }\n  }, [selectedData, selectedCommodity, analysisType]);\n\n  if (isLoading) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>\n        <CircularProgress />\n      </Box>\n    );\n  }\n\n  if (unifiedError || directionalError) {\n    return (\n      <Alert severity=\"error\">\n        <Alert.Title>Error Loading ECM Data</Alert.Title>\n        {unifiedError || directionalError}\n      </Alert>\n    );\n  }\n\n  const getParameterInterpretation = (param, value) => {\n    switch(param) {\n      case 'alpha':\n        return {\n          label: 'Adjustment Speed',\n          interpretation: value < 0 \n            ? `Markets correct ${Math.abs(value * 100).toFixed(1)}% of price gaps per period`\n            : 'Markets show divergent behavior',\n          detail: value < -0.5 \n            ? 'Rapid equilibrium restoration'\n            : value < 0 \n            ? 'Gradual price convergence'\n            : 'No price convergence'\n        };\n      case 'beta':\n        return {\n          label: 'Market Integration',\n          interpretation: `${Math.abs(value - 1) < 0.1 ? 'Perfect' : Math.abs(value) > 0.8 ? 'Strong' : Math.abs(value) > 0.5 ? 'Moderate' : 'Weak'} price transmission`,\n          detail: Math.abs(value - 1) < 0.1 \n            ? 'Complete price pass-through'\n            : `${(Math.abs(value) * 100).toFixed(1)}% long-run price transmission`\n        };\n      case 'gamma':\n        return {\n          label: 'Short-run Dynamics',\n          interpretation: `${Math.abs(value) > 0.5 ? 'Strong' : Math.abs(value) > 0.2 ? 'Moderate' : 'Weak'} immediate response`,\n          detail: `${(Math.abs(value) * 100).toFixed(1)}% immediate price transmission`\n        };\n      default:\n        return { label: '', interpretation: '', detail: '' };\n    }\n  };\n\n  return (\n    <Box sx={{ width: '100%', mb: 4 }}>\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2 }}>\n          <ToggleButtonGroup\n            value={analysisType}\n            exclusive\n            onChange={handleAnalysisTypeChange}\n            size={isMobile ? 'small' : 'medium'}\n          >\n            <ToggleButton value=\"unified\">Unified Analysis</ToggleButton>\n            <ToggleButton value=\"directional\">Directional Analysis</ToggleButton>\n          </ToggleButtonGroup>\n\n          {analysisType === 'directional' && (\n            <ToggleButtonGroup\n              value={direction}\n              exclusive\n              onChange={handleDirectionChange}\n              size={isMobile ? 'small' : 'medium'}\n            >\n              <ToggleButton value=\"northToSouth\">North to South</ToggleButton>\n              <ToggleButton value=\"southToNorth\">South to North</ToggleButton>\n            </ToggleButtonGroup>\n          )}\n\n          <Button\n            variant=\"contained\"\n            startIcon={<Download />}\n            onClick={handleDownloadData}\n            disabled={!selectedData}\n          >\n            Download Results\n          </Button>\n        </Box>\n      </Paper>\n\n      {selectedData && (\n        <>\n          {/* Model Framework Section - Moved up */}\n          <Accordion \n            expanded={equationExpanded} \n            onChange={() => setEquationExpanded(!equationExpanded)}\n            sx={{ mb: 3 }}\n          >\n            <AccordionSummary \n              expandIcon={<ExpandMore />}\n              sx={{\n                backgroundColor: theme.palette.grey[50],\n                '&:hover': {\n                  backgroundColor: theme.palette.grey[100],\n                }\n              }}\n            >\n              <Typography variant=\"h6\">\n                Error Correction Model Framework\n              </Typography>\n            </AccordionSummary>\n            <AccordionDetails>\n              <Box sx={{ '& .katex': { fontSize: '1.3em' }}}>\n                <Typography variant=\"h6\" gutterBottom sx={{ color: theme.palette.primary.main }}>\n                  Long-run Market Integration:\n                </Typography>\n                <Box sx={{ my: 3 }}>\n                  <BlockMath math={`P_{1,t} = \\\\beta P_{2,t} + u_t`} />\n                </Box>\n                <Typography variant=\"body2\" paragraph>\n                  Where <InlineMath math=\"P_{1,t}, P_{2,t}\" /> are market prices and <InlineMath math=\"\\beta\" /> measures price transmission\n                </Typography>\n\n                <Typography variant=\"h6\" gutterBottom sx={{ color: theme.palette.primary.main, mt: 4 }}>\n                  Error Correction Mechanism:\n                </Typography>\n                <Box sx={{ my: 3 }}>\n                  <BlockMath math={`\\\\Delta P_{1,t} = \\\\alpha(P_{1,t-1} - \\\\beta P_{2,t-1}) + \\\\gamma \\\\Delta P_{2,t} + \\\\epsilon_t`} />\n                </Box>\n\n                <Grid container spacing={4} sx={{ mt: 2 }}>\n                  <Grid item xs={12} md={6}>\n                    <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n                      Parameter Interpretations:\n                    </Typography>\n                    <Typography variant=\"body2\">\n                      • <InlineMath math=\"\\alpha\" />: Speed of price convergence<br />\n                      • <InlineMath math=\"\\beta\" />: Long-run price relationship<br />\n                      • <InlineMath math=\"\\gamma\" />: Immediate price transmission<br />\n                      • <InlineMath math=\"\\Delta P\" />: Price changes<br />\n                      • <InlineMath math=\"\\epsilon_t\" />: Random shocks\n                    </Typography>\n                  </Grid>\n                  <Grid item xs={12} md={6}>\n                    <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n                      Economic Implications:\n                    </Typography>\n                    <Typography variant=\"body2\">\n                      • Negative α indicates market correction<br />\n                      • β ≈ 1 suggests perfect integration<br />\n                      • γ measures short-term responses<br />\n                      • Error term captures market frictions\n                    </Typography>\n                  </Grid>\n                </Grid>\n              </Box>\n            </AccordionDetails>\n          </Accordion>\n\n          <Paper sx={{ p: 2, mb: 3 }}>\n            <Typography variant=\"h6\" gutterBottom sx={{ mb: 2 }}>\n              Market Integration Parameters\n            </Typography>\n            <Grid container spacing={2}>\n              {['alpha', 'beta', 'gamma'].map(param => {\n                const value = selectedData[param];\n                const interpretation = getParameterInterpretation(param, value);\n                return (\n                  <Grid item xs={12} md={4} key={param}>\n                    <Box sx={{ \n                      p: 2, \n                      bgcolor: theme.palette.background.default,\n                      borderRadius: 1,\n                      height: '100%',\n                      '&:hover .parameter-info': {\n                        opacity: 1\n                      }\n                    }}>\n                      <Typography variant=\"h6\" sx={{ fontSize: '1.1rem', fontWeight: 600 }}>\n                        {param === 'alpha' ? 'α' : param === 'beta' ? 'β' : 'γ'} = {value.toFixed(4)}\n                      </Typography>\n                      <Typography variant=\"body2\" color=\"text.secondary\">\n                        {interpretation.label}\n                      </Typography>\n                      <Typography variant=\"body2\" sx={{ mt: 1 }}>\n                        {interpretation.interpretation}\n                      </Typography>\n                      <Typography \n                        className=\"parameter-info\"\n                        variant=\"caption\" \n                        sx={{ \n                          display: 'block',\n                          mt: 1,\n                          opacity: 0,\n                          transition: 'opacity 0.2s',\n                          color: theme.palette.text.secondary\n                        }}\n                      >\n                        {interpretation.detail}\n                      </Typography>\n                    </Box>\n                  </Grid>\n                );\n              })}\n            </Grid>\n          </Paper>\n\n          <Paper sx={{ p: 2, mb: 3 }}>\n            <Typography variant=\"h6\" gutterBottom>Model Diagnostics</Typography>\n            <Grid container spacing={2}>\n              {[\n                {\n                  label: 'Model Fit',\n                  value: selectedData.aic,\n                  format: (v) => v.toFixed(2),\n                  info: 'Akaike Information Criterion - Lower is better'\n                },\n                {\n                  label: 'Serial Correlation',\n                  value: selectedData.diagnostics?.Variable_1?.durbin_watson_stat,\n                  format: (v) => v.toFixed(3),\n                  info: 'Durbin-Watson statistic - Close to 2 indicates no autocorrelation'\n                },\n                {\n                  label: 'Normality',\n                  value: selectedData.diagnostics?.Variable_1?.jarque_bera_pvalue,\n                  format: (v) => v.toExponential(2),\n                  info: 'Jarque-Bera test p-value - Higher indicates normal distribution'\n                },\n                {\n                  label: 'Granger Causality',\n                  value: selectedData.granger_causality?.usdprice_north?.[1]?.ssr_ftest_pvalue,\n                  format: (v) => v.toExponential(2),\n                  info: 'Tests for price leadership - Lower p-value indicates causality'\n                }\n              ].map((metric, index) => (\n                <Grid item xs={12} sm={6} md={3} key={index}>\n                  <Box sx={{ \n                    p: 2, \n                    bgcolor: theme.palette.background.default,\n                    borderRadius: 1,\n                    height: '100%',\n                    '&:hover .diagnostic-info': {\n                      opacity: 1\n                    }\n                  }}>\n                    <Typography variant=\"subtitle2\" color=\"text.secondary\">\n                      {metric.label}\n                    </Typography>\n                    <Typography variant=\"body1\">\n                      {metric.value ? metric.format(metric.value) : 'N/A'}\n                    </Typography>\n                    <Typography \n                      className=\"diagnostic-info\"\n                      variant=\"caption\" \n                      sx={{ \n                        display: 'block',\n                        mt: 1,\n                        opacity: 0,\n                        transition: 'opacity 0.2s',\n                        color: theme.palette.text.secondary\n                      }}\n                    >\n                      {metric.info}\n                    </Typography>\n                  </Box>\n                </Grid>\n              ))}\n            </Grid>\n          </Paper>\n\n          <Grid container spacing={3}>\n            <Grid item xs={12}>\n              <Paper sx={{ p: 2 }}>\n                <Typography variant=\"h6\" gutterBottom>\n                  Impulse Response Function\n                  <Tooltip title=\"Shows how markets respond to price shocks over time\">\n                    <IconButton size=\"small\" sx={{ ml: 1 }}>\n                      <Info fontSize=\"small\" />\n                    </IconButton>\n                  </Tooltip>\n                </Typography>\n                <Box sx={{ height: 400 }}>\n                  <IRFChart \n                    data={selectedData.irf?.impulse_response?.irf}\n                    analysisType={analysisType}\n                    direction={direction}\n                  />\n                </Box>\n              </Paper>\n            </Grid>\n\n            <Grid item xs={12} md={6}>\n              <Paper sx={{ p: 2 }}>\n                <Typography variant=\"h6\" gutterBottom>\n                  Autocorrelation Function\n                  <Tooltip title=\"Shows temporal price dependencies\">\n                    <IconButton size=\"small\" sx={{ ml: 1 }}>\n                      <Info fontSize=\"small\" />\n                    </IconButton>\n                  </Tooltip>\n                </Typography>\n                <Box sx={{ height: 300 }}>\n                  <ACFPlot \n                    data={selectedData.diagnostics?.Variable_1?.acf} \n                    significance={0.05}\n                  />\n                </Box>\n              </Paper>\n            </Grid>\n\n            <Grid item xs={12} md={6}>\n              <Paper sx={{ p: 2 }}>\n                <Typography variant=\"h6\" gutterBottom>\n                  Partial Autocorrelation Function\n                  <Tooltip title=\"Shows direct price relationships at different lags\">\n                    <IconButton size=\"small\" sx={{ ml: 1 }}>\n                      <Info fontSize=\"small\" />\n                    </IconButton>\n                  </Tooltip>\n                </Typography>\n                <Box sx={{ height: 300 }}>\n                  <PACFPlot \n                    data={selectedData.diagnostics?.Variable_1?.pacf} \n                    significance={0.05}\n                  />\n                </Box>\n              </Paper>\n            </Grid>\n          </Grid>\n\n          <Accordion\n            expanded={interpretationExpanded}\n            onChange={() => setInterpretationExpanded(!interpretationExpanded)}\n            sx={{ mt: 3 }}\n          >\n            <AccordionSummary expandIcon={<ExpandMore />}>\n              <Typography variant=\"h6\">Interpretation of ECM Analysis Results</Typography>\n            </AccordionSummary>\n            <AccordionDetails>\n              <InterpretationSection selectedData={selectedData} />\n            </AccordionDetails>\n          </Accordion>\n        </>\n      )}\n\n      <Snackbar\n        open={snackbar.open}\n        autoHideDuration={6000}\n        onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}\n        message={snackbar.message}\n        severity={snackbar.severity}\n      />\n    </Box>\n  );\n};\n\nECMAnalysis.propTypes = {\n  selectedCommodity: PropTypes.string.isRequired,\n  windowWidth: PropTypes.number.isRequired\n};\n\nconst getAlphaInterpretation = (alpha) => {\n  if (alpha === null || alpha === undefined) {\n    return { severity: 'info', message: 'No adjustment speed data available' };\n  }\n  if (alpha < -0.5) {\n    return { severity: 'success', message: 'Rapid adjustment to equilibrium (>50% per period)' };\n  }\n  if (alpha < 0) {\n    return { severity: 'warning', message: 'Slow adjustment to equilibrium' };\n  }\n  return { severity: 'error', message: 'No convergence to equilibrium' };\n};\n\nconst getBetaInterpretation = (beta) => {\n  if (beta === null || beta === undefined) {\n    return { severity: 'info', message: 'No long-run relationship data available' };\n  }\n  if (Math.abs(beta) > 0.8) {\n    return { severity: 'success', message: 'Strong long-run relationship between markets' };\n  }\n  if (Math.abs(beta) > 0.5) {\n    return { severity: 'warning', message: 'Moderate long-run relationship between markets' };\n  }\n  return { severity: 'error', message: 'Weak long-run relationship between markets' };\n};\n\nconst getGammaInterpretation = (gamma) => {\n  if (gamma === null || gamma === undefined) {\n    return { severity: 'info', message: 'No short-run dynamics data available' };\n  }\n  if (Math.abs(gamma) > 0.5) {\n    return { severity: 'success', message: 'Strong immediate price transmission' };\n  }\n  if (Math.abs(gamma) > 0.2) {\n    return { severity: 'warning', message: 'Moderate immediate price transmission' };\n  }\n  return { severity: 'error', message: 'Weak immediate price transmission' };\n};\n\nexport default React.memo(ECMAnalysis);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "file-saver",
          "react-katex",
          "katex/dist/katex.min.css",
          "../../../hooks/dataHooks",
          "./IRFChart",
          "./ACFPlot",
          "./PACFPlot",
          "./InterpretationSection"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "file-saver",
          "react-katex",
          "katex/dist/katex.min.css",
          "../../../hooks/dataHooks",
          "./IRFChart",
          "./ACFPlot",
          "./PACFPlot",
          "./InterpretationSection"
        ]
      },
      {
        "path": "components/analysis/ecm/ECMResultsEnhanced.js",
        "content": "// src/components/analysis/ecm/ECMResultsEnhanced.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Grid,\n  Alert,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails,\n  useTheme,\n  Tooltip,\n  CircularProgress\n} from '@mui/material';\nimport { ExpandMore, Info } from '@mui/icons-material';\nimport { analysisStyles } from '../../../styles/analysisStyles';\nimport { BlockMath } from 'react-katex';\nimport 'katex/dist/katex.min.css';\n\n// Lazy load diagnostic components\nconst ACFPlot = React.lazy(() => import('./ACFPlot'));\nconst PACFPlot = React.lazy(() => import('./PACFPlot'));\nconst QQPlot = React.lazy(() => import('./QQPlot'));\nconst IRFChart = React.lazy(() => import('./IRFChart'));\n\nconst ECMResultsEnhanced = ({ selectedData, isMobile, analysisType, direction }) => {\n  const theme = useTheme();\n  const styles = analysisStyles(theme);\n\n  // Memoized coefficient interpretations\n  const interpretations = useMemo(() => ({\n    alpha: getAlphaInterpretation(selectedData?.alpha),\n    beta: getBetaInterpretation(selectedData?.beta),\n    gamma: getGammaInterpretation(selectedData?.gamma)\n  }), [selectedData]);\n\n  // Helper function to format numbers\n  const formatNumber = (num) => {\n    if (num === null || num === undefined) return 'N/A';\n    return parseFloat(num).toFixed(3);\n  };\n\n  // Coefficient interpretation functions\n  function getAlphaInterpretation(alpha) {\n    if (alpha === null || alpha === undefined) return { severity: 'info', message: 'No adjustment speed data available' };\n    if (alpha < -0.5) return { severity: 'success', message: 'Rapid adjustment to equilibrium (>50% per period)' };\n    if (alpha < 0) return { severity: 'warning', message: 'Slow adjustment to equilibrium' };\n    return { severity: 'error', message: 'No convergence to equilibrium' };\n  }\n\n  function getBetaInterpretation(beta) {\n    if (beta === null || beta === undefined) return { severity: 'info', message: 'No long-run relationship data available' };\n    if (Math.abs(beta) > 0.8) return { severity: 'success', message: 'Strong long-run relationship between variables' };\n    if (Math.abs(beta) > 0.3) return { severity: 'warning', message: 'Moderate long-run relationship between variables' };\n    return { severity: 'error', message: 'Weak long-run relationship between variables' };\n  }\n\n  function getGammaInterpretation(gamma) {\n    if (gamma === null || gamma === undefined) return { severity: 'info', message: 'No short-run dynamics data available' };\n    if (Math.abs(gamma) > 0.5) return { severity: 'success', message: 'Strong immediate effect' };\n    if (Math.abs(gamma) > 0.2) return { severity: 'warning', message: 'Moderate immediate effect' };\n    return { severity: 'error', message: 'Weak immediate effect' };\n  }\n\n  return (\n    <Box sx={{ width: '100%', mb: 4 }}>\n      {/* Executive Summary */}\n      <Paper sx={styles.summaryPaper}>\n        <Typography variant=\"h5\" gutterBottom>\n          Executive Summary\n        </Typography>\n        <Typography variant=\"body1\">\n          {`The ECM analysis for ${selectedData.commodity} reveals a ${\n            Math.abs(selectedData.beta) > 0.8 ? 'strong' : \n            Math.abs(selectedData.beta) > 0.3 ? 'moderate' : 'weak'\n          } long-run relationship between markets, with ${\n            Math.abs(selectedData.alpha) > 0.5 ? 'rapid' : 'slow'\n          } convergence to equilibrium.`}\n        </Typography>\n      </Paper>\n\n      {/* Coefficients Grid */}\n      <Grid container spacing={3} sx={{ mt: 2 }}>\n        {/* Alpha Coefficient */}\n        <Grid item xs={12} md={4}>\n          <Paper sx={styles.coefficientCard}>\n            <Typography variant=\"h6\">Speed of Adjustment (α)</Typography>\n            <Typography variant=\"h4\" sx={styles.coefficientValue}>\n              {formatNumber(selectedData.alpha)}\n            </Typography>\n            <Alert severity={interpretations.alpha.severity}>\n              {interpretations.alpha.message}\n            </Alert>\n          </Paper>\n        </Grid>\n\n        {/* Beta Coefficient */}\n        <Grid item xs={12} md={4}>\n          <Paper sx={styles.coefficientCard}>\n            <Typography variant=\"h6\">Long-run Relationship (β)</Typography>\n            <Typography variant=\"h4\" sx={styles.coefficientValue}>\n              {formatNumber(selectedData.beta)}\n            </Typography>\n            <Alert severity={interpretations.beta.severity}>\n              {interpretations.beta.message}\n            </Alert>\n          </Paper>\n        </Grid>\n\n        {/* Gamma Coefficient */}\n        <Grid item xs={12} md={4}>\n          <Paper sx={styles.coefficientCard}>\n            <Typography variant=\"h6\">Short-run Dynamics (γ)</Typography>\n            <Typography variant=\"h4\" sx={styles.coefficientValue}>\n              {formatNumber(selectedData.gamma)}\n            </Typography>\n            <Alert severity={interpretations.gamma.severity}>\n              {interpretations.gamma.message}\n            </Alert>\n          </Paper>\n        </Grid>\n\n        {/* Model Equation */}\n        <Grid item xs={12}>\n          <Paper sx={styles.equationPaper}>\n            <Typography variant=\"h6\" gutterBottom>\n              Error Correction Model Equation\n              <Tooltip title=\"The ECM equation represents the relationship between price changes and deviations from long-run equilibrium\">\n                <Info sx={{ ml: 1, fontSize: '1rem', color: 'info.main' }} />\n              </Tooltip>\n            </Typography>\n            <Box sx={{ display: 'flex', justifyContent: 'center', mt: 2 }}>\n              <BlockMath math={`\\\\Delta y_t = \\\\alpha(y_{t-1} - \\\\beta x_{t-1}) + \\\\gamma \\\\Delta x_t + \\\\epsilon_t`} />\n            </Box>\n            <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mt: 2 }}>\n              where Δyt represents price changes, α is the speed of adjustment,\n              β represents the long-run equilibrium relationship, and γ captures short-run dynamics\n            </Typography>\n          </Paper>\n        </Grid>\n\n        {/* IRF Chart */}\n        <Grid item xs={12}>\n          <Paper sx={styles.chartPaper}>\n            <Typography variant=\"h6\" gutterBottom>\n              Impulse Response Function\n              <Tooltip title=\"Shows how variables respond to shocks over time\">\n                <Info sx={{ ml: 1, fontSize: '1rem', color: 'info.main' }} />\n              </Tooltip>\n            </Typography>\n            <Box sx={{ height: 400, width: '100%' }}>\n              <React.Suspense fallback={<Box sx={{ display: 'flex', justifyContent: 'center' }}><CircularProgress /></Box>}>\n                <IRFChart\n                  data={selectedData.irf}\n                  confidenceIntervals={{\n                    lower: selectedData.confidence_intervals?.lower,\n                    upper: selectedData.confidence_intervals?.upper\n                  }}\n                />\n              </React.Suspense>\n            </Box>\n          </Paper>\n        </Grid>\n\n        {/* Diagnostic Plots */}\n        <Grid item xs={12}>\n          <Paper sx={styles.diagnosticsPaper}>\n            <Typography variant=\"h6\" gutterBottom>\n              Model Diagnostics\n              <Tooltip title=\"Diagnostic plots help assess model assumptions and fit\">\n                <Info sx={{ ml: 1, fontSize: '1rem', color: 'info.main' }} />\n              </Tooltip>\n            </Typography>\n            <Grid container spacing={3}>\n              {/* ACF Plot */}\n              <Grid item xs={12} md={6}>\n                <Paper sx={styles.plotPaper}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    Autocorrelation Function (ACF)\n                  </Typography>\n                  <Box sx={{ height: 300 }}>\n                    <React.Suspense fallback={<Box sx={{ display: 'flex', justifyContent: 'center' }}><CircularProgress /></Box>}>\n                      <ACFPlot\n                        data={selectedData.diagnostics?.Variable_1?.acf}\n                        significance={0.05}\n                      />\n                    </React.Suspense>\n                  </Box>\n                </Paper>\n              </Grid>\n\n              {/* PACF Plot */}\n              <Grid item xs={12} md={6}>\n                <Paper sx={styles.plotPaper}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    Partial Autocorrelation Function (PACF)\n                  </Typography>\n                  <Box sx={{ height: 300 }}>\n                    <React.Suspense fallback={<Box sx={{ display: 'flex', justifyContent: 'center' }}><CircularProgress /></Box>}>\n                      <PACFPlot\n                        data={selectedData.diagnostics?.Variable_1?.pacf}\n                        significance={0.05}\n                      />\n                    </React.Suspense>\n                  </Box>\n                </Paper>\n              </Grid>\n\n              {/* Q-Q Plot */}\n              <Grid item xs={12} md={6}>\n                <Paper sx={styles.plotPaper}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    Q-Q Plot\n                  </Typography>\n                  <Box sx={{ height: 300 }}>\n                    <React.Suspense fallback={<Box sx={{ display: 'flex', justifyContent: 'center' }}><CircularProgress /></Box>}>\n                      <QQPlot\n                        residuals={selectedData.residuals}\n                      />\n                    </React.Suspense>\n                  </Box>\n                </Paper>\n              </Grid>\n\n              {/* Model Quality Metrics */}\n              <Grid item xs={12} md={6}>\n                <Paper sx={styles.metricsPaper}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    Model Quality Metrics\n                  </Typography>\n                  <Box sx={{ mt: 2 }}>\n                    {/* Jarque-Bera Test */}\n                    <Alert \n                      severity={selectedData.diagnostics?.Variable_1?.jarque_bera_pvalue > 0.05 ? 'success' : 'warning'}\n                      sx={{ mb: 2 }}\n                    >\n                      {selectedData.diagnostics?.Variable_1?.jarque_bera_pvalue > 0.05 \n                        ? 'Residuals are normally distributed (Jarque-Bera test)'\n                        : 'Residuals may not be normally distributed'}\n                    </Alert>\n\n                    {/* Durbin-Watson Test */}\n                    <Alert \n                      severity={\n                        selectedData.diagnostics?.Variable_1?.durbin_watson_stat > 1.5 &&\n                        selectedData.diagnostics?.Variable_1?.durbin_watson_stat < 2.5 \n                          ? 'success' \n                          : 'warning'\n                      }\n                      sx={{ mb: 2 }}\n                    >\n                      {`Durbin-Watson statistic: ${formatNumber(selectedData.diagnostics?.Variable_1?.durbin_watson_stat)}`}\n                    </Alert>\n\n                    {/* Model Fit Statistics */}\n                    <Box sx={{ mt: 2 }}>\n                      <Typography variant=\"body2\" gutterBottom>\n                        AIC: {formatNumber(selectedData.aic)}\n                      </Typography>\n                      <Typography variant=\"body2\" gutterBottom>\n                        BIC: {formatNumber(selectedData.bic)}\n                      </Typography>\n                      <Typography variant=\"body2\" gutterBottom>\n                        HQIC: {formatNumber(selectedData.hqic)}\n                      </Typography>\n                    </Box>\n                  </Box>\n                </Paper>\n              </Grid>\n            </Grid>\n          </Paper>\n        </Grid>\n\n        {/* Model Interpretation Guide */}\n        <Grid item xs={12}>\n          <Accordion>\n            <AccordionSummary expandIcon={<ExpandMore />}>\n              <Typography variant=\"h6\">Model Interpretation Guide</Typography>\n            </AccordionSummary>\n            <AccordionDetails>\n              <Grid container spacing={3}>\n                <Grid item xs={12} md={4}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    Speed of Adjustment (α)\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    • Values between -1 and 0 indicate convergence<br/>\n                    • Closer to -1: Faster adjustment<br/>\n                    • Closer to 0: Slower adjustment<br/>\n                    • Current value: {formatNumber(selectedData.alpha)}\n                  </Typography>\n                </Grid>\n\n                <Grid item xs={12} md={4}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    Long-run Relationship (β)\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    • Measures equilibrium relationship<br/>\n                    • |β| &gt; 0.8: Strong relationship<br/>\n                    • |β| &gt; 0.3: Moderate relationship<br/>\n                    • Current value: {formatNumber(selectedData.beta)}\n                  </Typography>\n                </Grid>\n\n                <Grid item xs={12} md={4}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    Short-run Dynamics (γ)\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    • Captures immediate price adjustments<br/>\n                    • |γ| &gt; 0.5: Strong immediate effect<br/>\n                    • |γ| &gt; 0.2: Moderate immediate effect<br/>\n                    • Current value: {formatNumber(selectedData.gamma)}\n                  </Typography>\n                </Grid>\n              </Grid>\n            </AccordionDetails>\n          </Accordion>\n        </Grid>\n      </Grid>\n    </Box>\n  );\n};\n\nECMResultsEnhanced.propTypes = {\n  selectedData: PropTypes.shape({\n    commodity: PropTypes.string.isRequired,\n    alpha: PropTypes.number,\n    beta: PropTypes.number,\n    gamma: PropTypes.number,\n    aic: PropTypes.number,\n    bic: PropTypes.number,\n    hqic: PropTypes.number,\n    diagnostics: PropTypes.shape({\n      Variable_1: PropTypes.shape({\n        acf: PropTypes.arrayOf(PropTypes.number),\n        pacf: PropTypes.arrayOf(PropTypes.number),\n        jarque_bera_pvalue: PropTypes.number,\n        durbin_watson_stat: PropTypes.number\n      })\n    }),\n    irf: PropTypes.arrayOf(PropTypes.number),\n    confidence_intervals: PropTypes.shape({\n      lower: PropTypes.arrayOf(PropTypes.number),\n      upper: PropTypes.arrayOf(PropTypes.number)\n    }),\n    residuals: PropTypes.arrayOf(PropTypes.number)\n  }).isRequired,\n  isMobile: PropTypes.bool.isRequired,\n  analysisType: PropTypes.oneOf(['unified', 'directional']).isRequired,\n  direction: PropTypes.string\n};\n\nexport default React.memo(ECMResultsEnhanced);",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "../../../styles/analysisStyles",
          "react-katex",
          "katex/dist/katex.min.css"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "../../../styles/analysisStyles",
          "react-katex",
          "katex/dist/katex.min.css"
        ]
      },
      {
        "path": "components/analysis/ecm/IRFChart.js",
        "content": "// src/components/analysis/ecm/IRFChart.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  ResponsiveContainer,\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  Legend,\n  ReferenceLine\n} from 'recharts';\nimport { useTheme, Typography, Box, Paper } from '@mui/material';\n\nconst IRFChart = ({ data, analysisType, direction }) => {\n  const theme = useTheme();\n\n  const getResponseDetails = () => {\n    if (analysisType === 'unified') {\n      return {\n        response1: {\n          label: 'Northern Market Response to Own Shock',\n          interpretation: 'Shows how northern market prices respond to local shocks',\n          economic: 'Measures market resilience to internal disruptions'\n        },\n        response2: {\n          label: 'Southern Market Response to Northern Shock',\n          interpretation: 'Shows price transmission from north to south',\n          economic: 'Indicates north-to-south market integration strength'\n        },\n        response3: {\n          label: 'Northern Market Response to Southern Shock',\n          interpretation: 'Shows price transmission from south to north',\n          economic: 'Indicates south-to-north market integration strength'\n        },\n        response4: {\n          label: 'Southern Market Response to Own Shock',\n          interpretation: 'Shows how southern market prices respond to local shocks',\n          economic: 'Measures market resilience to internal disruptions'\n        }\n      };\n    } else if (direction === 'northToSouth') {\n      return {\n        response1: {\n          label: 'Source Market Response to Own Shock',\n          interpretation: 'Shows how source market absorbs local shocks',\n          economic: 'Indicates source market stability'\n        },\n        response2: {\n          label: 'Destination Market Response to Source Shock',\n          interpretation: 'Shows price transmission to destination',\n          economic: 'Measures market integration effectiveness'\n        },\n        response3: {\n          label: 'Source Market Response to Destination Shock',\n          interpretation: 'Shows feedback effects from destination',\n          economic: 'Indicates bidirectional market linkages'\n        },\n        response4: {\n          label: 'Destination Market Response to Own Shock',\n          interpretation: 'Shows destination market resilience',\n          economic: 'Measures local market stability'\n        }\n      };\n    } else {\n      return {\n        response1: {\n          label: 'Southern Market Response to Own Shock',\n          interpretation: 'Shows southern market stability',\n          economic: 'Measures local market resilience'\n        },\n        response2: {\n          label: 'Northern Market Response to Southern Shock',\n          interpretation: 'Shows south-to-north transmission',\n          economic: 'Indicates upward price transmission'\n        },\n        response3: {\n          label: 'Southern Market Response to Northern Shock',\n          interpretation: 'Shows north-to-south transmission',\n          economic: 'Indicates downward price transmission'\n        },\n        response4: {\n          label: 'Northern Market Response to Own Shock',\n          interpretation: 'Shows northern market stability',\n          economic: 'Measures local market resilience'\n        }\n      };\n    }\n  };\n\n  const responseDetails = getResponseDetails();\n  \n  const colors = {\n    response1: theme.palette.primary.main,\n    response2: theme.palette.secondary.main,\n    response3: theme.palette.error.main,\n    response4: theme.palette.success.main\n  };\n\n  const formattedData = useMemo(() => {\n    if (!data) return [];\n    return data.map((period, index) => ({\n      period: index,\n      response1: period[0][0],\n      response2: period[0][1],\n      response3: period[1][0],\n      response4: period[1][1]\n    }));\n  }, [data]);\n\n  const CustomTooltip = ({ active, payload, label }) => {\n    if (!active || !payload || !payload.length) return null;\n\n    const response = payload[0];\n    const responseKey = response.dataKey;\n    const details = responseDetails[responseKey];\n\n    return (\n      <Paper \n        sx={{ \n          p: 2, \n          bgcolor: theme.palette.background.paper,\n          border: `1px solid ${theme.palette.divider}`,\n          boxShadow: theme.shadows[2]\n        }}\n      >\n        <Typography variant=\"subtitle2\" color=\"primary\" gutterBottom>\n          Period {label}\n        </Typography>\n        <Typography variant=\"body2\" gutterBottom>\n          {details.label}\n        </Typography>\n        <Typography variant=\"body2\" color=\"text.secondary\" gutterBottom>\n          Response: {response.value.toFixed(4)}\n        </Typography>\n        <Box sx={{ mt: 1, pt: 1, borderTop: `1px solid ${theme.palette.divider}` }}>\n          <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n            {details.interpretation}\n          </Typography>\n          <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n            {details.economic}\n          </Typography>\n        </Box>\n      </Paper>\n    );\n  };\n\n  if (formattedData.length === 0) {\n    return (\n      <Typography variant=\"body2\" color=\"text.secondary\">\n        No IRF data available to display.\n      </Typography>\n    );\n  }\n\n  return (\n    <Box sx={{ width: '100%', height: '100%', p: 2 }}>\n      <ResponsiveContainer width=\"100%\" height=\"100%\">\n        <LineChart\n          data={formattedData}\n          margin={{ top: 20, right: 30, left: 20, bottom: 20 }}\n        >\n          <CartesianGrid \n            strokeDasharray=\"3 3\" \n            stroke={theme.palette.divider}\n            opacity={0.5} \n          />\n          <XAxis \n            dataKey=\"period\" \n            stroke={theme.palette.text.primary}\n            tick={{ fill: theme.palette.text.primary }}\n            label={{ \n              value: 'Time Periods After Shock', \n              position: 'insideBottom', \n              offset: -10,\n              fill: theme.palette.text.primary,\n              fontSize: 12,\n              fontWeight: 500\n            }} \n          />\n          <YAxis \n            stroke={theme.palette.text.primary}\n            tick={{ fill: theme.palette.text.primary }}\n            label={{ \n              value: 'Price Response', \n              angle: -90, \n              position: 'insideLeft',\n              fill: theme.palette.text.primary,\n              fontSize: 12,\n              fontWeight: 500\n            }}\n          />\n          <ReferenceLine \n            y={0} \n            stroke={theme.palette.divider}\n            strokeDasharray=\"3 3\"\n          />\n          <Tooltip content={<CustomTooltip />} />\n          <Legend \n            verticalAlign=\"bottom\"\n            height={72}\n            wrapperStyle={{\n              paddingTop: '20px',\n              fontSize: '12px',\n              fontWeight: 500\n            }}\n          />\n          {Object.entries(responseDetails).map(([key, details]) => (\n            <Line\n              key={key}\n              type=\"monotone\"\n              dataKey={key}\n              name={details.label}\n              stroke={colors[key]}\n              dot={{ r: 4, strokeWidth: 2 }}\n              activeDot={{ r: 6, strokeWidth: 2 }}\n              strokeWidth={2}\n            />\n          ))}\n        </LineChart>\n      </ResponsiveContainer>\n    </Box>\n  );\n};\n\nIRFChart.propTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.arrayOf(\n      PropTypes.arrayOf(PropTypes.number)\n    )\n  ),\n  analysisType: PropTypes.oneOf(['unified', 'directional']).isRequired,\n  direction: PropTypes.oneOf(['northToSouth', 'southToNorth'])\n};\n\nexport default React.memo(IRFChart);\n",
        "imports": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material"
        ]
      },
      {
        "path": "components/analysis/ecm/InterpretationSection.js",
        "content": "// src/components/analysis/ecm/InterpretationSection.js\n\nimport React from 'react';\nimport { Box, Typography, Paper, Grid, Chip, useTheme } from '@mui/material';\nimport PropTypes from 'prop-types';\nimport { CheckCircle as CheckCircleIcon, Warning as WarningIcon } from '@mui/icons-material';\n\nconst InterpretationSection = ({ selectedData }) => {\n  const theme = useTheme();\n\n  if (!selectedData) {\n    return (\n      <Typography variant=\"body2\" color=\"text.secondary\">\n        No interpretation data available.\n      </Typography>\n    );\n  }\n\n  const sections = [\n    {\n      title: 'Market Adjustment Analysis',\n      content: () => {\n        const adjustmentSpeed = Math.abs(selectedData.alpha);\n        const isEfficient = adjustmentSpeed > 0.2;\n        return {\n          summary: isEfficient\n            ? `Markets adjust ${(adjustmentSpeed * 100).toFixed(1)}% of price gaps per period`\n            : 'Markets show slow adjustment to shocks',\n          details: [\n            `Adjustment Speed: ${adjustmentSpeed > 0.5 ? 'Fast' : adjustmentSpeed > 0.2 ? 'Moderate' : 'Slow'}`,\n            `Half-life: ${(Math.log(2) / adjustmentSpeed).toFixed(1)} periods`,\n            `Convergence: ${selectedData.alpha < 0 ? 'Present' : 'Absent'}`\n          ],\n          interpretation: isEfficient\n            ? 'Markets efficiently correct price discrepancies'\n            : 'Significant market frictions may exist',\n          status: isEfficient ? 'success' : 'warning'\n        };\n      }\n    },\n    {\n      title: 'Long-run Integration',\n      content: () => {\n        const betaDiff = Math.abs(selectedData.beta - 1);\n        const isIntegrated = betaDiff < 0.2;\n        return {\n          summary: isIntegrated\n            ? 'Markets show strong long-run integration'\n            : 'Limited long-run price relationship',\n          details: [\n            `Integration Level: ${betaDiff < 0.1 ? 'Perfect' : betaDiff < 0.2 ? 'Strong' : 'Weak'}`,\n            `Price Transmission: ${((1 - betaDiff) * 100).toFixed(1)}%`,\n            `Market Efficiency: ${isIntegrated ? 'High' : 'Low'}`\n          ],\n          interpretation: isIntegrated\n            ? 'Prices move together in the long run'\n            : 'Markets may be segmented',\n          status: isIntegrated ? 'success' : 'warning'\n        };\n      }\n    },\n    {\n      title: 'Short-run Dynamics',\n      content: () => {\n        const immediateResponse = Math.abs(selectedData.gamma);\n        const isResponsive = immediateResponse > 0.2;\n        return {\n          summary: isResponsive\n            ? `${(immediateResponse * 100).toFixed(1)}% immediate price transmission`\n            : 'Weak immediate price response',\n          details: [\n            `Response Speed: ${immediateResponse > 0.5 ? 'Rapid' : immediateResponse > 0.2 ? 'Moderate' : 'Slow'}`,\n            `Impact: ${(immediateResponse * 100).toFixed(1)}% transmission`,\n            `Market Friction: ${isResponsive ? 'Low' : 'High'}`\n          ],\n          interpretation: isResponsive\n            ? 'Markets quickly respond to price changes'\n            : 'Significant short-term barriers exist',\n          status: isResponsive ? 'success' : 'warning'\n        };\n      }\n    },\n    {\n      title: 'Model Validation',\n      content: () => {\n        const dw = selectedData.diagnostics?.Variable_1?.durbin_watson_stat || 0;\n        const jb = selectedData.diagnostics?.Variable_1?.jarque_bera_pvalue || 0;\n        const isValid = Math.abs(dw - 2) < 0.5 && jb > 0.05;\n        return {\n          summary: isValid\n            ? 'Model assumptions are satisfied'\n            : 'Some model assumptions violated',\n          details: [\n            `Residuals: ${Math.abs(dw - 2) < 0.5 ? 'Independent' : 'Correlated'}`,\n            `Distribution: ${jb > 0.05 ? 'Normal' : 'Non-normal'}`,\n            `Reliability: ${isValid ? 'High' : 'Moderate'}`\n          ],\n          interpretation: isValid\n            ? 'Results are statistically reliable'\n            : 'Interpret results with caution',\n          status: isValid ? 'success' : 'warning'\n        };\n      }\n    }\n  ];\n\n  return (\n    <Box>\n      <Grid container spacing={3}>\n        {sections.map((section) => {\n          const interpretation = section.content();\n          return (\n            <Grid item xs={12} key={section.title}>\n              <Paper \n                sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  '&:hover .interpretation-info': {\n                    opacity: 1\n                  }\n                }}\n              >\n                <Box sx={{ \n                  display: 'flex', \n                  justifyContent: 'space-between', \n                  alignItems: 'center',\n                  mb: 2 \n                }}>\n                  <Typography variant=\"h6\" color=\"primary\">\n                    {section.title}\n                  </Typography>\n                  <Chip\n                    icon={interpretation.status === 'success' ? <CheckCircleIcon /> : <WarningIcon />}\n                    label={interpretation.status === 'success' ? 'Favorable' : 'Attention Needed'}\n                    color={interpretation.status}\n                    variant=\"outlined\"\n                  />\n                </Box>\n                <Typography variant=\"body1\" paragraph>\n                  {interpretation.summary}\n                </Typography>\n                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 2 }}>\n                  {interpretation.details.map((detail, index) => (\n                    <Chip\n                      key={index}\n                      label={detail}\n                      size=\"small\"\n                      variant=\"outlined\"\n                      sx={{ my: 0.5 }}\n                    />\n                  ))}\n                </Box>\n                <Typography \n                  className=\"interpretation-info\"\n                  variant=\"body2\" \n                  sx={{ \n                    opacity: 0,\n                    transition: 'opacity 0.2s',\n                    color: theme.palette.text.secondary\n                  }}\n                >\n                  {interpretation.interpretation}\n                </Typography>\n              </Paper>\n            </Grid>\n          );\n        })}\n      </Grid>\n\n      <Box sx={{ \n        mt: 3, \n        p: 2, \n        bgcolor: theme.palette.grey[50], \n        borderRadius: 1,\n        '&:hover .methodology-info': {\n          opacity: 1\n        }\n      }}>\n        <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n          Economic Implications\n        </Typography>\n        <Typography variant=\"body2\">\n          The Error Correction Model reveals the complex dynamics of price adjustment and market integration in Yemen's commodity markets.\n        </Typography>\n        <Typography \n          className=\"methodology-info\"\n          variant=\"caption\" \n          sx={{ \n            display: 'block',\n            mt: 1,\n            opacity: 0,\n            transition: 'opacity 0.2s',\n            color: theme.palette.text.secondary\n          }}\n        >\n          Results suggest {Math.abs(selectedData.alpha) > 0.2 ? 'efficient' : 'inefficient'} price adjustment mechanisms, \n          {Math.abs(selectedData.beta - 1) < 0.2 ? ' strong' : ' weak'} market integration, and \n          {Math.abs(selectedData.gamma) > 0.2 ? ' responsive' : ' sluggish'} short-term dynamics.\n        </Typography>\n      </Box>\n    </Box>\n  );\n};\n\nInterpretationSection.propTypes = {\n  selectedData: PropTypes.shape({\n    alpha: PropTypes.number,\n    beta: PropTypes.number,\n    gamma: PropTypes.number,\n    diagnostics: PropTypes.shape({\n      Variable_1: PropTypes.shape({\n        durbin_watson_stat: PropTypes.number,\n        jarque_bera_pvalue: PropTypes.number\n      })\n    })\n  }).isRequired,\n};\n\nexport default React.memo(InterpretationSection);\n",
        "imports": [
          "react",
          "@mui/material",
          "prop-types",
          "@mui/icons-material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "prop-types",
          "@mui/icons-material"
        ]
      },
      {
        "path": "components/analysis/ecm/PACFPlot.js",
        "content": "// src/components/analysis/ecm/PACFPlot.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  ResponsiveContainer,\n  BarChart,\n  Bar,\n  XAxis,\n  YAxis,\n  ReferenceLine,\n  Tooltip\n} from 'recharts';\nimport { Typography, Box, Paper, useTheme } from '@mui/material';\n\nconst PACFPlot = ({ data, significance }) => {\n  const theme = useTheme();\n  const confidenceBound = Math.abs(1.96 / Math.sqrt(data?.length || 1));\n\n  const getPartialCorrelationInterpretation = (value, lag) => {\n    const absValue = Math.abs(value);\n    if (absValue < confidenceBound) {\n      return {\n        strength: 'Insignificant',\n        interpretation: 'No direct price relationship at this lag',\n        economic: 'Efficient price discovery process'\n      };\n    }\n    \n    // First lag interpretations\n    if (lag === 1) {\n      if (absValue > 0.7) {\n        return {\n          strength: 'Very Strong',\n          interpretation: 'High direct price dependence',\n          economic: 'Strong market friction in price discovery'\n        };\n      } else if (absValue > 0.3) {\n        return {\n          strength: 'Moderate',\n          interpretation: 'Notable direct price dependence',\n          economic: 'Some market friction present'\n        };\n      }\n      return {\n        strength: 'Weak',\n        interpretation: 'Limited direct price dependence',\n        economic: 'Relatively efficient price discovery'\n      };\n    }\n    \n    // Higher lag interpretations\n    if (absValue > 0.3) {\n      return {\n        strength: 'Strong',\n        interpretation: 'Significant direct relationship at longer lags',\n        economic: 'Potential market segmentation or barriers'\n      };\n    } else if (absValue > 0.2) {\n      return {\n        strength: 'Moderate',\n        interpretation: 'Some direct relationship at longer lags',\n        economic: 'Possible market inefficiencies'\n      };\n    }\n    return {\n      strength: 'Weak',\n      interpretation: 'Minor direct relationship at longer lags',\n      economic: 'Generally efficient market behavior'\n    };\n  };\n\n  const formattedData = useMemo(() => {\n    if (!data || data.length === 0) return [];\n    return data.map((value, index) => ({\n      lag: index + 1,\n      correlation: value,\n      significanceUpper: confidenceBound,\n      significanceLower: -confidenceBound,\n      ...getPartialCorrelationInterpretation(value, index + 1)\n    }));\n  }, [data, confidenceBound]);\n\n  const CustomTooltip = ({ active, payload, label }) => {\n    if (!active || !payload || !payload.length) return null;\n\n    const { correlation, strength, interpretation, economic } = payload[0].payload;\n    const isSignificant = Math.abs(correlation) > confidenceBound;\n\n    return (\n      <Paper \n        sx={{ \n          p: 2, \n          bgcolor: theme.palette.background.paper,\n          border: `1px solid ${theme.palette.divider}`,\n          boxShadow: theme.shadows[2]\n        }}\n      >\n        <Typography variant=\"subtitle2\" color=\"primary\" gutterBottom>\n          Lag {label}\n        </Typography>\n        <Typography variant=\"body2\" gutterBottom>\n          Direct Effect: {correlation.toFixed(4)}\n        </Typography>\n        <Typography \n          variant=\"body2\" \n          color={isSignificant ? theme.palette.error.main : theme.palette.success.main}\n          gutterBottom\n        >\n          {isSignificant ? 'Statistically Significant' : 'Not Significant'}\n        </Typography>\n        <Box sx={{ mt: 1, pt: 1, borderTop: `1px solid ${theme.palette.divider}` }}>\n          <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n            Strength: {strength}\n          </Typography>\n          <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n            {interpretation}\n          </Typography>\n          <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n            {economic}\n          </Typography>\n        </Box>\n      </Paper>\n    );\n  };\n\n  if (formattedData.length === 0) {\n    return (\n      <Typography variant=\"body2\" color=\"text.secondary\">\n        No PACF data available to display.\n      </Typography>\n    );\n  }\n\n  return (\n    <Box sx={{ width: '100%', height: '100%', p: 2 }}>\n      <ResponsiveContainer width=\"100%\" height=\"100%\">\n        <BarChart \n          data={formattedData} \n          margin={{ top: 20, right: 30, left: 20, bottom: 20 }}\n        >\n          <XAxis \n            dataKey=\"lag\" \n            stroke={theme.palette.text.primary}\n            tick={{ fill: theme.palette.text.primary }}\n            label={{ \n              value: 'Time Lag (Periods)', \n              position: 'insideBottom', \n              offset: -10,\n              fill: theme.palette.text.primary,\n              fontSize: 12,\n              fontWeight: 500\n            }} \n          />\n          <YAxis \n            stroke={theme.palette.text.primary}\n            tick={{ fill: theme.palette.text.primary }}\n            label={{ \n              value: 'Direct Price Effect', \n              angle: -90, \n              position: 'insideLeft',\n              fill: theme.palette.text.primary,\n              fontSize: 12,\n              fontWeight: 500\n            }}\n            domain={[-1, 1]}\n            tickFormatter={(value) => value.toFixed(2)}\n          />\n          <Tooltip content={<CustomTooltip />} />\n          <ReferenceLine \n            y={confidenceBound} \n            stroke={theme.palette.error.main}\n            strokeDasharray=\"3 3\"\n            strokeWidth={2}\n            label={{\n              value: 'Statistical Significance',\n              fill: theme.palette.error.main,\n              fontSize: 10,\n              position: 'right'\n            }}\n          />\n          <ReferenceLine \n            y={-confidenceBound} \n            stroke={theme.palette.error.main}\n            strokeDasharray=\"3 3\"\n            strokeWidth={2}\n          />\n          <ReferenceLine \n            y={0} \n            stroke={theme.palette.divider}\n            strokeWidth={1}\n          />\n          <Bar \n            dataKey=\"correlation\" \n            fill={theme.palette.primary.main}\n            stroke={theme.palette.primary.dark}\n            strokeWidth={1}\n            radius={[2, 2, 0, 0]}\n            maxBarSize={50}\n          />\n        </BarChart>\n      </ResponsiveContainer>\n      <Typography \n        variant=\"caption\" \n        color=\"text.secondary\"\n        sx={{ \n          display: 'block', \n          textAlign: 'center',\n          mt: 2\n        }}\n      >\n        Bars outside dashed lines indicate significant direct price relationships\n      </Typography>\n    </Box>\n  );\n};\n\nPACFPlot.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.number).isRequired,\n  significance: PropTypes.number.isRequired\n};\n\nexport default React.memo(PACFPlot);\n",
        "imports": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material"
        ]
      },
      {
        "path": "components/analysis/ecm/QQPlot.js",
        "content": "//src/components/analysis/ecm/QQPlot.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  ResponsiveContainer,\n  ScatterChart,\n  Scatter,\n  XAxis,\n  YAxis,\n  ReferenceLine,\n  Tooltip,\n  Legend\n} from 'recharts';\nimport { jStat } from 'jstat';\nimport { Typography, Box, useTheme } from '@mui/material';\n\nconst QQPlot = ({ residuals }) => {\n  const theme = useTheme();\n\n  const qqData = useMemo(() => {\n    if (!residuals || residuals.length === 0) return [];\n\n    const sortedResiduals = [...residuals].sort((a, b) => a - b);\n    const n = sortedResiduals.length;\n\n    return sortedResiduals.map((value, i) => {\n      const p = (i + 0.5) / n;\n      const theoreticalQuantile = jStat.normal.inv(p, 0, 1);\n      return {\n        theoretical: theoreticalQuantile,\n        sample: value\n      };\n    });\n  }, [residuals]);\n\n  if (qqData.length === 0) {\n    return (\n      <Typography variant=\"body2\" color=\"text.secondary\">\n        No residuals data available to display Q-Q Plot.\n      </Typography>\n    );\n  }\n\n  return (\n    <Box sx={{ width: '100%', height: '100%', p: 2 }}>\n      <ResponsiveContainer width=\"100%\" height=\"100%\">\n        <ScatterChart margin={{ top: 20, right: 30, left: 20, bottom: 20 }}>\n          <XAxis \n            dataKey=\"theoretical\" \n            stroke={theme.palette.text.primary}\n            tick={{ fill: theme.palette.text.primary }}\n            label={{ \n              value: 'Theoretical Quantiles', \n              position: 'insideBottom', \n              offset: -10,\n              fill: theme.palette.text.primary,\n              fontSize: 12,\n              fontWeight: 500\n            }} \n          />\n          <YAxis \n            dataKey=\"sample\"\n            stroke={theme.palette.text.primary}\n            tick={{ fill: theme.palette.text.primary }}\n            label={{ \n              value: 'Sample Quantiles', \n              angle: -90, \n              position: 'insideLeft',\n              fill: theme.palette.text.primary,\n              fontSize: 12,\n              fontWeight: 500\n            }} \n          />\n          <Tooltip \n            formatter={(value) => [`${value.toFixed(4)}`, 'Sample Quantile']}\n            labelFormatter={(label) => `Theoretical: ${Number(label).toFixed(4)}`}\n            contentStyle={{\n              backgroundColor: theme.palette.background.paper,\n              border: `1px solid ${theme.palette.divider}`,\n              borderRadius: 4,\n              padding: '8px 12px',\n              boxShadow: theme.shadows[2]\n            }}\n          />\n          <Legend \n            verticalAlign=\"top\"\n            height={36}\n            wrapperStyle={{\n              fontSize: '12px',\n              fontWeight: 500\n            }}\n          />\n          <ReferenceLine \n            y={0} \n            stroke={theme.palette.divider}\n            strokeWidth={2}\n            strokeDasharray=\"3 3\" \n          />\n          <ReferenceLine \n            x={0} \n            stroke={theme.palette.divider}\n            strokeWidth={2}\n            strokeDasharray=\"3 3\" \n          />\n          <Scatter \n            name=\"Q-Q Plot Points\"\n            data={qqData} \n            fill={theme.palette.primary.main}\n            stroke={theme.palette.primary.dark}\n            strokeWidth={1}\n            r={4}\n          />\n        </ScatterChart>\n      </ResponsiveContainer>\n    </Box>\n  );\n};\n\nQQPlot.propTypes = {\n  residuals: PropTypes.arrayOf(PropTypes.number).isRequired\n};\n\nexport default React.memo(QQPlot);",
        "imports": [
          "react",
          "prop-types",
          "recharts",
          "jstat",
          "@mui/material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "recharts",
          "jstat",
          "@mui/material"
        ]
      },
      {
        "path": "components/analysis/price-differential/CointegrationAnalysis.js",
        "content": "// src/components/analysis/price-differential/CointegrationAnalysis.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Paper,\n  Typography,\n  Grid,\n  Box,\n  Chip,\n  useTheme\n} from '@mui/material';\nimport {\n  CheckCircle as CheckCircleIcon,\n  Warning as WarningIcon\n} from '@mui/icons-material';\n\nconst CointegrationAnalysis = ({ cointegrationData }) => {\n  const theme = useTheme();\n\n  if (!cointegrationData) return null;\n\n  const isSignificant = cointegrationData.p_value < 0.05;\n  const testStat = cointegrationData.test_statistic;\n  const criticalValue5 = cointegrationData.critical_values['5%'];\n\n  return (\n    <Paper sx={{ p: 2, height: '100%' }}>\n      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>\n        <Typography variant=\"h6\">\n          Market Integration Analysis\n        </Typography>\n        <Chip\n          icon={isSignificant ? <CheckCircleIcon /> : <WarningIcon />}\n          label={isSignificant ? 'Markets Integrated' : 'Markets Segmented'}\n          color={isSignificant ? 'success' : 'warning'}\n          variant=\"outlined\"\n        />\n      </Box>\n\n      <Grid container spacing={2}>\n        <Grid item xs={12}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.background.default,\n            borderRadius: 1,\n            '&:hover .test-info': {\n              opacity: 1\n            }\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Cointegration Test Results\n            </Typography>\n            <Typography variant=\"body1\">\n              Test Statistic: {testStat.toFixed(4)}\n            </Typography>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              Critical Value (5%): {criticalValue5.toFixed(4)}\n            </Typography>\n            <Typography \n              className=\"test-info\"\n              variant=\"caption\" \n              sx={{ \n                display: 'block',\n                mt: 1,\n                opacity: 0,\n                transition: 'opacity 0.2s',\n                color: theme.palette.text.secondary\n              }}\n            >\n              {testStat < criticalValue5 \n                ? 'Evidence of long-run price relationship'\n                : 'No evidence of stable price relationship'}\n            </Typography>\n          </Box>\n        </Grid>\n\n        <Grid item xs={12}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.background.default,\n            borderRadius: 1,\n            '&:hover .significance-info': {\n              opacity: 1\n            }\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Statistical Significance\n            </Typography>\n            <Typography variant=\"body1\">\n              P-value: {cointegrationData.p_value.toFixed(4)}\n            </Typography>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              {isSignificant ? 'Significant at 5% level' : 'Not significant at 5% level'}\n            </Typography>\n            <Typography \n              className=\"significance-info\"\n              variant=\"caption\" \n              sx={{ \n                display: 'block',\n                mt: 1,\n                opacity: 0,\n                transition: 'opacity 0.2s',\n                color: theme.palette.text.secondary\n              }}\n            >\n              {isSignificant \n                ? 'Strong evidence of market integration'\n                : 'Markets may be operating independently'}\n            </Typography>\n          </Box>\n        </Grid>\n\n        <Grid item xs={12}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.grey[50],\n            borderRadius: 1\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Critical Values\n            </Typography>\n            <Grid container spacing={2}>\n              {Object.entries(cointegrationData.critical_values).map(([level, value]) => (\n                <Grid item xs={4} key={level}>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    {level} Level\n                  </Typography>\n                  <Typography variant=\"body1\">\n                    {value.toFixed(4)}\n                  </Typography>\n                </Grid>\n              ))}\n            </Grid>\n          </Box>\n        </Grid>\n      </Grid>\n    </Paper>\n  );\n};\n\nCointegrationAnalysis.propTypes = {\n  cointegrationData: PropTypes.shape({\n    test_statistic: PropTypes.number.isRequired,\n    p_value: PropTypes.number.isRequired,\n    critical_values: PropTypes.objectOf(PropTypes.number).isRequired\n  })\n};\n\nexport default React.memo(CointegrationAnalysis);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material"
        ]
      },
      {
        "path": "components/analysis/price-differential/InterpretationSection.js",
        "content": "// src/components/analysis/price-differential/InterpretationSection.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Alert,\n  Grid,\n  Chip,\n  useTheme\n} from '@mui/material';\nimport { CheckCircle as CheckCircleIcon, Warning as WarningIcon } from '@mui/icons-material';\n\nconst InterpretationSection = ({ data, baseMarket, comparisonMarket }) => {\n  const theme = useTheme();\n\n  if (!data) {\n    return (\n      <Alert severity=\"info\">\n        No data available for interpretation.\n      </Alert>\n    );\n  }\n\n  const sections = [\n    {\n      title: 'Market Integration Analysis',\n      content: () => {\n        const isIntegrated = data.cointegration_results?.p_value < 0.05;\n        const integrationStrength = data.regression_results?.r_squared || 0;\n        return {\n          summary: isIntegrated \n            ? 'Markets exhibit significant price co-movement patterns'\n            : 'Markets show limited price relationship',\n          details: [\n            `Integration: ${isIntegrated ? 'Present' : 'Absent'}`,\n            `Strength: ${(integrationStrength * 100).toFixed(1)}%`,\n            `Confidence: ${((1 - (data.cointegration_results?.p_value || 1)) * 100).toFixed(1)}%`\n          ],\n          interpretation: isIntegrated\n            ? 'Price changes in one market are systematically reflected in the other, suggesting effective arbitrage'\n            : 'Markets appear to operate independently, indicating potential trade barriers',\n          status: isIntegrated ? 'success' : 'warning'\n        };\n      }\n    },\n    {\n      title: 'Price Stability Analysis',\n      content: () => {\n        const isStationaryADF = data.stationarity_results?.ADF?.['p-value'] < 0.05;\n        const isStationaryKPSS = data.stationarity_results?.KPSS?.['p-value'] >= 0.05;\n        const isStable = isStationaryADF && isStationaryKPSS;\n        \n        return {\n          summary: isStable\n            ? 'Price differentials show mean-reverting behavior'\n            : 'Price differentials exhibit persistent deviations',\n          details: [\n            `Mean Reversion: ${isStationaryADF ? 'Confirmed' : 'Not Confirmed'}`,\n            `Trend Stability: ${isStationaryKPSS ? 'Stable' : 'Unstable'}`,\n            `Overall: ${isStable ? 'Stable' : 'Volatile'}`\n          ],\n          interpretation: isStable\n            ? 'Price differences tend to correct over time, indicating effective market mechanisms'\n            : 'Price gaps persist, suggesting structural market inefficiencies',\n          status: isStable ? 'success' : 'warning'\n        };\n      }\n    },\n    {\n      title: 'Market Friction Analysis',\n      content: () => {\n        const distance = data.diagnostics?.distance_km || 0;\n        const conflict = data.diagnostics?.conflict_correlation || 0;\n        const hasSignificantFrictions = distance > 2 || Math.abs(conflict) > 0.3;\n        \n        return {\n          summary: hasSignificantFrictions\n            ? 'Significant market frictions detected'\n            : 'Limited market frictions observed',\n          details: [\n            `Distance: ${distance.toFixed(1)} km`,\n            `Conflict Impact: ${(conflict * 100).toFixed(1)}%`,\n            `Friction Level: ${hasSignificantFrictions ? 'High' : 'Low'}`\n          ],\n          interpretation: hasSignificantFrictions\n            ? 'Physical and conflict-related barriers may impede market efficiency'\n            : 'Market conditions support relatively smooth trade flows',\n          status: hasSignificantFrictions ? 'warning' : 'success'\n        };\n      }\n    },\n    {\n      title: 'Policy Implications',\n      content: () => {\n        const needsIntervention = \n          data.cointegration_results?.p_value >= 0.05 ||\n          Math.abs(data.diagnostics?.conflict_correlation || 0) > 0.3;\n        \n        return {\n          summary: needsIntervention\n            ? 'Market intervention may be warranted'\n            : 'Markets functioning relatively efficiently',\n          details: [\n            `Integration Support: ${needsIntervention ? 'Needed' : 'Limited Need'}`,\n            `Trade Barriers: ${needsIntervention ? 'Address' : 'Monitor'}`,\n            `Policy Focus: ${needsIntervention ? 'Intervention' : 'Maintenance'}`\n          ],\n          interpretation: needsIntervention\n            ? 'Consider policies to reduce trade barriers and enhance market integration'\n            : 'Focus on maintaining current market conditions and monitoring changes',\n          status: needsIntervention ? 'warning' : 'success'\n        };\n      }\n    }\n  ];\n\n  return (\n    <Box>\n      <Grid container spacing={3}>\n        {sections.map((section) => {\n          const interpretation = section.content();\n          return (\n            <Grid item xs={12} key={section.title}>\n              <Paper \n                sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  '&:hover .interpretation-info': {\n                    opacity: 1\n                  }\n                }}\n              >\n                <Box sx={{ \n                  display: 'flex', \n                  justifyContent: 'space-between', \n                  alignItems: 'center',\n                  mb: 2 \n                }}>\n                  <Typography variant=\"h6\" color=\"primary\">\n                    {section.title}\n                  </Typography>\n                  <Chip\n                    icon={interpretation.status === 'success' ? <CheckCircleIcon /> : <WarningIcon />}\n                    label={interpretation.status === 'success' ? 'Favorable' : 'Attention Needed'}\n                    color={interpretation.status}\n                    variant=\"outlined\"\n                  />\n                </Box>\n                <Typography variant=\"body1\" paragraph>\n                  {interpretation.summary}\n                </Typography>\n                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 2 }}>\n                  {interpretation.details.map((detail, index) => (\n                    <Chip\n                      key={index}\n                      label={detail}\n                      size=\"small\"\n                      variant=\"outlined\"\n                      sx={{ my: 0.5 }}\n                    />\n                  ))}\n                </Box>\n                <Typography \n                  className=\"interpretation-info\"\n                  variant=\"body2\" \n                  sx={{ \n                    opacity: 0,\n                    transition: 'opacity 0.2s',\n                    color: theme.palette.text.secondary\n                  }}\n                >\n                  {interpretation.interpretation}\n                </Typography>\n              </Paper>\n            </Grid>\n          );\n        })}\n      </Grid>\n\n      <Box sx={{ \n        mt: 3, \n        p: 2, \n        bgcolor: theme.palette.grey[50], \n        borderRadius: 1,\n        '&:hover .methodology-info': {\n          opacity: 1\n        }\n      }}>\n        <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n          Methodology Note\n        </Typography>\n        <Typography variant=\"body2\">\n          Analysis of market relationship between {baseMarket} and {comparisonMarket} combines multiple \n          statistical indicators with economic theory.\n        </Typography>\n        <Typography \n          className=\"methodology-info\"\n          variant=\"caption\" \n          sx={{ \n            display: 'block',\n            mt: 1,\n            opacity: 0,\n            transition: 'opacity 0.2s',\n            color: theme.palette.text.secondary\n          }}\n        >\n          Interpretations should be considered alongside local market conditions, temporal factors, \n          and broader economic context.\n        </Typography>\n      </Box>\n    </Box>\n  );\n};\n\nInterpretationSection.propTypes = {\n  data: PropTypes.shape({\n    cointegration_results: PropTypes.shape({\n      p_value: PropTypes.number,\n    }),\n    regression_results: PropTypes.shape({\n      r_squared: PropTypes.number,\n    }),\n    stationarity_results: PropTypes.shape({\n      ADF: PropTypes.shape({\n        'p-value': PropTypes.number,\n      }),\n      KPSS: PropTypes.shape({\n        'p-value': PropTypes.number,\n      })\n    }),\n    diagnostics: PropTypes.shape({\n      distance_km: PropTypes.number,\n      conflict_correlation: PropTypes.number,\n    })\n  }).isRequired,\n  baseMarket: PropTypes.string.isRequired,\n  comparisonMarket: PropTypes.string.isRequired\n};\n\nexport default React.memo(InterpretationSection);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material"
        ]
      },
      {
        "path": "components/analysis/price-differential/MarketPairInfo.js",
        "content": "// src/components/analysis/price-differential/MarketPairInfo.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Paper,\n  Typography,\n  Grid,\n  Box,\n  Chip,\n  useTheme\n} from '@mui/material';\nimport {\n  TrendingUp as TrendingUpIcon,\n  TrendingDown as TrendingDownIcon,\n  SwapHoriz as SwapHorizIcon\n} from '@mui/icons-material';\n\nconst MarketPairInfo = ({ data, baseMarket, comparisonMarket, isMobile }) => {\n  const theme = useTheme();\n  \n  const metrics = useMemo(() => {\n    const distance = data.diagnostics?.distance_km || 0;\n    const conflictCorr = data.diagnostics?.conflict_correlation || 0;\n    const commonDates = data.diagnostics?.common_dates || 0;\n    \n    return {\n      distance: {\n        value: distance.toFixed(1),\n        label: 'Market Distance',\n        unit: 'km',\n        status: distance > 2 ? 'warning' : 'success',\n        description: 'Geographical separation between markets',\n        interpretation: distance > 2 \n          ? 'Significant spatial barriers may exist'\n          : 'Markets are geographically close'\n      },\n      correlation: {\n        value: (conflictCorr * 100).toFixed(1),\n        label: 'Conflict Impact',\n        unit: '%',\n        status: Math.abs(conflictCorr) > 0.3 ? 'warning' : 'success',\n        description: 'Correlation of conflict intensities',\n        interpretation: Math.abs(conflictCorr) > 0.3\n          ? 'High conflict synchronization'\n          : 'Limited conflict correlation'\n      },\n      periods: {\n        value: commonDates,\n        label: 'Time Coverage',\n        unit: 'months',\n        status: commonDates >= 24 ? 'success' : 'warning',\n        description: 'Length of analysis period',\n        interpretation: commonDates >= 24\n          ? 'Sufficient historical data'\n          : 'Limited time coverage'\n      }\n    };\n  }, [data]);\n\n  return (\n    <Box>\n      <Box sx={{ \n        display: 'flex', \n        alignItems: 'center', \n        gap: 1, \n        mb: 2 \n      }}>\n        <Typography variant=\"h6\" sx={{ flexGrow: 1 }}>\n          {baseMarket}\n        </Typography>\n        <SwapHorizIcon color=\"action\" />\n        <Typography variant=\"h6\">\n          {comparisonMarket}\n        </Typography>\n      </Box>\n\n      <Grid container spacing={2}>\n        {Object.entries(metrics).map(([key, metric]) => (\n          <Grid item xs={12} md={4} key={key}>\n            <Box sx={{\n              p: 2,\n              bgcolor: theme.palette.background.default,\n              borderRadius: 1,\n              height: '100%',\n              '&:hover .metric-info': {\n                opacity: 1\n              }\n            }}>\n              <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n                {metric.label}\n              </Typography>\n              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>\n                <Typography variant=\"h6\" sx={{ fontSize: '1.1rem', fontWeight: 600 }}>\n                  {metric.value}{metric.unit && ` ${metric.unit}`}\n                </Typography>\n                <Chip\n                  size=\"small\"\n                  icon={metric.status === 'success' ? <TrendingUpIcon /> : <TrendingDownIcon />}\n                  label={metric.status === 'success' ? 'Favorable' : 'Concerning'}\n                  color={metric.status}\n                  variant=\"outlined\"\n                />\n              </Box>\n              <Typography variant=\"body2\" color=\"text.secondary\">\n                {metric.description}\n              </Typography>\n              <Typography \n                className=\"metric-info\"\n                variant=\"caption\" \n                sx={{ \n                  display: 'block',\n                  mt: 1,\n                  opacity: 0,\n                  transition: 'opacity 0.2s',\n                  color: theme.palette.text.secondary\n                }}\n              >\n                {metric.interpretation}\n              </Typography>\n            </Box>\n          </Grid>\n        ))}\n      </Grid>\n    </Box>\n  );\n};\n\nMarketPairInfo.propTypes = {\n  data: PropTypes.shape({\n    diagnostics: PropTypes.shape({\n      distance_km: PropTypes.number,\n      conflict_correlation: PropTypes.number,\n      common_dates: PropTypes.number\n    }),\n    cointegration_results: PropTypes.shape({\n      p_value: PropTypes.number\n    })\n  }).isRequired,\n  baseMarket: PropTypes.string.isRequired,\n  comparisonMarket: PropTypes.string.isRequired,\n  isMobile: PropTypes.bool.isRequired\n};\n\nexport default React.memo(MarketPairInfo);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material"
        ]
      },
      {
        "path": "components/analysis/price-differential/PriceDifferentialAnalysis.js",
        "content": "// src/components/analysis/price-differential/PriceDifferentialAnalysis.js\n\nimport React, { useState, useCallback, useMemo, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Button,\n  useTheme,\n  CircularProgress,\n  Alert,\n  Typography,\n  Snackbar,\n  Paper,\n  Grid,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails,\n  IconButton,\n  Tooltip,\n  FormControl,\n  InputLabel,\n  Select,\n  MenuItem,\n  Divider\n} from '@mui/material';\nimport { Download, ExpandMore, Info } from '@mui/icons-material';\nimport { saveAs } from 'file-saver';\nimport { usePriceDifferentialData } from '../../../hooks/dataHooks';\n\nimport PriceDifferentialChart from './PriceDifferentialChart';\nimport MarketPairInfo from './MarketPairInfo';\nimport CointegrationAnalysis from './CointegrationAnalysis';\nimport StationarityTest from './StationarityTest';\nimport PriceDifferentialFramework from './PriceDifferentialFramework';\nimport InterpretationSection from './InterpretationSection';\n\nconst PriceDifferentialAnalysis = ({ selectedCommodity, windowWidth }) => {\n  const theme = useTheme();\n  const isMobile = windowWidth < theme.breakpoints.values.sm;\n  \n  const [baseMarket, setBaseMarket] = useState('');\n  const [otherMarket, setOtherMarket] = useState('');\n  const [frameworkExpanded, setFrameworkExpanded] = useState(false);\n  const [interpretationExpanded, setInterpretationExpanded] = useState(false);\n  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });\n\n  const {\n    data,\n    markets,\n    error,\n    isLoading\n  } = usePriceDifferentialData(selectedCommodity);\n\n  // Set initial base market\n  useEffect(() => {\n    if (markets.length > 0) {\n      setBaseMarket((prev) => (markets.includes(prev) ? prev : markets[0]));\n    }\n  }, [markets]);\n\n  // Filter available comparison markets based on base market\n  const availableComparisonMarkets = useMemo(() => {\n    if (!baseMarket || !data.length) return [];\n    return data\n      .filter(item => item.base_market === baseMarket)\n      .map(item => item.other_market);\n  }, [baseMarket, data]);\n\n  // Update comparison market when base market changes\n  useEffect(() => {\n    if (baseMarket && availableComparisonMarkets.length > 0) {\n      setOtherMarket((prev) => \n        availableComparisonMarkets.includes(prev) ? prev : availableComparisonMarkets[0]\n      );\n    } else {\n      setOtherMarket('');\n    }\n  }, [baseMarket, availableComparisonMarkets]);\n\n  const selectedPairData = useMemo(() => {\n    if (!baseMarket || !otherMarket || !data.length) return null;\n    return data.find(d => \n      d.base_market === baseMarket && \n      d.other_market === otherMarket\n    );\n  }, [data, baseMarket, otherMarket]);\n\n  const handleBaseMarketChange = useCallback((event) => {\n    setBaseMarket(event.target.value);\n  }, []);\n\n  const handleComparisonMarketChange = useCallback((event) => {\n    setOtherMarket(event.target.value);\n  }, []);\n\n  const handleDownloadData = useCallback(() => {\n    if (!selectedPairData) return;\n    try {\n      const blob = new Blob(\n        [JSON.stringify(selectedPairData, null, 2)],\n        { type: 'application/json' }\n      );\n      saveAs(blob, `price_differential_${baseMarket}_${otherMarket}_${selectedCommodity}.json`);\n      setSnackbar({\n        open: true,\n        message: 'Data downloaded successfully',\n        severity: 'success'\n      });\n    } catch (error) {\n      setSnackbar({\n        open: true,\n        message: 'Failed to download data',\n        severity: 'error'\n      });\n    }\n  }, [selectedPairData, baseMarket, otherMarket, selectedCommodity]);\n\n  if (isLoading) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>\n        <CircularProgress />\n      </Box>\n    );\n  }\n\n  if (error) {\n    return (\n      <Alert severity=\"error\">\n        <Typography variant=\"subtitle1\" gutterBottom>Error Loading Data</Typography>\n        {error}\n      </Alert>\n    );\n  }\n\n  return (\n    <Box sx={{ width: '100%', mb: 4 }}>\n      {/* Controls with Market Selection and Download Button */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Grid container spacing={2} alignItems=\"center\">\n          <Grid item xs={12} md={4}>\n            <FormControl fullWidth size=\"small\">\n              <InputLabel>Base Market</InputLabel>\n              <Select\n                value={baseMarket}\n                onChange={handleBaseMarketChange}\n                label=\"Base Market\"\n              >\n                {markets.map(market => (\n                  <MenuItem key={market} value={market}>{market}</MenuItem>\n                ))}\n              </Select>\n            </FormControl>\n          </Grid>\n          \n          <Grid item xs={12} md={4}>\n            <FormControl fullWidth size=\"small\">\n              <InputLabel>Comparison Market</InputLabel>\n              <Select\n                value={otherMarket}\n                onChange={handleComparisonMarketChange}\n                label=\"Comparison Market\"\n                disabled={!baseMarket || availableComparisonMarkets.length === 0}\n              >\n                {availableComparisonMarkets.map(market => (\n                  <MenuItem key={market} value={market}>{market}</MenuItem>\n                ))}\n              </Select>\n            </FormControl>\n          </Grid>\n\n          <Grid item xs={12} md={4}>\n            <Button\n              fullWidth\n              variant=\"contained\"\n              startIcon={<Download />}\n              onClick={handleDownloadData}\n              disabled={!selectedPairData}\n            >\n              Download Results\n            </Button>\n          </Grid>\n        </Grid>\n      </Paper>\n\n      {selectedPairData && (\n        <>\n          {/* Model Framework Section - Moved up to be right after controls */}\n          <Accordion \n            expanded={frameworkExpanded} \n            onChange={() => setFrameworkExpanded(!frameworkExpanded)}\n            sx={{ mb: 3 }}\n          >\n            <AccordionSummary \n              expandIcon={<ExpandMore />}\n              sx={{\n                backgroundColor: theme.palette.grey[50],\n                '&:hover': {\n                  backgroundColor: theme.palette.grey[100],\n                }\n              }}\n            >\n              <Typography variant=\"h6\">\n                Price Differential Model Framework\n              </Typography>\n            </AccordionSummary>\n            <AccordionDetails sx={{ p: 3 }}>\n              <PriceDifferentialFramework \n                baseMarket={baseMarket}\n                comparisonMarket={otherMarket}\n                regressionResults={selectedPairData.regression_results}\n                diagnostics={selectedPairData.diagnostics}\n              />\n            </AccordionDetails>\n          </Accordion>\n\n          <Paper sx={{ p: 1.5, mb: 3 }}>\n            <MarketPairInfo \n              data={selectedPairData}\n              baseMarket={baseMarket}\n              comparisonMarket={otherMarket}\n              isMobile={isMobile}\n            />\n          </Paper>\n\n          <Paper sx={{ p: 2, mb: 3 }}>\n            <Typography variant=\"h6\" gutterBottom sx={{ mb: 2 }}>\n              Model Parameters\n            </Typography>\n            <Grid container spacing={2}>\n              <Grid item xs={12} md={3}>\n                <Box sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  borderRadius: 1,\n                  '&:hover .parameter-info': {\n                    opacity: 1\n                  }\n                }}>\n                  <Typography variant=\"h6\" sx={{ fontSize: '1.1rem', fontWeight: 600 }}>\n                    β = {selectedPairData.regression_results?.slope?.toFixed(4)}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Market Integration Speed\n                  </Typography>\n                  <Typography \n                    className=\"parameter-info\"\n                    variant=\"caption\" \n                    sx={{ \n                      opacity: 0,\n                      transition: 'opacity 0.2s',\n                      color: theme.palette.text.secondary\n                    }}\n                  >\n                    Rate of price convergence between markets\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <Box sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  borderRadius: 1,\n                  '&:hover .parameter-info': {\n                    opacity: 1\n                  }\n                }}>\n                  <Typography variant=\"h6\" sx={{ fontSize: '1.1rem', fontWeight: 600 }}>\n                    α = {selectedPairData.regression_results?.intercept?.toFixed(4)}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Long-run Differential\n                  </Typography>\n                  <Typography \n                    className=\"parameter-info\"\n                    variant=\"caption\" \n                    sx={{ \n                      opacity: 0,\n                      transition: 'opacity 0.2s',\n                      color: theme.palette.text.secondary\n                    }}\n                  >\n                    Equilibrium price difference between markets\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <Box sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  borderRadius: 1,\n                  '&:hover .parameter-info': {\n                    opacity: 1\n                  }\n                }}>\n                  <Typography variant=\"h6\" sx={{ fontSize: '1.1rem', fontWeight: 600 }}>\n                    d = {selectedPairData.diagnostics?.distance_km?.toFixed(2)} km\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Market Distance\n                  </Typography>\n                  <Typography \n                    className=\"parameter-info\"\n                    variant=\"caption\" \n                    sx={{ \n                      opacity: 0,\n                      transition: 'opacity 0.2s',\n                      color: theme.palette.text.secondary\n                    }}\n                  >\n                    Geographical separation between markets\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <Box sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  borderRadius: 1,\n                  '&:hover .parameter-info': {\n                    opacity: 1\n                  }\n                }}>\n                  <Typography variant=\"h6\" sx={{ fontSize: '1.1rem', fontWeight: 600 }}>\n                    ρ = {selectedPairData.diagnostics?.conflict_correlation?.toFixed(2)}\n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    Conflict Impact\n                  </Typography>\n                  <Typography \n                    className=\"parameter-info\"\n                    variant=\"caption\" \n                    sx={{ \n                      opacity: 0,\n                      transition: 'opacity 0.2s',\n                      color: theme.palette.text.secondary\n                    }}\n                  >\n                    Correlation of conflict intensities\n                  </Typography>\n                </Box>\n              </Grid>\n            </Grid>\n          </Paper>\n\n          <Paper sx={{ p: 2, mb: 3 }}>\n            <Typography variant=\"h6\" gutterBottom>Model Diagnostics</Typography>\n            <Grid container spacing={2}>\n              <Grid item xs={12} sm={6} md={3}>\n                <Box sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  borderRadius: 1,\n                  '&:hover .diagnostic-info': {\n                    opacity: 1\n                  }\n                }}>\n                  <Typography variant=\"subtitle2\" color=\"text.secondary\">\n                    Model Fit\n                  </Typography>\n                  <Typography variant=\"body1\">\n                    {selectedPairData.regression_results?.r_squared\n                      ? `${(selectedPairData.regression_results.r_squared * 100).toFixed(1)}%`\n                      : 'N/A'}\n                  </Typography>\n                  <Typography \n                    className=\"diagnostic-info\"\n                    variant=\"caption\" \n                    sx={{ \n                      opacity: 0,\n                      transition: 'opacity 0.2s',\n                      color: theme.palette.text.secondary\n                    }}\n                  >\n                    R² - Explained variation in price differentials\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} sm={6} md={3}>\n                <Box sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  borderRadius: 1,\n                  '&:hover .diagnostic-info': {\n                    opacity: 1\n                  }\n                }}>\n                  <Typography variant=\"subtitle2\" color=\"text.secondary\">\n                    AIC Score\n                  </Typography>\n                  <Typography variant=\"body1\">\n                    {selectedPairData.regression_results?.aic?.toFixed(2) || 'N/A'}\n                  </Typography>\n                  <Typography \n                    className=\"diagnostic-info\"\n                    variant=\"caption\" \n                    sx={{ \n                      opacity: 0,\n                      transition: 'opacity 0.2s',\n                      color: theme.palette.text.secondary\n                    }}\n                  >\n                    Akaike Information Criterion\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} sm={6} md={3}>\n                <Box sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  borderRadius: 1,\n                  '&:hover .diagnostic-info': {\n                    opacity: 1\n                  }\n                }}>\n                  <Typography variant=\"subtitle2\" color=\"text.secondary\">\n                    BIC Score\n                  </Typography>\n                  <Typography variant=\"body1\">\n                    {selectedPairData.regression_results?.bic?.toFixed(2) || 'N/A'}\n                  </Typography>\n                  <Typography \n                    className=\"diagnostic-info\"\n                    variant=\"caption\" \n                    sx={{ \n                      opacity: 0,\n                      transition: 'opacity 0.2s',\n                      color: theme.palette.text.secondary\n                    }}\n                  >\n                    Bayesian Information Criterion\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} sm={6} md={3}>\n                <Box sx={{ \n                  p: 2, \n                  bgcolor: theme.palette.background.default,\n                  borderRadius: 1,\n                  '&:hover .diagnostic-info': {\n                    opacity: 1\n                  }\n                }}>\n                  <Typography variant=\"subtitle2\" color=\"text.secondary\">\n                    Significance\n                  </Typography>\n                  <Typography variant=\"body1\">\n                    {selectedPairData.regression_results?.p_value < 0.05 ? 'Significant' : 'Not Significant'}\n                  </Typography>\n                  <Typography \n                    className=\"diagnostic-info\"\n                    variant=\"caption\" \n                    sx={{ \n                      opacity: 0,\n                      transition: 'opacity 0.2s',\n                      color: theme.palette.text.secondary\n                    }}\n                  >\n                    p = {selectedPairData.regression_results?.p_value?.toExponential(2) || 'N/A'}\n                  </Typography>\n                </Box>\n              </Grid>\n            </Grid>\n          </Paper>\n\n          <Grid container spacing={3}>\n            <Grid item xs={12}>\n              <PriceDifferentialChart \n                data={{\n                  dates: selectedPairData.price_differential.dates,\n                  values: selectedPairData.price_differential.values\n                }}\n                baseMarket={baseMarket}\n                comparisonMarket={otherMarket}\n                commodity={selectedCommodity}\n                isMobile={isMobile}\n              />\n            </Grid>\n\n            <Grid item xs={12} md={6}>\n              <StationarityTest \n                stationarityData={selectedPairData.stationarity_results}\n              />\n            </Grid>\n\n            <Grid item xs={12} md={6}>\n              <CointegrationAnalysis \n                cointegrationData={selectedPairData.cointegration_results}\n              />\n            </Grid>\n          </Grid>\n\n          <Accordion\n            expanded={interpretationExpanded}\n            onChange={() => setInterpretationExpanded(!interpretationExpanded)}\n            sx={{ mt: 3 }}\n          >\n            <AccordionSummary \n              expandIcon={<ExpandMore />}\n              sx={{\n                backgroundColor: theme.palette.grey[50],\n                '&:hover': {\n                  backgroundColor: theme.palette.grey[100],\n                }\n              }}\n            >\n              <Typography variant=\"h6\">\n                Detailed Market Analysis Interpretation\n              </Typography>\n            </AccordionSummary>\n            <AccordionDetails>\n              <InterpretationSection \n                data={selectedPairData}\n                baseMarket={baseMarket}\n                comparisonMarket={otherMarket}\n              />\n            </AccordionDetails>\n          </Accordion>\n        </>\n      )}\n\n      <Snackbar\n        open={snackbar.open}\n        autoHideDuration={6000}\n        onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}\n        message={snackbar.message}\n        severity={snackbar.severity}\n      />\n    </Box>\n  );\n};\n\nPriceDifferentialAnalysis.propTypes = {\n  selectedCommodity: PropTypes.string.isRequired,\n  windowWidth: PropTypes.number.isRequired\n};\n\nexport default React.memo(PriceDifferentialAnalysis);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "file-saver",
          "../../../hooks/dataHooks",
          "./PriceDifferentialChart",
          "./MarketPairInfo",
          "./CointegrationAnalysis",
          "./StationarityTest",
          "./PriceDifferentialFramework",
          "./InterpretationSection"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "file-saver",
          "../../../hooks/dataHooks",
          "./PriceDifferentialChart",
          "./MarketPairInfo",
          "./CointegrationAnalysis",
          "./StationarityTest",
          "./PriceDifferentialFramework",
          "./InterpretationSection"
        ]
      },
      {
        "path": "components/analysis/price-differential/PriceDifferentialChart.js",
        "content": "// src/components/analysis/price-differential/PriceDifferentialChart.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Paper,\n  Typography,\n  Tooltip,\n  IconButton,\n  Alert,\n  useTheme\n} from '@mui/material';\nimport {\n  ComposedChart,\n  Line,\n  Area,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip as RechartsTooltip,\n  Legend,\n  ResponsiveContainer,\n  Brush\n} from 'recharts';\nimport { Info as InfoIcon } from '@mui/icons-material';\n\n\nconst PriceDifferentialChart = ({\n  data,\n  baseMarket,\n  comparisonMarket,\n  commodity,\n  isMobile\n}) => {\n  const theme = useTheme();\n\n  const chartData = useMemo(() => {\n    if (!data?.values || !data?.dates) return [];\n    \n    return data.dates.map((date, index) => ({\n      date: new Date(date).toLocaleDateString(),\n      differential: data.values[index],\n      upperBound: data.confidence_bounds?.upper?.[index],\n      lowerBound: data.confidence_bounds?.lower?.[index]\n    }));\n  }, [data]);\n\n  const CustomTooltip = ({ active, payload, label }) => {\n    if (!active || !payload || !payload.length) return null;\n\n    return (\n      <Box sx={{\n        bgcolor: 'background.paper',\n        p: 1.5,\n        border: `1px solid ${theme.palette.divider}`,\n        borderRadius: 1,\n        boxShadow: theme.shadows[1],\n      }}>\n        <Typography variant=\"subtitle2\" gutterBottom>\n          {label}\n        </Typography>\n        {payload.map((entry, index) => (\n          <Typography \n            key={index}\n            variant=\"body2\"\n            color={entry.color}\n            sx={{ display: 'flex', justifyContent: 'space-between', gap: 2 }}\n          >\n            <span>{entry.name}:</span>\n            <span>{entry.value.toFixed(4)}</span>\n          </Typography>\n        ))}\n      </Box>\n    );\n  };\n\n  return (\n    <Paper sx={{ p: 3, mb: 3 }}>\n      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>\n        <Typography variant=\"h6\">\n          Price Differential Trends\n          <Tooltip title=\"Visualization of price differentials over time\">\n            <IconButton size=\"small\">\n              <InfoIcon fontSize=\"small\" />\n            </IconButton>\n          </Tooltip>\n        </Typography>\n      </Box>\n\n      {chartData.length === 0 ? (\n        <Alert severity=\"warning\">No price differential data available.</Alert>\n      ) : (\n        <ResponsiveContainer width=\"100%\" height={isMobile ? 300 : 500}>\n          <ComposedChart data={chartData}>\n            <CartesianGrid strokeDasharray=\"3 3\" stroke={theme.palette.divider} />\n            <XAxis \n              dataKey=\"date\"\n              label={{\n                value: 'Date',\n                position: 'insideBottom',\n                offset: -10\n              }}\n            />\n            <YAxis \n              label={{\n                value: 'Price Differential',\n                angle: -90,\n                position: 'insideLeft',\n                offset: 10\n              }}\n            />\n            <RechartsTooltip content={<CustomTooltip />} />\n            <Legend verticalAlign=\"top\" height={36} />\n            \n            <Line \n              type=\"monotone\" \n              dataKey=\"differential\" \n              stroke={theme.palette.primary.main}\n              name=\"Price Differential\"\n              dot={false}\n              strokeWidth={2}\n            />\n            \n            {data.confidence_bounds && (\n              <>\n                <Area\n                  type=\"monotone\"\n                  dataKey=\"upperBound\"\n                  stroke=\"none\"\n                  fill={theme.palette.primary.light}\n                  fillOpacity={0.2}\n                  name=\"Upper Confidence\"\n                />\n                <Area\n                  type=\"monotone\"\n                  dataKey=\"lowerBound\"\n                  stroke=\"none\"\n                  fill={theme.palette.primary.light}\n                  fillOpacity={0.2}\n                  name=\"Lower Confidence\"\n                />\n              </>\n            )}\n            \n            <Brush \n              dataKey=\"date\" \n              height={30} \n              stroke={theme.palette.primary.main}\n              fill={theme.palette.background.paper}\n            />\n          </ComposedChart>\n        </ResponsiveContainer>\n      )}\n    </Paper>\n  );\n};\n\nPriceDifferentialChart.propTypes = {\n  data: PropTypes.shape({\n    dates: PropTypes.arrayOf(PropTypes.string).isRequired,\n    values: PropTypes.arrayOf(PropTypes.number).isRequired,\n    confidence_bounds: PropTypes.shape({\n      upper: PropTypes.arrayOf(PropTypes.number),\n      lower: PropTypes.arrayOf(PropTypes.number)\n    })\n  }).isRequired,\n  baseMarket: PropTypes.string.isRequired,\n  comparisonMarket: PropTypes.string.isRequired,\n  commodity: PropTypes.string.isRequired,\n  isMobile: PropTypes.bool.isRequired\n};\n\nexport default React.memo(PriceDifferentialChart);",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "recharts",
          "@mui/icons-material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "recharts",
          "@mui/icons-material"
        ]
      },
      {
        "path": "components/analysis/price-differential/PriceDifferentialFramework.js",
        "content": "// src/components/analysis/price-differential/PriceDifferentialFramework.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Grid,\n  useTheme\n} from '@mui/material';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport 'katex/dist/katex.min.css';\n\nconst PriceDifferentialFramework = ({ \n  baseMarket, \n  comparisonMarket, \n  regressionResults, \n  diagnostics\n}) => {\n  const theme = useTheme();\n\n  return (\n    <Box sx={{ '& .katex': { fontSize: '1.3em' } }}>\n      {/* Price Differential Definition */}\n      <Typography variant=\"h6\" gutterBottom sx={{ color: theme.palette.primary.main }}>\n        Price Differential Relationship:\n      </Typography>\n      <Box sx={{ my: 3 }}>\n        <BlockMath math={`PD_{ij,t} = \\ln(P_{i,t}) - \\ln(P_{j,t})`} />\n      </Box>\n      <Typography variant=\"body2\" sx={{ mb: 4 }}>\n        Where <InlineMath math=\"PD_{ij,t}\" /> represents the log price differential between {baseMarket} (i) and {comparisonMarket} (j) at time t\n      </Typography>\n\n      {/* Market Integration Model */}\n      <Typography variant=\"h6\" gutterBottom sx={{ color: theme.palette.primary.main, mt: 4 }}>\n        Market Integration Model:\n      </Typography>\n      <Box sx={{ my: 3 }}>\n        <BlockMath math={`PD_{ij,t} = \\alpha + \\beta t + \\gamma_1 Distance_{ij} + \\gamma_2 Conflict_t + \\epsilon_t`} />\n      </Box>\n\n      <Grid container spacing={4} sx={{ mt: 2 }}>\n        {/* Parameter Interpretations */}\n        <Grid item xs={12} md={6}>\n          <Paper elevation={2} sx={{ p: 2, height: '100%', backgroundColor: theme.palette.background.default }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Market Integration Parameters\n            </Typography>\n            <Typography variant=\"body2\" paragraph>\n              • <InlineMath math=\"\\alpha\" /> = {regressionResults?.intercept?.toFixed(4) || 'N/A'}: Base price differential<br />\n              • <InlineMath math=\"\\beta\" /> = {regressionResults?.slope?.toFixed(4) || 'N/A'}: Integration trend over time<br />\n              • <InlineMath math=\"\\gamma_1\" /> = {regressionResults?.beta_distance?.toFixed(4) || 'N/A'}: Distance effect<br />\n              • <InlineMath math=\"\\gamma_2\" /> = {regressionResults?.beta_conflict?.toFixed(4) || 'N/A'}: Conflict effect\n            </Typography>\n          </Paper>\n        </Grid>\n\n        <Grid item xs={12} md={6}>\n          <Paper elevation={2} sx={{ p: 2, height: '100%', backgroundColor: theme.palette.background.default }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Market Characteristics\n            </Typography>\n            <Typography variant=\"body2\" paragraph>\n              • Distance: {diagnostics?.distance_km?.toFixed(2) || 'N/A'} km<br />\n              • Conflict Correlation: {diagnostics?.conflict_correlation?.toFixed(2) || 'N/A'}<br />\n              • Time Periods: {diagnostics?.common_dates || 'N/A'}<br />\n              • Model Fit: {regressionResults?.r_squared ? `${(regressionResults.r_squared * 100).toFixed(1)}%` : 'N/A'}\n            </Typography>\n          </Paper>\n        </Grid>\n      </Grid>\n\n      {/* Variable Definitions */}\n      <Box sx={{ mt: 4, p: 2, backgroundColor: theme.palette.grey[50], borderRadius: 1 }}>\n        <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n          Variable Definitions:\n        </Typography>\n        <Grid container spacing={2}>\n          <Grid item xs={12} md={6}>\n            <Typography variant=\"body2\">\n              • <InlineMath math=\"PD_{ij,t}\" />: Log price differential<br />\n              • <InlineMath math=\"P_{i,t}, P_{j,t}\" />: Market prices<br />\n              • <InlineMath math=\"t\" />: Time trend\n            </Typography>\n          </Grid>\n          <Grid item xs={12} md={6}>\n            <Typography variant=\"body2\">\n              • <InlineMath math=\"Distance_{ij}\" />: Market separation (km)<br />\n              • <InlineMath math=\"Conflict_t\" />: Conflict intensity<br />\n              • <InlineMath math=\"\\epsilon_t\" />: Error term\n            </Typography>\n          </Grid>\n        </Grid>\n      </Box>\n\n      {/* Model Interpretation */}\n      <Box sx={{ mt: 4, p: 2, backgroundColor: theme.palette.grey[50], borderRadius: 1 }}>\n        <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n          Model Interpretation:\n        </Typography>\n        <Grid container spacing={2}>\n          <Grid item xs={12} md={6}>\n            <Typography variant=\"body2\">\n              • Negative β indicates price convergence<br />\n              • Positive β suggests market divergence<br />\n              • Distance effect shows spatial barriers\n            </Typography>\n          </Grid>\n          <Grid item xs={12} md={6}>\n            <Typography variant=\"body2\">\n              • Conflict correlation measures disruption<br />\n              • R² indicates model explanatory power<br />\n              • P-value shows statistical significance\n            </Typography>\n          </Grid>\n        </Grid>\n      </Box>\n    </Box>\n  );\n};\n\nPriceDifferentialFramework.propTypes = {\n  baseMarket: PropTypes.string.isRequired,\n  comparisonMarket: PropTypes.string.isRequired,\n  regressionResults: PropTypes.shape({\n    intercept: PropTypes.number,\n    slope: PropTypes.number,\n    beta_distance: PropTypes.number,\n    beta_conflict: PropTypes.number,\n    r_squared: PropTypes.number\n  }),\n  diagnostics: PropTypes.shape({\n    distance_km: PropTypes.number,\n    conflict_correlation: PropTypes.number,\n    common_dates: PropTypes.number\n  })\n};\n\nexport default React.memo(PriceDifferentialFramework);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "react-katex",
          "katex/dist/katex.min.css"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "react-katex",
          "katex/dist/katex.min.css"
        ]
      },
      {
        "path": "components/analysis/price-differential/StationarityTest.js",
        "content": "// src/components/analysis/price-differential/StationarityTest.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Paper,\n  Typography,\n  Grid,\n  Box,\n  Chip,\n  useTheme\n} from '@mui/material';\nimport {\n  CheckCircle as CheckCircleIcon,\n  Warning as WarningIcon\n} from '@mui/icons-material';\n\nconst StationarityTest = ({ stationarityData }) => {\n  const theme = useTheme();\n\n  if (!stationarityData) return null;\n\n  const { ADF, KPSS } = stationarityData;\n  const isStationaryADF = ADF?.['p-value'] < 0.05;\n  const isStationaryKPSS = KPSS?.['p-value'] >= 0.05;\n  const isStable = isStationaryADF && isStationaryKPSS;\n\n  return (\n    <Paper sx={{ p: 2, height: '100%' }}>\n      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>\n        <Typography variant=\"h6\">\n          Price Stability Analysis\n        </Typography>\n        <Chip\n          icon={isStable ? <CheckCircleIcon /> : <WarningIcon />}\n          label={isStable ? 'Stable Prices' : 'Unstable Prices'}\n          color={isStable ? 'success' : 'warning'}\n          variant=\"outlined\"\n        />\n      </Box>\n\n      <Grid container spacing={2}>\n        <Grid item xs={12}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.background.default,\n            borderRadius: 1,\n            '&:hover .adf-info': {\n              opacity: 1\n            }\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              ADF Test Results\n            </Typography>\n            <Typography variant=\"body1\">\n              Test Statistic: {ADF?.statistic?.toFixed(4) || 'N/A'}\n            </Typography>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              P-value: {ADF?.['p-value']?.toFixed(4) || 'N/A'}\n            </Typography>\n            <Typography \n              className=\"adf-info\"\n              variant=\"caption\" \n              sx={{ \n                display: 'block',\n                mt: 1,\n                opacity: 0,\n                transition: 'opacity 0.2s',\n                color: theme.palette.text.secondary\n              }}\n            >\n              {isStationaryADF \n                ? 'Evidence against unit root - prices tend to revert to mean'\n                : 'Cannot reject unit root - prices may follow random walk'}\n            </Typography>\n          </Box>\n        </Grid>\n\n        <Grid item xs={12}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.background.default,\n            borderRadius: 1,\n            '&:hover .kpss-info': {\n              opacity: 1\n            }\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              KPSS Test Results\n            </Typography>\n            <Typography variant=\"body1\">\n              Test Statistic: {KPSS?.statistic?.toFixed(4) || 'N/A'}\n            </Typography>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              P-value: {KPSS?.['p-value']?.toFixed(4) || 'N/A'}\n            </Typography>\n            <Typography \n              className=\"kpss-info\"\n              variant=\"caption\" \n              sx={{ \n                display: 'block',\n                mt: 1,\n                opacity: 0,\n                transition: 'opacity 0.2s',\n                color: theme.palette.text.secondary\n              }}\n            >\n              {isStationaryKPSS \n                ? 'Cannot reject stationarity - prices show stability'\n                : 'Evidence against stationarity - prices may be volatile'}\n            </Typography>\n          </Box>\n        </Grid>\n\n        <Grid item xs={12}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.grey[50],\n            borderRadius: 1,\n            '&:hover .interpretation-info': {\n              opacity: 1\n            }\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Economic Interpretation\n            </Typography>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              {isStable \n                ? 'Price differentials show mean-reverting behavior, suggesting effective market arbitrage'\n                : 'Price differentials may be persistent, indicating potential market frictions'}\n            </Typography>\n            <Typography \n              className=\"interpretation-info\"\n              variant=\"caption\" \n              sx={{ \n                display: 'block',\n                mt: 1,\n                opacity: 0,\n                transition: 'opacity 0.2s',\n                color: theme.palette.text.secondary\n              }}\n            >\n              Combined test results provide {isStable ? 'strong' : 'weak'} evidence for price stability\n            </Typography>\n          </Box>\n        </Grid>\n      </Grid>\n    </Paper>\n  );\n};\n\nStationarityTest.propTypes = {\n  stationarityData: PropTypes.shape({\n    ADF: PropTypes.shape({\n      'p-value': PropTypes.number,\n      statistic: PropTypes.number\n    }),\n    KPSS: PropTypes.shape({\n      'p-value': PropTypes.number,\n      statistic: PropTypes.number\n    })\n  })\n};\n\nexport default React.memo(StationarityTest);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material"
        ]
      },
      {
        "path": "components/analysis/spatial/SpatialAnalysis.js",
        "content": "// src/components/analysis/spatial/SpatialAnalysis.js\n\nimport React, { useState, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Button,\n  Grid,\n  Typography,\n  CircularProgress,\n  Paper,\n  Snackbar,\n  Alert\n} from '@mui/material';\nimport { Download } from '@mui/icons-material';\nimport { saveAs } from 'file-saver';\nimport { useTheme } from '@mui/material/styles';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { selectSpatialDataOptimized } from '../../../selectors/optimizedSelectors';\nimport { fetchRegressionAnalysis } from '../../../slices/spatialSlice';\nimport SpatialRegressionResults from './SpatialRegressionResults';\nimport SpatialMap from './SpatialMap';\nimport SpatialFramework from './SpatialFramework';\n\nconst SpatialAnalysis = ({ selectedCommodity, windowWidth }) => {\n  const theme = useTheme();\n  const dispatch = useDispatch();\n  const spatialData = useSelector(selectSpatialDataOptimized);\n  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });\n\n  React.useEffect(() => {\n    // Always fetch regression analysis, even if selectedCommodity is empty\n    // The selector will handle using the default commodity\n    dispatch(fetchRegressionAnalysis({ selectedCommodity }));\n  }, [selectedCommodity, dispatch]);\n\n  const spatialResults = React.useMemo(() => {\n    const regressionData = spatialData?.regressionAnalysis;\n    \n    if (!regressionData || !regressionData.residuals?.raw?.length) {\n      return null;\n    }\n\n    // Don't check selectedCommodity here since the selector handles it\n    return {\n      coefficients: regressionData.model.coefficients || {},\n      intercept: regressionData.model.intercept || 0,\n      p_values: regressionData.model.p_values || {},\n      moran_i: regressionData.spatial.moran_i || { I: 0, 'p-value': 1 },\n      residual: regressionData.residuals.raw,\n      r_squared: regressionData.model.r_squared || 0,\n      adj_r_squared: regressionData.model.adj_r_squared || 0,\n      mse: regressionData.model.mse || 0,\n      observations: regressionData.model.observations || 0,\n      regime: regressionData.metadata?.regime || 'unified',\n      timestamp: regressionData.metadata?.timestamp\n    };\n  }, [spatialData]);\n\n  const handleDownloadData = useCallback(() => {\n    if (!spatialResults) return;\n    try {\n      const blob = new Blob(\n        [JSON.stringify(spatialResults, null, 2)], \n        { type: 'application/json' }\n      );\n      saveAs(blob, `spatial_analysis_${selectedCommodity || 'beans_kidney_red'}.json`);\n      setSnackbar({\n        open: true,\n        message: 'Data downloaded successfully',\n        severity: 'success'\n      });\n    } catch (error) {\n      setSnackbar({\n        open: true,\n        message: 'Failed to download data',\n        severity: 'error'\n      });\n    }\n  }, [spatialResults, selectedCommodity]);\n\n  if (!spatialResults) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>\n        <CircularProgress />\n      </Box>\n    );\n  }\n\n  if (spatialData?.error) {\n    return (\n      <Alert severity=\"error\" sx={{ mb: 3 }}>\n        <Typography variant=\"subtitle1\" gutterBottom>Error Loading Data</Typography>\n        {spatialData.error}\n      </Alert>\n    );\n  }\n\n  return (\n    <Box sx={{ width: '100%', mb: 4, bgcolor: 'background.paper' }}>\n      {/* Controls */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Grid container spacing={2} alignItems=\"center\" justifyContent=\"flex-end\">\n          <Grid item xs={12} md={3}>\n            <Button\n              fullWidth\n              variant=\"contained\"\n              startIcon={<Download />}\n              onClick={handleDownloadData}\n            >\n              Download Results\n            </Button>\n          </Grid>\n        </Grid>\n      </Paper>\n\n      {/* Framework Section - Moved to be right after download button */}\n      <Box sx={{ mb: 3 }}>\n        <SpatialFramework selectedData={spatialResults} />\n      </Box>\n\n      {/* Market Integration Analysis */}\n      <Box sx={{ mb: 3 }}>\n        <SpatialRegressionResults \n          results={spatialResults}\n          windowWidth={windowWidth}\n        />\n      </Box>\n\n      {/* Spatial Visualization */}\n      <Box sx={{ mb: 3 }}>\n        <Typography variant=\"h6\" gutterBottom sx={{ mb: 2 }}>\n          Regional Price Patterns\n        </Typography>\n        <SpatialMap\n          results={spatialResults}\n          windowWidth={windowWidth}\n        />\n      </Box>\n\n      <Snackbar\n        open={snackbar.open}\n        autoHideDuration={6000}\n        onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}\n        message={snackbar.message}\n        severity={snackbar.severity}\n      />\n    </Box>\n  );\n};\n\nSpatialAnalysis.propTypes = {\n  selectedCommodity: PropTypes.string.isRequired,\n  windowWidth: PropTypes.number.isRequired\n};\n\nexport default SpatialAnalysis;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "file-saver",
          "@mui/material/styles",
          "react-redux",
          "../../../selectors/optimizedSelectors",
          "../../../slices/spatialSlice",
          "./SpatialRegressionResults",
          "./SpatialMap",
          "./SpatialFramework"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "file-saver",
          "@mui/material/styles",
          "react-redux",
          "../../../selectors/optimizedSelectors",
          "../../../slices/spatialSlice",
          "./SpatialRegressionResults",
          "./SpatialMap",
          "./SpatialFramework"
        ]
      },
      {
        "path": "components/analysis/spatial/SpatialFramework.js",
        "content": "// src/components/analysis/spatial/SpatialFramework.js\n\nimport React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Typography,\n  Paper,\n  Grid,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails,\n  useTheme\n} from '@mui/material';\nimport { ExpandMore } from '@mui/icons-material';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport 'katex/dist/katex.min.css';\n\nconst SpatialFramework = ({ selectedData }) => {\n  const [frameworkExpanded, setFrameworkExpanded] = useState(false);\n  const theme = useTheme();\n\n  const renderMethodBox = (title, content, mathContent = null) => (\n    <Box sx={{ \n      p: 2, \n      bgcolor: theme.palette.background.default,\n      borderRadius: 1,\n      height: '100%',\n      '&:hover .method-info': {\n        opacity: 1\n      }\n    }}>\n      <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n        {title}\n      </Typography>\n      {mathContent && (\n        <Box sx={{ my: 2 }}>\n          <BlockMath math={mathContent} />\n        </Box>\n      )}\n      <Typography variant=\"body2\">\n        {content}\n      </Typography>\n    </Box>\n  );\n\n  return (\n    <Accordion \n      expanded={frameworkExpanded} \n      onChange={() => setFrameworkExpanded(!frameworkExpanded)}\n      sx={{ mb: 3 }}\n    >\n      <AccordionSummary \n        expandIcon={<ExpandMore />}\n        sx={{\n          backgroundColor: theme.palette.grey[50],\n          '&:hover': {\n            backgroundColor: theme.palette.grey[100],\n          }\n        }}\n      >\n        <Typography variant=\"h6\">\n          Spatial Market Integration Model Framework\n        </Typography>\n      </AccordionSummary>\n      <AccordionDetails sx={{ p: 3 }}>\n        <Box sx={{ '& .katex': { fontSize: '1.3em' } }}>\n          {/* Core Framework */}\n          <Paper sx={{ p: 2, mb: 3 }}>\n            <Typography variant=\"h6\" gutterBottom>\n              Market Integration Model\n            </Typography>\n            <Box sx={{ my: 3 }}>\n              <BlockMath math={`P_i = \\\\alpha + \\\\rho(WP)_i + \\\\gamma CI_i + \\\\epsilon_i`} />\n            </Box>\n            <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mb: 2 }}>\n              Where <InlineMath math=\"P_i\" /> is the price in region i, <InlineMath math=\"(WP)_i\" /> represents neighboring prices,\n              <InlineMath math=\"CI_i\" /> is conflict intensity, and <InlineMath math=\"\\epsilon_i\" /> captures unexplained variations.\n            </Typography>\n          </Paper>\n\n          {/* Methodology Components */}\n          <Grid container spacing={3} sx={{ mb: 3 }}>\n            <Grid item xs={12} md={4}>\n              {renderMethodBox(\n                \"Spatial Weights Matrix\",\n                \"Defines market connectivity based on geographical proximity and trade routes.\",\n                `W_{ij} = \\\\begin{cases} \n                  1 & \\\\text{if } j \\\\text{ is connected to } i \\\\\\\\\n                  0 & \\\\text{otherwise}\n                \\\\end{cases}`\n              )}\n            </Grid>\n            <Grid item xs={12} md={4}>\n              {renderMethodBox(\n                \"Price Spillovers\",\n                \"Measures how price changes in one market affect neighboring regions.\",\n                `(WP)_i = \\\\sum_{j=1}^n W_{ij}P_j`\n              )}\n            </Grid>\n            <Grid item xs={12} md={4}>\n              {renderMethodBox(\n                \"Conflict Impact\",\n                \"Incorporates conflict intensity's effect on market connections.\",\n                `CI_i = f(\\\\text{events}, \\\\text{intensity}, \\\\text{duration})`\n              )}\n            </Grid>\n          </Grid>\n\n          {/* Model Parameters */}\n          <Paper sx={{ p: 2, mb: 3, bgcolor: theme.palette.grey[50] }}>\n            <Typography variant=\"h6\" gutterBottom>\n              Key Parameters\n            </Typography>\n            <Grid container spacing={2}>\n              <Grid item xs={12} md={4}>\n                <Box sx={{ p: 2, bgcolor: 'background.paper', borderRadius: 1 }}>\n                  <Typography variant=\"subtitle1\" color=\"primary\">\n                    ρ = {selectedData?.coefficients?.spatial_lag_price?.toFixed(4) || 'N/A'}\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    Spatial dependence coefficient measuring market integration strength\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} md={4}>\n                <Box sx={{ p: 2, bgcolor: 'background.paper', borderRadius: 1 }}>\n                  <Typography variant=\"subtitle1\" color=\"primary\">\n                    I = {selectedData?.moran_i?.I?.toFixed(4) || 'N/A'}\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    Moran's I indicating spatial price clustering patterns\n                  </Typography>\n                </Box>\n              </Grid>\n              <Grid item xs={12} md={4}>\n                <Box sx={{ p: 2, bgcolor: 'background.paper', borderRadius: 1 }}>\n                  <Typography variant=\"subtitle1\" color=\"primary\">\n                    γ = {selectedData?.coefficients?.conflict_intensity?.toFixed(4) || 'N/A'}\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    Conflict impact coefficient on price dynamics\n                  </Typography>\n                </Box>\n              </Grid>\n            </Grid>\n          </Paper>\n\n          {/* Model Properties */}\n          <Paper sx={{ p: 2, bgcolor: theme.palette.grey[50] }}>\n            <Typography variant=\"h6\" gutterBottom>\n              Technical Details\n            </Typography>\n            <Grid container spacing={2}>\n              <Grid item xs={12} md={6}>\n                <Typography variant=\"body2\" paragraph>\n                  • Seasonal adjustment removes cyclical patterns<br />\n                  • Robust to heteroskedasticity in conflict zones<br />\n                  • Controls for spatial autocorrelation bias\n                </Typography>\n              </Grid>\n              <Grid item xs={12} md={6}>\n                <Typography variant=\"body2\" paragraph>\n                  • Ridge regression handles multicollinearity<br />\n                  • Spatial error correction for local shocks<br />\n                  • MSE: {selectedData?.mse?.toFixed(4) || 'N/A'} (model precision)\n                </Typography>\n              </Grid>\n            </Grid>\n          </Paper>\n        </Box>\n      </AccordionDetails>\n    </Accordion>\n  );\n};\n\nSpatialFramework.propTypes = {\n  selectedData: PropTypes.shape({\n    coefficients: PropTypes.shape({\n      spatial_lag_price: PropTypes.number,\n      conflict_intensity: PropTypes.number\n    }),\n    moran_i: PropTypes.shape({\n      I: PropTypes.number\n    }),\n    mse: PropTypes.number\n  }).isRequired\n};\n\nexport default SpatialFramework;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "react-katex",
          "katex/dist/katex.min.css"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "react-katex",
          "katex/dist/katex.min.css"
        ]
      },
      {
        "path": "components/analysis/spatial/SpatialMap.js",
        "content": "// src/components/analysis/spatial/SpatialMap.js\n\nimport React, { useMemo, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { \n  Box, \n  Typography, \n  FormControl, \n  InputLabel, \n  Select, \n  MenuItem, \n  Grid,\n  Paper,\n  useTheme\n} from '@mui/material';\nimport { MapContainer, TileLayer, GeoJSON } from 'react-leaflet';\nimport { useSelector } from 'react-redux';\nimport { selectGeometryData } from '../../../selectors/optimizedSelectors';\nimport { \n  getColorScale, \n  getResidualStats, \n  getFeatureStyle,\n  formatTooltipValue,\n  DEFAULT_CENTER,\n  DEFAULT_ZOOM,\n  DEFAULT_BOUNDS \n} from './utils/mapUtils';\nimport Legend from './components/Legend';\n\nconst SpatialMap = ({ results, windowWidth, mode = 'analysis' }) => {\n  const theme = useTheme();\n  const [selectedDate, setSelectedDate] = useState(null);\n  const [visualizationType, setVisualizationType] = useState('residuals');\n  const [selectedRegion, setSelectedRegion] = useState(null);\n  \n  const geometryData = useSelector(selectGeometryData);\n\n  // Process map data\n  const mapData = useMemo(() => {\n    if (!geometryData?.polygons || !results?.residual) return null;\n\n    try {\n      const residualsByDate = results.residual.reduce((acc, r) => {\n        if (!acc[r.date]) acc[r.date] = {};\n        acc[r.date][r.region_id] = r.residual;\n        return acc;\n      }, {});\n\n      const dates = Object.keys(residualsByDate).sort();\n      if (!selectedDate && dates.length > 0) {\n        setSelectedDate(dates[dates.length - 1]);\n      }\n\n      const currentResiduals = selectedDate ? residualsByDate[selectedDate] : {};\n      \n      return {\n        type: 'FeatureCollection',\n        features: geometryData.polygons.map(polygon => ({\n          type: 'Feature',\n          geometry: polygon.geometry,\n          properties: {\n            ...polygon.properties,\n            residual: currentResiduals[polygon.properties.region_id] || null,\n            spillover: results.spillover_effects?.[polygon.properties.region_id] || 0,\n            regime: results.regime || 'unified',\n            isSelected: polygon.properties.region_id === selectedRegion\n          }\n        }))\n      };\n    } catch (error) {\n      console.error('Error processing map data:', error);\n      return null;\n    }\n  }, [geometryData, results, selectedDate, selectedRegion]);\n\n  // Calculate statistics and color scale\n  const { colorScale, minResidual, maxResidual } = useMemo(() => {\n    if (!results?.residual) {\n      return { colorScale: null, minResidual: null, maxResidual: null };\n    }\n\n    const relevantResiduals = selectedDate\n      ? results.residual.filter(r => r.date === selectedDate)\n      : results.residual;\n\n    const stats = getResidualStats(relevantResiduals);\n    if (!stats) return { colorScale: null, minResidual: null, maxResidual: null };\n\n    return {\n      colorScale: getColorScale(stats.min, stats.max, theme),\n      minResidual: stats.min,\n      maxResidual: stats.max\n    };\n  }, [results, selectedDate, theme]);\n\n  // Update colorScale based on actual residuals\n  const dynamicColorScale = useMemo(() => {\n    return getColorScale(minResidual, maxResidual, theme);\n  }, [minResidual, maxResidual, theme]);\n\n  // Update mapData with new colorScale\n  const styledMapData = useMemo(() => {\n    if (!mapData) return null;\n\n    return {\n      ...mapData,\n      features: mapData.features.map(feature => ({\n        ...feature,\n        properties: {\n          ...feature.properties,\n          fillColor: feature.properties.residual != null \n            ? dynamicColorScale(feature.properties.residual).hex() \n            : theme.palette.grey[300]\n        }\n      }))\n    };\n  }, [mapData, dynamicColorScale, theme]);\n\n  // Style function for GeoJSON features\n  const getRegionStyle = (feature) => ({\n    fillColor: feature.properties.fillColor || theme.palette.grey[300],\n    weight: feature.properties.isSelected ? 2 : 1,\n    opacity: 1,\n    color: feature.properties.isSelected ? theme.palette.primary.main : theme.palette.divider,\n    fillOpacity: 0.7\n  });\n\n  // Handle region interactions\n  const onEachFeature = (feature, layer) => {\n    const properties = feature.properties;\n    layer.on({\n      mouseover: () => setSelectedRegion(properties.region_id),\n      mouseout: () => setSelectedRegion(null),\n      click: () => setSelectedRegion(properties.region_id)\n    });\n\n    layer.bindTooltip(\n      () => {\n        const value = mode === 'model' && visualizationType === 'spillover'\n          ? properties.spillover\n          : properties.residual;\n\n        return `\n          <div style=\"\n            background: ${theme.palette.background.paper};\n            padding: 8px;\n            border-radius: 4px;\n            border: 1px solid ${theme.palette.divider};\n            font-family: ${theme.typography.fontFamily};\n          \">\n            <div style=\"font-weight: 600; margin-bottom: 4px;\">\n              ${properties.region_name || properties.region_id}\n            </div>\n            <div style=\"color: ${theme.palette.text.secondary};\">\n              ${visualizationType === 'spillover' ? 'Spillover Effect' : 'Price Deviation'}: \n              ${formatTooltipValue(value)}\n            </div>\n            ${selectedDate ? `\n              <div style=\"color: ${theme.palette.text.secondary}; margin-top: 4px; font-size: 0.9em;\">\n                ${new Date(selectedDate).toLocaleDateString()}\n              </div>\n            ` : ''}\n          </div>\n        `;\n      },\n      {\n        sticky: true,\n        direction: 'auto',\n        className: 'custom-tooltip'\n      }\n    );\n  };\n\n  if (!styledMapData || !dynamicColorScale) {\n    return (\n      <Paper sx={{ p: 2 }}>\n        <Typography variant=\"body1\" color=\"text.secondary\">\n          Loading map data...\n        </Typography>\n      </Paper>\n    );\n  }\n\n  return (\n    <Paper sx={{ p: 2 }}>\n      {/* Controls */}\n      <Grid container spacing={2} sx={{ mb: 3 }}>\n        <Grid item xs={12} md={mode === 'model' ? 6 : 12}>\n          <FormControl fullWidth size=\"small\">\n            <InputLabel>Analysis Date</InputLabel>\n            <Select\n              value={selectedDate || ''}\n              onChange={(e) => setSelectedDate(e.target.value)}\n              label=\"Analysis Date\"\n            >\n              {results.residual\n                .map(r => r.date)\n                .filter((date, index, self) => self.indexOf(date) === index)\n                .sort()\n                .map(date => (\n                  <MenuItem key={date} value={date}>\n                    {new Date(date).toLocaleDateString()}\n                  </MenuItem>\n                ))\n              }\n            </Select>\n          </FormControl>\n        </Grid>\n\n        {mode === 'model' && (\n          <Grid item xs={12} md={6}>\n            <FormControl fullWidth size=\"small\">\n              <InputLabel>Analysis Type</InputLabel>\n              <Select\n                value={visualizationType}\n                onChange={(e) => setVisualizationType(e.target.value)}\n                label=\"Analysis Type\"\n              >\n                <MenuItem value=\"residuals\">Price Deviations</MenuItem>\n                <MenuItem value=\"spillover\">Market Spillovers</MenuItem>\n              </Select>\n            </FormControl>\n          </Grid>\n        )}\n      </Grid>\n\n      {/* Map container */}\n      <Box \n        sx={{ \n          height: 500, \n          position: 'relative',\n          border: `1px solid ${theme.palette.divider}`,\n          borderRadius: 1,\n          overflow: 'hidden',\n          bgcolor: theme.palette.background.default\n        }}\n      >\n        <MapContainer\n          center={DEFAULT_CENTER}\n          zoom={DEFAULT_ZOOM}\n          bounds={DEFAULT_BOUNDS}\n          style={{ height: '100%', width: '100%' }}\n          maxBounds={DEFAULT_BOUNDS}\n          minZoom={DEFAULT_ZOOM - 0.5}\n          maxZoom={DEFAULT_ZOOM + 1}\n          zoomControl={true}\n          dragging={true}\n          touchZoom={true}\n          doubleClickZoom={true}\n          scrollWheelZoom={false}\n          boxZoom={true}\n          keyboard={true}\n          bounceAtZoomLimits={true}\n        >\n          <TileLayer\n            url=\"https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png\"\n            attribution='&copy; OpenStreetMap contributors'\n          />\n          <GeoJSON\n            data={styledMapData}\n            style={getRegionStyle}\n            onEachFeature={onEachFeature}\n          />\n        </MapContainer>\n\n        <Legend\n          min={minResidual}\n          max={maxResidual}\n          colorScale={dynamicColorScale}\n          position=\"bottomright\"\n          title={visualizationType === 'spillover' ? 'Market Spillovers' : 'Price Deviations'}\n        />\n      </Box>\n    </Paper>\n  );\n};\n\nSpatialMap.propTypes = {\n  results: PropTypes.shape({\n    residual: PropTypes.arrayOf(PropTypes.shape({\n      region_id: PropTypes.string.isRequired,\n      date: PropTypes.string.isRequired,\n      residual: PropTypes.number.isRequired\n    })).isRequired,\n    regime: PropTypes.string,\n    spillover_effects: PropTypes.object\n  }).isRequired,\n  windowWidth: PropTypes.number.isRequired,\n  mode: PropTypes.oneOf(['analysis', 'model'])\n};\n\nexport default SpatialMap;",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "react-leaflet",
          "react-redux",
          "../../../selectors/optimizedSelectors",
          "./utils/mapUtils",
          "./components/Legend"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "react-leaflet",
          "react-redux",
          "../../../selectors/optimizedSelectors",
          "./utils/mapUtils",
          "./components/Legend"
        ]
      },
      {
        "path": "components/analysis/spatial/SpatialRegressionResults.js",
        "content": "// src/components/analysis/spatial/SpatialRegressionResults.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Grid,\n  Typography,\n  useTheme,\n  Paper\n} from '@mui/material';\nimport ResidualsChart from './components/ResidualsChart';\n\nconst SpatialRegressionResults = ({ results, windowWidth }) => {\n  const theme = useTheme();\n\n  const getParameterInterpretation = (param, value) => {\n    switch(param) {\n      case 'spatial_lag':\n        return {\n          label: 'Price Spillovers',\n          value: value.toFixed(4),\n          symbol: 'ρ',\n          interpretation: `${(Math.abs(value) * 100).toFixed(1)}% price transmission`,\n          detail: value > 0.5 \n            ? 'Strong market integration'\n            : value > 0.2 \n            ? 'Moderate market linkages'\n            : 'Limited price transmission',\n          significance: results.p_values.spatial_lag_price < 0.05\n        };\n      case 'spatial_correlation':\n        return {\n          label: 'Market Clustering',\n          value: value.I.toFixed(4),\n          symbol: 'I',\n          interpretation: `${Math.abs(value.I) > 0.3 ? 'Strong' : Math.abs(value.I) > 0.1 ? 'Moderate' : 'Weak'} spatial patterns`,\n          detail: value.I > 0 \n            ? 'Similar prices in neighboring regions'\n            : 'Distinct local price dynamics',\n          significance: value['p-value'] < 0.05\n        };\n      case 'model_fit':\n        return {\n          label: 'Market Integration',\n          value: (value * 100).toFixed(1) + '%',\n          symbol: 'R²',\n          interpretation: `${value > 0.7 ? 'Strong' : value > 0.3 ? 'Moderate' : 'Weak'} explanatory power`,\n          detail: value > 0.5\n            ? 'Model captures key spatial relationships'\n            : 'Additional factors influence prices',\n          significance: true\n        };\n      case 'residual_pattern':\n        return {\n          label: 'Price Deviations',\n          value: value.toFixed(4),\n          symbol: 'σ',\n          interpretation: `${value > 2 ? 'Large' : value > 1 ? 'Moderate' : 'Small'} price variations`,\n          detail: 'Standard deviation of regional price differences',\n          significance: value < results.mse * 2\n        };\n      default:\n        return null;\n    }\n  };\n\n  const renderParameterCard = (param, value) => {\n    const interpretation = getParameterInterpretation(param, value);\n    return (\n      <Box sx={{ \n        p: 2, \n        bgcolor: theme.palette.background.default,\n        borderRadius: 1,\n        height: '100%',\n        '&:hover .parameter-info': {\n          opacity: 1\n        }\n      }}>\n        <Typography variant=\"h6\" sx={{ fontSize: '1.1rem', fontWeight: 600 }}>\n          {interpretation.symbol} = {interpretation.value}\n        </Typography>\n        <Typography variant=\"body2\" color=\"text.secondary\">\n          {interpretation.label}\n        </Typography>\n        <Typography variant=\"body2\" sx={{ mt: 1 }}>\n          {interpretation.interpretation}\n        </Typography>\n        <Typography \n          className=\"parameter-info\"\n          variant=\"caption\" \n          sx={{ \n            display: 'block',\n            mt: 1,\n            opacity: 0,\n            transition: 'opacity 0.2s',\n            color: theme.palette.text.secondary\n          }}\n        >\n          {interpretation.detail}\n          {interpretation.significance && (\n            <Box component=\"span\" sx={{ display: 'block', mt: 0.5, fontStyle: 'italic' }}>\n              Statistically significant pattern\n            </Box>\n          )}\n        </Typography>\n      </Box>\n    );\n  };\n\n  // Calculate residual standard deviation\n  const residualStd = Math.sqrt(\n    results.residual.reduce((acc, r) => acc + Math.pow(r.residual, 0), 0) / \n    results.residual.length\n  );\n\n  return (\n    <Paper sx={{ p: 2 }}>\n      {/* Key Parameters */}\n      <Typography variant=\"h6\" gutterBottom sx={{ mb: 2 }}>\n        Model Parameters\n      </Typography>\n      <Grid container spacing={2} sx={{ mb: 3 }}>\n        <Grid item xs={12} md={3}>\n          {renderParameterCard('spatial_lag', results.coefficients.spatial_lag_price)}\n        </Grid>\n        <Grid item xs={12} md={3}>\n          {renderParameterCard('spatial_correlation', results.moran_i)}\n        </Grid>\n        <Grid item xs={12} md={3}>\n          {renderParameterCard('model_fit', results.r_squared)}\n        </Grid>\n        <Grid item xs={12} md={3}>\n          {renderParameterCard('residual_pattern', residualStd)}\n        </Grid>\n      </Grid>\n\n      {/* Price Deviations */}\n      <Box sx={{ mt: 4 }}>\n        <Typography variant=\"h6\" gutterBottom>\n          Regional Price Patterns\n        </Typography>\n        <Box sx={{ height: 400 }}>\n          <ResidualsChart \n            residuals={results.residual}\n            isMobile={windowWidth < theme.breakpoints.values.sm}\n          />\n        </Box>\n      </Box>\n    </Paper>\n  );\n};\n\nSpatialRegressionResults.propTypes = {\n  results: PropTypes.shape({\n    coefficients: PropTypes.shape({\n      spatial_lag_price: PropTypes.number\n    }).isRequired,\n    p_values: PropTypes.shape({\n      spatial_lag_price: PropTypes.number\n    }).isRequired,\n    r_squared: PropTypes.number.isRequired,\n    mse: PropTypes.number.isRequired,\n    moran_i: PropTypes.shape({\n      I: PropTypes.number.isRequired,\n      'p-value': PropTypes.number.isRequired\n    }).isRequired,\n    residual: PropTypes.arrayOf(PropTypes.shape({\n      region_id: PropTypes.string.isRequired,\n      date: PropTypes.string.isRequired,\n      residual: PropTypes.number.isRequired\n    })).isRequired\n  }).isRequired,\n  windowWidth: PropTypes.number.isRequired\n};\n\nexport default SpatialRegressionResults;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "./components/ResidualsChart"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "./components/ResidualsChart"
        ]
      },
      {
        "path": "components/analysis/spatial/components/Legend.js",
        "content": "// src/components/analysis/spatial/components/Legend.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { \n  Box, \n  Typography, \n  useTheme, \n  useMediaQuery,\n  Paper,\n  Tooltip\n} from '@mui/material';\nimport { formatNumber } from '../utils/mapUtils';\n\nconst Legend = ({ min, max, colorScale, position = 'bottomright', title = 'Price Deviations' }) => {\n  const theme = useTheme();\n  const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm'));\n\n  const getPositionStyle = () => {\n    const base = isSmallScreen ? 12 : 20;\n    switch (position) {\n      case 'bottomright':\n        return { bottom: base, right: base };\n      case 'bottomleft':\n        return { bottom: base, left: base };\n      case 'topright':\n        return { top: base, right: base };\n      case 'topleft':\n        return { top: base, left: base };\n      default:\n        return { bottom: base, right: base };\n    }\n  };\n\n  const getLegendDescription = () => {\n    switch (title.toLowerCase()) {\n      case 'price deviations':\n        return 'Shows how regional prices differ from model predictions. ' +\n               'Positive values (red) indicate higher prices than expected, ' +\n               'negative values (blue) indicate lower prices.';\n      case 'market spillovers':\n        return 'Indicates the strength of price transmission between markets. ' +\n               'Higher values show stronger market integration, ' +\n               'lower values suggest market fragmentation.';\n      default:\n        return 'Distribution of values across regions';\n    }\n  };\n\n  if (!colorScale || min == null || max == null) return null;\n\n  return (\n    <Tooltip \n      title={getLegendDescription()}\n      placement=\"left\"\n      arrow\n    >\n      <Paper\n        elevation={3}\n        sx={{\n          position: 'absolute',\n          ...getPositionStyle(),\n          p: isSmallScreen ? 1.5 : 2,\n          borderRadius: 1,\n          zIndex: 1000,\n          minWidth: isSmallScreen ? 120 : 180,\n          maxWidth: isSmallScreen ? 150 : 220,\n          opacity: 0.95,\n          transition: theme.transitions.create(['opacity', 'box-shadow']),\n          '&:hover': {\n            opacity: 1,\n            boxShadow: theme.shadows[8]\n          }\n        }}\n      >\n        <Typography \n          variant=\"subtitle2\"\n          sx={{ \n            fontSize: isSmallScreen ? '0.75rem' : '0.875rem',\n            fontWeight: 600,\n            mb: 1,\n            color: theme.palette.text.primary\n          }}\n        >\n          {title}\n        </Typography>\n\n        {/* Gradient Bar */}\n        <Box\n          sx={{\n            width: '100%',\n            height: isSmallScreen ? 10 : 12,\n            background: `linear-gradient(to right, \n              ${colorScale(min)}, \n              ${colorScale(min/2)},\n              ${colorScale(0)},\n              ${colorScale(max/2)},\n              ${colorScale(max)}\n            )`,\n            borderRadius: 0.5,\n            border: `1px solid ${theme.palette.divider}`\n          }}\n          role=\"img\"\n          aria-label={`Color scale from ${formatNumber(min)} to ${formatNumber(max)}`}\n        />\n\n        {/* Value Labels */}\n        <Box sx={{ \n          display: 'flex', \n          justifyContent: 'space-between', \n          mt: 1,\n          px: 0.5\n        }}>\n          <Typography \n            variant=\"caption\" \n            sx={{ \n              fontSize: isSmallScreen ? '0.7rem' : '0.75rem',\n              color: theme.palette.text.secondary,\n              fontWeight: 500\n            }}\n          >\n            {formatNumber(min)}\n          </Typography>\n          <Typography \n            variant=\"caption\" \n            sx={{ \n              fontSize: isSmallScreen ? '0.7rem' : '0.75rem',\n              color: theme.palette.text.secondary,\n              fontWeight: 500\n            }}\n          >\n            0\n          </Typography>\n          <Typography \n            variant=\"caption\" \n            sx={{ \n              fontSize: isSmallScreen ? '0.7rem' : '0.75rem',\n              color: theme.palette.text.secondary,\n              fontWeight: 500\n            }}\n          >\n            {formatNumber(max)}\n          </Typography>\n        </Box>\n\n        {/* Description (small screens only show on hover) */}\n        <Typography\n          variant=\"caption\"\n          sx={{\n            display: isSmallScreen ? 'none' : 'block',\n            mt: 1,\n            color: theme.palette.text.secondary,\n            fontSize: '0.7rem',\n            opacity: 0.8,\n            transition: 'opacity 0.2s',\n            '.MuiPaper-root:hover &': {\n              opacity: 1\n            }\n          }}\n        >\n          {getLegendDescription().split('.')[0] + '.'}\n        </Typography>\n      </Paper>\n    </Tooltip>\n  );\n};\n\nLegend.propTypes = {\n  min: PropTypes.number.isRequired,\n  max: PropTypes.number.isRequired,\n  colorScale: PropTypes.func.isRequired,\n  position: PropTypes.oneOf(['bottomright', 'bottomleft', 'topright', 'topleft']),\n  title: PropTypes.string\n};\n\nexport default Legend;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "../utils/mapUtils"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "../utils/mapUtils"
        ]
      },
      {
        "path": "components/analysis/spatial/components/ResidualsChart.js",
        "content": "// src/components/analysis/spatial/components/ResidualsChart.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Typography,\n  useTheme,\n  Paper\n} from '@mui/material';\nimport {\n  ResponsiveContainer,\n  ComposedChart,\n  Line,\n  Area,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip as RechartsTooltip,\n  Legend,\n  Brush\n} from 'recharts';\n\nconst ResidualsChart = ({ residuals, isMobile }) => {\n  const theme = useTheme();\n\n  // Process residuals data for visualization\n  const chartData = useMemo(() => {\n    if (!residuals?.length) return [];\n\n    // Group residuals by date\n    const groupedData = residuals.reduce((acc, curr) => {\n      const date = curr.date.split('T')[0];\n      if (!acc[date]) {\n        acc[date] = {\n          date,\n          residuals: [],\n          mean: 0,\n          upper: 0,\n          lower: 0\n        };\n      }\n      acc[date].residuals.push(curr.residual);\n      return acc;\n    }, {});\n\n    // Calculate statistics for each date\n    return Object.values(groupedData).map(day => {\n      const sorted = [...day.residuals].sort((a, b) => a - b);\n      const mean = day.residuals.reduce((a, b) => a + b, 0) / day.residuals.length;\n      const q1 = sorted[Math.floor(sorted.length * 0.25)];\n      const q3 = sorted[Math.floor(sorted.length * 0.75)];\n      const stdDev = Math.sqrt(\n        day.residuals.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / day.residuals.length\n      );\n      \n      return {\n        date: new Date(day.date).toLocaleDateString(),\n        mean,\n        upper: q3,\n        lower: q1,\n        range: q3 - q1,\n        volatility: stdDev\n      };\n    }).sort((a, b) => new Date(a.date) - new Date(b.date));\n  }, [residuals]);\n\n  // Calculate overall statistics for interpretation\n  const statistics = useMemo(() => {\n    if (!chartData.length) return null;\n\n    const ranges = chartData.map(d => d.range);\n    const meanRange = ranges.reduce((a, b) => a + b, 0) / ranges.length;\n    const volatilities = chartData.map(d => d.volatility);\n    const meanVolatility = volatilities.reduce((a, b) => a + b, 0) / volatilities.length;\n    \n    return {\n      meanRange,\n      meanVolatility,\n      volatility: meanRange > 2 ? 'high' : meanRange > 1 ? 'moderate' : 'low',\n      stability: meanVolatility < 0.5 ? 'stable' : meanVolatility < 1 ? 'moderately stable' : 'volatile'\n    };\n  }, [chartData]);\n\n  const CustomTooltip = ({ active, payload, label }) => {\n    if (!active || !payload || !payload.length) return null;\n\n    // Safely extract values\n    const meanValue = payload.find(p => p.dataKey === 'mean')?.value;\n    const rangeValue = payload.find(p => p.dataKey === 'range')?.value;\n    const volatilityValue = payload.find(p => p.dataKey === 'volatility')?.value;\n\n    if (meanValue === undefined) return null;\n\n    return (\n      <Paper elevation={3} sx={{ p: 2, maxWidth: 250 }}>\n        <Typography variant=\"subtitle2\" gutterBottom>\n          {label}\n        </Typography>\n        \n        <Box sx={{ mt: 1 }}>\n          <Typography variant=\"body2\" color=\"text.secondary\" gutterBottom>\n            Mean Deviation: {meanValue.toFixed(4)}\n          </Typography>\n          {rangeValue !== undefined && (\n            <Typography variant=\"body2\" color=\"text.secondary\" gutterBottom>\n              Price Dispersion: {rangeValue.toFixed(4)}\n            </Typography>\n          )}\n          {volatilityValue !== undefined && (\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              Volatility: {volatilityValue.toFixed(4)}\n            </Typography>\n          )}\n        </Box>\n\n        {rangeValue !== undefined && (\n          <Typography \n            variant=\"caption\" \n            sx={{ \n              display: 'block', \n              mt: 1.5,\n              pt: 1,\n              borderTop: `1px solid ${theme.palette.divider}`,\n              color: theme.palette.text.secondary\n            }}\n          >\n            {rangeValue > 2 \n              ? 'High market fragmentation' \n              : rangeValue > 1 \n              ? 'Moderate price differences' \n              : 'Well-integrated markets'}\n          </Typography>\n        )}\n      </Paper>\n    );\n  };\n\n  if (!chartData.length) {\n    return (\n      <Paper sx={{ p: 3, textAlign: 'center' }}>\n        <Typography variant=\"body1\" color=\"text.secondary\">\n          No price deviation data available for visualization.\n        </Typography>\n      </Paper>\n    );\n  }\n\n  return (\n    <Paper sx={{ p: 2, height: '100%' }}>\n      {statistics && (\n        <Box sx={{ mb: 2 }}>\n          <Typography variant=\"body2\" color=\"text.secondary\" gutterBottom>\n            {`Markets show ${statistics.volatility} price dispersion with ${statistics.stability} dynamics`}\n          </Typography>\n        </Box>\n      )}\n\n      <Box sx={{ height: isMobile ? '80%' : '85%' }}>\n        <ResponsiveContainer width=\"100%\" height=\"100%\">\n          <ComposedChart \n            data={chartData} \n            margin={{ top: 10, right: 30, left: 20, bottom: 5 }}\n          >\n            <CartesianGrid \n              strokeDasharray=\"3 3\" \n              stroke={theme.palette.divider} \n            />\n            <XAxis \n              dataKey=\"date\"\n              tick={{ fill: theme.palette.text.secondary, fontSize: 12 }}\n              label={{ \n                value: 'Analysis Period',\n                position: 'insideBottom',\n                offset: -10,\n                fill: theme.palette.text.secondary\n              }}\n            />\n            <YAxis\n              tick={{ fill: theme.palette.text.secondary, fontSize: 12 }}\n              label={{ \n                value: 'Price Deviation (YER)',\n                angle: -90,\n                position: 'insideLeft',\n                offset: 15,\n                fill: theme.palette.text.secondary\n              }}\n            />\n            <RechartsTooltip content={<CustomTooltip />} />\n            <Legend \n              verticalAlign=\"top\" \n              height={36}\n              wrapperStyle={{\n                paddingBottom: '20px'\n              }}\n            />\n\n            <Area\n              type=\"monotone\"\n              dataKey=\"upper\"\n              stroke=\"none\"\n              fill={theme.palette.primary.light}\n              fillOpacity={0.2}\n              name=\"Price Range\"\n            />\n            <Area\n              type=\"monotone\"\n              dataKey=\"lower\"\n              stroke=\"none\"\n              fill={theme.palette.primary.light}\n              fillOpacity={0.2}\n              name=\"Price Range\"\n            />\n            <Line\n              type=\"monotone\"\n              dataKey=\"mean\"\n              stroke={theme.palette.primary.main}\n              strokeWidth={2}\n              dot={false}\n              name=\"Mean Deviation\"\n            />\n            <Line\n              type=\"monotone\"\n              dataKey=\"range\"\n              stroke={theme.palette.secondary.main}\n              strokeWidth={2}\n              dot={false}\n              name=\"Market Dispersion\"\n            />\n            <Line\n              type=\"monotone\"\n              dataKey=\"volatility\"\n              stroke={theme.palette.error.main}\n              strokeWidth={2}\n              dot={false}\n              name=\"Price Volatility\"\n            />\n            <Brush \n              dataKey=\"date\"\n              height={30}\n              stroke={theme.palette.primary.main}\n              fill={theme.palette.background.paper}\n              travellerWidth={10}\n            />\n          </ComposedChart>\n        </ResponsiveContainer>\n      </Box>\n    </Paper>\n  );\n};\n\nResidualsChart.propTypes = {\n  residuals: PropTypes.arrayOf(PropTypes.shape({\n    region_id: PropTypes.string.isRequired,\n    date: PropTypes.string.isRequired,\n    residual: PropTypes.number.isRequired\n  })).isRequired,\n  isMobile: PropTypes.bool.isRequired\n};\n\nexport default ResidualsChart;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "recharts"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "recharts"
        ]
      },
      {
        "path": "components/analysis/spatial/components/StatCard.js",
        "content": "// src/components/analysis/spatial/components/StatCard.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Paper, Typography, Box, useTheme, useMediaQuery } from '@mui/material';\nimport { formatNumber, formatPValue } from '../utils/mapUtils';\n\nconst StatCard = ({ title, value, subvalue, format = 'decimal', mini = false }) => {\n  const theme = useTheme();\n  const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm'));\n\n  const formatValue = (val) => {\n    if (val === null || val === undefined) return 'N/A';\n    \n    switch (format) {\n      case 'percentage':\n        return `${formatNumber(val * 100)}%`;\n      case 'pvalue':\n        return formatPValue(val);\n      case 'number':\n        return val.toLocaleString();\n      default:\n        return formatNumber(val);\n    }\n  };\n\n  return (\n    <Paper\n      sx={{\n        p: mini ? 1.5 : { xs: 1.5, sm: 2 },\n        height: '100%',\n        display: 'flex',\n        flexDirection: 'column',\n        bgcolor: theme.palette.background.paper,\n        borderRadius: 2,\n        boxShadow: theme.shadows[2],\n        transition: 'all 0.2s ease-in-out',\n        '&:hover': {\n          boxShadow: theme.shadows[4],\n          transform: 'translateY(-2px)'\n        }\n      }}\n    >\n      <Typography \n        variant={mini || isSmallScreen ? \"body2\" : \"subtitle1\"} \n        component=\"div\"\n        color=\"textSecondary\"\n        gutterBottom\n        sx={{\n          fontSize: mini ? '0.875rem' : { xs: '0.875rem', sm: '1rem' },\n          fontWeight: 500\n        }}\n      >\n        {title}\n      </Typography>\n      \n      <Box sx={{ \n        flex: 1, \n        display: 'flex', \n        flexDirection: 'column', \n        justifyContent: 'center' \n      }}>\n        <Typography \n          variant={mini || isSmallScreen ? \"h6\" : \"h4\"} \n          component=\"div\"\n          sx={{ \n            fontWeight: 'bold', \n            my: 1,\n            fontSize: mini ? '1.25rem' : { \n              xs: '1.5rem', \n              sm: '2rem' \n            }\n          }}\n        >\n          {formatValue(value)}\n        </Typography>\n        \n        {subvalue && (\n          <Typography \n            variant=\"body2\" \n            color=\"textSecondary\"\n            sx={{\n              fontSize: mini ? '0.75rem' : {\n                xs: '0.75rem',\n                sm: '0.875rem'\n              },\n              mt: 'auto',\n              overflow: 'hidden',\n              textOverflow: 'ellipsis',\n              display: '-webkit-box',\n              WebkitLineClamp: 2,\n              WebkitBoxOrient: 'vertical'\n            }}\n          >\n            {subvalue}\n          </Typography>\n        )}\n      </Box>\n    </Paper>\n  );\n};\n\nStatCard.propTypes = {\n  title: PropTypes.string.isRequired,\n  value: PropTypes.number,\n  subvalue: PropTypes.string,\n  format: PropTypes.oneOf(['decimal', 'percentage', 'number', 'pvalue']),\n  mini: PropTypes.bool\n};\n\nexport default StatCard;",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "../utils/mapUtils"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "../utils/mapUtils"
        ]
      },
      {
        "path": "components/analysis/spatial/utils/mapUtils.js",
        "content": "// src/components/analysis/spatial/utils/mapUtils.js\n\nimport chroma from 'chroma-js';\n\n/**\n * Formats a number to a fixed decimal or exponential notation if too small.\n * @param {number} value - The number to format.\n * @param {number} decimals - Number of decimal places.\n * @returns {string} - Formatted number.\n */\nexport const formatNumber = (value, decimals = 2) => {\n  if (value === null || value === undefined || isNaN(value)) return 'N/A';\n  if (Math.abs(value) < 0.01) return value.toExponential(decimals);\n  return value.toFixed(decimals);\n};\n\n/**\n * Formats a p-value appropriately.\n * @param {number} value - The p-value to format.\n * @returns {string} - Formatted p-value.\n */\nexport const formatPValue = (value) => {\n  if (value === null || value === undefined || isNaN(value)) return 'N/A';\n  if (value < 0.01) return '< 0.01';\n  return value.toFixed(2);\n};\n\n/**\n * Calculates statistical summaries of residuals.\n * @param {Array} residuals - Array of residual objects.\n * @returns {Object|null} - Statistical summaries or null if invalid input.\n */\nexport const getResidualStats = (residuals) => {\n  if (!residuals || residuals.length === 0) return null;\n\n  const values = residuals.map(r => r.residual).filter(r => !isNaN(r));\n  if (values.length === 0) return null;\n\n  const mean = _.mean(values);\n  const stdDev = Math.sqrt(_.sum(values.map(r => Math.pow(r - mean, 2))) / values.length);\n  const min = Math.min(...values);\n  const max = Math.max(...values);\n  const domainPadding = (max - min) * 0.1; // Add 10% padding\n\n  return {\n    min: min - domainPadding,\n    max: max + domainPadding,\n    mean: Number(mean.toFixed(2)),\n    stdDev: Number(stdDev.toFixed(2)),\n    q1: Number(getQuantile(values, 0.25).toFixed(2)),\n    q3: Number(getQuantile(values, 0.75).toFixed(2))\n  };\n};\n\n/**\n * Determines map dimensions based on window width.\n * @param {number} windowWidth - The width of the window.\n * @returns {Object} - Map height and legend width.\n */\nexport const getMapDimensions = (windowWidth) => {\n  if (windowWidth < 600) return { height: 300, legendWidth: 120 };\n  if (windowWidth < 960) return { height: 400, legendWidth: 150 };\n  return { height: 500, legendWidth: 180 };\n};\n\n/**\n * Generates a color scale based on residuals.\n * @param {number} min - Minimum residual value.\n * @param {number} max - Maximum residual value.\n * @param {Object} theme - Material-UI theme.\n * @returns {Function} - Chroma color scale function.\n */\nexport const getColorScale = (min, max, theme) => {\n  // Ensure the scale is centered around zero for balanced visualization\n  const maxAbs = Math.max(Math.abs(min), Math.abs(max));\n  const scaleDomain = [-maxAbs, 0, maxAbs];\n\n  return chroma.scale([\n    theme.palette.error.main,\n    theme.palette.grey[300],\n    theme.palette.success.main,\n  ]).domain(scaleDomain).classes(5);\n};\n\n/**\n * Styles for the map components.\n * @param {Object} theme - Material-UI theme.\n * @returns {Object} - Style definitions.\n */\nexport const MAP_STYLES = (theme) => ({\n  container: {\n    position: 'relative',\n    width: '100%',\n    borderRadius: theme.shape.borderRadius,\n    overflow: 'hidden',\n    boxShadow: theme.shadows[2]\n  },\n  tooltip: {\n    backgroundColor: theme.palette.background.paper,\n    border: `1px solid ${theme.palette.divider}`,\n    borderRadius: theme.shape.borderRadius,\n    padding: theme.spacing(1),\n    boxShadow: theme.shadows[2],\n    fontSize: '0.875rem'\n  }\n});\n\n/**\n * Calculates the quantile of an array.\n * @param {Array} arr - The array of numbers.\n * @param {number} q - The quantile to calculate (between 0 and 1).\n * @returns {number} - The quantile value.\n */\nexport const getQuantile = (arr, q) => {\n  const sorted = Array.from(arr).sort((a, b) => a - b);\n  const pos = (sorted.length - 1) * q;\n  const base = Math.floor(pos);\n  const rest = pos - base;\n\n  if (sorted[base + 1] !== undefined) {\n    return sorted[base] + rest * (sorted[base + 1] - sorted[base]);\n  } else {\n    return sorted[base];\n  }\n};\n\n/**\n * Calculates the spatial lag based on weights.\n * @param {Array} values - Array of values.\n * @param {Array} weights - Array of weight arrays.\n * @returns {Array|null} - Array of spatial lag values or null if invalid input.\n */\nexport const calculateSpatialLag = (values, weights) => {\n  if (!values || !weights || values.length !== weights.length) return null;\n\n  return values.map((_, i) => {\n    let weightedSum = 0;\n    let totalWeight = 0;\n\n    weights[i].forEach((weight, j) => {\n      if (values[j] !== undefined && !isNaN(values[j])) {\n        weightedSum += weight * values[j];\n        totalWeight += weight;\n      }\n    });\n\n    return totalWeight > 0 ? weightedSum / totalWeight : null;\n  });\n};\n\n/**\n * Determines the style of a GeoJSON feature based on its value.\n * @param {number} value - The residual or spillover value.\n * @param {Function} colorScale - Chroma color scale function.\n * @param {Object} theme - Material-UI theme.\n * @param {boolean} selected - Whether the region is selected.\n * @returns {Object} - Style properties.\n */\nexport const getFeatureStyle = (value, colorScale, theme, selected = false) => {\n  return {\n    fillColor: value != null ? colorScale(value).hex() : theme.palette.grey[300],\n    weight: selected ? 2 : 1,\n    opacity: 1,\n    color: selected ? theme.palette.primary.main : theme.palette.grey[500],\n    fillOpacity: value != null ? (selected ? 0.8 : 0.7) : 0.3,\n    dashArray: selected ? '3' : null\n  };\n};\n\n/**\n * Formats tooltip values based on type.\n * @param {number} value - The value to format.\n * @param {string} type - The type of value (e.g., 'residual').\n * @returns {string} - Formatted value.\n */\nexport const formatTooltipValue = (value, type = 'residual') => {\n  if (value == null || isNaN(value)) return 'N/A';\n\n  switch (type) {\n    case 'residual':\n      return value.toFixed(4);\n    case 'percentage':\n      return `${(value * 100).toFixed(2)}%`;\n    case 'price':\n      return value.toLocaleString(undefined, {\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n      });\n    default:\n      return value.toString();\n  }\n};\n\n/**\n * Calculates the bounding box for a set of GeoJSON features.\n * @param {Array} features - Array of GeoJSON features.\n * @returns {Array|null} - Bounding box coordinates or null.\n */\nexport const calculateBoundingBox = (features) => {\n  if (!features || features.length === 0) return null;\n\n  let minLat = Infinity;\n  let maxLat = -Infinity;\n  let minLng = Infinity;\n  let maxLng = -Infinity;\n\n  features.forEach(feature => {\n    const coordinates = feature.geometry.coordinates;\n    if (!coordinates) return;\n\n    coordinates.forEach(ring => {\n      ring.forEach(([lng, lat]) => {\n        minLat = Math.min(minLat, lat);\n        maxLat = Math.max(maxLat, lat);\n        minLng = Math.min(minLng, lng);\n        maxLng = Math.max(maxLng, lng);\n      });\n    });\n  });\n\n  return [[minLat, minLng], [maxLat, maxLng]];\n};\n\nexport const DEFAULT_CENTER = [15.5527, 48.5164];\nexport const DEFAULT_ZOOM = 6;\nexport const DEFAULT_BOUNDS = [\n  [12.5, 42.5],\n  [19.0, 54.5]\n];",
        "imports": [
          "chroma-js"
        ],
        "exports": [
          "formatNumber",
          "formatPValue",
          "getResidualStats",
          "getMapDimensions",
          "getColorScale",
          "MAP_STYLES",
          "getQuantile",
          "calculateSpatialLag",
          "getFeatureStyle",
          "formatTooltipValue",
          "calculateBoundingBox",
          "DEFAULT_CENTER",
          "DEFAULT_ZOOM",
          "DEFAULT_BOUNDS"
        ],
        "dependencies": [
          "chroma-js"
        ]
      },
      {
        "path": "components/analysis/tvmii/TVMIIAnalysis.js",
        "content": "// src/components/analysis/tvmii/TVMIIAnalysis.js\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  useTheme,\n  ToggleButtonGroup,\n  ToggleButton,\n  Button,\n  Paper,\n  Grid,\n  Typography,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails\n} from '@mui/material';\nimport { Download, ExpandMore } from '@mui/icons-material';\nimport { saveAs } from 'file-saver';\nimport { useTVMIIData, useTechnicalHelp } from '../../../hooks';\nimport TVMIIChart from './TVMIIChart';\nimport TVMIIMarketPairsChart from './TVMIIMarketPairsChart';\nimport TVMIIInterpretation from './TVMIIInterpretation';\nimport TVMIIFramework from './TVMIIFramework';\nimport { analysisStyles } from '../../../styles/analysisStyles';\n\nconst TVMIIAnalysis = ({ selectedCommodity, windowWidth }) => {\n  const theme = useTheme();\n  const styles = analysisStyles(theme);\n  const isMobile = windowWidth < theme.breakpoints.values.sm;\n\n  // State management\n  const [viewType, setViewType] = useState('overall');\n  const [frameworkExpanded, setFrameworkExpanded] = useState(false);\n  const [interpretationExpanded, setInterpretationExpanded] = useState(false);\n  const [filteredTVMIIData, setFilteredTVMIIData] = useState([]);\n  const [filteredMarketPairsData, setFilteredMarketPairsData] = useState([]);\n\n  // Custom hooks\n  const { tvmiiData, marketPairsData, status, error } = useTVMIIData();\n  const { getTechnicalTooltip } = useTechnicalHelp('tvmii');\n\n  // Effect to filter data based on selected commodity\n  useEffect(() => {\n    if (tvmiiData) {\n      const dataForCommodity = tvmiiData.filter(\n        (item) => item.commodity.toLowerCase() === selectedCommodity.toLowerCase()\n      );\n      setFilteredTVMIIData(dataForCommodity);\n    }\n\n    if (marketPairsData) {\n      const marketPairsForCommodity = marketPairsData.filter(\n        (item) => item.commodity.toLowerCase() === selectedCommodity.toLowerCase()\n      );\n      setFilteredMarketPairsData(marketPairsForCommodity);\n    }\n  }, [tvmiiData, marketPairsData, selectedCommodity]);\n\n  // Handlers\n  const handleViewTypeChange = (event, newViewType) => {\n    if (newViewType) setViewType(newViewType);\n  };\n\n  const handleDownloadData = useCallback(() => {\n    try {\n      const dataToDownload = viewType === 'overall' ? filteredTVMIIData : filteredMarketPairsData;\n      const blob = new Blob(\n        [JSON.stringify(dataToDownload, null, 2)],\n        { type: 'application/json' }\n      );\n      saveAs(blob, `tvmii_${viewType}_${selectedCommodity}.json`);\n    } catch (error) {\n      console.error('Error downloading data:', error);\n    }\n  }, [viewType, filteredTVMIIData, filteredMarketPairsData, selectedCommodity]);\n\n  // Determine if we have data to show\n  const hasData = viewType === 'overall' \n    ? filteredTVMIIData.length > 0 \n    : filteredMarketPairsData.length > 0;\n\n  if (status === 'loading' || error) {\n    return null; // AnalysisContainer will handle loading and error states\n  }\n\n  return (\n    <Box sx={{ width: '100%', mb: 4 }}>\n      {/* Controls and Download Button */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Grid container spacing={2} alignItems=\"center\">\n          <Grid item xs={12} md={8}>\n            <ToggleButtonGroup\n              value={viewType}\n              exclusive\n              onChange={handleViewTypeChange}\n              aria-label=\"View Type\"\n              size={isMobile ? 'small' : 'medium'}\n              sx={styles.toggleGroup}\n            >\n              <ToggleButton value=\"overall\">Overall TV-MII</ToggleButton>\n              <ToggleButton value=\"marketPairs\">Market Pairs</ToggleButton>\n            </ToggleButtonGroup>\n          </Grid>\n          <Grid item xs={12} md={4}>\n            <Button\n              fullWidth\n              variant=\"contained\"\n              startIcon={<Download />}\n              onClick={handleDownloadData}\n              disabled={!hasData}\n            >\n              Download Results\n            </Button>\n          </Grid>\n        </Grid>\n      </Paper>\n\n      {hasData && (\n        <>\n          {/* Model Framework Section */}\n          <Accordion \n            expanded={frameworkExpanded}\n            onChange={() => setFrameworkExpanded(!frameworkExpanded)}\n            sx={{ mb: 3 }}\n          >\n            <AccordionSummary \n              expandIcon={<ExpandMore />}\n              sx={{\n                backgroundColor: theme.palette.grey[50],\n                '&:hover': {\n                  backgroundColor: theme.palette.grey[100],\n                }\n              }}\n            >\n              <Typography variant=\"h6\">\n                Time-Varying Market Integration Index Framework\n              </Typography>\n            </AccordionSummary>\n            <AccordionDetails>\n              <TVMIIFramework \n                data={viewType === 'overall' ? filteredTVMIIData : filteredMarketPairsData}\n              />\n            </AccordionDetails>\n          </Accordion>\n\n          {/* Charts Section */}\n          <Paper sx={{ p: 2, mb: 3 }}>\n            <Typography variant=\"h6\" gutterBottom>\n              {viewType === 'overall' ? 'Overall Market Integration' : 'Market Pair Integration'}\n            </Typography>\n            {viewType === 'overall' ? (\n              <TVMIIChart\n                data={filteredTVMIIData}\n                selectedCommodity={selectedCommodity}\n                isMobile={isMobile}\n              />\n            ) : (\n              <TVMIIMarketPairsChart\n                data={filteredMarketPairsData}\n                selectedCommodity={selectedCommodity}\n                isMobile={isMobile}\n              />\n            )}\n          </Paper>\n\n          {/* Interpretation Section */}\n          <Accordion\n            expanded={interpretationExpanded}\n            onChange={() => setInterpretationExpanded(!interpretationExpanded)}\n            sx={{ mt: 3 }}\n          >\n            <AccordionSummary \n              expandIcon={<ExpandMore />}\n              sx={{\n                backgroundColor: theme.palette.grey[50],\n                '&:hover': {\n                  backgroundColor: theme.palette.grey[100],\n                }\n              }}\n            >\n              <Typography variant=\"h6\">\n                Market Integration Analysis Interpretation\n              </Typography>\n            </AccordionSummary>\n            <AccordionDetails>\n              <TVMIIInterpretation\n                data={filteredTVMIIData}\n                marketPairsData={filteredMarketPairsData}\n                selectedCommodity={selectedCommodity}\n                viewType={viewType}\n                isMobile={isMobile}\n              />\n            </AccordionDetails>\n          </Accordion>\n        </>\n      )}\n    </Box>\n  );\n};\n\nTVMIIAnalysis.propTypes = {\n  selectedCommodity: PropTypes.string.isRequired,\n  windowWidth: PropTypes.number.isRequired,\n};\n\nexport default TVMIIAnalysis;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "file-saver",
          "../../../hooks",
          "./TVMIIChart",
          "./TVMIIMarketPairsChart",
          "./TVMIIInterpretation",
          "./TVMIIFramework",
          "../../../styles/analysisStyles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "file-saver",
          "../../../hooks",
          "./TVMIIChart",
          "./TVMIIMarketPairsChart",
          "./TVMIIInterpretation",
          "./TVMIIFramework",
          "../../../styles/analysisStyles"
        ]
      },
      {
        "path": "components/analysis/tvmii/TVMIIChart.js",
        "content": "// src/components/analysis/tvmii/TVMIIChart.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip as RechartsTooltip,\n  Legend,\n  ResponsiveContainer,\n  ReferenceLine,\n} from 'recharts';\nimport {\n  Box,\n  Paper,\n  Typography,\n  FormControl,\n  InputLabel,\n  Select,\n  MenuItem,\n  Tooltip,\n  IconButton,\n  Alert,\n} from '@mui/material';\nimport { Info as InfoIcon } from '@mui/icons-material';\nimport { useTechnicalHelp } from '@/hooks';;\n\nconst TVMIIChart = ({ data, selectedCommodity, isMobile }) => {\n  // Format the data for the chart\n  const formattedData = useMemo(() => {\n    return Array.isArray(data)\n      ? data.map((d) => ({\n          date: d.date.getTime(),\n          tvmii: d.tvmii,\n          upper: d.confidence_bounds?.[1],\n          lower: d.confidence_bounds?.[0],\n        }))\n      : [];\n  }, [data]);\n\n  // Filter data based on the selected time period\n  const [selectedPeriod, setSelectedPeriod] = React.useState('all');\n\n  const { getTechnicalTooltip } = useTechnicalHelp('tvmii');\n\n  const chartData = useMemo(() => {\n    if (!formattedData.length) return [];\n\n    let filteredData = formattedData;\n    if (selectedPeriod !== 'all') {\n      const cutoffDate = new Date();\n      cutoffDate.setMonth(cutoffDate.getMonth() - parseInt(selectedPeriod, 10));\n      filteredData = formattedData.filter((d) => d.date >= cutoffDate.getTime());\n    }\n\n    return filteredData;\n  }, [formattedData, selectedPeriod]);\n\n  const handlePeriodChange = (event) => {\n    setSelectedPeriod(event.target.value);\n  };\n\n  // Calculate average TV-MII using only the \"Raw\" data\n  const averageTVMII = useMemo(() => {\n    if (!chartData.length) return 0;\n    return chartData.reduce((sum, d) => sum + d.tvmii, 0) / chartData.length;\n  }, [chartData]);\n\n  const getIntegrationLevel = (value) => {\n    if (value >= 0.7) return { label: 'High', color: 'success.main' };\n    if (value >= 0.3) return { label: 'Moderate', color: 'warning.main' };\n    return { label: 'Low', color: 'error.main' };\n  };\n\n  const integrationStatus = getIntegrationLevel(averageTVMII);\n\n  return (\n    <Paper sx={{ p: 2, mt: 2 }}>\n      <Box\n        sx={{\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n          flexWrap: 'wrap',\n          gap: 2,\n          mb: 2,\n        }}\n      >\n        <Typography variant=\"h6\">\n          Time-Varying Market Integration Index\n          <Tooltip title={getTechnicalTooltip('chart')}>\n            <IconButton size=\"small\">\n              <InfoIcon fontSize=\"small\" />\n            </IconButton>\n          </Tooltip>\n        </Typography>\n\n        <FormControl size=\"small\" sx={{ minWidth: 120 }}>\n          <InputLabel>Time Period</InputLabel>\n          <Select\n            value={selectedPeriod}\n            onChange={handlePeriodChange}\n            label=\"Time Period\"\n          >\n            <MenuItem value=\"all\">All Time</MenuItem>\n            <MenuItem value=\"12\">Last 12 Months</MenuItem>\n            <MenuItem value=\"6\">Last 6 Months</MenuItem>\n            <MenuItem value=\"3\">Last 3 Months</MenuItem>\n          </Select>\n        </FormControl>\n      </Box>\n\n      <Alert\n        severity={\n          integrationStatus.label === 'High'\n            ? 'success'\n            : integrationStatus.label === 'Moderate'\n            ? 'warning'\n            : 'error'\n        }\n        sx={{ mb: 2 }}\n      >\n        Average integration level: <strong>{integrationStatus.label}</strong> (\n        {averageTVMII.toFixed(3)})\n      </Alert>\n\n      <Box sx={{ height: isMobile ? 300 : 400, width: '100%' }}>\n        <ResponsiveContainer>\n          <LineChart\n            data={chartData}\n            margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n          >\n            <CartesianGrid strokeDasharray=\"3 3\" />\n            <XAxis\n              dataKey=\"date\"\n              type=\"number\"\n              scale=\"time\"\n              domain={['dataMin', 'dataMax']}\n              tickFormatter={(timestamp) =>\n                new Date(timestamp).toLocaleDateString()\n              }\n              label={{\n                value: 'Date',\n                position: 'insideBottom',\n                offset: -10,\n              }}\n            />\n            <YAxis\n              domain={[0, 1]}\n              label={{\n                value: 'Integration Index',\n                angle: -90,\n                position: 'insideLeft',\n                offset: 10,\n              }}\n            />\n            <RechartsTooltip\n              content={({ active, payload, label }) => {\n                if (!active || !payload?.length) return null;\n                return (\n                  <Box\n                    sx={{\n                      bgcolor: 'background.paper',\n                      p: 1,\n                      border: 1,\n                      borderColor: 'divider',\n                      borderRadius: 1,\n                    }}\n                  >\n                    <Typography variant=\"body2\">\n                      {new Date(label).toLocaleDateString()}\n                    </Typography>\n                    {payload.map((entry) => (\n                      <Typography\n                        key={entry.name}\n                        variant=\"body2\"\n                        color={entry.color}\n                      >\n                        {`${entry.name}: ${entry.value.toFixed(3)}`}\n                      </Typography>\n                    ))}\n                  </Box>\n                );\n              }}\n            />\n            <Legend />\n\n            <ReferenceLine\n              y={0.7}\n              stroke=\"green\"\n              strokeDasharray=\"3 3\"\n              label={{ value: 'High Integration', position: 'right' }}\n            />\n            <ReferenceLine\n              y={0.3}\n              stroke=\"orange\"\n              strokeDasharray=\"3 3\"\n              label={{ value: 'Low Integration', position: 'right' }}\n            />\n\n            <Line\n              type=\"monotone\"\n              dataKey=\"tvmii\"\n              stroke=\"#8884d8\"\n              dot={false}\n              name=\"Raw TV-MII\"\n            />\n          </LineChart>\n        </ResponsiveContainer>\n      </Box>\n\n      <Box sx={{ mt: 2 }}>\n        <Typography variant=\"body2\" color=\"text.secondary\">\n          Time-Varying Market Integration Index (TV-MII) for {selectedCommodity}.\n          Values closer to 1 indicate stronger market integration, while values closer\n          to 0 suggest weaker integration.\n        </Typography>\n      </Box>\n    </Paper>\n  );\n};\n\nTVMIIChart.propTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.shape({\n      date: PropTypes.number.isRequired,\n      tvmii: PropTypes.number.isRequired,\n      confidence_bounds: PropTypes.arrayOf(PropTypes.number),\n    })\n  ).isRequired,\n  selectedCommodity: PropTypes.string.isRequired,\n  isMobile: PropTypes.bool.isRequired,\n};\n\nexport default TVMIIChart;\n",
        "imports": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material",
          "@mui/icons-material",
          "@/hooks"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material",
          "@mui/icons-material",
          "@/hooks"
        ]
      },
      {
        "path": "components/analysis/tvmii/TVMIIFramework.js",
        "content": "// src/components/analysis/tvmii/TVMIIFramework.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Typography,\n  Grid,\n  useTheme,\n  Paper,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails\n} from '@mui/material';\nimport { ExpandMore } from '@mui/icons-material';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport 'katex/dist/katex.min.css';\n\nconst TVMIIFramework = ({ data }) => {\n  const theme = useTheme();\n\n  return (\n    <Box sx={{ '& .katex': { fontSize: '1.3em' } }}>\n      {/* Core Framework */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Typography variant=\"h6\" gutterBottom sx={{ color: theme.palette.primary.main }}>\n          Time-Varying Market Integration Index Model\n        </Typography>\n        <Box sx={{ my: 3 }}>\n          <BlockMath math={`MII_t = \\\\frac{1}{N} \\\\sum_{i=1}^N \\\\sum_{j=1}^N w_{ij} \\\\rho_{ij,t}`} />\n        </Box>\n        <Typography variant=\"body2\" paragraph>\n          Where <InlineMath math=\"MII_t\" /> is the market integration index at time t, \n          <InlineMath math=\"\\\\rho_{ij,t}\" /> is the price correlation between markets i and j, \n          and <InlineMath math=\"w_{ij}\" /> are spatial weights based on market distances\n        </Typography>\n      </Paper>\n\n      {/* Methodology Components */}\n      <Grid container spacing={3} sx={{ mb: 3 }}>\n        <Grid item xs={12} md={4}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.background.default,\n            borderRadius: 1,\n            height: '100%'\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Rolling Window Estimation\n            </Typography>\n            <Box sx={{ my: 2 }}>\n              <BlockMath math={`\\\\rho_{ij,t} = corr(P_i, P_j)_{t-w:t}`} />\n            </Box>\n            <Typography variant=\"body2\">\n              Dynamic price correlations computed using a rolling window of w periods to capture temporal variations in market relationships\n            </Typography>\n          </Box>\n        </Grid>\n\n        <Grid item xs={12} md={4}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.background.default,\n            borderRadius: 1,\n            height: '100%'\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Spatial Weights\n            </Typography>\n            <Box sx={{ my: 2 }}>\n              <BlockMath math={`w_{ij} = \\\\frac{1}{d_{ij}^\\\\alpha}`} />\n            </Box>\n            <Typography variant=\"body2\">\n              Distance-based weights capturing market connectivity and trade flows, where d_ij is the distance between markets\n            </Typography>\n          </Box>\n        </Grid>\n\n        <Grid item xs={12} md={4}>\n          <Box sx={{ \n            p: 2, \n            bgcolor: theme.palette.background.default,\n            borderRadius: 1,\n            height: '100%'\n          }}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Conflict Adjustment\n            </Typography>\n            <Box sx={{ my: 2 }}>\n              <BlockMath math={`\\\\rho_{ij,t}^* = \\\\rho_{ij,t} \\\\cdot (1 - CI_{ij,t})`} />\n            </Box>\n            <Typography variant=\"body2\">\n              Adjusts market correlations based on conflict intensity between market pairs to account for trade disruptions\n            </Typography>\n          </Box>\n        </Grid>\n      </Grid>\n\n      {/* Model Properties */}\n      <Paper sx={{ p: 2, bgcolor: theme.palette.grey[50] }}>\n        <Typography variant=\"h6\" gutterBottom>\n          Model Properties\n        </Typography>\n        <Grid container spacing={2}>\n          <Grid item xs={12} md={6}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Key Features:\n            </Typography>\n            <Typography variant=\"body2\">\n              • Dynamic measurement of market integration<br />\n              • Accounts for spatial dependencies<br />\n              • Incorporates conflict impacts<br />\n              • Normalized index range: [0,1]\n            </Typography>\n          </Grid>\n          <Grid item xs={12} md={6}>\n            <Typography variant=\"subtitle1\" color=\"primary\" gutterBottom>\n              Economic Implications:\n            </Typography>\n            <Typography variant=\"body2\">\n              • Higher values indicate stronger market integration<br />\n              • Temporal variations reveal integration dynamics<br />\n              • Distance decay affects integration strength<br />\n              • Conflict reduces effective market connectivity\n            </Typography>\n          </Grid>\n        </Grid>\n      </Paper>\n    </Box>\n  );\n};\n\nTVMIIFramework.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.shape({\n    date: PropTypes.string,\n    mii: PropTypes.number,\n    window_size: PropTypes.number,\n    conflict_adjusted: PropTypes.bool\n  }))\n};\n\nexport default TVMIIFramework;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "react-katex",
          "katex/dist/katex.min.css"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "react-katex",
          "katex/dist/katex.min.css"
        ]
      },
      {
        "path": "components/analysis/tvmii/TVMIIInterpretation.js",
        "content": "// src/components/analysis/tvmii/TVMIIInterpretation.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Paper,\n  Typography,\n  Grid,\n  Card,\n  CardContent,\n  Box,\n  Alert,\n  Divider,\n  Tooltip,\n  IconButton,\n} from '@mui/material';\nimport {\n  TrendingUp as TrendingUpIcon,\n  TrendingDown as TrendingDownIcon,\n  Info as InfoIcon,\n} from '@mui/icons-material';\nimport { useTechnicalHelp } from '@/hooks';;\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip as RechartsTooltip,\n  ResponsiveContainer,\n  ReferenceLine,\n} from 'recharts';\n\nconst TVMIIInterpretation = ({\n  data,\n  selectedCommodity,\n  isMobile,\n}) => {\n  const { getTechnicalTooltip } = useTechnicalHelp('tvmii');\n\n  // Overall Analysis\n  const analysis = useMemo(() => {\n    if (!data || data.length === 0) return null;\n\n    const values = data.map((d) => d.tvmii);\n    const dates = data.map((d) => new Date(d.date));\n\n    // Calculate basic statistics\n    const mean =\n      values.reduce((sum, val) => sum + val, 0) / values.length || 0;\n\n    // Identify peak and trough\n    const peak = Math.max(...values);\n    const trough = Math.min(...values);\n    const peakDate = data.find((d) => d.tvmii === peak)?.date;\n    const troughDate = data.find((d) => d.tvmii === trough)?.date;\n\n    // Calculate changes month-over-month\n    const changes = data\n      .slice(1)\n      .map((d, idx) => ({\n        month: d.date,\n        change: d.tvmii - data[idx].tvmii,\n      }));\n\n    // Identify the most significant increase\n    const significantIncrease = changes.reduce(\n      (max, current) =>\n        current.change > max.change ? current : max,\n      { change: -Infinity, month: null }\n    );\n\n    // Identify the most significant decrease\n    const significantDecrease = changes.reduce(\n      (min, current) =>\n        current.change < min.change ? current : min,\n      { change: Infinity, month: null }\n    );\n\n    return {\n      mean,\n      peak: { value: peak, date: peakDate },\n      trough: { value: trough, date: troughDate },\n      significantIncrease,\n      significantDecrease,\n    };\n  }, [data]);\n\n  const getIntegrationLevel = (value) => {\n    if (value >= 0.7) return { level: 'High', color: 'success.main' };\n    if (value >= 0.3) return { level: 'Moderate', color: 'warning.main' };\n    return { level: 'Low', color: 'error.main' };\n  };\n\n  if (!analysis) {\n    return (\n      <Alert severity=\"info\">\n        No TV-MII data available for interpretation.\n      </Alert>\n    );\n  }\n\n  return (\n    <Paper sx={{ p: 2, mt: 2 }}>\n      <Typography variant=\"h6\" gutterBottom>\n        TV-MII Analysis Interpretation\n        <Tooltip title={getTechnicalTooltip('interpretation')}>\n          <IconButton size=\"small\">\n            <InfoIcon fontSize=\"small\" />\n          </IconButton>\n        </Tooltip>\n      </Typography>\n\n      {analysis && (\n        <>\n          <Grid container spacing={3}>\n            {/* Overall Summary */}\n            <Grid item xs={12} md={6}>\n              <Card>\n                <CardContent>\n                  <Typography\n                    variant=\"subtitle1\"\n                    gutterBottom\n                    sx={{ display: 'flex', alignItems: 'center', gap: 1 }}\n                  >\n                    <TrendingUpIcon color=\"primary\" />\n                    Overall Summary\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    The average TV-MII for <strong>{selectedCommodity}</strong> is{' '}\n                    <strong>{analysis.mean.toFixed(3)}</strong>, indicating{' '}\n                    <strong>\n                      {getIntegrationLevel(analysis.mean).level}\n                    </strong>{' '}\n                    market integration.\n                  </Typography>\n                </CardContent>\n              </Card>\n            </Grid>\n\n            {/* Peak and Trough */}\n            <Grid item xs={12} md={6}>\n              <Card>\n                <CardContent>\n                  <Typography\n                    variant=\"subtitle1\"\n                    gutterBottom\n                    sx={{ display: 'flex', alignItems: 'center', gap: 1 }}\n                  >\n                    <TrendingUpIcon color=\"secondary\" />\n                    Peak & Trough\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    <strong>Peak TV-MII:</strong> {analysis.peak.value.toFixed(3)} on{' '}\n                    {new Date(analysis.peak.date).toLocaleDateString()}\n                  </Typography>\n                  <Typography variant=\"body2\" sx={{ mt: 1 }}>\n                    <strong>Trough TV-MII:</strong> {analysis.trough.value.toFixed(3)} on{' '}\n                    {new Date(analysis.trough.date).toLocaleDateString()}\n                  </Typography>\n                </CardContent>\n              </Card>\n            </Grid>\n          </Grid>\n\n          <Divider sx={{ my: 3 }} />\n\n          {/* Significant Changes */}\n          <Grid container spacing={3}>\n            <Grid item xs={12} md={6}>\n              <Card>\n                <CardContent>\n                  <Typography\n                    variant=\"subtitle1\"\n                    gutterBottom\n                    sx={{ display: 'flex', alignItems: 'center', gap: 1 }}\n                  >\n                    <TrendingDownIcon color=\"error\" />\n                    Significant Decrease\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    <strong>Change:</strong> {analysis.significantDecrease.change.toFixed(3)}\n                  </Typography>\n                  <Typography variant=\"body2\" sx={{ mt: 1 }}>\n                    <strong>Month:</strong>{' '}\n                    {analysis.significantDecrease.month\n                      ? new Date(analysis.significantDecrease.month).toLocaleDateString()\n                      : 'N/A'}\n                  </Typography>\n                </CardContent>\n              </Card>\n            </Grid>\n\n            <Grid item xs={12} md={6}>\n              <Card>\n                <CardContent>\n                  <Typography\n                    variant=\"subtitle1\"\n                    gutterBottom\n                    sx={{ display: 'flex', alignItems: 'center', gap: 1 }}\n                  >\n                    <TrendingUpIcon color=\"success\" />\n                    Significant Increase\n                  </Typography>\n                  <Typography variant=\"body2\">\n                    <strong>Change:</strong> {analysis.significantIncrease.change.toFixed(3)}\n                  </Typography>\n                  <Typography variant=\"body2\" sx={{ mt: 1 }}>\n                    <strong>Month:</strong>{' '}\n                    {analysis.significantIncrease.month\n                      ? new Date(analysis.significantIncrease.month).toLocaleDateString()\n                      : 'N/A'}\n                  </Typography>\n                </CardContent>\n              </Card>\n            </Grid>\n          </Grid>\n\n          <Divider sx={{ my: 3 }} />\n\n          {/* TV-MII Trend Chart */}\n          <Typography variant=\"subtitle1\" gutterBottom>\n            TV-MII Trend\n          </Typography>\n          <Box sx={{ width: '100%', height: isMobile ? 300 : 400 }}>\n            <ResponsiveContainer>\n              <LineChart\n                data={data.map((d) => ({\n                  date:\n                    d.date instanceof Date\n                      ? d.date.toLocaleDateString()\n                      : new Date(d.date).toLocaleDateString(),\n                  tvmii: d.tvmii,\n                }))}\n                margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n              >\n                <CartesianGrid strokeDasharray=\"3 3\" />\n                <XAxis dataKey=\"date\" />\n                <YAxis\n                  domain={[0, 1]}\n                  label={{\n                    value: 'TV-MII',\n                    angle: -90,\n                    position: 'insideLeft',\n                    offset: 10,\n                  }}\n                />\n                <RechartsTooltip />\n                <Line\n                  type=\"monotone\"\n                  dataKey=\"tvmii\"\n                  stroke=\"#82ca9d\"\n                  dot={false}\n                  name=\"TV-MII\"\n                />\n                <ReferenceLine\n                  y={analysis.mean}\n                  stroke=\"blue\"\n                  strokeDasharray=\"3 3\"\n                  label={{ value: 'Mean TV-MII', position: 'right' }}\n                />\n              </LineChart>\n            </ResponsiveContainer>\n          </Box>\n        </>\n      )}\n    </Paper>\n  );\n};\n\nTVMIIInterpretation.propTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.shape({\n      date: PropTypes.oneOfType([\n        PropTypes.instanceOf(Date),\n        PropTypes.string,\n      ]).isRequired,\n      tvmii: PropTypes.number.isRequired,\n    })\n  ).isRequired,\n  selectedCommodity: PropTypes.string.isRequired,\n  isMobile: PropTypes.bool.isRequired,\n};\n\nexport default TVMIIInterpretation;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "@/hooks",
          "recharts"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "@/hooks",
          "recharts"
        ]
      },
      {
        "path": "components/analysis/tvmii/TVMIIMarketPairsChart.js",
        "content": "// src/components/analysis/tvmii/TVMIIMarketPairsChart.js\n\nimport React, { useState, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip as RechartsTooltip,\n  Legend,\n  ResponsiveContainer,\n} from 'recharts';\nimport {\n  Box,\n  Paper,\n  Typography,\n  FormControl,\n  InputLabel,\n  Select,\n  MenuItem,\n  Tooltip,\n  IconButton,\n  Alert,\n} from '@mui/material';\nimport { Info as InfoIcon } from '@mui/icons-material';\nimport { useTechnicalHelp } from '../../../hooks';\n\nconst TVMIIMarketPairsChart = ({ data, selectedCommodity, isMobile }) => {\n  const [selectedMarketPair, setSelectedMarketPair] = useState('');\n  const [animationKey, setAnimationKey] = useState(0); // Key for forcing smooth re-renders\n  const { getTechnicalTooltip } = useTechnicalHelp('tvmii');\n\n  // Extract unique market pairs\n  const marketPairs = useMemo(() => {\n    const pairsSet = new Set(data.map((item) => item.market_pair));\n    return Array.from(pairsSet);\n  }, [data]);\n\n  // Set initial market pair\n  useEffect(() => {\n    if (marketPairs.length > 0) {\n      setSelectedMarketPair((prevPair) =>\n        marketPairs.includes(prevPair) ? prevPair : marketPairs[0]\n      );\n    }\n  }, [marketPairs]);\n\n  // Filter data based on selected market pair\n  const filteredData = useMemo(() => {\n    return data.filter((item) => item.market_pair === selectedMarketPair);\n  }, [data, selectedMarketPair]);\n\n  // Format chart data\n  const chartData = useMemo(() => {\n    return filteredData.map((d) => ({\n      date: d.date.getTime(),\n      tvmii: d.tv_mii || d.tvmii || d.value,\n    }));\n  }, [filteredData]);\n\n  const handleMarketPairChange = (event) => {\n    setSelectedMarketPair(event.target.value);\n    setAnimationKey(prev => prev + 1); // Trigger smooth re-render\n  };\n\n  // Custom animation configuration\n  const animationConfig = {\n    initial: { duration: 0 },\n    enter: { duration: 800, easing: 'ease-out' },\n    leave: { duration: 300, easing: 'ease-in' }\n  };\n\n  return (\n    <Paper sx={{ p: 2, mt: 2 }}>\n      <Box\n        sx={{\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n          flexWrap: 'wrap',\n          gap: 2,\n          mb: 2,\n        }}\n      >\n        <Typography variant=\"h6\">\n          Market Pairs TV-MII\n          <Tooltip title={getTechnicalTooltip('marketPairsChart')}>\n            <IconButton size=\"small\">\n              <InfoIcon fontSize=\"small\" />\n            </IconButton>\n          </Tooltip>\n        </Typography>\n\n        <FormControl size=\"small\" sx={{ minWidth: 200 }}>\n          <InputLabel>Market Pair</InputLabel>\n          <Select\n            value={selectedMarketPair}\n            onChange={handleMarketPairChange}\n            label=\"Market Pair\"\n          >\n            {marketPairs.map((pair) => (\n              <MenuItem key={pair} value={pair}>\n                {pair}\n              </MenuItem>\n            ))}\n          </Select>\n        </FormControl>\n      </Box>\n\n      {filteredData.length === 0 ? (\n        <Alert severity=\"info\" sx={{ mt: 2 }}>\n          No TV-MII data available for the selected market pair.\n        </Alert>\n      ) : (\n        <Box \n          sx={{ \n            height: isMobile ? 300 : 400, \n            width: '100%',\n            transition: 'all 0.3s ease-in-out' // Smooth container transitions\n          }}\n        >\n          <ResponsiveContainer key={animationKey}>\n            <LineChart\n              data={chartData}\n              margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n            >\n              <CartesianGrid strokeDasharray=\"3 3\" />\n              <XAxis\n                dataKey=\"date\"\n                type=\"number\"\n                scale=\"time\"\n                domain={['dataMin', 'dataMax']}\n                tickFormatter={(timestamp) =>\n                  new Date(timestamp).toLocaleDateString()\n                }\n                label={{\n                  value: 'Date',\n                  position: 'insideBottom',\n                  offset: -10,\n                }}\n              />\n              <YAxis\n                domain={[0, 1]}\n                label={{\n                  value: 'Integration Index',\n                  angle: -90,\n                  position: 'insideLeft',\n                  offset: 10,\n                }}\n              />\n              <RechartsTooltip\n                content={({ active, payload, label }) => {\n                  if (!active || !payload?.length) return null;\n                  return (\n                    <Box\n                      sx={{\n                        bgcolor: 'background.paper',\n                        p: 1,\n                        border: 1,\n                        borderColor: 'divider',\n                        borderRadius: 1,\n                        boxShadow: 1,\n                        transition: 'all 0.2s ease' // Smooth tooltip transitions\n                      }}\n                    >\n                      <Typography variant=\"body2\">\n                        {new Date(label).toLocaleDateString()}\n                      </Typography>\n                      {payload.map((entry) => (\n                        <Typography\n                          key={entry.name}\n                          variant=\"body2\"\n                          color={entry.color}\n                        >\n                          {`${entry.name}: ${entry.value.toFixed(3)}`}\n                        </Typography>\n                      ))}\n                    </Box>\n                  );\n                }}\n                animationDuration={300}\n                animationEasing=\"ease-out\"\n              />\n              <Legend />\n\n              <Line\n                type=\"monotone\"\n                dataKey=\"tvmii\"\n                stroke=\"#8884d8\"\n                dot={false}\n                name=\"TV-MII\"\n                strokeWidth={2}\n                animationBegin={0}\n                animationDuration={1500}\n                animationEasing=\"ease-in-out\"\n                isAnimationActive={true}\n              />\n            </LineChart>\n          </ResponsiveContainer>\n        </Box>\n      )}\n\n      <Box \n        sx={{ \n          mt: 2,\n          transition: 'opacity 0.3s ease-in-out' // Smooth text transitions\n        }}\n      >\n        <Typography variant=\"body2\" color=\"text.secondary\">\n          Time-Varying Market Integration Index for market pair{' '}\n          <strong>{selectedMarketPair}</strong>. Values closer to 1 indicate\n          stronger market integration, while values closer to 0 suggest weaker\n          integration.\n        </Typography>\n      </Box>\n    </Paper>\n  );\n};\n\nTVMIIMarketPairsChart.propTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.shape({\n      date: PropTypes.instanceOf(Date).isRequired,\n      tv_mii: PropTypes.number,\n      tvmii: PropTypes.number,\n      value: PropTypes.number,\n      market_pair: PropTypes.string.isRequired,\n    })\n  ).isRequired,\n  selectedCommodity: PropTypes.string.isRequired,\n  isMobile: PropTypes.bool.isRequired,\n};\n\nexport default TVMIIMarketPairsChart;\n",
        "imports": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material",
          "@mui/icons-material",
          "../../../hooks"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "recharts",
          "@mui/material",
          "@mui/icons-material",
          "../../../hooks"
        ]
      },
      {
        "path": "components/common/AnalysisContainer.js",
        "content": "// src/components/common/AnalysisContainer.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Paper,\n  Typography,\n  CircularProgress,\n  Alert,\n  IconButton,\n  Tooltip,\n} from '@mui/material';\nimport { Info as InfoIcon } from '@mui/icons-material';\nimport { useTheme } from '@mui/material/styles';\nimport { analysisStyles } from '../../styles/analysisStyles';\n\nconst AnalysisContainer = ({\n  title,\n  infoTooltip,\n  loading,\n  error,\n  controls,\n  children,\n  noDataMessage,\n  hasData = true,\n  selectedCommodity,\n}) => {\n  const theme = useTheme();\n  const styles = analysisStyles(theme);\n\n  if (loading) {\n    return (\n      <Paper elevation={3} sx={styles.root}>\n        <Box sx={styles.loadingContainer}>\n          <CircularProgress size={60} />\n          <Typography variant=\"h6\" color=\"textSecondary\">\n            Loading {title}...\n          </Typography>\n        </Box>\n      </Paper>\n    );\n  }\n\n  if (error) {\n    return (\n      <Paper elevation={3} sx={styles.root}>\n        <Box sx={styles.errorContainer}>\n          <Alert severity=\"error\" variant=\"outlined\">\n            {error}\n          </Alert>\n        </Box>\n      </Paper>\n    );\n  }\n\n  if (!hasData) {\n    return (\n      <Paper elevation={3} sx={styles.root}>\n        <Alert severity=\"info\" variant=\"outlined\">\n          {noDataMessage || `No ${title} data available for ${selectedCommodity}`}\n        </Alert>\n      </Paper>\n    );\n  }\n\n  return (\n    <Paper \n      elevation={3} \n      sx={{\n        ...styles.root,\n        width: '100%',\n      }}\n    >\n      {/* Header Section */}\n      <Box sx={{\n        ...styles.header,\n        mb: 3,\n      }}>\n        <Typography variant=\"h4\" sx={styles.title}>\n          {title}\n          {infoTooltip && (\n            <Tooltip title={infoTooltip}>\n              <IconButton size=\"small\" sx={styles.infoIcon}>\n                <InfoIcon />\n              </IconButton>\n            </Tooltip>\n          )}\n        </Typography>\n        {controls && (\n          <Box sx={styles.controlsContainer}>\n            {controls}\n          </Box>\n        )}\n      </Box>\n\n      {/* Content Section */}\n      <Box sx={{\n        ...styles.contentSection,\n        width: '100%',\n      }}>\n        {children}\n      </Box>\n    </Paper>\n  );\n};\n\nAnalysisContainer.propTypes = {\n  title: PropTypes.string.isRequired,\n  infoTooltip: PropTypes.string,\n  loading: PropTypes.bool,\n  error: PropTypes.string,\n  controls: PropTypes.node,\n  children: PropTypes.node,\n  noDataMessage: PropTypes.string,\n  hasData: PropTypes.bool,\n  selectedCommodity: PropTypes.string.isRequired,\n};\n\nexport default AnalysisContainer;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "@mui/material/styles",
          "../../styles/analysisStyles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material",
          "@mui/material/styles",
          "../../styles/analysisStyles"
        ]
      },
      {
        "path": "components/common/AnalysisWrapper.js",
        "content": "//src/components/common/AnalysisWrapper.js\n\nimport React, { Suspense } from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, CircularProgress, useTheme } from '@mui/material';\n\n// Enhanced loading fallback component with dark mode support\nconst LoadingFallback = () => {\n  const theme = useTheme();\n  \n  return (\n    <Box \n      display=\"flex\" \n      justifyContent=\"center\" \n      alignItems=\"center\" \n      minHeight=\"200px\"\n      sx={{\n        backgroundColor: theme.palette.background.paper,\n        borderRadius: 1,\n        transition: theme.transitions.create(['background-color', 'box-shadow'], {\n          duration: theme.transitions.duration.standard,\n        }),\n        boxShadow: theme.palette.mode === 'dark' \n          ? '0 2px 4px rgba(0,0,0,0.4)' \n          : '0 1px 3px rgba(0,0,0,0.12)',\n      }}\n    >\n      <CircularProgress \n        sx={{\n          color: theme.palette.primary.main,\n          '& .MuiCircularProgress-circle': {\n            strokeLinecap: 'round',\n          },\n        }}\n      />\n    </Box>\n  );\n};\n\n// Enhanced Analysis Wrapper component\nconst AnalysisWrapper = ({ children }) => {\n  const theme = useTheme();\n\n  return (\n    <Box \n      sx={{ \n        width: '100%', \n        height: '100%',\n        backgroundColor: theme.palette.background.default,\n        borderRadius: 1,\n        transition: theme.transitions.create(\n          ['background-color', 'box-shadow'],\n          {\n            duration: theme.transitions.duration.standard,\n          }\n        ),\n        '& > *': {\n          transition: theme.transitions.create(\n            ['background-color', 'color'],\n            {\n              duration: theme.transitions.duration.standard,\n            }\n          ),\n        },\n        p: 2,\n        boxShadow: theme.palette.mode === 'dark'\n          ? '0 2px 8px rgba(0,0,0,0.5)'\n          : '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n      }}\n    >\n      <Suspense fallback={<LoadingFallback />}>\n        {children}\n      </Suspense>\n    </Box>\n  );\n};\n\nAnalysisWrapper.propTypes = {\n  children: PropTypes.node.isRequired,\n};\n\nexport default AnalysisWrapper;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material"
        ]
      },
      {
        "path": "components/common/ChartContainer.js",
        "content": "// src/components/common/ChartContainer.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Card,\n  CardContent,\n  useTheme,\n} from '@mui/material';\nimport { analysisStyles, chartStyles } from '../../styles/analysisStyles';\n\nconst ChartContainer = ({\n  children,\n  height = 400,\n}) => {\n  const theme = useTheme();\n  const styles = analysisStyles(theme);\n\n  return (\n    <Card sx={{\n      ...styles.chartContainer,\n      mb: 3,\n      minHeight: height,\n    }}>\n      <CardContent>\n        <Box \n          sx={{ \n            position: 'relative',\n            '& .recharts-responsive-container': {\n              '& .recharts-surface': {\n                borderRadius: '8px',\n              }\n            },\n            '& .recharts-tooltip-wrapper': {\n              ...chartStyles.tooltip,\n            },\n            '& .recharts-cartesian-grid-horizontal line, .recharts-cartesian-grid-vertical line': {\n              stroke: theme.palette.divider,\n              strokeDasharray: '3 3',\n              strokeOpacity: 0.5,\n            },\n            '& .recharts-cartesian-axis-line': {\n              stroke: theme.palette.divider,\n              strokeWidth: 2,\n            },\n            '& .recharts-cartesian-axis-tick-line': {\n              stroke: theme.palette.text.secondary,\n            },\n            '& .recharts-cartesian-axis-tick-value': {\n              fill: theme.palette.text.secondary,\n              fontSize: '0.75rem',\n            },\n            '& .recharts-legend-item-text': {\n              fontSize: '0.875rem',\n              color: theme.palette.text.primary,\n            }\n          }}\n        >\n          {children}\n        </Box>\n      </CardContent>\n    </Card>\n  );\n};\n\nChartContainer.propTypes = {\n  children: PropTypes.node.isRequired,\n  height: PropTypes.number,\n};\n\nexport default ChartContainer;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "../../styles/analysisStyles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "../../styles/analysisStyles"
        ]
      },
      {
        "path": "components/common/EnhancedErrorBoundary.js",
        "content": "// src/components/common/EnhancedErrorBoundary.js\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, Typography, Button } from '@mui/material';\nimport { CircularProgress } from '@mui/material';\nimport { AlertTriangle, RefreshCw } from 'lucide-react';\n\nclass EnhancedErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      hasError: false, \n      error: null,\n      errorInfo: null,\n      isRetrying: false\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error);\n    this.setState({ errorInfo });\n\n    if (process.env.NODE_ENV === 'production' && window?.Sentry) {\n      window.Sentry.captureException(error, { extra: errorInfo });\n    }\n  }\n\n  handleRetry = async () => {\n    this.setState({ isRetrying: true });\n    try {\n      await this.props.onRetry?.();\n      this.setState({ \n        hasError: false, \n        error: null, \n        errorInfo: null, \n        isRetrying: false \n      });\n    } catch (error) {\n      this.setState({ \n        hasError: true, \n        error, \n        isRetrying: false \n      });\n    }\n  };\n\n  render() {\n    if (!this.state.hasError) {\n      return this.props.children;\n    }\n\n    return (\n      <Box \n        sx={{ \n          p: 3, \n          maxWidth: '100%',\n          backgroundColor: 'background.paper',\n          borderRadius: 1,\n          boxShadow: 1\n        }}\n      >\n        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>\n          <AlertTriangle size={24} color=\"error\" />\n          <Typography variant=\"h6\" color=\"error\">\n            Application Error\n          </Typography>\n        </Box>\n\n        <Typography variant=\"body1\" gutterBottom color=\"text.primary\">\n          {this.state.error?.message || 'An unexpected error occurred'}\n        </Typography>\n\n        {process.env.NODE_ENV !== 'production' && this.state.errorInfo && (\n          <Box \n            component=\"pre\"\n            sx={{ \n              mt: 2,\n              p: 2, \n              backgroundColor: 'grey.100',\n              borderRadius: 1,\n              overflow: 'auto',\n              fontSize: '0.875rem',\n              fontFamily: 'monospace',\n              whiteSpace: 'pre-wrap',\n              wordBreak: 'break-word'\n            }}\n          >\n            {this.state.errorInfo.componentStack}\n          </Box>\n        )}\n\n        <Box sx={{ mt: 3, display: 'flex', gap: 2 }}>\n          <Button\n            onClick={this.handleRetry}\n            disabled={this.state.isRetrying}\n            startIcon={this.state.isRetrying ? (\n              <CircularProgress size={16} />\n            ) : (\n              <RefreshCw className=\"w-4 h-4\" />\n            )}\n            variant=\"contained\"\n            color=\"primary\"\n          >\n            {this.state.isRetrying ? 'Retrying...' : 'Retry'}\n          </Button>\n          <Button\n            onClick={() => window.location.reload()}\n            variant=\"outlined\"\n            color=\"primary\"\n          >\n            Reload Page\n          </Button>\n        </Box>\n      </Box>\n    );\n  }\n}\n\nEnhancedErrorBoundary.propTypes = {\n  children: PropTypes.node.isRequired,\n  onRetry: PropTypes.func\n};\n\nexport default EnhancedErrorBoundary;",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material",
          "lucide-react"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "lucide-react"
        ]
      },
      {
        "path": "components/common/EquationWithHelp.js",
        "content": "//src/components/common/EquationWithHelp.js\n\nimport React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Paper,\n  Typography,\n  Collapse,\n  IconButton,\n  List,\n  ListItem,\n  ListItemText,\n  Divider,\n} from '@mui/material';\nimport { ChevronDown, ChevronUp } from 'lucide-react';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport 'katex/dist/katex.min.css';\n\nconst EquationWithHelp = ({\n  latex,\n  description,\n  variables,\n  title,\n}) => {\n  const [expanded, setExpanded] = useState(false);\n\n  return (\n    <Paper sx={{ p: 2, mb: 2 }}>\n      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n        <Typography variant=\"subtitle1\" gutterBottom>\n          {title}\n        </Typography>\n        <IconButton\n          onClick={() => setExpanded(!expanded)}\n          size=\"small\"\n          sx={{ transform: expanded ? 'rotate(180deg)' : 'none' }}\n        >\n          {expanded ? <ChevronUp /> : <ChevronDown />}\n        </IconButton>\n      </Box>\n\n      {latex && (\n        <Box sx={{ my: 2 }}>\n          <BlockMath>{latex}</BlockMath>\n        </Box>\n      )}\n\n      <Collapse in={expanded}>\n        <Box sx={{ mt: 2 }}>\n          {description && (\n            <>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Description\n              </Typography>\n              <Typography variant=\"body2\" paragraph>\n                {description}\n              </Typography>\n              <Divider sx={{ my: 2 }} />\n            </>\n          )}\n\n          {variables && Object.keys(variables).length > 0 && (\n            <>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Variables\n              </Typography>\n              <List dense>\n                {Object.entries(variables).map(([symbol, description]) => (\n                  <ListItem key={symbol}>\n                    <ListItemText\n                      primary={<InlineMath>{symbol}</InlineMath>}\n                      secondary={description}\n                      primaryTypographyProps={{\n                        component: 'div',\n                        sx: { mb: 0.5 },\n                      }}\n                    />\n                  </ListItem>\n                ))}\n              </List>\n            </>\n          )}\n        </Box>\n      </Collapse>\n    </Paper>\n  );\n};\n\nEquationWithHelp.propTypes = {\n  latex: PropTypes.string,\n  description: PropTypes.string,\n  variables: PropTypes.objectOf(PropTypes.string),\n  title: PropTypes.string.isRequired,\n  componentType: PropTypes.string.isRequired,\n};\n\nexport default EquationWithHelp;",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "lucide-react",
          "react-katex",
          "katex/dist/katex.min.css"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "lucide-react",
          "react-katex",
          "katex/dist/katex.min.css"
        ]
      },
      {
        "path": "components/common/ErrorBoundary.js",
        "content": "//src/components/common/ErrorBoundary.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  Paper,\n  Typography,\n  Button,\n  Alert,\n  AlertTitle\n} from '@mui/material';\nimport RefreshIcon from '@mui/icons-material/Refresh';\nimport BugReportIcon from '@mui/icons-material/BugReport';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null,\n      errorInfo: null\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n\n    // Log error to monitoring service\n    console.error('Error caught by boundary:', error, errorInfo);\n\n    // Call error handler if provided\n    if (this.props.onError) {\n      this.props.onError(error, errorInfo);\n    }\n  }\n\n  handleReset = () => {\n    this.setState({\n      hasError: false,\n      error: null,\n      errorInfo: null\n    });\n  };\n\n  handleReload = () => {\n    window.location.reload();\n  };\n\n  render() {\n    if (this.state.hasError) {\n      const isDevelopment = process.env.NODE_ENV === 'development';\n\n      return (\n        <Box\n          sx={{\n            p: 3,\n            height: '100%',\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center'\n          }}\n        >\n          <Paper\n            elevation={3}\n            sx={{\n              p: 4,\n              maxWidth: 600,\n              width: '100%'\n            }}\n          >\n            <Alert\n              severity=\"error\"\n              variant=\"filled\"\n              sx={{ mb: 3 }}\n            >\n              <AlertTitle>An Error Has Occurred</AlertTitle>\n              {this.props.message || 'Something went wrong while rendering this component.'}\n            </Alert>\n\n            <Box sx={{ mb: 3 }}>\n              <Typography variant=\"subtitle1\" gutterBottom>\n                Actions:\n              </Typography>\n              <Box sx={{ display: 'flex', gap: 2 }}>\n                <Button\n                  variant=\"contained\"\n                  color=\"primary\"\n                  startIcon={<RefreshIcon />}\n                  onClick={this.handleReset}\n                >\n                  Try Again\n                </Button>\n                <Button\n                  variant=\"outlined\"\n                  color=\"primary\"\n                  startIcon={<RefreshIcon />}\n                  onClick={this.handleReload}\n                >\n                  Reload Page\n                </Button>\n              </Box>\n            </Box>\n\n            {isDevelopment && this.state.error && (\n              <>\n                <Box sx={{ mb: 2 }}>\n                  <Typography variant=\"subtitle1\" color=\"error\" gutterBottom>\n                    <BugReportIcon sx={{ mr: 1, verticalAlign: 'middle' }} />\n                    Error Details:\n                  </Typography>\n                  <Paper\n                    variant=\"outlined\"\n                    sx={{\n                      p: 2,\n                      bgcolor: 'grey.100',\n                      maxHeight: 200,\n                      overflow: 'auto'\n                    }}\n                  >\n                    <Typography\n                      variant=\"body2\"\n                      component=\"pre\"\n                      sx={{ \n                        fontFamily: 'monospace',\n                        whiteSpace: 'pre-wrap',\n                        wordBreak: 'break-word'\n                      }}\n                    >\n                      {this.state.error.toString()}\n                    </Typography>\n                  </Paper>\n                </Box>\n\n                <Box>\n                  <Typography variant=\"subtitle1\" color=\"error\" gutterBottom>\n                    <BugReportIcon sx={{ mr: 1, verticalAlign: 'middle' }} />\n                    Stack Trace:\n                  </Typography>\n                  <Paper\n                    variant=\"outlined\"\n                    sx={{\n                      p: 2,\n                      bgcolor: 'grey.100',\n                      maxHeight: 300,\n                      overflow: 'auto'\n                    }}\n                  >\n                    <Typography\n                      variant=\"body2\"\n                      component=\"pre\"\n                      sx={{ \n                        fontFamily: 'monospace',\n                        whiteSpace: 'pre-wrap',\n                        wordBreak: 'break-word'\n                      }}\n                    >\n                      {this.state.errorInfo?.componentStack}\n                    </Typography>\n                  </Paper>\n                </Box>\n              </>\n            )}\n\n            {this.props.children && (\n              <Box sx={{ mt: 3 }}>\n                <Typography variant=\"subtitle1\" gutterBottom>\n                  Fallback UI:\n                </Typography>\n                {this.props.children}\n              </Box>\n            )}\n          </Paper>\n        </Box>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nErrorBoundary.propTypes = {\n  children: PropTypes.node,\n  message: PropTypes.string,\n  onError: PropTypes.func\n};\n\nexport default ErrorBoundary;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material/Refresh",
          "@mui/icons-material/BugReport"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material/Refresh",
          "@mui/icons-material/BugReport"
        ]
      },
      {
        "path": "components/common/ErrorDisplay.js",
        "content": "// src/components/common/ErrorDisplay.js\nimport React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { \n  Box, \n  Typography, \n  Button, \n  Collapse,\n  Paper,\n  useTheme,\n  alpha\n} from '@mui/material';\nimport { ChevronDown, ChevronUp, RefreshCw } from 'lucide-react';\nimport { styled } from '@mui/material/styles';\n\nconst StyledPaper = styled(Paper)(({ theme }) => ({\n  padding: theme.spacing(3),\n  backgroundColor: theme.palette.mode === 'dark' \n    ? alpha(theme.palette.error.dark, 0.2)\n    : alpha(theme.palette.error.light, 0.1),\n  border: `1px solid ${theme.palette.mode === 'dark' \n    ? theme.palette.error.dark \n    : theme.palette.error.light}`,\n  color: theme.palette.error.main,\n  marginTop: theme.spacing(2),\n  transition: theme.transitions.create(\n    ['background-color', 'border-color', 'box-shadow'],\n    {\n      duration: theme.transitions.duration.short,\n    }\n  ),\n  '&:hover': {\n    boxShadow: theme.palette.mode === 'dark'\n      ? `0 0 10px ${alpha(theme.palette.error.main, 0.3)}`\n      : `0 0 10px ${alpha(theme.palette.error.light, 0.2)}`,\n  }\n}));\n\nconst DetailBox = styled(Box)(({ theme }) => ({\n  marginTop: theme.spacing(2),\n  padding: theme.spacing(2),\n  backgroundColor: theme.palette.mode === 'dark'\n    ? alpha(theme.palette.background.paper, 0.1)\n    : alpha(theme.palette.background.paper, 0.1),\n  borderRadius: theme.shape.borderRadius,\n  fontFamily: 'monospace',\n  fontSize: '0.875rem',\n  whiteSpace: 'pre-wrap',\n  color: theme.palette.text.primary,\n  border: `1px solid ${theme.palette.divider}`,\n  transition: theme.transitions.create(\n    ['background-color', 'border-color'],\n    {\n      duration: theme.transitions.duration.short,\n    }\n  ),\n}));\n\nconst ErrorDisplay = ({ \n  error,\n  title = 'Error',\n  onRetry,\n  showDetails = false,\n  className\n}) => {\n  const [expanded, setExpanded] = useState(false);\n  const theme = useTheme();\n  const errorMessage = typeof error === 'string' ? error : error?.message;\n  const errorDetails = typeof error === 'object' ? error?.details : null;\n\n  if (!error) return null;\n\n  return (\n    <StyledPaper className={className} elevation={3}>\n      <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 2 }}>\n        <Box sx={{ flex: 1 }}>\n          <Typography \n            variant=\"h6\" \n            gutterBottom\n            sx={{ \n              color: theme.palette.error.main,\n              fontWeight: 600,\n            }}\n          >\n            {title}\n          </Typography>\n          <Typography \n            variant=\"body1\" \n            gutterBottom\n            sx={{ \n              color: theme.palette.text.primary,\n              opacity: 0.9,\n            }}\n          >\n            {errorMessage}\n          </Typography>\n          \n          {errorDetails && showDetails && (\n            <>\n              <Button\n                size=\"small\"\n                onClick={() => setExpanded(!expanded)}\n                startIcon={expanded ? <ChevronUp size={18} /> : <ChevronDown size={18} />}\n                sx={{ \n                  mt: 1, \n                  color: theme.palette.text.secondary,\n                  '&:hover': {\n                    backgroundColor: theme.palette.mode === 'dark'\n                      ? alpha(theme.palette.common.white, 0.05)\n                      : alpha(theme.palette.common.black, 0.05),\n                  }\n                }}\n              >\n                {expanded ? 'Hide' : 'Show'} Details\n              </Button>\n              \n              <Collapse in={expanded}>\n                <DetailBox>\n                  {typeof errorDetails === 'string' \n                    ? errorDetails \n                    : JSON.stringify(errorDetails, null, 2)}\n                </DetailBox>\n              </Collapse>\n            </>\n          )}\n        </Box>\n        \n        {onRetry && (\n          <Button\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<RefreshCw size={18} />}\n            onClick={onRetry}\n            sx={{ \n              color: theme.palette.error.main,\n              borderColor: theme.palette.error.main,\n              '&:hover': {\n                borderColor: theme.palette.error.dark,\n                backgroundColor: theme.palette.mode === 'dark'\n                  ? alpha(theme.palette.error.main, 0.1)\n                  : alpha(theme.palette.error.light, 0.1),\n              },\n              transition: theme.transitions.create(\n                ['background-color', 'border-color', 'color'],\n                {\n                  duration: theme.transitions.duration.short,\n                }\n              ),\n            }}\n          >\n            Retry\n          </Button>\n        )}\n      </Box>\n    </StyledPaper>\n  );\n};\n\nErrorDisplay.propTypes = {\n  error: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.shape({\n      message: PropTypes.string.isRequired,\n      details: PropTypes.any\n    })\n  ]).isRequired,\n  title: PropTypes.string,\n  onRetry: PropTypes.func,\n  showDetails: PropTypes.bool,\n  className: PropTypes.string\n};\n\nexport default ErrorDisplay;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "lucide-react",
          "@mui/material/styles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "lucide-react",
          "@mui/material/styles"
        ]
      },
      {
        "path": "components/common/ErrorMessage.js",
        "content": "//sr./components/common/ErrorMessage.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Alert } from '@mui/material';\n\nconst ErrorMessage = ({ message }) => (\n  <Alert severity=\"error\" sx={{ mt: 2 }}>\n    {message}\n  </Alert>\n);\n\nErrorMessage.propTypes = {\n  message: PropTypes.string.isRequired,\n};\n\nexport default ErrorMessage;",
        "imports": [
          "react",
          "prop-types",
          "@mui/material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material"
        ]
      },
      {
        "path": "components/common/Header.js",
        "content": "// src/components/common/Header.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { IconButton, Typography, Box } from '@mui/material';\nimport Brightness4Icon from '@mui/icons-material/Brightness4';\nimport Brightness7Icon from '@mui/icons-material/Brightness7';\nimport { styled } from '@mui/material/styles';\n\nconst TitleTypography = styled(Typography)(({ theme }) => ({\n  flexGrow: 1,\n  fontWeight: 600,\n  color: theme.palette.mode === 'dark' \n    ? theme.palette.primary.contrastText\n    : theme.palette.primary.contrastText,\n  transition: theme.transitions.create(['color'], {\n    duration: theme.transitions.duration.short,\n  }),\n  [theme.breakpoints.down('sm')]: {\n    fontSize: '1rem',\n  },\n}));\n\nconst StyledIconButton = styled(IconButton)(({ theme }) => ({\n  color: theme.palette.primary.contrastText,\n  transition: theme.transitions.create(['color', 'background-color'], {\n    duration: theme.transitions.duration.short,\n  }),\n  '&:hover': {\n    backgroundColor: theme.palette.mode === 'dark' \n      ? 'rgba(255, 255, 255, 0.08)'\n      : 'rgba(0, 0, 0, 0.08)',\n  },\n  '& .MuiSvgIcon-root': {\n    transition: theme.transitions.create(['transform'], {\n      duration: theme.transitions.duration.short,\n    }),\n  },\n  '&:hover .MuiSvgIcon-root': {\n    transform: 'rotate(30deg)',\n  },\n}));\n\nconst Header = ({ isDarkMode, toggleDarkMode }) => {\n  return (\n    <Box \n      sx={{ \n        display: 'flex', \n        alignItems: 'center', \n        width: '100%',\n        px: 2,\n        transition: (theme) => theme.transitions.create(['background-color'], {\n          duration: theme.transitions.duration.short,\n        }),\n      }}\n    >\n      <TitleTypography variant=\"h6\" noWrap component=\"div\">\n        Yemen Market Analysis Dashboard\n      </TitleTypography>\n      \n      <StyledIconButton\n        onClick={toggleDarkMode}\n        aria-label={isDarkMode ? 'switch to light mode' : 'switch to dark mode'}\n        size=\"large\"\n        edge=\"end\"\n      >\n        {isDarkMode ? (\n          <Brightness7Icon />\n        ) : (\n          <Brightness4Icon />\n        )}\n      </StyledIconButton>\n    </Box>\n  );\n};\n\nHeader.propTypes = {\n  isDarkMode: PropTypes.bool.isRequired,\n  toggleDarkMode: PropTypes.func.isRequired,\n};\n\nexport default Header;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material/Brightness4",
          "@mui/icons-material/Brightness7",
          "@mui/material/styles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material/Brightness4",
          "@mui/icons-material/Brightness7",
          "@mui/material/styles"
        ]
      },
      {
        "path": "components/common/LoadingIndicator.js",
        "content": "//src/components/common/LoadingIndicator.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Box,\n  CircularProgress,\n  LinearProgress,\n  Typography,\n  Paper\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\n\nconst LoadingIndicator = ({\n  message = 'Loading...',\n  progress,\n  variant = 'circular',\n  fullscreen = false,\n  overlay = false,\n  height = '100%'\n}) => {\n  const theme = useTheme();\n\n  const content = (\n    <Box\n      sx={{\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center',\n        height: fullscreen ? '100vh' : height,\n        width: '100%',\n        ...(overlay && {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          zIndex: theme.zIndex.modal,\n          backgroundColor: 'rgba(255, 255, 255, 0.9)'\n        })\n      }}\n    >\n      {variant === 'circular' ? (\n        <CircularProgress\n          size={48}\n          thickness={4}\n          sx={{ mb: 2 }}\n          {...(typeof progress === 'number' && {\n            variant: 'determinate',\n            value: progress\n          })}\n        />\n      ) : (\n        <Box sx={{ width: '60%', maxWidth: 400, mb: 2 }}>\n          <LinearProgress\n            {...(typeof progress === 'number' && {\n              variant: 'determinate',\n              value: progress\n            })}\n          />\n        </Box>\n      )}\n\n      {message && (\n        <Typography\n          variant=\"body1\"\n          color=\"textSecondary\"\n          align=\"center\"\n          sx={{ \n            maxWidth: 400,\n            px: 2,\n            ...(typeof progress === 'number' && { mb: 1 })\n          }}\n        >\n          {message}\n        </Typography>\n      )}\n\n      {typeof progress === 'number' && (\n        <Typography variant=\"body2\" color=\"textSecondary\">\n          {Math.round(progress)}%\n        </Typography>\n      )}\n    </Box>\n  );\n\n  if (fullscreen || overlay) {\n    return content;\n  }\n\n  return (\n    <Paper\n      elevation={0}\n      sx={{\n        height,\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        bgcolor: 'transparent'\n      }}\n    >\n      {content}\n    </Paper>\n  );\n};\n\nLoadingIndicator.propTypes = {\n  message: PropTypes.string,\n  progress: PropTypes.number,\n  variant: PropTypes.oneOf(['circular', 'linear']),\n  fullscreen: PropTypes.bool,\n  overlay: PropTypes.bool,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\n\nexport const LoadingOverlay = (props) => (\n  <LoadingIndicator {...props} overlay />\n);\n\nexport const FullscreenLoading = (props) => (\n  <LoadingIndicator {...props} fullscreen />\n);\n\nexport default LoadingIndicator;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles"
        ],
        "exports": [
          "LoadingOverlay",
          "FullscreenLoading",
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles"
        ]
      },
      {
        "path": "components/common/LoadingSpinner.js",
        "content": "// src/components/common/LoadingSpinner.js\n\nimport React from 'react';\nimport { Box, CircularProgress, Typography, useTheme, keyframes } from '@mui/material';\n\nconst fadeIn = keyframes`\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n`;\n\nconst pulse = keyframes`\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.7;\n  }\n  100% {\n    opacity: 1;\n  }\n`;\n\nconst LoadingSpinner = () => {\n  const theme = useTheme();\n\n  return (\n    <Box\n      sx={{\n        display: 'flex',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        alignItems: 'center',\n        height: '100vh',\n        backgroundColor: theme.palette.background.default,\n        p: 2,\n        animation: `${fadeIn} 0.3s ease-in`,\n        transition: theme.transitions.create(['background-color'], {\n          duration: theme.transitions.duration.standard,\n        }),\n      }}\n    >\n      <CircularProgress \n        size={60} \n        thickness={4}\n        sx={{\n          color: theme.palette.primary.main,\n          '& .MuiCircularProgress-circle': {\n            strokeLinecap: 'round',\n            transition: theme.transitions.create(['color'], {\n              duration: theme.transitions.duration.standard,\n            }),\n          },\n        }} \n      />\n      <Typography \n        variant=\"h6\" \n        sx={{ \n          mt: 2,\n          color: theme.palette.text.primary,\n          fontWeight: 500,\n          animation: `${pulse} 2s ease-in-out infinite`,\n          transition: theme.transitions.create(['color'], {\n            duration: theme.transitions.duration.standard,\n          }),\n          textAlign: 'center',\n          [theme.breakpoints.down('sm')]: {\n            fontSize: '1rem',\n          },\n        }}\n      >\n        Loading, please wait...\n      </Typography>\n      <Typography \n        variant=\"body2\" \n        sx={{ \n          mt: 1,\n          color: theme.palette.text.secondary,\n          opacity: 0.8,\n          transition: theme.transitions.create(['color'], {\n            duration: theme.transitions.duration.standard,\n          }),\n          textAlign: 'center',\n        }}\n      >\n        Preparing your analysis dashboard\n      </Typography>\n    </Box>\n  );\n};\n\nexport default LoadingSpinner;\n",
        "imports": [
          "react",
          "@mui/material"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material"
        ]
      },
      {
        "path": "components/common/MethodologyLink.js",
        "content": "// src/components/common/MethodologyLink.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { \n  Button, \n  IconButton, \n  Tooltip, \n  Dialog, \n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  useTheme,\n  useMediaQuery\n} from '@mui/material';\nimport { BookOpen, X } from 'lucide-react';\nimport { useMethodologyAccess } from '@/hooks';;\nimport MethodologySection from '../methodology/MethodologySection';\n\nconst MethodologyLink = ({ \n  componentType,\n  iconOnly = false,\n  tooltip = \"View Methodology\",\n  buttonText = \"Learn More\"\n}) => {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));\n  const { \n    activeSection,\n    isDialogOpen,\n    openMethodologySection,\n    closeMethodology \n  } = useMethodologyAccess();\n\n  if (iconOnly) {\n    return (\n      <>\n        <Tooltip title={tooltip}>\n          <IconButton\n            size=\"small\"\n            onClick={() => openMethodologySection(componentType)}\n            aria-label=\"View methodology\"\n          >\n            <BookOpen size={20} />\n          </IconButton>\n        </Tooltip>\n        <MethodologyDialog\n          open={isDialogOpen}\n          onClose={closeMethodology}\n          section={activeSection}\n          isMobile={isMobile}\n        />\n      </>\n    );\n  }\n\n  return (\n    <>\n      <Button\n        startIcon={<BookOpen size={20} />}\n        onClick={() => openMethodologySection(componentType)}\n        variant=\"outlined\"\n        size=\"small\"\n      >\n        {buttonText}\n      </Button>\n      <MethodologyDialog\n        open={isDialogOpen}\n        onClose={closeMethodology}\n        section={activeSection}\n        isMobile={isMobile}\n      />\n    </>\n  );\n};\n\nconst MethodologyDialog = ({ open, onClose, section, isMobile }) => {\n  return (\n    <Dialog\n      open={open}\n      onClose={onClose}\n      maxWidth=\"md\"\n      fullWidth\n      fullScreen={isMobile}\n    >\n      <DialogTitle sx={{ \n        display: 'flex', \n        justifyContent: 'space-between',\n        alignItems: 'center'\n      }}>\n        {section?.title || 'Methodology'}\n        <IconButton\n          aria-label=\"close\"\n          onClick={onClose}\n          size=\"small\"\n        >\n          <X size={20} />\n        </IconButton>\n      </DialogTitle>\n      <DialogContent dividers>\n        {section && <MethodologySection section={section} level={1} />}\n      </DialogContent>\n      <DialogActions>\n        <Button onClick={onClose}>Close</Button>\n      </DialogActions>\n    </Dialog>\n  );\n};\n\nMethodologyDialog.propTypes = {\n  open: PropTypes.bool.isRequired,\n  onClose: PropTypes.func.isRequired,\n  section: PropTypes.object,\n  isMobile: PropTypes.bool.isRequired,\n};\n\nMethodologyLink.propTypes = {\n  componentType: PropTypes.string.isRequired,\n  iconOnly: PropTypes.bool,\n  tooltip: PropTypes.string,\n  buttonText: PropTypes.string,\n};\n\nexport default MethodologyLink;",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "lucide-react",
          "@/hooks",
          "../methodology/MethodologySection"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "lucide-react",
          "@/hooks",
          "../methodology/MethodologySection"
        ]
      },
      {
        "path": "components/common/Navigation.js",
        "content": "// src/components/common/Navigation.js\n\nimport React, { useCallback, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport PropTypes from 'prop-types';\nimport { \n  Drawer, Box, Toolbar, Divider, Button, Stack,\n  useTheme, useMediaQuery, FormControl, InputLabel,\n  Select, MenuItem, Checkbox, ListItemText, Typography,\n  List, ListItemIcon, ListItem, ListItemButton,\n  FormHelperText,\n  alpha,\n} from '@mui/material';\nimport InfoIcon from '@mui/icons-material/Info';\nimport _ from 'lodash';\nimport { fetchSpatialData, selectSpatialData } from '../../slices/spatialSlice';\nimport { useDashboardData } from '../../hooks/useDashboardData';\nimport { fetchAllSpatialData } from '../../slices/spatialSlice';\n\nconst capitalizeWords = (str) => {\n  return str\n    .split(/[_\\s]+/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(' ');\n};\n\nconst drawerWidth = 240;\n\nconst NavigationItem = ({ onClick = () => {}, selected = false, children }) => {\n  const theme = useTheme();\n  return (\n    <ListItem disablePadding>\n      <ListItemButton \n        onClick={onClick} \n        selected={selected}\n        sx={{\n          '&.Mui-selected': {\n            backgroundColor: alpha(theme.palette.primary.main, 0.1),\n            color: theme.palette.primary.main,\n            '&:hover': {\n              backgroundColor: alpha(theme.palette.primary.main, 0.2),\n            },\n          },\n        }}\n      >\n        {children}\n      </ListItemButton>\n    </ListItem>\n  );\n};\n\nNavigationItem.propTypes = {\n  onClick: PropTypes.func,\n  selected: PropTypes.bool,\n  children: PropTypes.node.isRequired,\n};\n\nconst useLoadingState = () => useSelector(\n  state => state.spatial?.status?.dataFetching ?? false,\n  _.isEqual\n);\n\nconst useUniqueMonths = () => useSelector(\n  state => state.spatial?.data?.uniqueMonths ?? [],\n  _.isEqual\n);\n\nconst useSpatialDataMemo = () => useSelector(\n  state => {\n    const data = state.spatial?.data || {};\n    return {\n      geoData: data.geometry || {},\n      flows: data.flowMaps || [],\n      analysis: data.spatialAnalysis || {},\n      uniqueMonths: data.uniqueMonths || []\n    };\n  },\n  _.isEqual\n);\n\nexport const CommoditySelector = React.memo(({ \n  commodities = [], \n  selectedCommodity = '', \n  onSelectCommodity \n}) => {\n  const dispatch = useDispatch();\n  const { data, loading, fetchData } = useDashboardData();\n  const lastSelectionRef = useRef(selectedCommodity);\n  const theme = useTheme();\n\n  const handleCommoditySelect = useCallback(async (event) => {\n    const newCommodity = event.target.value;\n    \n    if (newCommodity === lastSelectionRef.current) return;\n    lastSelectionRef.current = newCommodity;\n\n    try {\n      dispatch({ \n        type: 'spatial/setSelectedCommodity', \n        payload: newCommodity \n      });\n      \n      await Promise.all([\n        dispatch(fetchAllSpatialData({ \n          commodity: newCommodity,\n          date: \"2020-10-01\"\n        })),\n        onSelectCommodity(newCommodity)\n      ]);\n    } catch (error) {\n      console.error('Error selecting commodity:', error);\n    }\n  }, [dispatch, fetchData, onSelectCommodity]);\n\n  return (\n    <FormControl \n      fullWidth \n      variant=\"outlined\" \n      size=\"small\" \n      margin=\"normal\"\n      disabled={loading}\n    >\n      <InputLabel \n        id=\"commodity-select-label\"\n        sx={{\n          color: theme.palette.text.primary,\n          '&.Mui-focused': {\n            color: theme.palette.primary.main,\n          },\n        }}\n      >\n        Select Commodity {loading ? '(Loading...)' : ''}\n      </InputLabel>\n      <Select\n        labelId=\"commodity-select-label\"\n        id=\"commodity-select\"\n        value={selectedCommodity}\n        onChange={handleCommoditySelect}\n        label={`Select Commodity ${loading ? '(Loading...)' : ''}`}\n        sx={{\n          '& .MuiSelect-select': {\n            color: theme.palette.text.primary,\n          },\n          '& .MuiOutlinedInput-notchedOutline': {\n            borderColor: theme.palette.divider,\n          },\n          '&:hover .MuiOutlinedInput-notchedOutline': {\n            borderColor: theme.palette.primary.main,\n          },\n          '&.Mui-focused .MuiOutlinedInput-notchedOutline': {\n            borderColor: theme.palette.primary.main,\n          },\n        }}\n      >\n        {commodities.map(commodity => (\n          <MenuItem \n            key={commodity} \n            value={commodity}\n            sx={{\n              color: theme.palette.text.primary,\n              '&:hover': {\n                backgroundColor: alpha(theme.palette.primary.main, 0.08),\n              },\n              '&.Mui-selected': {\n                backgroundColor: alpha(theme.palette.primary.main, 0.12),\n                color: theme.palette.primary.main,\n                '&:hover': {\n                  backgroundColor: alpha(theme.palette.primary.main, 0.16),\n                },\n              },\n            }}\n          >\n            {capitalizeWords(commodity)}\n          </MenuItem>\n        ))}\n      </Select>\n    </FormControl>\n  );\n});\n\nCommoditySelector.displayName = 'CommoditySelector';\n\nconst RegimeSelector = ({ regimes, selectedRegimes, onSelectRegimes }) => {\n  const theme = useTheme();\n  const ITEM_HEIGHT = 48;\n  const ITEM_PADDING_TOP = 8;\n  const MenuProps = {\n    PaperProps: {\n      style: {\n        maxHeight: ITEM_HEIGHT * 4.5 + ITEM_PADDING_TOP,\n        width: 250,\n        backgroundColor: theme.palette.background.paper,\n      },\n    },\n  };\n\n  return (\n    <FormControl fullWidth variant=\"outlined\" size=\"small\" margin=\"normal\">\n      <InputLabel \n        id=\"regime-select-label\"\n        sx={{\n          color: theme.palette.text.primary,\n          '&.Mui-focused': {\n            color: theme.palette.primary.main,\n          },\n        }}\n      >\n        Select Regimes\n      </InputLabel>\n      <Select\n        labelId=\"regime-select-label\"\n        id=\"regime-select\"\n        name=\"regimes\"\n        multiple\n        value={selectedRegimes}\n        onChange={(e) => onSelectRegimes(e.target.value)}\n        label=\"Select Regimes\"\n        aria-label=\"Select regimes\"\n        renderValue={(selected) => selected.map((regime) => capitalizeWords(regime)).join(', ')}\n        MenuProps={MenuProps}\n        sx={{\n          '& .MuiSelect-select': {\n            color: theme.palette.text.primary,\n          },\n          '& .MuiOutlinedInput-notchedOutline': {\n            borderColor: theme.palette.divider,\n          },\n          '&:hover .MuiOutlinedInput-notchedOutline': {\n            borderColor: theme.palette.primary.main,\n          },\n          '&.Mui-focused .MuiOutlinedInput-notchedOutline': {\n            borderColor: theme.palette.primary.main,\n          },\n        }}\n      >\n        {regimes.map((regime) => (\n          <MenuItem \n            key={regime} \n            value={regime}\n            sx={{\n              color: theme.palette.text.primary,\n              '&:hover': {\n                backgroundColor: alpha(theme.palette.primary.main, 0.08),\n              },\n              '&.Mui-selected': {\n                backgroundColor: alpha(theme.palette.primary.main, 0.12),\n                color: theme.palette.primary.main,\n                '&:hover': {\n                  backgroundColor: alpha(theme.palette.primary.main, 0.16),\n                },\n              },\n            }}\n          >\n            <Checkbox \n              checked={selectedRegimes.indexOf(regime) > -1}\n              sx={{\n                color: theme.palette.text.secondary,\n                '&.Mui-checked': {\n                  color: theme.palette.primary.main,\n                },\n              }}\n            />\n            <ListItemText \n              primary={capitalizeWords(regime)}\n              sx={{\n                '& .MuiTypography-root': {\n                  color: theme.palette.text.primary,\n                },\n              }}\n            />\n          </MenuItem>\n        ))}\n      </Select>\n    </FormControl>\n  );\n};\n\nRegimeSelector.propTypes = {\n  regimes: PropTypes.arrayOf(PropTypes.string).isRequired,\n  selectedRegimes: PropTypes.arrayOf(PropTypes.string).isRequired,\n  onSelectRegimes: PropTypes.func.isRequired,\n};\n\nexport const Sidebar = ({\n  commodities = [],\n  regimes = [],\n  selectedCommodity = '',\n  setSelectedCommodity,\n  selectedAnalysis = 'spatial',\n  setSelectedAnalysis,\n  sidebarOpen,\n  setSidebarOpen,\n  onMethodologyClick,\n  selectedRegimes,\n  setSelectedRegimes,\n  onOpenWelcomeModal,\n  handleDrawerToggle,\n}) => {\n  const theme = useTheme();\n  const isSmUp = useMediaQuery(theme.breakpoints.up('sm'));\n  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));\n  const dispatch = useDispatch();\n  const { geoData, flows, analysis, uniqueMonths } = useSelector(selectSpatialData);\n\n  const handleCommodityChange = useCallback(async (newCommodity) => {\n    if (newCommodity && newCommodity !== selectedCommodity) {\n      try {\n        await dispatch(fetchAllSpatialData({ \n          commodity: newCommodity, \n          date: \"2020-10-01\" \n        }));\n        \n        setSelectedCommodity(newCommodity);\n        \n        if (!isSmUp) {\n          setSidebarOpen(false);\n        }\n      } catch (error) {\n        console.error('Error changing commodity:', error);\n      }\n    }\n  }, [dispatch, selectedCommodity, isSmUp, setSelectedCommodity, setSidebarOpen]);\n\n  const handleAnalysisChange = useCallback(\n    (analysisType) => {\n      setSelectedAnalysis(analysisType);\n      if (!isSmUp) {\n        setSidebarOpen(false);\n      }\n\n      if (analysisType === 'spatial' && selectedCommodity) {\n        dispatch(\n          fetchSpatialData({\n            selectedCommodity,\n            selectedDate: uniqueMonths[0],\n          })\n        );\n      }\n    },\n    [setSelectedAnalysis, isSmUp, setSidebarOpen, dispatch, selectedCommodity, uniqueMonths]\n  );\n\n  const handleRegimesSelect = useCallback(\n    (regimesSelected) => {\n      setSelectedRegimes(regimesSelected);\n    },\n    [setSelectedRegimes]\n  );\n\n  const buttonSx = {\n    color: theme.palette.text.primary,\n    borderColor: theme.palette.divider,\n    '&:hover': {\n      borderColor: theme.palette.primary.main,\n      backgroundColor: alpha(theme.palette.primary.main, 0.08),\n    },\n    '&.MuiButton-contained': {\n      backgroundColor: theme.palette.primary.main,\n      color: theme.palette.primary.contrastText,\n      '&:hover': {\n        backgroundColor: theme.palette.primary.dark,\n      },\n    },\n    '&.MuiButton-outlined': {\n      borderColor: theme.palette.divider,\n      '&:hover': {\n        borderColor: theme.palette.primary.main,\n        backgroundColor: alpha(theme.palette.primary.main, 0.08),\n      },\n    },\n  };\n\n  const sidebarContent = useMemo(\n    () => (\n      <Box \n        sx={{ \n          p: 2,\n          backgroundColor: theme.palette.background.paper,\n          height: '100%',\n        }}\n      >\n        <Stack spacing={3}>\n          <CommoditySelector\n            commodities={commodities}\n            selectedCommodity={selectedCommodity}\n            onSelectCommodity={handleCommodityChange}\n          />\n\n          <RegimeSelector\n            regimes={regimes}\n            selectedRegimes={selectedRegimes}\n            onSelectRegimes={handleRegimesSelect}\n          />\n\n          <Stack spacing={2}>\n            <Button\n              variant={selectedAnalysis === 'spatial' ? 'contained' : 'outlined'}\n              color=\"primary\"\n              fullWidth\n              onClick={() => handleAnalysisChange('spatial')}\n              sx={buttonSx}\n            >\n              Spatial Analysis\n            </Button>\n            <Button\n              variant={selectedAnalysis === 'ecm' ? 'contained' : 'outlined'}\n              color=\"primary\"\n              fullWidth\n              onClick={() => handleAnalysisChange('ecm')}\n              sx={buttonSx}\n            >\n              ECM Model\n            </Button>\n            <Button\n              variant={selectedAnalysis === 'priceDiff' ? 'contained' : 'outlined'}\n              color=\"primary\"\n              fullWidth\n              onClick={() => handleAnalysisChange('priceDiff')}\n              sx={buttonSx}\n            >\n              Price Differential Model\n            </Button>\n            <Button\n              variant={selectedAnalysis === 'spatial_model' ? 'contained' : 'outlined'}\n              color=\"primary\"\n              fullWidth\n              onClick={() => handleAnalysisChange('spatial_model')}\n              sx={buttonSx}\n            >\n              Spatial Model\n            </Button>\n            <Button\n              variant={selectedAnalysis === 'tvmii' ? 'contained' : 'outlined'}\n              color=\"primary\"\n              fullWidth\n              onClick={() => handleAnalysisChange('tvmii')}\n              sx={buttonSx}\n            >\n              TV-MII Index\n            </Button>\n          </Stack>\n\n          <Button\n            variant=\"contained\"\n            sx={{ \n              backgroundColor: theme.palette.error.main,\n              color: '#ffffff',\n              '&:hover': {\n                backgroundColor: theme.palette.error.dark,\n              },\n            }}\n            fullWidth\n            onClick={onMethodologyClick}\n            startIcon={<InfoIcon />}\n          >\n            Methodology\n          </Button>\n\n          <Button\n            variant=\"contained\"\n            sx={{ \n              backgroundColor: theme.palette.success.main,\n              color: '#ffffff',\n              '&:hover': {\n                backgroundColor: theme.palette.success.dark,\n              },\n            }}\n            fullWidth\n            onClick={onOpenWelcomeModal}\n            startIcon={<InfoIcon />}\n          >\n            How to Use\n          </Button>\n        </Stack>\n      </Box>\n    ),\n    [\n      theme,\n      commodities,\n      selectedCommodity,\n      regimes,\n      selectedRegimes,\n      handleRegimesSelect,\n      selectedAnalysis,\n      handleAnalysisChange,\n      onMethodologyClick,\n      onOpenWelcomeModal,\n      buttonSx,\n    ]\n  );\n\n  return (\n    <Drawer\n      variant={isMobile ? 'temporary' : 'persistent'}\n      open={sidebarOpen}\n      onClose={handleDrawerToggle}\n      ModalProps={{\n        keepMounted: true,\n      }}\n      sx={{\n        '& .MuiDrawer-paper': {\n          width: drawerWidth,\n          boxSizing: 'border-box',\n          backgroundColor: theme.palette.background.paper,\n          borderRight: `1px solid ${theme.palette.divider}`,\n          [theme.breakpoints.down('sm')]: {\n            top: '56px',\n            height: 'calc(100% - 56px)',\n          },\n        },\n      }}\n    >\n      <Toolbar />\n      <Divider sx={{ borderColor: theme.palette.divider }} />\n      {sidebarContent}\n    </Drawer>\n  );\n};\n\nSidebar.propTypes = {\n  commodities: PropTypes.arrayOf(PropTypes.string).isRequired,\n  regimes: PropTypes.arrayOf(PropTypes.string).isRequired,\n  selectedCommodity: PropTypes.string.isRequired,\n  setSelectedCommodity: PropTypes.func.isRequired,\n  selectedAnalysis: PropTypes.string.isRequired,\n  setSelectedAnalysis: PropTypes.func.isRequired,\n  sidebarOpen: PropTypes.bool.isRequired,\n  setSidebarOpen: PropTypes.func.isRequired,\n  onMethodologyClick: PropTypes.func.isRequired,\n  selectedRegimes: PropTypes.arrayOf(PropTypes.string).isRequired,\n  setSelectedRegimes: PropTypes.func.isRequired,\n  onOpenWelcomeModal: PropTypes.func.isRequired,\n  handleDrawerToggle: PropTypes.func.isRequired,\n};\n",
        "imports": [
          "react",
          "react-redux",
          "prop-types",
          "@mui/material",
          "@mui/icons-material/Info",
          "lodash",
          "../../slices/spatialSlice",
          "../../hooks/useDashboardData",
          "../../slices/spatialSlice"
        ],
        "exports": [
          "CommoditySelector",
          "Sidebar"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "prop-types",
          "@mui/material",
          "@mui/icons-material/Info",
          "lodash",
          "../../slices/spatialSlice",
          "../../hooks/useDashboardData"
        ]
      },
      {
        "path": "components/common/WelcomeModal.js",
        "content": "// src/components/WelcomeModal.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogContentText,\n  DialogActions,\n  Button,\n  Typography,\n  List,\n  ListItem,\n  ListItemText,\n  Checkbox,\n  FormControlLabel,\n  useMediaQuery,\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\n\nexport const WelcomeModal = React.memo(({ open, onClose }) => {\n  const [dontShowAgain, setDontShowAgain] = React.useState(false);\n  const theme = useTheme();\n  const fullScreen = useMediaQuery(theme.breakpoints.down('sm'));\n\n  const handleCheckboxChange = (event) => {\n    setDontShowAgain(event.target.checked);\n  };\n\n  const handleGetStarted = () => {\n    onClose(dontShowAgain);\n  };\n\n  return (\n    <Dialog\n      open={open}\n      onClose={handleGetStarted}\n      fullWidth\n      maxWidth=\"md\"\n      fullScreen={fullScreen}\n      aria-labelledby=\"welcome-modal-title\"\n      aria-describedby=\"welcome-modal-description\"\n    >\n      <DialogTitle id=\"welcome-modal-title\">\n        Welcome to the Commodity and Conflict Analysis Dashboard\n      </DialogTitle>\n      <DialogContent dividers>\n        <DialogContentText id=\"welcome-modal-description\" component=\"div\">\n          <Typography variant=\"body1\" gutterBottom>\n            This dashboard allows you to explore the relationship between commodity prices and conflict intensity through interactive analyses and visualizations.\n          </Typography>\n          <Typography variant=\"h6\" gutterBottom sx={{ mt: 2 }}>\n            How to Use the Dashboard:\n          </Typography>\n          <List>\n            <ListItem>\n              <ListItemText\n                primary={\n                  <>\n                    <strong>Select a Commodity:</strong> Use the dropdown menu in the sidebar to choose a commodity you're interested in analyzing.\n                  </>\n                }\n              />\n            </ListItem>\n            <ListItem>\n              <ListItemText\n                primary={\n                  <>\n                    <strong>Navigate Analyses:</strong> Explore different analyses such as Error Correction Model (ECM) and Price Differential Analysis using the buttons in the sidebar.\n                  </>\n                }\n              />\n            </ListItem>\n            <ListItem>\n              <ListItemText\n                primary={\n                  <>\n                    <strong>Interactive Charts:</strong> Hover over charts to see detailed information, and use the provided controls to customize your view.\n                  </>\n                }\n              />\n            </ListItem>\n            <ListItem>\n              <ListItemText\n                primary={\n                  <>\n                    <strong>Access Tutorials:</strong> Click on the \"Tutorials\" button in the sidebar to learn more about the methods used.\n                  </>\n                }\n              />\n            </ListItem>\n          </List>\n          <Typography variant=\"body1\" gutterBottom sx={{ mt: 2 }}>\n            We hope this dashboard provides valuable insights into commodity markets and conflict dynamics. If you have any questions or feedback, feel free to contact us.\n          </Typography>\n        </DialogContentText>\n      </DialogContent>\n      <DialogActions>\n        <FormControlLabel\n          control={\n            <Checkbox\n              checked={dontShowAgain}\n              onChange={handleCheckboxChange}\n              color=\"primary\"\n            />\n          }\n          label=\"Don't show this again\"\n        />\n        <Button onClick={handleGetStarted} variant=\"contained\" color=\"primary\" aria-label=\"Close Welcome Modal\">\n          Get Started\n        </Button>\n      </DialogActions>\n    </Dialog>\n  );\n});\n\nWelcomeModal.displayName = 'WelcomeModal';\n\nWelcomeModal.propTypes = {\n  open: PropTypes.bool.isRequired,\n  onClose: PropTypes.func.isRequired,\n};",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles"
        ],
        "exports": [
          "WelcomeModal"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles"
        ]
      },
      {
        "path": "components/documentation/TechnicalReference.js",
        "content": "// src/components/documentation/TechnicalReference.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { \n  Paper, \n  Box, \n  Typography, \n  Divider,\n  Card,\n  CardContent,\n} from '@mui/material';\nimport { useTechnicalHelp } from '@/hooks';;\nimport EquationWithHelp from '../common/EquationWithHelp';\nimport TechnicalTooltip from '../common/TechnicalTooltip';\nimport MethodologyLink from '../common/MethodologyLink';\n\nconst TechnicalReference = ({ componentType }) => {\n  const { \n    getTechnicalTooltip, \n    getTechnicalEquation, \n    getTechnicalConcept,\n    getMethodology \n  } = useTechnicalHelp(componentType);\n\n  const methodology = getMethodology();\n  const mainEquation = getTechnicalEquation('main');\n\n  return (\n    <Paper sx={{ p: 3 }}>\n      <Box sx={{ \n        display: 'flex', \n        alignItems: 'center', \n        justifyContent: 'space-between',\n        mb: 2 \n      }}>\n        <Typography variant=\"h6\">\n          Technical Reference\n        </Typography>\n        <MethodologyLink componentType={componentType} iconOnly />\n      </Box>\n\n      {mainEquation && (\n        <Box sx={{ mb: 3 }}>\n          <Typography variant=\"subtitle1\" gutterBottom>\n            Model Specification\n          </Typography>\n          <EquationWithHelp\n            latex={mainEquation.latex}\n            description={mainEquation.description}\n            variables={mainEquation.variables}\n            title=\"Main Equation\"\n            componentType={componentType}\n          />\n        </Box>\n      )}\n\n      <Divider sx={{ my: 3 }} />\n\n      <Box sx={{ mb: 3 }}>\n        <Typography variant=\"subtitle1\" gutterBottom>\n          Key Concepts\n        </Typography>\n        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2 }}>\n          {Object.entries(getTechnicalEquation('concepts') || {}).map(([key, concept]) => (\n            <Card key={key} sx={{ minWidth: 200, flex: 1 }}>\n              <CardContent>\n                <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>\n                  <Typography variant=\"subtitle2\" sx={{ flex: 1 }}>\n                    {key}\n                  </Typography>\n                  <TechnicalTooltip\n                    componentType={componentType}\n                    element={key}\n                    tooltipContent={getTechnicalTooltip(key)}\n                  />\n                </Box>\n                <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mt: 1 }}>\n                  {concept}\n                </Typography>\n              </CardContent>\n            </Card>\n          ))}\n        </Box>\n      </Box>\n\n      {methodology && (\n        <Box sx={{ mt: 3 }}>\n          <Typography variant=\"subtitle1\" gutterBottom>\n            Further Reading\n          </Typography>\n          <Typography variant=\"body2\" color=\"text.secondary\">\n            For more detailed information, view the full methodology section.\n          </Typography>\n        </Box>\n      )}\n    </Paper>\n  );\n};\n\nTechnicalReference.propTypes = {\n  componentType: PropTypes.string.isRequired,\n};\n\nexport default TechnicalReference;",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@/hooks",
          "../common/EquationWithHelp",
          "../common/TechnicalTooltip",
          "../common/MethodologyLink"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@/hooks",
          "../common/EquationWithHelp",
          "../common/TechnicalTooltip",
          "../common/MethodologyLink"
        ]
      },
      {
        "path": "components/interactive_graph/InteractiveChart.js",
        "content": "// src/components/interactive_graph/InteractiveChart.js\nimport React, { useMemo, useState } from 'react';\nimport { Line } from 'react-chartjs-2';\nimport {\n  Chart as ChartJS,\n  CategoryScale,\n  LinearScale,\n  PointElement,\n  LineElement,\n  Title as ChartTitle,\n  Tooltip as ChartTooltip,\n  Legend,\n  TimeScale,\n  Filler,\n} from 'chart.js';\nimport 'chartjs-adapter-date-fns';\nimport PropTypes from 'prop-types';\nimport { useTheme, alpha } from '@mui/material/styles';\nimport {\n  Box,\n  Paper,\n  ToggleButtonGroup,\n  ToggleButton,\n  Grid,\n  Typography,\n} from '@mui/material';\nimport {\n  applySeasonalAdjustment,\n  applySmoothing,\n} from '../../utils/appUtils';\nimport { useWindowWidth } from '../../hooks/useWindowWidth'; // Import the hook\n\nconst capitalizeWords = (str) => {\n  return str.replace(/\\b\\w/g, (char) => char.toUpperCase());\n};\n\nChartJS.register(\n  CategoryScale,\n  LinearScale,\n  PointElement,\n  LineElement,\n  ChartTitle,\n  ChartTooltip,\n  Legend,\n  TimeScale,\n  Filler\n);\n\nconst InteractiveChart = ({ data, selectedCommodity, selectedRegimes }) => {\n  const theme = useTheme();\n  const windowWidth = useWindowWidth(); // Get current window width\n\n  // Determine if the device is mobile based on window width\n  const isMobile = windowWidth < 600; // Adjust the breakpoint as needed\n\n  const [showConflictIntensity, setShowConflictIntensity] = useState(true);\n  const [priceType, setPriceType] = useState('lcu');\n  const [applySeasonalAdj, setApplySeasonalAdj] = useState(false);\n  const [applySmooth, setApplySmooth] = useState(false);\n\n  const chartData = useMemo(() => {\n    if (!data || !selectedCommodity || selectedRegimes.length === 0)\n      return null;\n\n    const dataByRegime = selectedRegimes.map((regime) => ({\n      regime,\n      data: data.filter(\n        (d) =>\n          d.commodity.toLowerCase() === selectedCommodity.toLowerCase() &&\n          d.regime.toLowerCase() === regime.toLowerCase()\n      ),\n    }));\n\n    const validDataByRegime = dataByRegime.filter(\n      (regimeData) => regimeData.data.length > 0\n    );\n\n    if (validDataByRegime.length === 0) return null;\n\n    const datasets = [];\n\n    validDataByRegime.forEach((regimeData, index) => {\n      const primaryColors = [\n        theme.palette.primary.main,\n        theme.palette.secondary.main,\n        theme.palette.success.main,\n        theme.palette.warning.main,\n        theme.palette.error.main,\n        theme.palette.info.main,\n      ];\n\n      const color = primaryColors[index % primaryColors.length];\n\n      let processedData = regimeData.data;\n\n      if (applySeasonalAdj) {\n        processedData = applySeasonalAdjustment(\n          processedData,\n          [regimeData.regime],\n          12,\n          priceType === 'lcu'\n        );\n      }\n\n      if (applySmooth) {\n        processedData = applySmoothing(\n          processedData,\n          [regimeData.regime],\n          6,\n          priceType === 'lcu'\n        );\n      }\n\n      // Price Dataset\n      datasets.push({\n        label: `${capitalizeWords(regimeData.regime)} Price`,\n        data: processedData.map((d) => ({\n          x: new Date(d.date),\n          y: priceType === 'lcu' ? d.price : d.usdprice,\n        })),\n        borderColor: color,\n        backgroundColor: alpha(color, 0.2),\n        yAxisID: 'y',\n        fill: true,\n        tension: 0.3,\n        pointRadius: 3,\n        pointHoverRadius: 5,\n      });\n\n      // Conflict Intensity Dataset\n      if (showConflictIntensity) {\n        const conflictColor = theme.palette.info.main;\n        const conflictColorTransparent = alpha(conflictColor, 0.2);\n\n        datasets.push({\n          label: `${capitalizeWords(regimeData.regime)} Conflict Intensity`,\n          data: processedData.map((d) => ({\n            x: new Date(d.date),\n            y: d.conflict_intensity,\n          })),\n          borderColor: conflictColorTransparent,\n          backgroundColor: conflictColorTransparent,\n          yAxisID: 'y1',\n          fill: 'origin',\n          tension: 0.3,\n          pointRadius: 0,\n          borderWidth: 0,\n        });\n      }\n    });\n\n    return {\n      datasets,\n    };\n  }, [\n    data,\n    selectedCommodity,\n    selectedRegimes,\n    priceType,\n    showConflictIntensity,\n    applySeasonalAdj,\n    applySmooth,\n    theme.palette,\n  ]);\n\n  const options = useMemo(\n    () => ({\n      responsive: true,\n      maintainAspectRatio: false,\n      interaction: {\n        mode: 'index',\n        intersect: false,\n      },\n      scales: {\n        x: {\n          type: 'time',\n          time: {\n            unit: isMobile ? 'month' : 'quarter', // Adjust time unit based on screen size\n          },\n          grid: {\n            display: true,\n            drawBorder: false,\n            color: alpha(theme.palette.divider, 0.2),\n            lineWidth: 1,\n            drawTicks: false,\n          },\n          border: {\n            display: false,\n          },\n          ticks: {\n            maxTicksLimit: isMobile ? 5 : 10,\n            color: theme.palette.text.primary,\n            font: {\n              size: isMobile ? 10 : 11, // Adjust font size\n              family: theme.typography.fontFamily,\n            },\n            padding: 8,\n          },\n          title: {\n            display: true,\n            text: 'Analysis Period',\n            color: theme.palette.text.primary,\n            font: {\n              size: isMobile ? 10 : 11, // Adjust font size\n              family: theme.typography.fontFamily,\n            },\n            padding: { top: 5 },\n          },\n        },\n        y: {\n          type: 'linear',\n          display: true,\n          position: 'left',\n          grid: {\n            display: true,\n            drawBorder: false,\n            color: alpha(theme.palette.divider, 0.2),\n            lineWidth: 1,\n            drawTicks: false,\n          },\n          border: {\n            display: false,\n          },\n          ticks: {\n            color: theme.palette.text.primary,\n            font: {\n              size: isMobile ? 10 : 11, // Adjust font size\n              family: theme.typography.fontFamily,\n            },\n            padding: 8,\n          },\n          title: {\n            display: true,\n            text: priceType === 'lcu' ? 'Price (LCU)' : 'Price (US$)',\n            color: theme.palette.text.primary,\n            font: {\n              size: isMobile ? 10 : 11, // Adjust font size\n              family: theme.typography.fontFamily,\n            },\n            padding: { bottom: 5 },\n          },\n        },\n        y1: {\n          type: 'linear',\n          display: showConflictIntensity,\n          position: 'right',\n          grid: {\n            drawOnChartArea: false,\n            color: alpha(theme.palette.divider, 0.2),\n            lineWidth: 1,\n            drawTicks: false,\n          },\n          border: {\n            display: false,\n          },\n          ticks: {\n            color: theme.palette.text.primary,\n            font: {\n              size: isMobile ? 10 : 11, // Adjust font size\n              family: theme.typography.fontFamily,\n            },\n            padding: 8,\n          },\n          title: {\n            display: true,\n            text: 'Conflict Intensity',\n            color: theme.palette.text.primary,\n            font: {\n              size: isMobile ? 10 : 11, // Adjust font size\n              family: theme.typography.fontFamily,\n            },\n            padding: { bottom: 5 },\n          },\n        },\n      },\n      plugins: {\n        tooltip: {\n          mode: 'index',\n          intersect: false,\n          backgroundColor: theme.palette.background.paper,\n          titleColor: theme.palette.text.primary,\n          bodyColor: theme.palette.text.secondary,\n          borderColor: theme.palette.divider,\n          borderWidth: 1,\n          padding: 8,\n          bodyFont: {\n            size: isMobile ? 10 : 11, // Adjust font size\n            family: theme.typography.fontFamily,\n          },\n          titleFont: {\n            size: isMobile ? 10 : 11, // Adjust font size\n            family: theme.typography.fontFamily,\n            weight: 'bold',\n          },\n          callbacks: {\n            title: (context) => {\n              const date = new Date(context[0].parsed.x);\n              return date.toLocaleDateString();\n            },\n            label: (context) => {\n              let label = `${context.dataset.label}: `;\n              label += context.parsed.y.toLocaleString();\n              return label;\n            },\n          },\n        },\n        legend: {\n          position: isMobile ? 'top' : 'bottom', // Change legend position\n          align: 'start',\n          labels: {\n            color: theme.palette.text.primary,\n            font: {\n              size: isMobile ? 10 : 11, // Adjust font size\n              family: theme.typography.fontFamily,\n            },\n            padding: 8,\n            boxWidth: 8,\n            usePointStyle: true,\n          },\n          display: true,\n          maxHeight: 40,\n        },\n      },\n    }),\n    [showConflictIntensity, priceType, theme, isMobile]\n  );\n\n  // Updated toggleButtonSx with responsive adjustments\n  const toggleButtonSx = {\n    minWidth: 'auto',\n    backgroundColor: theme.palette.background.default,\n    borderRadius: 1,\n    '& .MuiToggleButton-root': {\n      fontWeight: 600,\n      fontSize: isMobile ? '0.7rem' : '0.9rem', // Reduced font size on mobile\n      padding: isMobile ? '4px 6px' : '6px 12px', // Reduced padding on mobile\n      margin: isMobile ? '2px' : '4px', // Added margin to prevent overlap\n      border: `1px solid ${theme.palette.divider}`,\n      color: theme.palette.text.primary,\n      '&.Mui-selected': {\n        backgroundColor: theme.palette.primary.main,\n        color: theme.palette.primary.contrastText,\n        '&:hover': {\n          backgroundColor: theme.palette.primary.dark,\n        },\n      },\n    },\n    // Enable wrapping on mobile to prevent overflow\n    flexWrap: isMobile ? 'wrap' : 'nowrap',\n  };\n\n  if (!chartData) {\n    return (\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Typography variant=\"body1\" color=\"text.secondary\">\n          Please select at least one regime and a commodity.\n        </Typography>\n      </Paper>\n    );\n  }\n\n  return (\n    <Box sx={{ width: '100%', mb: 3 }}>\n      {/* Controls */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Grid container spacing={2} alignItems=\"center\">\n          {/* Price Type ToggleButtonGroup */}\n          <Grid item xs={12} sm={6} md={3}>\n            <ToggleButtonGroup\n              value={priceType}\n              exclusive\n              onChange={(e, newValue) => {\n                if (newValue !== null) setPriceType(newValue);\n              }}\n              aria-label=\"Price Type\"\n              size=\"small\"\n              fullWidth\n              sx={toggleButtonSx}\n            >\n              <ToggleButton value=\"lcu\" aria-label=\"Price in LCU\">\n                LCU\n              </ToggleButton>\n              <ToggleButton value=\"usd\" aria-label=\"Price in US$\">\n                US$\n              </ToggleButton>\n            </ToggleButtonGroup>\n          </Grid>\n\n          {/* Seasonal Adjustment ToggleButtonGroup */}\n          <Grid item xs={12} sm={6} md={3}>\n            <ToggleButtonGroup\n              value={applySeasonalAdj}\n              exclusive\n              onChange={() => setApplySeasonalAdj(!applySeasonalAdj)}\n              aria-label=\"Seasonal Adjustment\"\n              size=\"small\"\n              fullWidth\n              sx={toggleButtonSx}\n            >\n              <ToggleButton value={true} selected={applySeasonalAdj}>\n                Seasonal Adj\n              </ToggleButton>\n            </ToggleButtonGroup>\n          </Grid>\n\n          {/* Smoothing ToggleButtonGroup */}\n          <Grid item xs={12} sm={6} md={3}>\n            <ToggleButtonGroup\n              value={applySmooth}\n              exclusive\n              onChange={() => setApplySmooth(!applySmooth)}\n              aria-label=\"Smoothing\"\n              size=\"small\"\n              fullWidth\n              sx={toggleButtonSx}\n            >\n              <ToggleButton value={true} selected={applySmooth}>\n                Smoothing\n              </ToggleButton>\n            </ToggleButtonGroup>\n          </Grid>\n\n          {/* Conflict Intensity ToggleButtonGroup */}\n          <Grid item xs={12} sm={6} md={3}>\n            <ToggleButtonGroup\n              value={showConflictIntensity}\n              exclusive\n              onChange={() => setShowConflictIntensity(!showConflictIntensity)}\n              aria-label=\"Conflict Intensity\"\n              size=\"small\"\n              fullWidth\n              sx={toggleButtonSx}\n            >\n              <ToggleButton value={true} selected={showConflictIntensity}>\n                Conflict Intensity\n              </ToggleButton>\n            </ToggleButtonGroup>\n          </Grid>\n        </Grid>\n      </Paper>\n\n      {/* Chart */}\n      <Box\n        sx={{\n          width: '100%',\n          height: windowWidth < 600 ? 200 : windowWidth < 960 ? 250 : 350, // Dynamic height\n          position: 'relative',\n          bgcolor: theme.palette.background.default,\n          borderRadius: 1,\n          border: `1px solid ${theme.palette.divider}`,\n          overflow: 'hidden',\n          mb: 3,\n          p: 1,\n        }}\n      >\n        <Line options={options} data={chartData} />\n      </Box>\n    </Box>\n  );\n};\n\nInteractiveChart.propTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.shape({\n      date: PropTypes.string.isRequired,\n      commodity: PropTypes.string.isRequired,\n      regime: PropTypes.string.isRequired,\n      price: PropTypes.number.isRequired,\n      usdprice: PropTypes.number.isRequired,\n      conflict_intensity: PropTypes.number.isRequired,\n    })\n  ).isRequired,\n  selectedCommodity: PropTypes.string.isRequired,\n  selectedRegimes: PropTypes.arrayOf(PropTypes.string).isRequired,\n};\n\nexport default InteractiveChart;",
        "imports": [
          "react",
          "react-chartjs-2",
          "chart.js",
          "chartjs-adapter-date-fns",
          "prop-types",
          "@mui/material/styles",
          "@mui/material",
          "../../utils/appUtils",
          "../../hooks/useWindowWidth"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "react-chartjs-2",
          "chart.js",
          "chartjs-adapter-date-fns",
          "prop-types",
          "@mui/material/styles",
          "@mui/material",
          "../../utils/appUtils",
          "../../hooks/useWindowWidth"
        ]
      },
      {
        "path": "components/methodology/CodeBlock.js",
        "content": "// src/components/methodology/CodeBlock.js\n\nimport React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { vs, vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';\nimport { Box, IconButton, useTheme, Tooltip, alpha, Fade } from '@mui/material';\nimport ContentCopyIcon from '@mui/icons-material/ContentCopy';\nimport CheckIcon from '@mui/icons-material/Check';\n\nconst CodeBlock = ({ language, code }) => {\n  const theme = useTheme();\n  const isDarkMode = theme.palette.mode === 'dark';\n  const [copied, setCopied] = useState(false);\n\n  const handleCopy = async () => {\n    try {\n      await navigator.clipboard.writeText(code);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (err) {\n      console.error('Failed to copy code:', err);\n    }\n  };\n\n  // Customize syntax highlighting theme\n  const customStyle = isDarkMode ? {\n    ...vscDarkPlus,\n    'pre[class*=\"language-\"]': {\n      ...vscDarkPlus['pre[class*=\"language-\"]'],\n      background: alpha(theme.palette.background.paper, 0.5),\n    },\n    'code[class*=\"language-\"]': {\n      ...vscDarkPlus['code[class*=\"language-\"]'],\n      color: theme.palette.primary.light,\n    },\n  } : {\n    ...vs,\n    'pre[class*=\"language-\"]': {\n      ...vs['pre[class*=\"language-\"]'],\n      background: alpha(theme.palette.background.paper, 0.5),\n    },\n    'code[class*=\"language-\"]': {\n      ...vs['code[class*=\"language-\"]'],\n      color: theme.palette.primary.dark,\n    },\n  };\n\n  return (\n    <Box\n      sx={{\n        position: 'relative',\n        my: 2,\n        borderRadius: theme.shape.borderRadius,\n        overflow: 'hidden',\n        bgcolor: theme.palette.mode === 'dark'\n          ? alpha(theme.palette.background.paper, 0.2)\n          : alpha(theme.palette.background.paper, 0.5),\n        border: `1px solid ${theme.palette.divider}`,\n        transition: theme.transitions.create(\n          ['background-color', 'border-color', 'box-shadow'],\n          {\n            duration: theme.transitions.duration.standard,\n          }\n        ),\n        '&:hover': {\n          boxShadow: theme.palette.mode === 'dark'\n            ? `0 4px 20px ${alpha(theme.palette.common.black, 0.5)}`\n            : theme.shadows[4],\n          borderColor: theme.palette.primary.main,\n        },\n      }}\n    >\n      <Box\n        sx={{\n          position: 'absolute',\n          top: 0,\n          right: 0,\n          padding: theme.spacing(1),\n          background: theme.palette.mode === 'dark'\n            ? 'linear-gradient(90deg, transparent, rgba(18, 18, 18, 0.8) 50%)'\n            : 'linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8) 50%)',\n          borderBottomLeftRadius: theme.shape.borderRadius,\n          transition: theme.transitions.create('background', {\n            duration: theme.transitions.duration.standard,\n          }),\n        }}\n      >\n        <Tooltip \n          title={copied ? \"Copied!\" : \"Copy Code\"} \n          placement=\"left\"\n          TransitionComponent={Fade}\n          TransitionProps={{ timeout: 300 }}\n        >\n          <IconButton\n            onClick={handleCopy}\n            size=\"small\"\n            sx={{\n              backgroundColor: theme.palette.mode === 'dark'\n                ? alpha(theme.palette.background.paper, 0.1)\n                : alpha(theme.palette.background.paper, 0.8),\n              color: copied \n                ? theme.palette.success.main \n                : theme.palette.text.secondary,\n              '&:hover': {\n                backgroundColor: theme.palette.mode === 'dark'\n                  ? alpha(theme.palette.background.paper, 0.2)\n                  : alpha(theme.palette.background.paper, 0.9),\n                transform: 'scale(1.1)',\n              },\n              transition: theme.transitions.create(\n                ['background-color', 'transform', 'color'],\n                {\n                  duration: theme.transitions.duration.shorter,\n                }\n              ),\n            }}\n          >\n            {copied ? <CheckIcon fontSize=\"small\" /> : <ContentCopyIcon fontSize=\"small\" />}\n          </IconButton>\n        </Tooltip>\n      </Box>\n\n      <Box\n        sx={{\n          position: 'relative',\n          '&:before': {\n            content: `\"${language}\"`,\n            position: 'absolute',\n            top: theme.spacing(1),\n            left: theme.spacing(1),\n            color: theme.palette.text.secondary,\n            fontSize: '0.75rem',\n            textTransform: 'uppercase',\n            letterSpacing: '0.1em',\n            opacity: 0.7,\n          },\n        }}\n      >\n        <SyntaxHighlighter\n          language={language}\n          style={customStyle}\n          customStyle={{\n            margin: 0,\n            padding: theme.spacing(4, 2, 2, 2),\n            fontSize: '0.9rem',\n            backgroundColor: 'transparent',\n            overflowX: 'auto',\n            fontFamily: 'Consolas, Monaco, \"Andale Mono\", \"Ubuntu Mono\", monospace',\n            transition: theme.transitions.create('background-color', {\n              duration: theme.transitions.duration.standard,\n            }),\n          }}\n          wrapLongLines={true}\n        >\n          {code}\n        </SyntaxHighlighter>\n      </Box>\n    </Box>\n  );\n};\n\nCodeBlock.propTypes = {\n  language: PropTypes.string.isRequired,\n  code: PropTypes.string.isRequired,\n};\n\nexport default CodeBlock;\n",
        "imports": [
          "react",
          "prop-types",
          "react-syntax-highlighter",
          "react-syntax-highlighter/dist/esm/styles/prism",
          "@mui/material",
          "@mui/icons-material/ContentCopy",
          "@mui/icons-material/Check"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "react-syntax-highlighter",
          "react-syntax-highlighter/dist/esm/styles/prism",
          "@mui/material",
          "@mui/icons-material/ContentCopy",
          "@mui/icons-material/Check"
        ]
      },
      {
        "path": "components/methodology/MethodologyContentWrapper.js",
        "content": "// src/components/methodology/MethodologyContentWrapper.js\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, alpha } from '@mui/material';\nimport MethodologySection from './MethodologySection';\nimport { useTheme } from '@mui/material/styles';\nimport methodologyContent from '../../utils/methodologyContent';\n\nconst MethodologyContentWrapper = ({ searchQuery }) => {\n  const theme = useTheme();\n\n  const filteredContent = useMemo(() => {\n    if (!searchQuery) return methodologyContent;\n\n    const searchLower = searchQuery.toLowerCase();\n    const filterSections = (sections) =>\n      sections\n        .map((section) => {\n          const hasMatch =\n            section.title.toLowerCase().includes(searchLower) ||\n            (section.content && section.content.toLowerCase().includes(searchLower));\n\n          const filteredChildren = section.children\n            ? filterSections(section.children)\n            : [];\n\n          if (hasMatch || filteredChildren.length > 0) {\n            return {\n              ...section,\n              children: filteredChildren,\n            };\n          }\n          return null;\n        })\n        .filter(Boolean);\n\n    return filterSections(methodologyContent);\n  }, [searchQuery]);\n\n  return (\n    <Box \n      sx={{ \n        padding: theme.spacing(2),\n        color: theme.palette.text.primary,\n        backgroundColor: theme.palette.mode === 'dark'\n          ? alpha(theme.palette.background.paper, 0.6)\n          : theme.palette.background.paper,\n        borderRadius: theme.shape.borderRadius,\n        transition: theme.transitions.create(\n          ['background-color', 'color'],\n          {\n            duration: theme.transitions.duration.standard,\n          }\n        ),\n        '& > *:not(:last-child)': {\n          marginBottom: theme.spacing(4),\n        },\n        '& h1, & h2, & h3, & h4, & h5, & h6': {\n          color: theme.palette.mode === 'dark'\n            ? theme.palette.primary.light\n            : theme.palette.primary.main,\n          fontWeight: 600,\n          marginBottom: theme.spacing(2),\n          transition: theme.transitions.create('color', {\n            duration: theme.transitions.duration.standard,\n          }),\n        },\n        '& p': {\n          color: theme.palette.text.primary,\n          lineHeight: 1.7,\n          marginBottom: theme.spacing(2),\n          transition: theme.transitions.create('color', {\n            duration: theme.transitions.duration.standard,\n          }),\n        },\n        '& a': {\n          color: theme.palette.mode === 'dark'\n            ? theme.palette.primary.light\n            : theme.palette.primary.main,\n          textDecoration: 'none',\n          borderBottom: `1px solid ${alpha(theme.palette.primary.main, 0.3)}`,\n          transition: theme.transitions.create(\n            ['color', 'border-color'],\n            {\n              duration: theme.transitions.duration.standard,\n            }\n          ),\n          '&:hover': {\n            color: theme.palette.primary.main,\n            borderBottomColor: theme.palette.primary.main,\n          },\n        },\n        '& code': {\n          backgroundColor: theme.palette.mode === 'dark'\n            ? alpha(theme.palette.common.white, 0.1)\n            : alpha(theme.palette.common.black, 0.05),\n          padding: theme.spacing(0.5, 1),\n          borderRadius: theme.shape.borderRadius,\n          fontFamily: 'Consolas, Monaco, \"Andale Mono\", \"Ubuntu Mono\", monospace',\n          fontSize: '0.875em',\n          color: theme.palette.mode === 'dark'\n            ? theme.palette.primary.light\n            : theme.palette.primary.dark,\n          transition: theme.transitions.create(\n            ['background-color', 'color'],\n            {\n              duration: theme.transitions.duration.standard,\n            }\n          ),\n        },\n        '& pre': {\n          backgroundColor: theme.palette.mode === 'dark'\n            ? alpha(theme.palette.common.black, 0.3)\n            : alpha(theme.palette.common.black, 0.05),\n          padding: theme.spacing(2),\n          borderRadius: theme.shape.borderRadius,\n          overflow: 'auto',\n          marginBottom: theme.spacing(2),\n          transition: theme.transitions.create('background-color', {\n            duration: theme.transitions.duration.standard,\n          }),\n          '& code': {\n            backgroundColor: 'transparent',\n            padding: 0,\n          },\n        },\n        '& ul, & ol': {\n          paddingLeft: theme.spacing(3),\n          marginBottom: theme.spacing(2),\n          '& li': {\n            marginBottom: theme.spacing(1),\n            color: theme.palette.text.primary,\n            transition: theme.transitions.create('color', {\n              duration: theme.transitions.duration.standard,\n            }),\n          },\n        },\n        '& blockquote': {\n          borderLeft: `4px solid ${theme.palette.mode === 'dark'\n            ? theme.palette.primary.light\n            : theme.palette.primary.main}`,\n          margin: theme.spacing(2, 0),\n          padding: theme.spacing(1, 2),\n          backgroundColor: theme.palette.mode === 'dark'\n            ? alpha(theme.palette.primary.main, 0.1)\n            : alpha(theme.palette.primary.light, 0.1),\n          color: theme.palette.text.primary,\n          transition: theme.transitions.create(\n            ['background-color', 'border-color', 'color'],\n            {\n              duration: theme.transitions.duration.standard,\n            }\n          ),\n        },\n      }}\n    >\n      {filteredContent.map((section, index) => (\n        <MethodologySection key={index} section={section} level={1} />\n      ))}\n    </Box>\n  );\n};\n\nMethodologyContentWrapper.propTypes = {\n  searchQuery: PropTypes.string,\n};\n\nexport default MethodologyContentWrapper;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "./MethodologySection",
          "@mui/material/styles",
          "../../utils/methodologyContent"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "./MethodologySection",
          "@mui/material/styles",
          "../../utils/methodologyContent"
        ]
      },
      {
        "path": "components/methodology/MethodologyModal.js",
        "content": "// src/components/methodology/MethodologyModal.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  IconButton,\n  Typography,\n  useMediaQuery,\n  Box,\n  alpha,\n} from '@mui/material';\nimport CloseIcon from '@mui/icons-material/Close';\nimport MethodologyContentWrapper from './MethodologyContentWrapper';\nimport { useTheme } from '@mui/material/styles';\n\nconst MethodologyModal = ({ open, onClose }) => {\n  const theme = useTheme();\n  const isSmUp = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return (\n    <Dialog\n      open={open}\n      onClose={onClose}\n      fullScreen={!isSmUp}\n      fullWidth\n      maxWidth=\"lg\"\n      scroll=\"paper\"\n      PaperProps={{\n        sx: {\n          borderRadius: { xs: 0, sm: 2 },\n          boxShadow: theme.palette.mode === 'dark' \n            ? `0 8px 32px ${alpha(theme.palette.common.black, 0.5)}`\n            : theme.shadows[5],\n          maxHeight: '90vh',\n          bgcolor: theme.palette.background.paper,\n          backgroundImage: 'none',\n          transition: theme.transitions.create(\n            ['background-color', 'box-shadow'],\n            {\n              duration: theme.transitions.duration.standard,\n            }\n          ),\n        },\n      }}\n      TransitionProps={{\n        timeout: {\n          enter: theme.transitions.duration.enteringScreen,\n          exit: theme.transitions.duration.leavingScreen,\n        },\n      }}\n      slotProps={{\n        backdrop: {\n          sx: {\n            backgroundColor: theme.palette.mode === 'dark'\n              ? alpha(theme.palette.common.black, 0.8)\n              : alpha(theme.palette.common.black, 0.5),\n          },\n        },\n      }}\n    >\n      <DialogTitle\n        sx={{\n          m: 0,\n          p: 2,\n          bgcolor: theme.palette.mode === 'dark'\n            ? alpha(theme.palette.primary.dark, 0.9)\n            : theme.palette.primary.main,\n          color: theme.palette.primary.contrastText,\n          position: 'relative',\n          display: 'flex',\n          alignItems: 'center',\n          transition: theme.transitions.create(\n            ['background-color', 'color'],\n            {\n              duration: theme.transitions.duration.standard,\n            }\n          ),\n          borderBottom: `1px solid ${theme.palette.divider}`,\n        }}\n      >\n        <Typography \n          variant=\"h6\" \n          sx={{ \n            flexGrow: 1,\n            fontWeight: 600,\n            letterSpacing: 0.5,\n          }}\n        >\n          Methodology\n        </Typography>\n        <IconButton\n          aria-label=\"close\"\n          onClick={onClose}\n          size=\"large\"\n          sx={{\n            color: theme.palette.primary.contrastText,\n            transition: theme.transitions.create(\n              ['background-color', 'transform'],\n              {\n                duration: theme.transitions.duration.shorter,\n              }\n            ),\n            '&:hover': {\n              backgroundColor: theme.palette.mode === 'dark'\n                ? alpha(theme.palette.common.white, 0.1)\n                : alpha(theme.palette.common.black, 0.1),\n              transform: 'rotate(90deg)',\n            },\n          }}\n        >\n          <CloseIcon />\n        </IconButton>\n      </DialogTitle>\n      <DialogContent\n        dividers\n        sx={{\n          padding: theme.spacing(3),\n          bgcolor: theme.palette.background.default,\n          transition: theme.transitions.create(\n            ['background-color'],\n            {\n              duration: theme.transitions.duration.standard,\n            }\n          ),\n          '& > *': {\n            transition: theme.transitions.create(\n              ['color', 'background-color'],\n              {\n                duration: theme.transitions.duration.standard,\n              }\n            ),\n          },\n          overflowY: 'auto',\n          scrollbarWidth: 'thin',\n          scrollbarColor: theme.palette.mode === 'dark'\n            ? `${alpha(theme.palette.common.white, 0.2)} ${alpha(theme.palette.common.black, 0.3)}`\n            : `${alpha(theme.palette.common.black, 0.2)} ${alpha(theme.palette.common.white, 0.3)}`,\n          '&::-webkit-scrollbar': {\n            width: '8px',\n          },\n          '&::-webkit-scrollbar-track': {\n            backgroundColor: theme.palette.mode === 'dark'\n              ? alpha(theme.palette.common.black, 0.3)\n              : alpha(theme.palette.common.white, 0.3),\n          },\n          '&::-webkit-scrollbar-thumb': {\n            backgroundColor: theme.palette.mode === 'dark'\n              ? alpha(theme.palette.common.white, 0.2)\n              : alpha(theme.palette.common.black, 0.2),\n            borderRadius: '4px',\n            '&:hover': {\n              backgroundColor: theme.palette.mode === 'dark'\n                ? alpha(theme.palette.common.white, 0.3)\n                : alpha(theme.palette.common.black, 0.3),\n            },\n          },\n        }}\n      >\n        <MethodologyContentWrapper />\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nMethodologyModal.propTypes = {\n  open: PropTypes.bool.isRequired,\n  onClose: PropTypes.func.isRequired,\n};\n\nexport default MethodologyModal;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material/Close",
          "./MethodologyContentWrapper",
          "@mui/material/styles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/icons-material/Close",
          "./MethodologyContentWrapper",
          "@mui/material/styles"
        ]
      },
      {
        "path": "components/methodology/MethodologySection.js",
        "content": "// src/components/methodology/MethodologySection.js\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Typography, Box, alpha } from '@mui/material';\nimport CodeBlock from './CodeBlock';\nimport 'katex/dist/katex.min.css';\nimport { InlineMath, BlockMath } from 'react-katex';\nimport { useTheme } from '@mui/material/styles';\n\nconst MethodologySection = ({ section, level }) => {\n  const theme = useTheme();\n\n  // Map levels to desired heading variants with smaller font sizes\n  const headingVariants = {\n    1: 'h4',\n    2: 'h5',\n    3: 'h6',\n    4: 'subtitle1',\n    5: 'subtitle2',\n    6: 'body1',\n  };\n\n  const headingVariant = headingVariants[level] || 'body1';\n\n  const renderContent = (content) => {\n    if (typeof content === 'string') {\n      return content.split(/(\\$.*?\\$)/).map((part, index) => {\n        if (part.startsWith('$') && part.endsWith('$')) {\n          return (\n            <Box\n              component=\"span\"\n              sx={{\n                display: 'inline-flex',\n                alignItems: 'center',\n                mx: 0.5,\n                color: theme.palette.mode === 'dark'\n                  ? theme.palette.primary.light\n                  : theme.palette.primary.main,\n                transition: theme.transitions.create('color', {\n                  duration: theme.transitions.duration.standard,\n                }),\n              }}\n            >\n              <InlineMath key={index}>{part.slice(1, -1)}</InlineMath>\n            </Box>\n          );\n        }\n        return part;\n      });\n    }\n    return content;\n  };\n\n  return (\n    <Box \n      sx={{ \n        mb: 4,\n        '&:hover': {\n          '& > .MuiTypography-root:first-of-type': {\n            color: theme.palette.mode === 'dark'\n              ? theme.palette.primary.light\n              : theme.palette.primary.main,\n          },\n        },\n      }}\n    >\n      <Typography\n        component=\"div\"\n        variant={headingVariant}\n        sx={{\n          mb: 2,\n          fontWeight: 600,\n          color: theme.palette.mode === 'dark'\n            ? theme.palette.primary.light\n            : theme.palette.primary.main,\n          transition: theme.transitions.create('color', {\n            duration: theme.transitions.duration.standard,\n          }),\n          borderBottom: `1px solid ${alpha(\n            theme.palette.mode === 'dark'\n              ? theme.palette.primary.light\n              : theme.palette.primary.main,\n            0.1\n          )}`,\n          pb: 1,\n          '&:hover': {\n            color: theme.palette.mode === 'dark'\n              ? theme.palette.primary.main\n              : theme.palette.primary.dark,\n          },\n        }}\n      >\n        {section.title}\n      </Typography>\n\n      {section.content && (\n        <Typography\n          variant=\"body1\"\n          sx={{ \n            mb: 2, \n            textAlign: 'justify', \n            color: theme.palette.text.primary,\n            lineHeight: 1.7,\n            transition: theme.transitions.create('color', {\n              duration: theme.transitions.duration.standard,\n            }),\n            '& strong': {\n              color: theme.palette.mode === 'dark'\n                ? theme.palette.primary.light\n                : theme.palette.primary.main,\n              fontWeight: 600,\n            },\n            '& em': {\n              color: theme.palette.text.secondary,\n              fontStyle: 'italic',\n            },\n          }}\n        >\n          {renderContent(section.content)}\n        </Typography>\n      )}\n\n      {section.equation && (\n        <Box \n          sx={{ \n            my: 3,\n            px: 2,\n            py: 3,\n            backgroundColor: theme.palette.mode === 'dark'\n              ? alpha(theme.palette.background.paper, 0.2)\n              : alpha(theme.palette.background.paper, 0.5),\n            borderRadius: theme.shape.borderRadius,\n            border: `1px solid ${theme.palette.divider}`,\n            transition: theme.transitions.create(\n              ['background-color', 'border-color'],\n              {\n                duration: theme.transitions.duration.standard,\n              }\n            ),\n            '& .katex': {\n              color: theme.palette.mode === 'dark'\n                ? theme.palette.primary.light\n                : theme.palette.primary.main,\n              transition: theme.transitions.create('color', {\n                duration: theme.transitions.duration.standard,\n              }),\n            },\n          }}\n        >\n          <BlockMath>{section.equation}</BlockMath>\n        </Box>\n      )}\n\n      {section.code &&\n        section.code.map((codeBlock, idx) => (\n          <Box \n            key={idx}\n            sx={{ \n              my: 3,\n              transition: theme.transitions.create('transform', {\n                duration: theme.transitions.duration.standard,\n              }),\n              '&:hover': {\n                transform: 'scale(1.01)',\n              },\n            }}\n          >\n            <CodeBlock language={codeBlock.language} code={codeBlock.code} />\n          </Box>\n        ))}\n\n      {section.children &&\n        section.children.map((child, idx) => (\n          <Box \n            key={idx}\n            sx={{ \n              ml: theme.spacing(2),\n              borderLeft: `2px solid ${theme.palette.divider}`,\n              pl: theme.spacing(2),\n              transition: theme.transitions.create('border-color', {\n                duration: theme.transitions.duration.standard,\n              }),\n              '&:hover': {\n                borderColor: theme.palette.mode === 'dark'\n                  ? theme.palette.primary.light\n                  : theme.palette.primary.main,\n              },\n            }}\n          >\n            <MethodologySection section={child} level={level + 1} />\n          </Box>\n        ))}\n    </Box>\n  );\n};\n\nMethodologySection.propTypes = {\n  section: PropTypes.shape({\n    id: PropTypes.string,\n    title: PropTypes.string.isRequired,\n    content: PropTypes.string,\n    equation: PropTypes.string,\n    code: PropTypes.arrayOf(\n      PropTypes.shape({\n        language: PropTypes.string,\n        code: PropTypes.string,\n      })\n    ),\n    children: PropTypes.array,\n  }).isRequired,\n  level: PropTypes.number.isRequired,\n};\n\nexport default MethodologySection;\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "./CodeBlock",
          "katex/dist/katex.min.css",
          "react-katex",
          "@mui/material/styles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "./CodeBlock",
          "katex/dist/katex.min.css",
          "react-katex",
          "@mui/material/styles"
        ]
      },
      {
        "path": "components/spatialAnalysis/SpatialAnalysis.js",
        "content": "import React, { useState, useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  Box,\n  Paper,\n  Tabs,\n  Tab,\n  Typography,\n  Alert,\n  Button\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport MapIcon from '@mui/icons-material/Map';\nimport TimelineIcon from '@mui/icons-material/Timeline';\nimport HubIcon from '@mui/icons-material/Hub';\nimport TrendingUpIcon from '@mui/icons-material/TrendingUp';\nimport WarningIcon from '@mui/icons-material/Warning';\nimport CalendarTodayIcon from '@mui/icons-material/CalendarToday';\nimport HealthAndSafetyIcon from '@mui/icons-material/HealthAndSafety';\n\nimport { ClusterAnalysis } from './features/clusters';\nimport { SpatialAutocorrelationAnalysis } from './features/autocorrelation';\nimport { FlowNetworkAnalysis } from './features/flows';\nimport { ShockPropagationMap } from './features/shocks';\nimport { ConflictImpactDashboard } from './features/conflict';\nimport { SeasonalPriceMap } from './features/seasonal';\nimport { MarketHealthMetrics } from './features/health';\nimport { clearFlowData } from '../../slices/flowSlice';\n\nimport ErrorBoundary from '../common/ErrorBoundary';\nimport LoadingIndicator from '../common/LoadingIndicator';\n\nimport {\n  selectTimeSeriesData,\n  selectGeometryData,\n  selectMarketIntegration,\n  selectLoadingStatus,\n  selectStatus\n} from '../../selectors/optimizedSelectors';\n\nconst FEATURES = [\n  {\n    id: 'clusters',\n    label: 'Market Clusters',\n    icon: <MapIcon />,\n    component: ClusterAnalysis,\n    description: 'Analyze market clustering patterns and relationships'\n  },\n  {\n    id: 'autocorrelation',\n    label: 'Spatial Patterns',\n    icon: <TimelineIcon />,\n    component: SpatialAutocorrelationAnalysis,\n    description: 'Examine spatial price dependencies and patterns'\n  },\n  {\n    id: 'flows',\n    label: 'Market Flows',\n    icon: <HubIcon />,\n    component: FlowNetworkAnalysis,\n    description: 'Visualize and analyze market flow networks'\n  },\n  {\n    id: 'shocks',\n    label: 'Price Shocks',\n    icon: <TrendingUpIcon />,\n    component: ShockPropagationMap,\n    description: 'Track and analyze price shock propagation'\n  },\n  {\n    id: 'conflict',\n    label: 'Conflict Impact',\n    icon: <WarningIcon />,\n    component: ConflictImpactDashboard,\n    description: 'Assess conflict impact on market dynamics'\n  },\n  {\n    id: 'seasonal',\n    label: 'Seasonal Patterns',\n    icon: <CalendarTodayIcon />,\n    component: SeasonalPriceMap,\n    description: 'Analyze seasonal price patterns and variations'\n  },\n  {\n    id: 'health',\n    label: 'Market Health',\n    icon: <HealthAndSafetyIcon />,\n    component: MarketHealthMetrics,\n    description: 'Monitor overall market system health'\n  }\n];\n\nconst SpatialAnalysis = () => {\n  const theme = useTheme();\n  const dispatch = useDispatch();\n  const [activeFeature, setActiveFeature] = useState('clusters');\n  const [error, setError] = useState(null);\n\n  // Get data from Redux store\n  const timeSeriesData = useSelector(selectTimeSeriesData);\n  const geometryData = useSelector(selectGeometryData);\n  const marketIntegration = useSelector(selectMarketIntegration);\n  const loadingStatus = useSelector(selectLoadingStatus);\n  const status = useSelector(selectStatus);\n\n  // Handle feature change with event prevention\n  const handleFeatureChange = (event, newValue) => {\n    if (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    if (newValue === activeFeature) return; // Prevent unnecessary re-renders\n    \n    // Only clear flow data when switching away from flows feature\n    if (activeFeature === 'flows') {\n      dispatch(clearFlowData());\n    }\n    \n    setActiveFeature(newValue);\n    setError(null); // Reset error state on feature change\n  };\n\n  // Handle component errors\n  const handleError = (error) => {\n    setError(error);\n    console.error('Feature error:', error);\n  };\n\n  // Get active feature component\n  const ActiveFeatureComponent = FEATURES.find(f => \n    f.id === activeFeature\n  )?.component;\n\n  // Show loading state\n  if (loadingStatus.loading) {\n    return (\n      <LoadingIndicator\n        message={loadingStatus.stage || 'Loading spatial analysis...'}\n        progress={loadingStatus.progress}\n        variant=\"linear\"\n      />\n    );\n  }\n\n  // Show error if status indicates error\n  if (status === 'error') {\n    return (\n      <Alert\n        severity=\"error\"\n        sx={{ m: 2 }}\n        action={\n          <Button color=\"inherit\" onClick={() => window.location.reload()}>\n            Retry\n          </Button>\n        }\n      >\n        An error occurred while loading spatial analysis data.\n      </Alert>\n    );\n  }\n\n  return (\n    <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n      {/* Feature Navigation */}\n      <Paper \n        sx={{ \n          borderRadius: 0,\n          borderBottom: `1px solid ${theme.palette.divider}`\n        }}\n        elevation={0}\n      >\n        <Tabs\n          value={activeFeature}\n          variant=\"scrollable\"\n          scrollButtons=\"auto\"\n          sx={{ px: 2 }}\n          TabIndicatorProps={{\n            style: {\n              transition: 'none'\n            }\n          }}\n        >\n          {FEATURES.map(feature => (\n            <Tab\n              key={feature.id}\n              value={feature.id}\n              label={feature.label}\n              icon={feature.icon}\n              iconPosition=\"start\"\n              onClick={(e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                handleFeatureChange(e, feature.id);\n                return false;\n              }}\n              onMouseDown={(e) => {\n                e.preventDefault();\n                e.stopPropagation();\n              }}\n              component=\"div\"\n              sx={{\n                cursor: 'pointer',\n                WebkitTapHighlightColor: 'transparent',\n                '&:focus': {\n                  outline: 'none'\n                }\n              }}\n            />\n          ))}\n        </Tabs>\n      </Paper>\n\n      {/* Feature Description */}\n      <Paper \n        sx={{ \n          p: 2,\n          borderRadius: 0,\n          borderBottom: `1px solid ${theme.palette.divider}`,\n          bgcolor: theme.palette.grey[50]\n        }}\n        elevation={0}\n      >\n        <Typography variant=\"body2\" color=\"textSecondary\">\n          {FEATURES.find(f => f.id === activeFeature)?.description}\n        </Typography>\n      </Paper>\n\n      {/* Active Feature */}\n      <Box sx={{ flexGrow: 1, overflow: 'auto', p: 2 }}>\n        <ErrorBoundary\n          message={`An error occurred while rendering the ${\n            FEATURES.find(f => f.id === activeFeature)?.label\n          } feature.`}\n          onError={handleError}\n        >\n          {ActiveFeatureComponent && (\n            <ActiveFeatureComponent\n              timeSeriesData={timeSeriesData}\n              geometryData={geometryData}\n              marketIntegration={marketIntegration}\n            />\n          )}\n        </ErrorBoundary>\n\n        {error && (\n          <Alert\n            severity=\"error\"\n            sx={{ mt: 2 }}\n            onClose={() => setError(null)}\n          >\n            {error.message}\n          </Alert>\n        )}\n      </Box>\n    </Box>\n  );\n};\n\nexport default React.memo(SpatialAnalysis);\n",
        "imports": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Map",
          "@mui/icons-material/Timeline",
          "@mui/icons-material/Hub",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/Warning",
          "@mui/icons-material/CalendarToday",
          "@mui/icons-material/HealthAndSafety",
          "./features/clusters",
          "./features/autocorrelation",
          "./features/flows",
          "./features/shocks",
          "./features/conflict",
          "./features/seasonal",
          "./features/health",
          "../../slices/flowSlice",
          "../common/ErrorBoundary",
          "../common/LoadingIndicator",
          "../../selectors/optimizedSelectors"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Map",
          "@mui/icons-material/Timeline",
          "@mui/icons-material/Hub",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/Warning",
          "@mui/icons-material/CalendarToday",
          "@mui/icons-material/HealthAndSafety",
          "./features/clusters",
          "./features/autocorrelation",
          "./features/flows",
          "./features/shocks",
          "./features/conflict",
          "./features/seasonal",
          "./features/health",
          "../../slices/flowSlice",
          "../common/ErrorBoundary",
          "../common/LoadingIndicator",
          "../../selectors/optimizedSelectors"
        ]
      },
      {
        "path": "components/spatialAnalysis/atoms/Legend.js",
        "content": "/**\n * Legend Component\n * \n * Displays a legend for the map visualization\n */\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, Typography, Paper } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\n\nconst Legend = ({\n  title,\n  items = [],\n  position = { bottom: 32, right: 10 }\n}) => {\n  const theme = useTheme();\n\n  return (\n    <Paper\n      elevation={2}\n      sx={{\n        position: 'absolute',\n        ...position,\n        zIndex: 1000,\n        backgroundColor: 'background.paper',\n        borderRadius: 1,\n        p: 1.5,\n        minWidth: 180,\n        maxWidth: 280\n      }}\n    >\n      {title && (\n        <Typography \n          variant=\"subtitle2\" \n          sx={{ \n            mb: 1,\n            fontWeight: 500,\n            color: 'text.primary'\n          }}\n        >\n          {title}\n        </Typography>\n      )}\n\n      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>\n        {items.map((item, index) => (\n          <Box \n            key={index}\n            sx={{ \n              display: 'flex', \n              alignItems: 'center', \n              gap: 1.5 \n            }}\n          >\n            <Box\n              sx={{\n                width: 16,\n                height: 16,\n                backgroundColor: item.color,\n                flexShrink: 0,\n                ...item.style,\n                border: item.style?.border || 'none'\n              }}\n            />\n            <Box sx={{ flex: 1, minWidth: 0 }}>\n              <Typography \n                variant=\"body2\"\n                sx={{ \n                  fontWeight: 500,\n                  color: 'text.primary',\n                  lineHeight: 1.2\n                }}\n              >\n                {item.label}\n              </Typography>\n              {item.description && (\n                <Typography \n                  variant=\"caption\"\n                  sx={{ \n                    display: 'block',\n                    color: 'text.secondary',\n                    mt: 0.25,\n                    lineHeight: 1.2\n                  }}\n                >\n                  {item.description}\n                </Typography>\n              )}\n            </Box>\n          </Box>\n        ))}\n      </Box>\n    </Paper>\n  );\n};\n\nLegend.propTypes = {\n  title: PropTypes.string,\n  items: PropTypes.arrayOf(PropTypes.shape({\n    color: PropTypes.string.isRequired,\n    label: PropTypes.string.isRequired,\n    description: PropTypes.string,\n    style: PropTypes.object\n  })).isRequired,\n  position: PropTypes.shape({\n    top: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number,\n    left: PropTypes.number\n  })\n};\n\nexport default React.memo(Legend);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles"
        ]
      },
      {
        "path": "components/spatialAnalysis/atoms/MetricCard.js",
        "content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Card, CardContent, Typography, Box, Tooltip } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport InfoIcon from '@mui/icons-material/Info';\nimport TrendingUpIcon from '@mui/icons-material/TrendingUp';\nimport TrendingDownIcon from '@mui/icons-material/TrendingDown';\n\nconst MetricCard = ({\n  title,\n  value,\n  trend,\n  format = 'number',\n  description,\n  tooltip\n}) => {\n  const theme = useTheme();\n\n  const formatValue = (val) => {\n    if (typeof val !== 'number') return val;\n    \n    switch (format) {\n      case 'percentage':\n        return `${(val * 100).toFixed(1)}%`;\n      case 'currency':\n        return `$${val.toFixed(2)}`;\n      case 'integer':\n        return Math.round(val).toString();\n      default:\n        return val.toFixed(2);\n    }\n  };\n\n  const getTrendColor = () => {\n    if (!trend) return theme.palette.text.secondary;\n    return trend > 0 ? theme.palette.success.main : theme.palette.error.main;\n  };\n\n  const TrendIcon = trend > 0 ? TrendingUpIcon : TrendingDownIcon;\n\n  return (\n    <Card \n      elevation={1}\n      sx={{\n        height: '100%',\n        display: 'flex',\n        flexDirection: 'column',\n        '&:hover': {\n          boxShadow: theme.shadows[3]\n        }\n      }}\n    >\n      <CardContent>\n        <Box display=\"flex\" alignItems=\"center\" mb={1}>\n          <Typography variant=\"subtitle2\" color=\"textSecondary\">\n            {title}\n          </Typography>\n          {tooltip && (\n            <Tooltip title={tooltip} placement=\"top\">\n              <InfoIcon \n                sx={{ \n                  ml: 1, \n                  fontSize: '1rem',\n                  color: theme.palette.text.secondary\n                }} \n              />\n            </Tooltip>\n          )}\n        </Box>\n\n        <Box display=\"flex\" alignItems=\"baseline\" mb={1}>\n          <Typography \n            variant=\"h4\" \n            component=\"div\"\n            sx={{ fontWeight: 'medium' }}\n          >\n            {formatValue(value)}\n          </Typography>\n          {trend !== undefined && (\n            <Box \n              display=\"flex\" \n              alignItems=\"center\" \n              ml={1}\n              sx={{ color: getTrendColor() }}\n            >\n              <TrendIcon sx={{ fontSize: '1rem' }} />\n              <Typography variant=\"body2\" component=\"span\" ml={0.5}>\n                {Math.abs(trend)}%\n              </Typography>\n            </Box>\n          )}\n        </Box>\n\n        {description && (\n          <Typography \n            variant=\"body2\" \n            color=\"textSecondary\"\n            sx={{ \n              mt: 1,\n              minHeight: '2.5em',\n              display: '-webkit-box',\n              WebkitLineClamp: 2,\n              WebkitBoxOrient: 'vertical',\n              overflow: 'hidden'\n            }}\n          >\n            {description}\n          </Typography>\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n\nMetricCard.propTypes = {\n  title: PropTypes.string.isRequired,\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n  trend: PropTypes.number,\n  format: PropTypes.oneOf(['number', 'percentage', 'currency', 'integer']),\n  description: PropTypes.string,\n  tooltip: PropTypes.string\n};\n\nexport default React.memo(MetricCard);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Info",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Info",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown"
        ]
      },
      {
        "path": "components/spatialAnalysis/atoms/Tooltip.js",
        "content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Paper, Typography, Box } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\n\nconst Tooltip = ({\n  title,\n  content,\n  metrics,\n  className,\n  style\n}) => {\n  const theme = useTheme();\n\n  return (\n    <Paper\n      elevation={3}\n      className={className}\n      sx={{\n        padding: 1.5,\n        minWidth: 200,\n        maxWidth: 300,\n        backgroundColor: 'rgba(255, 255, 255, 0.95)',\n        borderRadius: 1,\n        ...style\n      }}\n    >\n      {title && (\n        <Typography \n          variant=\"subtitle2\" \n          sx={{ \n            fontWeight: 'medium',\n            color: theme.palette.text.primary,\n            mb: content || metrics ? 1 : 0,\n            borderBottom: metrics ? `1px solid ${theme.palette.divider}` : 'none',\n            pb: metrics ? 0.5 : 0\n          }}\n        >\n          {title}\n        </Typography>\n      )}\n\n      {content && (\n        <Typography \n          variant=\"body2\" \n          color=\"textSecondary\"\n          sx={{ mb: metrics ? 1 : 0 }}\n        >\n          {content}\n        </Typography>\n      )}\n\n      {metrics && (\n        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>\n          {metrics.map((metric, index) => (\n            <Box \n              key={index}\n              sx={{ \n                display: 'flex', \n                justifyContent: 'space-between',\n                alignItems: 'baseline'\n              }}\n            >\n              <Typography \n                variant=\"caption\" \n                color=\"textSecondary\"\n                sx={{ mr: 2 }}\n              >\n                {metric.label}:\n              </Typography>\n              <Typography \n                variant=\"body2\"\n                sx={{ \n                  fontWeight: 'medium',\n                  color: metric.color || theme.palette.text.primary\n                }}\n              >\n                {formatMetricValue(metric)}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n      )}\n    </Paper>\n  );\n};\n\nconst formatMetricValue = (metric) => {\n  const value = metric.value;\n  \n  if (typeof value !== 'number') return value;\n\n  switch (metric.format) {\n    case 'percentage':\n      return `${(value * 100).toFixed(1)}%`;\n    case 'currency':\n      return `$${value.toFixed(2)}`;\n    case 'integer':\n      return Math.round(value).toString();\n    default:\n      return value.toFixed(2);\n  }\n};\n\nTooltip.propTypes = {\n  title: PropTypes.string,\n  content: PropTypes.string,\n  metrics: PropTypes.arrayOf(PropTypes.shape({\n    label: PropTypes.string.isRequired,\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n    format: PropTypes.oneOf(['number', 'percentage', 'currency', 'integer']),\n    color: PropTypes.string\n  })),\n  className: PropTypes.string,\n  style: PropTypes.object\n};\n\nexport default React.memo(Tooltip);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/ClusterMatrix.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/ClusterMatrix.js\n\nimport React, { useMemo, useState } from 'react';\nimport {\n  Box,\n  Paper,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  TableSortLabel,\n  Typography,\n  useTheme,\n  useMediaQuery,\n  Tooltip,\n  Chip,\n  Button,\n  Collapse,\n  Card,\n  CardContent,\n  List,\n  ListItem,\n  ListItemText\n} from '@mui/material';\nimport InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\nimport { CLUSTER_COLORS, CLUSTER_TYPES, SIGNIFICANCE_LEVELS } from './types';\n\nconst ClusterMatrix = ({\n  clusters,\n  local,\n  selectedRegion,\n  onRegionSelect\n}) => {\n  const theme = useTheme();\n  const isSmallScreen = useMediaQuery(theme.breakpoints.down('md'));\n  const [orderBy, setOrderBy] = useState('local_i');\n  const [order, setOrder] = useState('desc');\n  const [showMethodology, setShowMethodology] = useState(false);\n\n  // Enhanced data processing with statistical measures\n  const processedData = useMemo(() => {\n    if (!local) return { rows: [], summary: {} };\n\n    const rows = Object.entries(local).map(([region, stats]) => {\n      const clusterStrength = Math.abs(stats.local_i) * \n        (stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 1 : 0.5);\n      \n      const significanceLevel = \n        stats.p_value <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT ? 'Highly Significant' :\n        stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 'Significant' :\n        stats.p_value <= SIGNIFICANCE_LEVELS.MARGINALLY_SIGNIFICANT ? 'Marginally Significant' :\n        'Not Significant';\n\n      const confidenceInterval = stats.variance ? {\n        lower: stats.local_i - 1.96 * Math.sqrt(stats.variance),\n        upper: stats.local_i + 1.96 * Math.sqrt(stats.variance)\n      } : null;\n\n      return {\n        region,\n        ...stats,\n        clusterStrength,\n        significanceLevel,\n        confidenceInterval\n      };\n    });\n\n    // Calculate summary statistics\n    const summary = {\n      totalRegions: rows.length,\n      significantClusters: rows.filter(r => r.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT).length,\n      averageStrength: rows.reduce((sum, r) => sum + r.clusterStrength, 0) / rows.length,\n      clusterCounts: Object.fromEntries(\n        Object.values(CLUSTER_TYPES).map(type => [\n          type,\n          rows.filter(r => r.cluster_type === type).length\n        ])\n      ),\n      significanceLevels: {\n        highlySignificant: rows.filter(r => r.p_value <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT).length,\n        significant: rows.filter(r => \n          r.p_value > SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT && \n          r.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT\n        ).length,\n        marginal: rows.filter(r => \n          r.p_value > SIGNIFICANCE_LEVELS.SIGNIFICANT && \n          r.p_value <= SIGNIFICANCE_LEVELS.MARGINALLY_SIGNIFICANT\n        ).length\n      }\n    };\n\n    return { rows, summary };\n  }, [local]);\n\n  // Sorting function\n  const handleSort = (property) => {\n    const isAsc = orderBy === property && order === 'asc';\n    setOrder(isAsc ? 'desc' : 'asc');\n    setOrderBy(property);\n  };\n\n  // Format values for display with enhanced precision\n  const formatValue = (value, precision = 3) => {\n    if (value == null) return 'N/A';\n    return typeof value === 'number' ? value.toFixed(precision) : value.toString();\n  };\n\n  if (!clusters || !local) {\n    return (\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        height=\"100%\"\n      >\n        <Typography color=\"textSecondary\">\n          No cluster data available\n        </Typography>\n      </Box>\n    );\n  }\n\n  // Sort data\n  const sortedData = [...processedData.rows].sort((a, b) => {\n    const multiplier = order === 'asc' ? 1 : -1;\n    if (orderBy === 'region') {\n      return multiplier * a.region.localeCompare(b.region);\n    }\n    return multiplier * ((a[orderBy] || 0) - (b[orderBy] || 0));\n  });\n\n  return (\n    <Box\n      sx={{\n        width: '100%',\n        height: '100%',\n        display: 'flex',\n        flexDirection: 'column',\n        p: 2,\n        gap: 2,\n        position: 'relative'\n      }}\n    >\n      {/* Instructions Banner */}\n      <Paper\n        elevation={1}\n        sx={{\n          position: 'absolute',\n          top: 10,\n          left: '50%',\n          transform: 'translateX(-50%)',\n          zIndex: 1,\n          p: 1,\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n          maxWidth: '90%',\n          textAlign: 'center'\n        }}\n      >\n        <Typography variant=\"body2\" color=\"textSecondary\">\n          Click on any row to view detailed market cluster analysis\n        </Typography>\n      </Paper>\n\n      {/* Enhanced Header with Summary Statistics */}\n      <Card sx={{ mb: 2, mt: 4, boxShadow: 2 }}>\n        <CardContent>\n          <Typography variant=\"h6\" align=\"center\" gutterBottom>\n            Market Cluster Analysis\n          </Typography>\n          <Box\n            sx={{\n              display: 'flex',\n              flexWrap: 'wrap',\n              gap: 2,\n              justifyContent: 'center',\n              mb: 2\n            }}\n          >\n            <Tooltip title=\"Regions with significant spatial association\">\n              <Chip\n                label={`${processedData.summary.significantClusters} Significant Clusters`}\n                color=\"primary\"\n                variant=\"outlined\"\n              />\n            </Tooltip>\n            <Tooltip title=\"Average cluster strength across all regions\">\n              <Chip\n                label={`Avg Strength: ${formatValue(processedData.summary.averageStrength)}`}\n                color=\"secondary\"\n                variant=\"outlined\"\n              />\n            </Tooltip>\n            <Tooltip title=\"Highly significant spatial patterns\">\n              <Chip\n                label={`${processedData.summary.significanceLevels.highlySignificant} Highly Significant`}\n                color=\"success\"\n                variant=\"outlined\"\n              />\n            </Tooltip>\n          </Box>\n        </CardContent>\n      </Card>\n\n      <TableContainer \n        component={Paper} \n        sx={{ \n          flexGrow: 1,\n          maxHeight: '100%',\n          bgcolor: 'background.default',\n          boxShadow: 2,\n          '& .MuiTableRow-hover:hover': {\n            backgroundColor: theme.palette.action.hover,\n            transition: 'background-color 0.2s ease'\n          },\n          '& .Mui-selected': {\n            backgroundColor: `${theme.palette.primary.main}15 !important`\n          }\n        }}\n      >\n        <Table stickyHeader size={isSmallScreen ? \"small\" : \"medium\"}>\n          <TableHead>\n            <TableRow>\n              <TableCell>\n                <TableSortLabel\n                  active={orderBy === 'region'}\n                  direction={orderBy === 'region' ? order : 'asc'}\n                  onClick={() => handleSort('region')}\n                >\n                  <Tooltip title=\"Market region name\">\n                    <span>Region</span>\n                  </Tooltip>\n                </TableSortLabel>\n              </TableCell>\n              <TableCell align=\"right\">\n                <TableSortLabel\n                  active={orderBy === 'local_i'}\n                  direction={orderBy === 'local_i' ? order : 'asc'}\n                  onClick={() => handleSort('local_i')}\n                >\n                  <Tooltip title=\"Local spatial autocorrelation measure\">\n                    <span>Local Moran&apos;s I</span>\n                  </Tooltip>\n                </TableSortLabel>\n              </TableCell>\n              <TableCell align=\"right\">\n                <TableSortLabel\n                  active={orderBy === 'p_value'}\n                  direction={orderBy === 'p_value' ? order : 'asc'}\n                  onClick={() => handleSort('p_value')}\n                >\n                  <Tooltip title=\"Statistical significance level\">\n                    <span>Significance</span>\n                  </Tooltip>\n                </TableSortLabel>\n              </TableCell>\n              <TableCell align=\"right\">\n                <TableSortLabel\n                  active={orderBy === 'clusterStrength'}\n                  direction={orderBy === 'clusterStrength' ? order : 'asc'}\n                  onClick={() => handleSort('clusterStrength')}\n                >\n                  <Tooltip title=\"Normalized cluster strength indicator\">\n                    <span>Strength</span>\n                  </Tooltip>\n                </TableSortLabel>\n              </TableCell>\n              <TableCell>\n                <Tooltip title=\"Type of spatial pattern\">\n                  <span>Pattern</span>\n                </Tooltip>\n              </TableCell>\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {sortedData.map((row) => (\n              <TableRow\n                key={row.region}\n                hover\n                selected={row.region === selectedRegion}\n                onClick={() => onRegionSelect(row.region)}\n                sx={{ \n                  cursor: 'pointer',\n                  '&:hover': {\n                    bgcolor: `${theme.palette.action.hover} !important`\n                  }\n                }}\n              >\n                <TableCell component=\"th\" scope=\"row\">\n                  <Typography variant={isSmallScreen ? \"body2\" : \"body1\"}>\n                    {row.region}\n                  </Typography>\n                </TableCell>\n                <TableCell align=\"right\">\n                  <Tooltip title={row.confidenceInterval ? \n                    `95% CI: [${formatValue(row.confidenceInterval.lower)}, ${formatValue(row.confidenceInterval.upper)}]` : \n                    'Confidence interval not available'\n                  }>\n                    <span>{formatValue(row.local_i)}</span>\n                  </Tooltip>\n                </TableCell>\n                <TableCell align=\"right\">\n                  <Tooltip title={`p-value: ${formatValue(row.p_value)}`}>\n                    <Box>\n                      <Chip\n                        label={row.significanceLevel}\n                        size=\"small\"\n                        color={\n                          row.p_value <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT ? \"success\" :\n                          row.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? \"primary\" :\n                          row.p_value <= SIGNIFICANCE_LEVELS.MARGINALLY_SIGNIFICANT ? \"warning\" :\n                          \"default\"\n                        }\n                        sx={{ fontSize: isSmallScreen ? '0.7rem' : '0.8rem' }}\n                      />\n                    </Box>\n                  </Tooltip>\n                </TableCell>\n                <TableCell align=\"right\">\n                  <Tooltip title={`Z-score: ${formatValue(row.z_score)}`}>\n                    <span>{formatValue(row.clusterStrength)}</span>\n                  </Tooltip>\n                </TableCell>\n                <TableCell>\n                  <Box\n                    sx={{\n                      display: 'flex',\n                      alignItems: 'center',\n                      gap: 1\n                    }}\n                  >\n                    <Box\n                      sx={{\n                        width: 12,\n                        height: 12,\n                        borderRadius: '50%',\n                        bgcolor: CLUSTER_COLORS[row.cluster_type],\n                        opacity: row.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 0.8 : 0.4,\n                        border: '1px solid rgba(0,0,0,0.1)'\n                      }}\n                    />\n                    <Typography variant={isSmallScreen ? \"body2\" : \"body1\"}>\n                      {row.cluster_type.split('-').map(word => \n                        word.charAt(0).toUpperCase() + word.slice(1)\n                      ).join('-')}\n                    </Typography>\n                  </Box>\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n      </TableContainer>\n\n      {/* Enhanced Summary */}\n      <Card sx={{ p: 2, bgcolor: 'background.default', boxShadow: 2 }}>\n        <Typography variant=\"subtitle2\" gutterBottom align=\"center\">\n          Cluster Distribution\n        </Typography>\n        <Box\n          sx={{\n            display: 'flex',\n            flexWrap: 'wrap',\n            gap: 2,\n            justifyContent: 'center'\n          }}\n        >\n          {Object.entries(processedData.summary.clusterCounts).map(([type, count]) => (\n            <Tooltip\n              key={type}\n              title={`${count} regions (${((count/processedData.summary.totalRegions)*100).toFixed(1)}%)`}\n            >\n              <Box\n                sx={{\n                  display: 'flex',\n                  alignItems: 'center',\n                  gap: 1,\n                  p: 1,\n                  borderRadius: 1,\n                  bgcolor: 'background.paper',\n                  border: `1px solid ${theme.palette.divider}`\n                }}\n              >\n                <Box\n                  sx={{\n                    width: 12,\n                    height: 12,\n                    borderRadius: '50%',\n                    bgcolor: CLUSTER_COLORS[type],\n                    opacity: 0.8,\n                    border: '1px solid rgba(0,0,0,0.1)'\n                  }}\n                />\n                <Typography variant=\"body2\">\n                  {`${type.split('-').map(word => \n                    word.charAt(0).toUpperCase() + word.slice(1)\n                  ).join('-')}: ${count}`}\n                </Typography>\n              </Box>\n            </Tooltip>\n          ))}\n        </Box>\n      </Card>\n\n      {/* Methodology Section */}\n      <Box sx={{ mt: 2 }}>\n        <Button\n          fullWidth\n          onClick={() => setShowMethodology(!showMethodology)}\n          endIcon={showMethodology ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n          startIcon={<InfoOutlinedIcon />}\n          sx={{ mb: 1 }}\n        >\n          Market Cluster Analysis Methodology\n        </Button>\n        <Collapse in={showMethodology}>\n          <Paper sx={{ p: 2, boxShadow: 2 }}>\n            <Typography variant=\"subtitle1\" gutterBottom>\n              Understanding Market Cluster Analysis\n            </Typography>\n            <Typography variant=\"body2\" paragraph>\n              Market clusters are identified using Local Indicators of Spatial Association (LISA) \n              to detect statistically significant spatial patterns in market behavior:\n            </Typography>\n            <List dense>\n              <ListItem>\n                <ListItemText\n                  primary=\"High-High Clusters (Hot Spots)\"\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Markets with high values surrounded by other high-value markets, \n                      indicating concentrated market activity\n                    </Typography>\n                  }\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary=\"Low-Low Clusters (Cold Spots)\"\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Markets with low values surrounded by other low-value markets, \n                      suggesting potential market barriers\n                    </Typography>\n                  }\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary=\"High-Low & Low-High (Outliers)\"\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Markets that differ significantly from their neighbors, \n                      indicating potential market anomalies\n                    </Typography>\n                  }\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary=\"Cluster Strength\"\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Measures the intensity of spatial association, weighted by statistical significance\n                    </Typography>\n                  }\n                />\n              </ListItem>\n            </List>\n            <Typography variant=\"body2\" sx={{ mt: 1 }}>\n              Statistical significance is determined using Monte Carlo simulation with three levels:\n              Highly Significant (p ≤ 0.01), Significant (p ≤ 0.05), and Marginally Significant (p ≤ 0.1)\n            </Typography>\n          </Paper>\n        </Collapse>\n      </Box>\n    </Box>\n  );\n};\n\nexport default React.memo(ClusterMatrix);\n",
        "imports": [
          "react",
          "@mui/material",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "./types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "./types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/LISAMap.js",
        "content": "// src/components/spatialAnalysis/features/autocorrelation/LISAMap.js\n\nimport React, { useMemo } from 'react';\nimport { Box, Typography, useTheme, useMediaQuery } from '@mui/material';\nimport { MapContainer, TileLayer, GeoJSON } from 'react-leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport { CLUSTER_COLORS, SIGNIFICANCE_LEVELS } from './types';\n\n// Yemen’s center and zoom aligned with the cluster map approach\nconst DEFAULT_CENTER = [15.3694, 44.1910];\nconst DEFAULT_ZOOM = 6;\nconst BUFFER = 2; // Adjust buffer if needed\nconst DEFAULT_BOUNDS = [\n  [12.1110 - BUFFER, 41.8140 - BUFFER],\n  [19.0025 + BUFFER, 54.5305 + BUFFER]\n];\n\nconst LISAMap = ({\n  localStats,\n  geometry,\n  selectedRegion,\n  onRegionSelect\n}) => {\n  const theme = useTheme();\n  const isSmallScreen = useMediaQuery(theme.breakpoints.down('md'));\n\n  const mapData = useMemo(() => {\n    if (!localStats || !geometry || !geometry.features || !Array.isArray(geometry.features)) {\n      console.warn('Invalid or missing data for LISA map');\n      return null;\n    }\n\n    try {\n      const features = geometry.features.map(feature => {\n        const region = feature.properties?.name || feature.properties?.region_id || '';\n        const stats = localStats[region];\n\n        const clusterStrength = stats ? Math.abs(stats.local_i) * (stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 1 : 0.5) : 0;\n        const significanceLevel = stats ?\n          stats.p_value <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT ? 'Highly Significant' :\n          stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 'Significant' :\n          stats.p_value <= SIGNIFICANCE_LEVELS.MARGINALLY_SIGNIFICANT ? 'Marginally Significant' :\n          'Not Significant' : 'No Data';\n\n        return {\n          ...feature,\n          properties: {\n            ...feature.properties,\n            stats: stats ? { ...stats, clusterStrength, significanceLevel } : null,\n            isSelected: region === selectedRegion\n          }\n        };\n      });\n\n      return { type: 'FeatureCollection', features };\n    } catch (error) {\n      console.error('Error processing map data:', error);\n      return null;\n    }\n  }, [localStats, geometry, selectedRegion]);\n\n  const getRegionStyle = (feature) => {\n    const stats = feature.properties.stats;\n    const isSelected = feature.properties.isSelected;\n\n    if (!stats) {\n      return {\n        fillColor: theme.palette.grey[300],\n        weight: isSelected ? 2 : 1,\n        opacity: 1,\n        color: isSelected ? theme.palette.primary.main : theme.palette.grey[500],\n        fillOpacity: 0.7\n      };\n    }\n\n    const baseOpacity = stats.p_value <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT ? 0.9 :\n                        stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 0.7 :\n                        stats.p_value <= SIGNIFICANCE_LEVELS.MARGINALLY_SIGNIFICANT ? 0.5 : 0.3;\n\n    const strengthAdjustment = Math.min(stats.clusterStrength * 0.2, 0.1);\n    const finalOpacity = Math.min(baseOpacity + strengthAdjustment, 1);\n\n    return {\n      fillColor: CLUSTER_COLORS[stats.cluster_type] || theme.palette.grey[300],\n      weight: isSelected ? 3 : 1,\n      opacity: 1,\n      color: isSelected ? theme.palette.primary.main : theme.palette.grey[500],\n      fillOpacity: finalOpacity\n    };\n  };\n\n  const formatValue = (value, precision = 3) => {\n    if (value == null) return 'N/A';\n    return typeof value === 'number' ? value.toFixed(precision) : value.toString();\n  };\n\n  const onEachFeature = (feature, layer) => {\n    const stats = feature.properties.stats;\n    const region = feature.properties.name || feature.properties.region_id || '';\n\n    // Simplify tooltip for clearer data display\n    layer.bindTooltip(() => {\n      if (!stats) {\n        return `<div><strong>${region}</strong><br/>No data available</div>`;\n      }\n\n      return `\n        <div style=\"min-width: ${isSmallScreen ? '180px' : '220px'};\">\n          <strong>${region}</strong><br/>\n          Type: ${stats.cluster_type.replace('-', ' ')}<br/>\n          Significance: ${stats.significanceLevel}<br/>\n          Moran’s I: ${formatValue(stats.local_i)}<br/>\n          p-value: ${formatValue(stats.p_value)}<br/>\n          Z-score: ${formatValue(stats.z_score)}\n        </div>\n      `;\n    }, { sticky: true, direction: 'auto', className: 'lisa-map-tooltip' });\n\n    layer.on({\n      click: () => onRegionSelect(region)\n    });\n  };\n\n  if (!mapData) {\n    return (\n      <Box display=\"flex\" flexDirection=\"column\" justifyContent=\"center\" alignItems=\"center\" height=\"100%\" p={2} gap={2}>\n        <Typography color=\"textSecondary\">No map data available</Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ height: '100%', position: 'relative' }}>\n      {/* Instructions Banner */}\n      <Box\n        sx={{\n          position: 'absolute',\n          top: 10,\n          left: '50%',\n          transform: 'translateX(-50%)',\n          zIndex: 1000,\n          bgcolor: 'background.paper',\n          p: 1,\n          borderRadius: 1,\n          boxShadow: 1,\n          textAlign: 'center',\n          maxWidth: '90%'\n        }}\n      >\n        <Typography variant=\"body2\" color=\"textSecondary\">\n          Click on any region to view detailed market cluster analysis\n        </Typography>\n      </Box>\n\n      <MapContainer\n        center={DEFAULT_CENTER}\n        zoom={DEFAULT_ZOOM}\n        style={{ height: '100%', width: '100%' }}\n        maxBounds={DEFAULT_BOUNDS}\n        minZoom={5}\n        maxZoom={8}\n        zoomControl={true}\n        dragging={true}\n        touchZoom={true}\n        doubleClickZoom={true}\n        scrollWheelZoom={false}\n        boxZoom={true}\n        keyboard={true}\n        bounceAtZoomLimits={true}\n        worldCopyJump={false}\n        preferCanvas={true}\n      >\n        <TileLayer\n          url=\"https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png\"\n          attribution='&copy; OpenStreetMap contributors'\n          noWrap={true}\n          maxNativeZoom={8}\n          maxZoom={8}\n          tileSize={256}\n          zoomOffset={0}\n          keepBuffer={8}\n        />\n        <GeoJSON\n          data={mapData}\n          style={getRegionStyle}\n          onEachFeature={onEachFeature}\n        />\n      </MapContainer>\n\n      {/* Legend with clearer instructions */}\n      <Box\n        sx={{\n          position: 'absolute',\n          bottom: isSmallScreen ? 10 : 20,\n          right: isSmallScreen ? 10 : 20,\n          bgcolor: 'background.paper',\n          p: isSmallScreen ? 1 : 1.5,\n          borderRadius: 1,\n          boxShadow: 2,\n          zIndex: 1000,\n          maxWidth: isSmallScreen ? '150px' : '200px'\n        }}\n      >\n        <Typography variant=\"caption\" display=\"block\" gutterBottom>\n          Spatial Clusters\n        </Typography>\n        {Object.entries(CLUSTER_COLORS).map(([type, color]) => (\n          <Box key={type} display=\"flex\" alignItems=\"center\" gap={0.5} mb={0.5}>\n            <Box\n              sx={{\n                width: isSmallScreen ? 10 : 14,\n                height: isSmallScreen ? 10 : 14,\n                bgcolor: color,\n                opacity: type === 'not_significant' ? 0.3 : 0.8,\n                border: '1px solid rgba(0,0,0,0.2)',\n                borderRadius: 0.5\n              }}\n            />\n            <Typography variant=\"caption\" sx={{ fontSize: isSmallScreen ? '0.7rem' : '0.8rem' }}>\n              {type.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('-')}\n            </Typography>\n          </Box>\n        ))}\n        <Typography\n          variant=\"caption\"\n          display=\"block\"\n          mt={1}\n          sx={{\n            fontSize: isSmallScreen ? '0.65rem' : '0.75rem',\n            color: theme.palette.text.secondary\n          }}\n        >\n          Opacity indicates significance and strength\n        </Typography>\n      </Box>\n    </Box>\n  );\n};\n\nexport default React.memo(LISAMap);",
        "imports": [
          "react",
          "@mui/material",
          "react-leaflet",
          "leaflet/dist/leaflet.css",
          "./types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "react-leaflet",
          "leaflet/dist/leaflet.css",
          "./types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/MoranScatterPlot.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/MoranScatterPlot.js\n\nimport React, { useMemo } from 'react';\nimport { Box, Typography, useTheme, useMediaQuery, Paper } from '@mui/material';\nimport { scaleLinear } from 'd3-scale';\nimport { extent, line } from 'd3-array';\nimport { CLUSTER_COLORS, SIGNIFICANCE_LEVELS } from './types';\n\nconst MoranScatterPlot = ({\n  data,\n  globalMoranI,\n  selectedRegion,\n  onPointSelect\n}) => {\n  const theme = useTheme();\n  const isSmallScreen = useMediaQuery(theme.breakpoints.down('md'));\n\n  // Calculate dimensions based on screen size\n  const margin = isSmallScreen ? \n    { top: 40, right: 20, bottom: 40, left: 40 } : \n    { top: 50, right: 30, bottom: 50, left: 50 };\n  \n  const width = isSmallScreen ? 300 : 500;\n  const height = isSmallScreen ? 300 : 500;\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n\n  // Transform data for plotting with enhanced statistics\n  const plotData = useMemo(() => {\n    if (!data) return { points: [], regressionLine: [], confidenceBands: [] };\n\n    const points = Object.entries(data).map(([region, stats]) => ({\n      region,\n      x: stats.local_i || 0,\n      y: stats.spatial_lag || 0,\n      cluster_type: stats.cluster_type || 'not_significant',\n      significance: stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT,\n      p_value: stats.p_value,\n      z_score: stats.z_score,\n      clusterStrength: Math.abs(stats.local_i) * (stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 1 : 0.5),\n      variance: stats.variance || 0,\n      isSelected: region === selectedRegion\n    }));\n\n    // Calculate regression line\n    const xValues = points.map(p => p.x);\n    const yValues = points.map(p => p.y);\n    const n = points.length;\n    const sumX = xValues.reduce((a, b) => a + b, 0);\n    const sumY = yValues.reduce((a, b) => a + b, 0);\n    const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);\n    const sumXX = xValues.reduce((sum, x) => sum + x * x, 0);\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n\n    // Generate regression line points\n    const [xMin, xMax] = extent(points, d => d.x);\n    const regressionLine = [\n      { x: xMin, y: slope * xMin + intercept },\n      { x: xMax, y: slope * xMax + intercept }\n    ];\n\n    // Calculate confidence bands\n    const standardError = Math.sqrt(\n      points.reduce((sum, p) => {\n        const predicted = slope * p.x + intercept;\n        return sum + Math.pow(p.y - predicted, 2);\n      }, 0) / (n - 2)\n    );\n\n    const confidenceBands = xValues.map(x => {\n      const predicted = slope * x + intercept;\n      const se = standardError * Math.sqrt(1/n + Math.pow(x - sumX/n, 2) / (sumXX - sumX*sumX/n));\n      const ci95 = 1.96 * se;\n      return {\n        x,\n        yLower: predicted - ci95,\n        yUpper: predicted + ci95\n      };\n    }).sort((a, b) => a.x - b.x);\n\n    return { points, regressionLine, confidenceBands };\n  }, [data, selectedRegion]);\n\n  // Calculate scales with padding\n  const xScale = useMemo(() => {\n    const [min, max] = extent(plotData.points, d => d.x);\n    const padding = Math.abs(max - min) * 0.1;\n    return scaleLinear()\n      .domain([min - padding, max + padding])\n      .range([0, innerWidth]);\n  }, [plotData, innerWidth]);\n\n  const yScale = useMemo(() => {\n    const [min, max] = extent(plotData.points, d => d.y);\n    const padding = Math.abs(max - min) * 0.1;\n    return scaleLinear()\n      .domain([min - padding, max + padding])\n      .range([innerHeight, 0]);\n  }, [plotData, innerHeight]);\n\n  // Format values for tooltip\n  const formatValue = (value, precision = 3) => {\n    if (value == null) return 'N/A';\n    return typeof value === 'number' ? value.toFixed(precision) : value.toString();\n  };\n\n  if (!data || Object.keys(data).length === 0) {\n    return (\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        height=\"100%\"\n      >\n        <Typography color=\"textSecondary\">\n          No data available for scatter plot\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box\n      sx={{\n        width: '100%',\n        height: '100%',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        p: 2,\n        position: 'relative'\n      }}\n    >\n      <Typography variant=\"h6\" gutterBottom align=\"center\">\n        Moran&apos;s I Scatter Plot\n      </Typography>\n      <Typography variant=\"body2\" color=\"textSecondary\" gutterBottom align=\"center\">\n        Global Moran&apos;s I: {formatValue(globalMoranI)} \n        {data[Object.keys(data)[0]]?.p_value && \n          ` (p-value: ${formatValue(data[Object.keys(data)[0]].p_value)})`}\n      </Typography>\n\n      {/* Instructions Banner */}\n      <Paper\n        elevation={1}\n        sx={{\n          position: 'absolute',\n          top: margin.top,\n          left: '50%',\n          transform: 'translateX(-50%)',\n          zIndex: 1,\n          p: 1,\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n          maxWidth: '90%',\n          textAlign: 'center'\n        }}\n      >\n        <Typography variant=\"body2\" color=\"textSecondary\">\n          Click on any point to view detailed market cluster analysis\n        </Typography>\n      </Paper>\n\n      <svg\n        width=\"100%\"\n        height=\"100%\"\n        viewBox={`0 0 ${width} ${height}`}\n        style={{ maxWidth: width, maxHeight: height }}\n        preserveAspectRatio=\"xMidYMid meet\"\n      >\n        <defs>\n          <clipPath id=\"plot-area\">\n            <rect x={0} y={0} width={innerWidth} height={innerHeight} />\n          </clipPath>\n        </defs>\n\n        <g transform={`translate(${margin.left},${margin.top})`}>\n          {/* Confidence bands */}\n          <path\n            d={`M ${plotData.confidenceBands.map(p => `${xScale(p.x)},${yScale(p.yLower)}`).join('L')} \n                L ${plotData.confidenceBands.reverse().map(p => `${xScale(p.x)},${yScale(p.yUpper)}`).join('L')} Z`}\n            fill={theme.palette.primary.main}\n            opacity={0.1}\n            clipPath=\"url(#plot-area)\"\n          />\n\n          {/* Regression line */}\n          <path\n            d={`M ${plotData.regressionLine.map(p => `${xScale(p.x)},${yScale(p.y)}`).join('L')}`}\n            stroke={theme.palette.primary.main}\n            strokeWidth={2}\n            strokeDasharray=\"4\"\n            fill=\"none\"\n            opacity={0.6}\n            clipPath=\"url(#plot-area)\"\n          />\n\n          {/* Axes */}\n          <line\n            x1={0}\n            y1={innerHeight / 2}\n            x2={innerWidth}\n            y2={innerHeight / 2}\n            stroke={theme.palette.text.secondary}\n            strokeWidth={1}\n            strokeDasharray=\"4\"\n          />\n          <line\n            x1={innerWidth / 2}\n            y1={0}\n            x2={innerWidth / 2}\n            y2={innerHeight}\n            stroke={theme.palette.text.secondary}\n            strokeWidth={1}\n            strokeDasharray=\"4\"\n          />\n\n          {/* Points with enhanced styling */}\n          {plotData.points.map((point, i) => {\n            const baseRadius = point.significance ? 6 : 5;\n            const radius = point.isSelected ? baseRadius + 2 : baseRadius;\n            \n            return (\n              <g key={i}>\n                {/* Confidence interval circle */}\n                {point.variance > 0 && (\n                  <circle\n                    cx={xScale(point.x)}\n                    cy={yScale(point.y)}\n                    r={radius + Math.sqrt(point.variance) * 10}\n                    fill={CLUSTER_COLORS[point.cluster_type]}\n                    opacity={0.1}\n                  />\n                )}\n                {/* Main point */}\n                <circle\n                  cx={xScale(point.x)}\n                  cy={yScale(point.y)}\n                  r={radius}\n                  fill={CLUSTER_COLORS[point.cluster_type]}\n                  stroke={point.isSelected ? theme.palette.primary.main : 'none'}\n                  strokeWidth={2}\n                  opacity={point.significance ? 0.8 : 0.4}\n                  style={{ cursor: 'pointer' }}\n                  onClick={() => onPointSelect(point.region)}\n                >\n                  <title>\n                    {`Region: ${point.region}\n                      Cluster: ${point.cluster_type.replace('-', ' ')}\n                      Local Moran's I: ${formatValue(point.x)}\n                      Spatial Lag: ${formatValue(point.y)}\n                      P-value: ${formatValue(point.p_value)}\n                      Z-score: ${formatValue(point.z_score)}\n                      Cluster Strength: ${formatValue(point.clusterStrength)}`}\n                  </title>\n                </circle>\n              </g>\n            );\n          })}\n\n          {/* Axes labels */}\n          <text\n            x={innerWidth / 2}\n            y={innerHeight + margin.bottom - 10}\n            textAnchor=\"middle\"\n            fill={theme.palette.text.primary}\n            fontSize={isSmallScreen ? \"0.8rem\" : \"1rem\"}\n          >\n            Local Moran&apos;s I\n          </text>\n          <text\n            x={-innerHeight / 2}\n            y={-margin.left + 15}\n            transform=\"rotate(-90)\"\n            textAnchor=\"middle\"\n            fill={theme.palette.text.primary}\n            fontSize={isSmallScreen ? \"0.8rem\" : \"1rem\"}\n          >\n            Spatial Lag\n          </text>\n        </g>\n      </svg>\n\n      {/* Enhanced Legend with Instructions */}\n      <Box\n        sx={{\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'center',\n          gap: 1,\n          mt: 2,\n          p: 1.5,\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n          boxShadow: 1,\n          width: '100%',\n          maxWidth: isSmallScreen ? 300 : 400\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 'bold' }}>\n          Cluster Types and Significance\n        </Typography>\n        <Box\n          sx={{\n            display: 'flex',\n            flexWrap: 'wrap',\n            justifyContent: 'center',\n            gap: 2\n          }}\n        >\n          {Object.entries(CLUSTER_COLORS).map(([type, color]) => (\n            <Box\n              key={type}\n              sx={{\n                display: 'flex',\n                alignItems: 'center',\n                gap: 0.5\n              }}\n            >\n              <Box\n                sx={{\n                  width: 12,\n                  height: 12,\n                  borderRadius: '50%',\n                  bgcolor: color,\n                  opacity: type === 'not_significant' ? 0.4 : 0.8,\n                  border: '1px solid rgba(0,0,0,0.1)'\n                }}\n              />\n              <Typography variant=\"caption\" sx={{ fontSize: isSmallScreen ? '0.7rem' : '0.8rem' }}>\n                {type.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('-')}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n        <Box sx={{ textAlign: 'center' }}>\n          <Typography \n            variant=\"caption\" \n            sx={{ \n              fontSize: isSmallScreen ? '0.65rem' : '0.75rem',\n              color: theme.palette.text.secondary,\n              display: 'block'\n            }}\n          >\n            Opacity indicates significance level\n          </Typography>\n          <Typography \n            variant=\"caption\" \n            sx={{ \n              fontSize: isSmallScreen ? '0.65rem' : '0.75rem',\n              color: theme.palette.text.secondary,\n              display: 'block'\n            }}\n          >\n            Circle size shows confidence interval\n          </Typography>\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nexport default React.memo(MoranScatterPlot);\n",
        "imports": [
          "react",
          "@mui/material",
          "d3-scale",
          "d3-array",
          "./types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "d3-scale",
          "d3-array",
          "./types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/SpatialAnalysisPanel.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/SpatialAnalysisPanel.js\n\nimport React, { useState, useMemo } from 'react';\nimport {\n  Paper,\n  Typography,\n  List,\n  ListItem,\n  ListItemText,\n  Box,\n  useTheme,\n  useMediaQuery,\n  Grid,\n  Alert,\n  Button,\n  Collapse,\n  Divider,\n  Chip,\n  Tooltip,\n  Card,\n  CardContent\n} from '@mui/material';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\nimport InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';\nimport { SIGNIFICANCE_LEVELS, CLUSTER_COLORS } from './types';\n\nconst SpatialAnalysisPanel = ({\n  global,\n  local,\n  selectedRegion,\n  clusters,\n  spatialMetrics\n}) => {\n  const theme = useTheme();\n  const isSmallScreen = useMediaQuery(theme.breakpoints.down('md'));\n  const [showDetails, setShowDetails] = useState(false);\n  const [showMethodology, setShowMethodology] = useState(false);\n\n  // Format values for display with enhanced precision\n  const formatValue = (value, precision = 3) => {\n    if (value == null) return 'N/A';\n    return typeof value === 'number' ? value.toFixed(precision) : value.toString();\n  };\n\n  // Format percentage\n  const formatPercentage = (value) => {\n    if (value == null) return 'N/A';\n    return `${(value * 100).toFixed(1)}%`;\n  };\n\n  // Calculate enhanced analysis metrics\n  const analysisMetrics = useMemo(() => {\n    if (!local || !global) return null;\n\n    const regions = Object.values(local);\n    const significantCount = regions.filter(r => r.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT).length;\n    const highlySignificantCount = regions.filter(r => r.p_value <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT).length;\n\n    return {\n      totalRegions: regions.length,\n      significantCount,\n      highlySignificantCount,\n      significanceRate: significantCount / regions.length,\n      averageLocalI: regions.reduce((sum, r) => sum + Math.abs(r.local_i), 0) / regions.length,\n      spatialAssociation: Math.abs(global.moran_i) * (global.significance ? 1 : 0.5),\n      clusterDistribution: {\n        hotspots: regions.filter(r => r.cluster_type === 'high-high').length,\n        coldspots: regions.filter(r => r.cluster_type === 'low-low').length,\n        outliers: regions.filter(r => ['high-low', 'low-high'].includes(r.cluster_type)).length\n      }\n    };\n  }, [local, global]);\n\n  // Get selected region metrics with enhanced statistics\n  const selectedMetrics = useMemo(() => {\n    if (!selectedRegion || !local || !local[selectedRegion]) return null;\n\n    const stats = local[selectedRegion];\n    const confidenceInterval = stats.variance ? {\n      lower: stats.local_i - 1.96 * Math.sqrt(stats.variance),\n      upper: stats.local_i + 1.96 * Math.sqrt(stats.variance)\n    } : null;\n\n    return {\n      ...stats,\n      confidenceInterval,\n      standardizedValue: stats.z_score,\n      clusterStrength: Math.abs(stats.local_i) * (stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 1 : 0.5),\n      significanceLevel: \n        stats.p_value <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT ? 'Highly Significant' :\n        stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 'Significant' :\n        stats.p_value <= SIGNIFICANCE_LEVELS.MARGINALLY_SIGNIFICANT ? 'Marginally Significant' :\n        'Not Significant'\n    };\n  }, [selectedRegion, local]);\n\n  // Render significance chip\n  const renderSignificanceChip = (level, pValue) => (\n    <Box sx={{ mt: 0.5 }}>\n      <Chip\n        label={level}\n        size=\"small\"\n        color={\n          pValue <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT ? \"success\" :\n          pValue <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? \"primary\" :\n          pValue <= SIGNIFICANCE_LEVELS.MARGINALLY_SIGNIFICANT ? \"warning\" :\n          \"default\"\n        }\n      />\n    </Box>\n  );\n\n  return (\n    <Box sx={{ mt: 2 }}>\n      {/* Global Statistics Summary */}\n      <Card sx={{ mb: 2, boxShadow: 2 }}>\n        <CardContent>\n          <Typography variant=\"h6\" gutterBottom>\n            Global Spatial Association\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={12} md={4}>\n              <Tooltip title=\"Overall spatial autocorrelation measure\">\n                <Box>\n                  <Typography variant=\"subtitle2\" color=\"textSecondary\">\n                    Global Moran&apos;s I\n                  </Typography>\n                  <Typography variant=\"h5\">\n                    {formatValue(global?.moran_i)}\n                  </Typography>\n                  <Typography variant=\"caption\" color=\"textSecondary\">\n                    p-value: {formatValue(global?.p_value)}\n                  </Typography>\n                </Box>\n              </Tooltip>\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <Tooltip title=\"Strength of spatial patterns\">\n                <Box>\n                  <Typography variant=\"subtitle2\" color=\"textSecondary\">\n                    Spatial Association\n                  </Typography>\n                  <Typography variant=\"h5\">\n                    {formatValue(analysisMetrics?.spatialAssociation)}\n                  </Typography>\n                  <Typography variant=\"caption\" color=\"textSecondary\">\n                    {formatPercentage(analysisMetrics?.significanceRate)} significant\n                  </Typography>\n                </Box>\n              </Tooltip>\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <Tooltip title=\"Statistical robustness\">\n                <Box>\n                  <Typography variant=\"subtitle2\" color=\"textSecondary\">\n                    Z-Score\n                  </Typography>\n                  <Typography variant=\"h5\">\n                    {formatValue(global?.z_score)}\n                  </Typography>\n                  <Typography variant=\"caption\" color=\"textSecondary\">\n                    {global?.significance ? 'Significant' : 'Not Significant'}\n                  </Typography>\n                </Box>\n              </Tooltip>\n            </Grid>\n          </Grid>\n        </CardContent>\n      </Card>\n\n      {/* Cluster Analysis Summary */}\n      <Card sx={{ mb: 2, boxShadow: 2 }}>\n        <CardContent>\n          <Typography variant=\"h6\" gutterBottom>\n            Cluster Analysis\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={12} md={4}>\n              <Box>\n                <Typography variant=\"subtitle2\" color=\"textSecondary\">\n                  Hot Spots\n                </Typography>\n                <Typography variant=\"h6\">\n                  {analysisMetrics?.clusterDistribution.hotspots || 0}\n                </Typography>\n                <Typography variant=\"caption\" color=\"textSecondary\">\n                  High-High Clusters\n                </Typography>\n              </Box>\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <Box>\n                <Typography variant=\"subtitle2\" color=\"textSecondary\">\n                  Cold Spots\n                </Typography>\n                <Typography variant=\"h6\">\n                  {analysisMetrics?.clusterDistribution.coldspots || 0}\n                </Typography>\n                <Typography variant=\"caption\" color=\"textSecondary\">\n                  Low-Low Clusters\n                </Typography>\n              </Box>\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <Box>\n                <Typography variant=\"subtitle2\" color=\"textSecondary\">\n                  Spatial Outliers\n                </Typography>\n                <Typography variant=\"h6\">\n                  {analysisMetrics?.clusterDistribution.outliers || 0}\n                </Typography>\n                <Typography variant=\"caption\" color=\"textSecondary\">\n                  High-Low/Low-High\n                </Typography>\n              </Box>\n            </Grid>\n          </Grid>\n        </CardContent>\n      </Card>\n\n      {/* Selected Region Analysis */}\n      {selectedMetrics && (\n        <Card sx={{ mb: 2, boxShadow: 2 }}>\n          <CardContent>\n            <Typography variant=\"h6\" gutterBottom>\n              {selectedRegion} Analysis\n            </Typography>\n            <Grid container spacing={2}>\n              <Grid item xs={12} md={6}>\n                <List dense>\n                  <ListItem>\n                    <ListItemText\n                      primary=\"Local Moran's I\"\n                      secondary={\n                        <Box>\n                          <Typography variant=\"body2\">\n                            {formatValue(selectedMetrics.local_i)}\n                          </Typography>\n                          {selectedMetrics.confidenceInterval && (\n                            <Typography variant=\"caption\" color=\"textSecondary\">\n                              95% CI: [{formatValue(selectedMetrics.confidenceInterval.lower)} to {\n                                formatValue(selectedMetrics.confidenceInterval.upper)}]\n                            </Typography>\n                          )}\n                        </Box>\n                      }\n                    />\n                  </ListItem>\n                  <ListItem>\n                    <ListItemText\n                      primary=\"Significance\"\n                      secondary={\n                        <Box sx={{ mt: 0.5 }}>\n                          {renderSignificanceChip(\n                            selectedMetrics.significanceLevel,\n                            selectedMetrics.p_value\n                          )}\n                        </Box>\n                      }\n                    />\n                  </ListItem>\n                </List>\n              </Grid>\n              <Grid item xs={12} md={6}>\n                <List dense>\n                  <ListItem>\n                    <ListItemText\n                      primary=\"Cluster Type\"\n                      secondary={\n                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mt: 0.5 }}>\n                          <Box\n                            sx={{\n                              width: 12,\n                              height: 12,\n                              borderRadius: '50%',\n                              bgcolor: CLUSTER_COLORS[selectedMetrics.cluster_type],\n                              opacity: 0.8,\n                              border: '1px solid rgba(0,0,0,0.1)'\n                            }}\n                          />\n                          <Typography variant=\"body2\">\n                            {selectedMetrics.cluster_type.split('-').map(word => \n                              word.charAt(0).toUpperCase() + word.slice(1)\n                            ).join('-')}\n                          </Typography>\n                        </Box>\n                      }\n                    />\n                  </ListItem>\n                  <ListItem>\n                    <ListItemText\n                      primary=\"Cluster Strength\"\n                      secondary={\n                        <Box sx={{ mt: 0.5 }}>\n                          <Typography variant=\"body2\">\n                            {formatValue(selectedMetrics.clusterStrength)}\n                          </Typography>\n                        </Box>\n                      }\n                    />\n                  </ListItem>\n                </List>\n              </Grid>\n            </Grid>\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Methodology Section */}\n      <Box sx={{ mt: 2 }}>\n        <Button\n          fullWidth\n          onClick={() => setShowMethodology(!showMethodology)}\n          endIcon={showMethodology ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n          startIcon={<InfoOutlinedIcon />}\n          sx={{ mb: 1 }}\n        >\n          Methodology\n        </Button>\n        <Collapse in={showMethodology}>\n          <Paper sx={{ p: 2, boxShadow: 2 }}>\n            <Typography variant=\"subtitle1\" gutterBottom>\n              Spatial Autocorrelation Analysis Methodology\n            </Typography>\n            <Typography variant=\"body2\" paragraph>\n              This analysis uses Local Indicators of Spatial Association (LISA) to identify \n              statistically significant spatial clusters and outliers. The analysis combines:\n            </Typography>\n            <List dense>\n              <ListItem>\n                <ListItemText\n                  primary=\"Global Moran's I\"\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Measures overall spatial autocorrelation\n                    </Typography>\n                  }\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary=\"Local Moran's I\"\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Identifies local spatial patterns and clusters\n                    </Typography>\n                  }\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary=\"Statistical Significance\"\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Uses Monte Carlo simulation for hypothesis testing\n                    </Typography>\n                  }\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary=\"Cluster Classification\"\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Categorizes regions into hot spots, cold spots, and outliers\n                    </Typography>\n                  }\n                />\n              </ListItem>\n            </List>\n            <Typography variant=\"body2\" sx={{ mt: 1 }}>\n              Significance levels: Highly Significant (p ≤ 0.01), Significant (p ≤ 0.05), \n              Marginally Significant (p ≤ 0.1)\n            </Typography>\n          </Paper>\n        </Collapse>\n      </Box>\n    </Box>\n  );\n};\n\nexport default React.memo(SpatialAnalysisPanel);\n",
        "imports": [
          "react",
          "@mui/material",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "@mui/icons-material/InfoOutlined",
          "./types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "@mui/icons-material/InfoOutlined",
          "./types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/SpatialAutocorrelationAnalysis.js",
        "content": "// src/components/spatialAnalysis/features/autocorrelation/SpatialAutocorrelationAnalysis.js\n\nimport React, { useState, Suspense } from 'react';\nimport {\n  Grid,\n  Paper,\n  Typography,\n  Box,\n  ToggleButtonGroup,\n  ToggleButton,\n  CircularProgress,\n  Alert,\n  Stack\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport MapIcon from '@mui/icons-material/Map';\nimport ScatterPlotIcon from '@mui/icons-material/ScatterPlot';\nimport TableChartIcon from '@mui/icons-material/TableChart';\n\nimport LISAMap from './LISAMap';\nimport MoranScatterPlot from './MoranScatterPlot';\nimport SpatialAnalysisPanel from './SpatialAnalysisPanel';\nimport ClusterMatrix from './ClusterMatrix';\nimport SpatialAnalysisErrorBoundary from './components/SpatialAnalysisErrorBoundary';\nimport { withSpatialOptimization } from './components/SpatialAnalysisOptimizer';\nimport { useSpatialAutocorrelation } from './hooks/useSpatialAutocorrelation';\n\n// Optimize visualization components\nconst OptimizedLISAMap = withSpatialOptimization(\n  LISAMap,\n  { transformData: true, cacheKey: 'lisa-map' }\n);\n\nconst OptimizedMoranScatterPlot = withSpatialOptimization(\n  MoranScatterPlot,\n  { transformData: true, cacheKey: 'moran-scatter' }\n);\n\nconst OptimizedClusterMatrix = withSpatialOptimization(\n  ClusterMatrix,\n  { transformData: true, cacheKey: 'cluster-matrix' }\n);\n\n// Loading component\nconst LoadingView = () => (\n  <Box \n    display=\"flex\" \n    flexDirection=\"column\"\n    justifyContent=\"center\" \n    alignItems=\"center\" \n    height=\"100%\" \n    minHeight={400}\n    gap={2}\n  >\n    <CircularProgress />\n    <Typography variant=\"h6\" color=\"textSecondary\">\n      Loading spatial analysis data...\n    </Typography>\n  </Box>\n);\n\n// Error fallback component\nconst ErrorFallback = () => (\n  <Box p={3}>\n    <Alert severity=\"error\">\n      <Typography variant=\"body1\">\n        Unable to load spatial analysis visualization.\n        Please check your data and try again.\n      </Typography>\n    </Alert>\n  </Box>\n);\n\nconst SpatialAutocorrelationAnalysis = () => {\n  const theme = useTheme();\n  const [viewMode, setViewMode] = useState('map');\n  const [selectedRegion, setSelectedRegion] = useState(null);\n\n  const {\n    global,\n    local,\n    clusters,\n    geometry,\n    clusterAnalysis,\n    spatialMetrics,\n    getRegionMetrics,\n    isLoading,\n    hasError\n  } = useSpatialAutocorrelation();\n\n  // Handle loading state\n  if (isLoading) {\n    return <LoadingView />;\n  }\n\n  // Handle error state\n  if (hasError) {\n    return <ErrorFallback />;\n  }\n\n  const selectedRegionMetrics = selectedRegion ? getRegionMetrics(selectedRegion) : null;\n\n  // Safely format values\n  const formatValue = (value) => {\n    if (value == null) return 'N/A';\n    return typeof value === 'number' ? value.toFixed(3) : value.toString();\n  };\n\n  const formatPercentage = (value) => {\n    if (value == null || isNaN(value)) return '0%';\n    const formatted = Math.min(Math.max(value, 0), 100);\n    return `${formatted.toFixed(1)}%`;\n  };\n\n  const renderContent = () => (\n    <Grid container spacing={2}>\n\n      {/* View Controls */}\n      <Grid item xs={12}>\n        <Box display=\"flex\" justifyContent=\"center\">\n          <Paper sx={{ p: 2, display: 'inline-flex' }}>\n            <ToggleButtonGroup\n              value={viewMode}\n              exclusive\n              onChange={(e, value) => value && setViewMode(value)}\n              size=\"small\"\n            >\n              <ToggleButton value=\"map\">\n                <MapIcon sx={{ mr: 1 }} />\n                LISA MAP\n              </ToggleButton>\n              <ToggleButton value=\"scatter\">\n                <ScatterPlotIcon sx={{ mr: 1 }} />\n                MORAN SCATTER\n              </ToggleButton>\n              <ToggleButton value=\"table\">\n                <TableChartIcon sx={{ mr: 1 }} />\n                CLUSTER MATRIX\n              </ToggleButton>\n            </ToggleButtonGroup>\n          </Paper>\n        </Box>\n      </Grid>\n\n      {/* Main Visualization */}\n      <Grid item xs={12}>\n        <Paper sx={{ height: 600 }}>\n          <Suspense fallback={<LoadingView />}>\n            {viewMode === 'map' && (\n              <OptimizedLISAMap\n                localStats={local}\n                geometry={geometry}\n                selectedRegion={selectedRegion}\n                onRegionSelect={setSelectedRegion}\n              />\n            )}\n            {viewMode === 'scatter' && (\n              <OptimizedMoranScatterPlot\n                data={local}\n                globalMoranI={global?.moran_i || 0}\n                selectedRegion={selectedRegion}\n                onPointSelect={setSelectedRegion}\n              />\n            )}\n            {viewMode === 'table' && (\n              <OptimizedClusterMatrix\n                clusters={clusters}\n                local={local}\n                selectedRegion={selectedRegion}\n                onRegionSelect={setSelectedRegion}\n              />\n            )}\n          </Suspense>\n        </Paper>\n      </Grid>\n\n      {/* Analysis Panel */}\n      <Grid item xs={12}>\n        <Paper \n          sx={{ \n            p: 3,\n            bgcolor: theme.palette.background.default,\n            borderRadius: 2,\n            boxShadow: theme.shadows[2]\n          }}\n        >\n          <Stack spacing={3}>\n            <Box>\n              <Typography variant=\"h6\" gutterBottom color=\"primary\">\n                Spatial Pattern Analysis\n              </Typography>\n              {/* The line mentioning negative spatial autocorrelation and zero patterns was removed */}\n            </Box>\n\n            {selectedRegionMetrics && (\n              <Box>\n                <Typography variant=\"h6\" gutterBottom color=\"primary\">\n                  Selected Region Analysis\n                </Typography>\n                <Typography variant=\"body1\">\n                  {`${selectedRegion} shows ${selectedRegionMetrics.cluster_type?.replace('-', ' ') || 'no'} \n                  pattern with local Moran's I of ${formatValue(selectedRegionMetrics.local_i)} \n                  (${selectedRegionMetrics.significanceLevel || 'Not Significant'}, p-value: ${formatValue(selectedRegionMetrics.p_value)})`}\n                </Typography>\n              </Box>\n            )}\n\n            <SpatialAnalysisPanel\n              global={global}\n              local={local}\n              selectedRegion={selectedRegion}\n              clusters={clusters}\n              spatialMetrics={spatialMetrics}\n            />\n          </Stack>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n\n  return (\n    <SpatialAnalysisErrorBoundary fallback={<ErrorFallback />}>\n      {renderContent()}\n    </SpatialAnalysisErrorBoundary>\n  );\n};\n\nexport default React.memo(SpatialAutocorrelationAnalysis);",
        "imports": [
          "react",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Map",
          "@mui/icons-material/ScatterPlot",
          "@mui/icons-material/TableChart",
          "./LISAMap",
          "./MoranScatterPlot",
          "./SpatialAnalysisPanel",
          "./ClusterMatrix",
          "./components/SpatialAnalysisErrorBoundary",
          "./components/SpatialAnalysisOptimizer",
          "./hooks/useSpatialAutocorrelation"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Map",
          "@mui/icons-material/ScatterPlot",
          "@mui/icons-material/TableChart",
          "./LISAMap",
          "./MoranScatterPlot",
          "./SpatialAnalysisPanel",
          "./ClusterMatrix",
          "./components/SpatialAnalysisErrorBoundary",
          "./components/SpatialAnalysisOptimizer",
          "./hooks/useSpatialAutocorrelation"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/components/SpatialAnalysisErrorBoundary.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/components/SpatialAnalysisErrorBoundary.js\n\nimport React from 'react';\nimport {\n  Box,\n  Paper,\n  Typography,\n  Button,\n  Collapse,\n  Alert,\n  AlertTitle,\n  IconButton,\n  useTheme\n} from '@mui/material';\nimport RefreshIcon from '@mui/icons-material/Refresh';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\nimport ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';\n\n/**\n * Error boundary for spatial analysis components\n * Handles errors gracefully and provides debugging information\n */\nclass SpatialAnalysisErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      expanded: false,\n      errorType: null\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Categorize the error\n    let errorType = 'unknown';\n    if (error.message?.includes('geometry')) {\n      errorType = 'geometry';\n    } else if (error.message?.includes('features')) {\n      errorType = 'features';\n    } else if (error.message?.includes('map')) {\n      errorType = 'mapping';\n    }\n\n    return { \n      hasError: true, \n      error,\n      errorType \n    };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Enhanced error logging\n    console.error('Spatial Analysis Error:', {\n      error,\n      errorInfo,\n      errorType: this.state.errorType,\n      timestamp: new Date().toISOString()\n    });\n\n    this.setState({\n      error,\n      errorInfo\n    });\n  }\n\n  handleRefresh = () => {\n    this.setState({\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      errorType: null\n    });\n    window.location.reload();\n  };\n\n  handleExpand = () => {\n    this.setState(prevState => ({\n      expanded: !prevState.expanded\n    }));\n  };\n\n  getErrorMessage = () => {\n    const { errorType, error } = this.state;\n\n    switch (errorType) {\n      case 'geometry':\n        return 'Invalid or missing geometry data. Please ensure the geometry data is properly formatted and available.';\n      case 'features':\n        return 'Error processing map features. The geometry features may be malformed or missing required properties.';\n      case 'mapping':\n        return 'Error rendering the map. This might be due to invalid coordinates or feature properties.';\n      default:\n        return error?.message || 'An unexpected error occurred in the spatial analysis.';\n    }\n  };\n\n  getErrorSeverity = () => {\n    const { errorType } = this.state;\n    switch (errorType) {\n      case 'geometry':\n      case 'features':\n        return 'error';\n      case 'mapping':\n        return 'warning';\n      default:\n        return 'error';\n    }\n  };\n\n  render() {\n    const { hasError, error, errorInfo, expanded, errorType } = this.state;\n    const { fallback } = this.props;\n\n    if (!hasError) {\n      return this.props.children;\n    }\n\n    // Use fallback if provided\n    if (fallback) {\n      return fallback;\n    }\n\n    // Default error UI\n    return (\n      <Paper \n        elevation={3}\n        sx={{\n          p: 3,\n          m: 2,\n          maxWidth: '100%',\n          overflow: 'hidden'\n        }}\n      >\n        <Box display=\"flex\" alignItems=\"center\" mb={2}>\n          <ErrorOutlineIcon color=\"error\" sx={{ mr: 2 }} />\n          <Typography variant=\"h6\" color=\"error\">\n            Spatial Analysis Error\n          </Typography>\n        </Box>\n\n        <Alert severity={this.getErrorSeverity()} sx={{ mb: 2 }}>\n          <AlertTitle>{errorType ? `${errorType.charAt(0).toUpperCase()}${errorType.slice(1)} Error` : 'Error'}</AlertTitle>\n          {this.getErrorMessage()}\n        </Alert>\n\n        <Box display=\"flex\" gap={2} mb={2}>\n          <Button\n            variant=\"contained\"\n            color=\"primary\"\n            startIcon={<RefreshIcon />}\n            onClick={this.handleRefresh}\n          >\n            Retry Analysis\n          </Button>\n          <Button\n            variant=\"outlined\"\n            endIcon={expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n            onClick={this.handleExpand}\n          >\n            {expanded ? 'Hide Details' : 'Show Details'}\n          </Button>\n        </Box>\n\n        <Collapse in={expanded}>\n          {/* Technical Details */}\n          <Paper variant=\"outlined\" sx={{ p: 2, mb: 2, bgcolor: 'grey.50' }}>\n            <Typography variant=\"subtitle2\" gutterBottom>\n              Technical Details\n            </Typography>\n            <Typography variant=\"body2\" component=\"pre\" sx={{ \n              whiteSpace: 'pre-wrap',\n              wordBreak: 'break-word',\n              fontFamily: 'monospace',\n              fontSize: '0.8rem'\n            }}>\n              Error Type: {errorType}\n              {'\\n\\n'}\n              {errorInfo?.componentStack || error?.stack || 'No stack trace available'}\n            </Typography>\n          </Paper>\n\n          {/* Troubleshooting Tips */}\n          <Alert severity=\"info\" sx={{ mt: 2 }}>\n            <AlertTitle>Troubleshooting Tips</AlertTitle>\n            {errorType === 'geometry' && (\n              <Typography variant=\"body2\">\n                • Verify that the geometry data is properly loaded{'\\n'}\n                • Check if the geometry features contain valid coordinates{'\\n'}\n                • Ensure the geometry follows the GeoJSON specification\n              </Typography>\n            )}\n            {errorType === 'features' && (\n              <Typography variant=\"body2\">\n                • Check if all features have required properties{'\\n'}\n                • Verify the feature array is properly structured{'\\n'}\n                • Ensure feature IDs or names are correctly set\n              </Typography>\n            )}\n            {errorType === 'mapping' && (\n              <Typography variant=\"body2\">\n                • Verify coordinate values are within valid ranges{'\\n'}\n                • Check if all required map properties are present{'\\n'}\n                • Ensure the map container has proper dimensions\n              </Typography>\n            )}\n          </Alert>\n\n          {/* Development Information */}\n          {process.env.NODE_ENV === 'development' && (\n            <Alert severity=\"info\" sx={{ mt: 2 }}>\n              <AlertTitle>Development Information</AlertTitle>\n              <Typography variant=\"body2\">\n                This error occurred in development mode. Check the console for more details.\n              </Typography>\n            </Alert>\n          )}\n        </Collapse>\n      </Paper>\n    );\n  }\n}\n\nexport default SpatialAnalysisErrorBoundary;\n",
        "imports": [
          "react",
          "@mui/material",
          "@mui/icons-material/Refresh",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "@mui/icons-material/ErrorOutline"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "@mui/icons-material/Refresh",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "@mui/icons-material/ErrorOutline"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/components/SpatialAnalysisOptimizer.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/components/SpatialAnalysisOptimizer.js\n\nimport React, { useMemo } from 'react';\n\n/**\n * HOC for optimizing spatial analysis components\n * Handles data transformations and caching\n */\nexport const withSpatialOptimization = (WrappedComponent, options = {}) => {\n  const {\n    transformData = false,\n    cacheKey = null\n  } = options;\n\n  return function OptimizedComponent(props) {\n    // Memoize transformed data\n    const transformedData = useMemo(() => {\n      if (!transformData) return props;\n\n      try {\n        // Handle geometry data specifically for LISA map\n        if (cacheKey === 'lisa-map') {\n          const { geometry, localStats, ...rest } = props;\n          \n          // Validate geometry data\n          if (!geometry || !geometry.features || !Array.isArray(geometry.features)) {\n            console.warn('Invalid geometry data provided to LISA map');\n            return { ...rest, geometry: null, localStats };\n          }\n\n          // Transform and validate geometry features\n          const validatedGeometry = {\n            ...geometry,\n            features: geometry.features.map(feature => {\n              if (!feature.properties) {\n                feature.properties = {};\n              }\n              return {\n                ...feature,\n                properties: {\n                  ...feature.properties,\n                  name: feature.properties.name || feature.properties.region_id || ''\n                }\n              };\n            })\n          };\n\n          return {\n            ...rest,\n            geometry: validatedGeometry,\n            localStats\n          };\n        }\n\n        // Handle other components' data transformation\n        return {\n          ...props,\n          transformed: true,\n          timestamp: Date.now()\n        };\n      } catch (error) {\n        console.error('Data transformation error:', error);\n        // Return null for geometry in case of error\n        if (cacheKey === 'lisa-map') {\n          const { geometry, ...rest } = props;\n          return { ...rest, geometry: null };\n        }\n        return props;\n      }\n    }, [props, transformData, cacheKey]);\n\n    // Pass transformed data to wrapped component\n    return <WrappedComponent {...transformedData} />;\n  };\n};\n\nexport default withSpatialOptimization;\n",
        "imports": [
          "react"
        ],
        "exports": [
          "withSpatialOptimization",
          "default"
        ],
        "dependencies": [
          "react"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/hooks/useSpatialAutocorrelation.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/hooks/useSpatialAutocorrelation.js\n\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport {\n  selectSpatialAutocorrelation,\n  selectTimeSeriesData,\n  selectGeometryData,\n  selectAutocorrelationMetrics,\n  selectStatus,\n  selectMarketFlows\n} from '../../../../../selectors/optimizedSelectors';\nimport { calculateGlobalMoranI, calculateLocalMoranI } from '../utils/spatialCalculations';\nimport {\n  SIGNIFICANCE_LEVELS,\n  CLUSTER_TYPES,\n  DEFAULT_SPATIAL_METRICS,\n  DEFAULT_CLUSTER_SUMMARY\n} from '../types';\n\n/**\n * Hook for managing spatial autocorrelation analysis with improved statistical inference\n */\nexport const useSpatialAutocorrelation = () => {\n  // Get data and loading status from Redux\n  const spatialData = useSelector(selectSpatialAutocorrelation);\n  const timeSeriesData = useSelector(selectTimeSeriesData);\n  const geometryData = useSelector(selectGeometryData);\n  const metrics = useSelector(selectAutocorrelationMetrics);\n  const status = useSelector(selectStatus);\n  const flowData = useSelector(selectMarketFlows);\n\n  // Transform geometry data into GeoJSON format with improved error handling\n  const geometry = useMemo(() => {\n    if (!geometryData) return null;\n\n    try {\n      // Check if unified is already in GeoJSON format\n      if (geometryData.unified?.type === 'FeatureCollection') {\n        return geometryData.unified;\n      }\n\n      // If unified is not in GeoJSON format, construct it from polygons\n      if (Array.isArray(geometryData.polygons)) {\n        return {\n          type: 'FeatureCollection',\n          features: geometryData.polygons.map(polygon => ({\n            type: 'Feature',\n            geometry: polygon.geometry,\n            properties: {\n              name: polygon.properties?.name || polygon.properties?.region_id,\n              region_id: polygon.properties?.region_id || polygon.properties?.name,\n              ...polygon.properties\n            }\n          }))\n        };\n      }\n\n      console.warn('Invalid geometry data structure:', geometryData);\n      return null;\n    } catch (error) {\n      console.error('Error transforming geometry data:', error);\n      return null;\n    }\n  }, [geometryData]);\n\n  // Calculate global Moran's I with improved statistical inference\n  const global = useMemo(() => {\n    if (!timeSeriesData?.length || !flowData?.length) {\n      return {\n        moran_i: 0,\n        p_value: 1,\n        z_score: 0,\n        significance: false\n      };\n    }\n\n    try {\n      // Get latest time period data for each region with improved date handling\n      const latestData = new Map();\n      timeSeriesData.forEach(d => {\n        const currentDate = new Date(d.month);\n        if (!latestData.has(d.region) || \n            currentDate > new Date(latestData.get(d.region).month)) {\n          latestData.set(d.region, d);\n        }\n      });\n\n      const currentData = Array.from(latestData.values());\n      return calculateGlobalMoranI(currentData, flowData);\n    } catch (error) {\n      console.error('Error calculating global Moran\\'s I:', error);\n      return {\n        moran_i: 0,\n        p_value: 1,\n        z_score: 0,\n        significance: false\n      };\n    }\n  }, [timeSeriesData, flowData]);\n\n  // Calculate local Moran's I statistics with improved precision\n  const local = useMemo(() => {\n    if (!timeSeriesData?.length || !flowData?.length) {\n      return {};\n    }\n\n    try {\n      // Get latest time period data with improved date handling\n      const latestData = new Map();\n      timeSeriesData.forEach(d => {\n        const currentDate = new Date(d.month);\n        if (!latestData.has(d.region) || \n            currentDate > new Date(latestData.get(d.region).month)) {\n          latestData.set(d.region, d);\n        }\n      });\n\n      const currentData = Array.from(latestData.values());\n      return calculateLocalMoranI(currentData, flowData);\n    } catch (error) {\n      console.error('Error calculating local Moran\\'s I:', error);\n      return {};\n    }\n  }, [timeSeriesData, flowData]);\n\n  // Calculate clusters with improved classification\n  const clusters = useMemo(() => {\n    const defaultClusters = {\n      [CLUSTER_TYPES.HIGH_HIGH]: [],\n      [CLUSTER_TYPES.LOW_LOW]: [],\n      [CLUSTER_TYPES.HIGH_LOW]: [],\n      [CLUSTER_TYPES.LOW_HIGH]: [],\n      [CLUSTER_TYPES.NOT_SIGNIFICANT]: []\n    };\n\n    if (!local || Object.keys(local).length === 0) return defaultClusters;\n\n    try {\n      // Calculate clusters with improved significance testing\n      return Object.entries(local).reduce((acc, [region, stats]) => {\n        if (!stats) return acc;\n        const type = stats.cluster_type || CLUSTER_TYPES.NOT_SIGNIFICANT;\n        \n        // Include additional statistical information\n        acc[type].push({\n          region,\n          ...stats,\n          standardizedValue: stats.z_score,\n          significanceLevel: stats.p_value <= 0.01 ? 'Highly Significant' :\n                           stats.p_value <= 0.05 ? 'Significant' :\n                           'Not Significant'\n        });\n        return acc;\n      }, { ...defaultClusters });\n    } catch (error) {\n      console.error('Error calculating clusters:', error);\n      return defaultClusters;\n    }\n  }, [local]);\n\n  // Calculate cluster analysis metrics with improved statistical measures\n  const clusterAnalysis = useMemo(() => {\n    if (!clusters || Object.values(clusters).every(arr => arr.length === 0)) {\n      return DEFAULT_CLUSTER_SUMMARY;\n    }\n\n    try {\n      const totals = {\n        [CLUSTER_TYPES.HIGH_HIGH]: clusters[CLUSTER_TYPES.HIGH_HIGH].length,\n        [CLUSTER_TYPES.LOW_LOW]: clusters[CLUSTER_TYPES.LOW_LOW].length,\n        [CLUSTER_TYPES.HIGH_LOW]: clusters[CLUSTER_TYPES.HIGH_LOW].length,\n        [CLUSTER_TYPES.LOW_HIGH]: clusters[CLUSTER_TYPES.LOW_HIGH].length,\n        [CLUSTER_TYPES.NOT_SIGNIFICANT]: clusters[CLUSTER_TYPES.NOT_SIGNIFICANT].length\n      };\n\n      const totalRegions = Object.values(totals).reduce((sum, count) => sum + count, 0);\n      const significantCount = totalRegions - totals[CLUSTER_TYPES.NOT_SIGNIFICANT];\n\n      // Calculate improved metrics\n      return {\n        totals,\n        significantCount,\n        totalRegions,\n        significanceRate: totalRegions > 0 ? (significantCount / totalRegions) * 100 : 0,\n        hotspotRate: totalRegions > 0 ? (totals[CLUSTER_TYPES.HIGH_HIGH] / totalRegions) * 100 : 0,\n        coldspotRate: totalRegions > 0 ? (totals[CLUSTER_TYPES.LOW_LOW] / totalRegions) * 100 : 0,\n        outlierRate: totalRegions > 0 ? \n          ((totals[CLUSTER_TYPES.HIGH_LOW] + totals[CLUSTER_TYPES.LOW_HIGH]) / totalRegions) * 100 : 0,\n        clusterStrength: calculateClusterStrength(clusters)\n      };\n    } catch (error) {\n      console.error('Error calculating cluster analysis:', error);\n      return DEFAULT_CLUSTER_SUMMARY;\n    }\n  }, [clusters]);\n\n  // Calculate spatial metrics with improved statistical measures\n  const spatialMetrics = useMemo(() => {\n    if (!metrics || !global) return DEFAULT_SPATIAL_METRICS;\n\n    try {\n      const localValues = Object.values(local);\n      const maxLocalI = localValues.length > 0 \n        ? Math.max(...localValues.map(l => Math.abs(l.local_i || 0)))\n        : 0;\n\n      // Calculate improved spatial association measure\n      const spatialAssociation = calculateSpatialAssociation(global, localValues);\n\n      return {\n        globalMoranI: global.moran_i,\n        pValue: global.p_value,\n        zScore: global.z_score,\n        avgLocalI: metrics.globalIndex ?? 0,\n        maxLocalI,\n        spatialAssociation,\n        significanceLevels: calculateSignificanceLevels(localValues)\n      };\n    } catch (error) {\n      console.error('Error calculating spatial metrics:', error);\n      return DEFAULT_SPATIAL_METRICS;\n    }\n  }, [metrics, global, local]);\n\n  // Get region-specific metrics with improved statistical inference\n  const getRegionMetrics = (regionId) => {\n    if (!local || !local[regionId]) return null;\n\n    try {\n      const stats = local[regionId];\n      const isSignificant = stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT;\n      \n      return {\n        ...stats,\n        isSignificant,\n        significanceLevel: \n          stats.p_value <= SIGNIFICANCE_LEVELS.HIGHLY_SIGNIFICANT ? 'Highly Significant' :\n          stats.p_value <= SIGNIFICANCE_LEVELS.SIGNIFICANT ? 'Significant' :\n          stats.p_value <= SIGNIFICANCE_LEVELS.MARGINALLY_SIGNIFICANT ? 'Marginally Significant' :\n          'Not Significant',\n        standardizedValue: stats.z_score,\n        clusterStrength: Math.abs(stats.local_i) * (isSignificant ? 1 : 0.5)\n      };\n    } catch (error) {\n      console.error('Error getting region metrics:', error);\n      return null;\n    }\n  };\n\n  // Helper function to calculate cluster strength\n  const calculateClusterStrength = (clusters) => {\n    const significantClusters = [\n      ...clusters[CLUSTER_TYPES.HIGH_HIGH],\n      ...clusters[CLUSTER_TYPES.LOW_LOW]\n    ];\n    \n    if (significantClusters.length === 0) return 0;\n    \n    return significantClusters.reduce((sum, cluster) => \n      sum + Math.abs(cluster.local_i || 0), 0) / significantClusters.length;\n  };\n\n  // Helper function to calculate spatial association\n  const calculateSpatialAssociation = (global, localValues) => {\n    if (!global || !localValues.length) return 0;\n    \n    const significantLocal = localValues.filter(v => v.p_value <= 0.05);\n    const localStrength = significantLocal.length > 0 \n      ? significantLocal.reduce((sum, v) => sum + Math.abs(v.local_i || 0), 0) / significantLocal.length\n      : 0;\n    \n    return Math.abs(global.moran_i) * (global.significance ? 1 : 0.5) * (1 + localStrength) / 2;\n  };\n\n  // Helper function to calculate significance levels\n  const calculateSignificanceLevels = (localValues) => {\n    return localValues.reduce((acc, value) => ({\n      highlySignificant: acc.highlySignificant + (value.p_value <= 0.01 ? 1 : 0),\n      significant: acc.significant + (value.p_value <= 0.05 && value.p_value > 0.01 ? 1 : 0),\n      marginal: acc.marginal + (value.p_value <= 0.1 && value.p_value > 0.05 ? 1 : 0),\n      notSignificant: acc.notSignificant + (value.p_value > 0.1 ? 1 : 0)\n    }), {\n      highlySignificant: 0,\n      significant: 0,\n      marginal: 0,\n      notSignificant: 0\n    });\n  };\n\n  // Loading and error states\n  const isLoading = status.loading || \n    (!spatialData && !status.error) || \n    (!timeSeriesData && !status.error) || \n    (!geometryData && !status.error) ||\n    (!flowData && !status.error);\n    \n  const hasError = status.error !== null;\n\n  return {\n    // Core data\n    global,\n    local,\n    clusters,\n    geometry,\n    \n    // Derived metrics\n    clusterAnalysis,\n    spatialMetrics,\n    \n    // Utility functions\n    getRegionMetrics,\n    \n    // State\n    isLoading,\n    hasError\n  };\n};\n\nexport default useSpatialAutocorrelation;\n",
        "imports": [
          "react",
          "react-redux",
          "../../../../../selectors/optimizedSelectors",
          "../utils/spatialCalculations",
          "../types"
        ],
        "exports": [
          "useSpatialAutocorrelation",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../../../selectors/optimizedSelectors",
          "../utils/spatialCalculations",
          "../types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/index.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/index.js\n\nimport SpatialAutocorrelationAnalysis from './SpatialAutocorrelationAnalysis';\nimport LISAMap from './LISAMap';\nimport MoranScatterPlot from './MoranScatterPlot';\nimport ClusterMatrix from './ClusterMatrix';\nimport SpatialAnalysisPanel from './SpatialAnalysisPanel';\nimport { useSpatialAutocorrelation } from './hooks/useSpatialAutocorrelation';\nimport { withSpatialOptimization } from './components/SpatialAnalysisOptimizer';\nimport SpatialAnalysisErrorBoundary from './components/SpatialAnalysisErrorBoundary';\nimport {\n  CLUSTER_TYPES,\n  SIGNIFICANCE_LEVELS,\n  CLUSTER_COLORS,\n  DEFAULT_SPATIAL_METRICS,\n  DEFAULT_CLUSTER_SUMMARY\n} from './types';\nimport { calculateGlobalMoranI, calculateLocalMoranI } from './utils/spatialCalculations';\n\n// Export individual components for granular imports\nexport {\n  SpatialAutocorrelationAnalysis,\n  LISAMap,\n  MoranScatterPlot,\n  ClusterMatrix,\n  SpatialAnalysisPanel,\n  SpatialAnalysisErrorBoundary\n};\n\n// Export hooks and utilities\nexport {\n  useSpatialAutocorrelation,\n  withSpatialOptimization,\n  calculateGlobalMoranI,\n  calculateLocalMoranI\n};\n\n// Export types and constants\nexport {\n  CLUSTER_TYPES,\n  SIGNIFICANCE_LEVELS,\n  CLUSTER_COLORS,\n  DEFAULT_SPATIAL_METRICS,\n  DEFAULT_CLUSTER_SUMMARY\n};\n\n// Export optimized components\nexport const OptimizedLISAMap = withSpatialOptimization(\n  LISAMap,\n  { transformData: true, cacheKey: 'lisa-map' }\n);\n\nexport const OptimizedMoranScatterPlot = withSpatialOptimization(\n  MoranScatterPlot,\n  { transformData: true, cacheKey: 'moran-scatter' }\n);\n\nexport const OptimizedClusterMatrix = withSpatialOptimization(\n  ClusterMatrix,\n  { transformData: true, cacheKey: 'cluster-matrix' }\n);\n\n// Export feature configuration\nexport const featureConfig = {\n  defaultView: 'map',\n  visualization: {\n    map: {\n      center: [15.5527, 48.5164], // Yemen's approximate center\n      zoom: 6,\n      maxZoom: 10,\n      minZoom: 5\n    },\n    colors: CLUSTER_COLORS\n  },\n  analysis: {\n    moranI: {\n      permutations: 999,\n      significanceLevels: [0.01, 0.05, 0.1]\n    },\n    clustering: {\n      minClusterSize: 2,\n      maxClusterSize: 10\n    }\n  }\n};\n\n// Export feature metadata\nexport const featureMetadata = {\n  id: 'spatial-autocorrelation',\n  name: 'Spatial Autocorrelation',\n  description: 'Analyze spatial dependencies and clustering patterns in market data',\n  version: '1.0.0',\n  category: 'spatial-analysis',\n  capabilities: [\n    'LISA statistics calculation',\n    'Cluster identification',\n    'Pattern visualization',\n    'Statistical significance testing'\n  ],\n  dependencies: [\n    'leaflet',\n    'd3',\n    '@mui/material'\n  ],\n  dataRequirements: {\n    spatialData: true,\n    timeSeriesData: true,\n    geometryData: true\n  }\n};\n\n// Export integration helpers\nexport const integrationHelpers = {\n  prepareAnalysisData: (timeSeriesData, geometryData) => ({\n    prepared: true,\n    timeSeriesData,\n    geometryData\n  }),\n\n  validateDataStructure: (data) => {\n    if (!data) return false;\n    if (!data.timeSeriesData || !data.geometryData) return false;\n    return true;\n  }\n};\n\n// Export main component as default\nexport default withSpatialOptimization(SpatialAutocorrelationAnalysis);\n",
        "imports": [
          "./SpatialAutocorrelationAnalysis",
          "./LISAMap",
          "./MoranScatterPlot",
          "./ClusterMatrix",
          "./SpatialAnalysisPanel",
          "./hooks/useSpatialAutocorrelation",
          "./components/SpatialAnalysisOptimizer",
          "./components/SpatialAnalysisErrorBoundary",
          "./types",
          "./utils/spatialCalculations"
        ],
        "exports": [
          "OptimizedLISAMap",
          "OptimizedMoranScatterPlot",
          "OptimizedClusterMatrix",
          "featureConfig",
          "featureMetadata",
          "integrationHelpers",
          "default"
        ],
        "dependencies": [
          "./SpatialAutocorrelationAnalysis",
          "./LISAMap",
          "./MoranScatterPlot",
          "./ClusterMatrix",
          "./SpatialAnalysisPanel",
          "./hooks/useSpatialAutocorrelation",
          "./components/SpatialAnalysisOptimizer",
          "./components/SpatialAnalysisErrorBoundary",
          "./types",
          "./utils/spatialCalculations"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/selectors/autocorrelationSelectors.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/selectors/autocorrelationSelectors.js\n\nimport { createSelector } from '@reduxjs/toolkit';\n\n// Base selector for autocorrelation state\nconst selectAutocorrelationState = state => state.spatialAnalysis?.spatialAutocorrelation || {};\n\n/**\n * Selects global Moran's I statistics and significance\n */\nexport const selectGlobalAutocorrelation = createSelector(\n  [selectAutocorrelationState],\n  (autocorrelation) => {\n    if (!autocorrelation?.global) {\n      return {\n        moran_i: 0,\n        p_value: null,\n        z_score: null,\n        significance: false\n      };\n    }\n\n    return {\n      moran_i: autocorrelation.global.moran_i || 0,\n      p_value: autocorrelation.global.p_value,\n      z_score: autocorrelation.global.z_score,\n      significance: autocorrelation.global.significance || false\n    };\n  }\n);\n\n/**\n * Selects local Moran's I statistics for all regions\n */\nexport const selectLocalAutocorrelation = createSelector(\n  [selectAutocorrelationState],\n  (autocorrelation) => {\n    if (!autocorrelation?.local) {\n      return {};\n    }\n\n    return Object.entries(autocorrelation.local).reduce((acc, [region, stats]) => {\n      acc[region] = {\n        local_i: stats.local_i || 0,\n        p_value: stats.p_value,\n        cluster_type: stats.cluster_type || 'not_significant',\n        z_score: stats.z_score,\n        spatial_lag: stats.spatial_lag || 0,\n        variance: stats.variance || 0\n      };\n      return acc;\n    }, {});\n  }\n);\n\n/**\n * Selects significant spatial clusters categorized by type\n */\nexport const selectSignificantClusters = createSelector(\n  [selectLocalAutocorrelation],\n  (localStats) => {\n    const clusters = {\n      'high-high': [],\n      'low-low': [],\n      'high-low': [],\n      'low-high': [],\n      'not_significant': []\n    };\n\n    Object.entries(localStats).forEach(([region, stats]) => {\n      const type = stats.cluster_type || 'not_significant';\n      clusters[type].push({\n        region,\n        ...stats\n      });\n    });\n\n    return clusters;\n  }\n);\n\n/**\n * Selects summary statistics for spatial autocorrelation analysis\n */\nexport const selectAutocorrelationSummary = createSelector(\n  [selectGlobalAutocorrelation, selectLocalAutocorrelation],\n  (global, local) => {\n    const localCount = Object.keys(local).length;\n    const significantCount = Object.values(local).filter(\n      stats => stats.p_value && stats.p_value < 0.05\n    ).length;\n\n    const clusterCounts = Object.values(local).reduce((acc, stats) => {\n      const type = stats.cluster_type || 'not_significant';\n      acc[type] = (acc[type] || 0) + 1;\n      return acc;\n    }, {});\n\n    return {\n      globalMoranI: global.moran_i,\n      globalSignificance: global.significance,\n      totalRegions: localCount,\n      significantRegions: significantCount,\n      significanceRate: localCount ? (significantCount / localCount) * 100 : 0,\n      clusterDistribution: {\n        hotspots: clusterCounts['high-high'] || 0,\n        coldspots: clusterCounts['low-low'] || 0,\n        outliers: (clusterCounts['high-low'] || 0) + (clusterCounts['low-high'] || 0),\n        notSignificant: clusterCounts['not_significant'] || 0\n      }\n    };\n  }\n);\n\n/**\n * Selects autocorrelation statistics for a specific region\n */\nexport const selectAutocorrelationByRegion = createSelector(\n  [selectLocalAutocorrelation, (_, regionId) => regionId],\n  (localStats, regionId) => {\n    if (!localStats[regionId]) return null;\n\n    const stats = localStats[regionId];\n    return {\n      ...stats,\n      isSignificant: stats.p_value <= 0.05,\n      standardizedValue: stats.local_i / Math.sqrt(stats.variance || 1)\n    };\n  }\n);\n\n/**\n * Selects spatial lag statistics for visualization\n */\nexport const selectSpatialLagData = createSelector(\n  [selectLocalAutocorrelation],\n  (localStats) => {\n    return Object.entries(localStats).map(([region, stats]) => ({\n      region,\n      value: stats.local_i,\n      spatialLag: stats.spatial_lag,\n      significance: stats.p_value <= 0.05,\n      quadrant: stats.cluster_type\n    }));\n  }\n);\n\n// Export all selectors\nexport default {\n  selectGlobalAutocorrelation,\n  selectLocalAutocorrelation,\n  selectSignificantClusters,\n  selectAutocorrelationSummary,\n  selectAutocorrelationByRegion,\n  selectSpatialLagData\n};\n",
        "imports": [
          "@reduxjs/toolkit"
        ],
        "exports": [
          "selectGlobalAutocorrelation",
          "selectLocalAutocorrelation",
          "selectSignificantClusters",
          "selectAutocorrelationSummary",
          "selectAutocorrelationByRegion",
          "selectSpatialLagData",
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/types.js",
        "content": "//src/components/spatialAnalysis/features/autocorrelation/types.js\n\n/**\n * Constants and types for spatial autocorrelation analysis\n */\nimport PropTypes from 'prop-types';\n\n// Significance levels for statistical tests with improved granularity\nexport const SIGNIFICANCE_LEVELS = {\n  HIGHLY_SIGNIFICANT: 0.01,\n  SIGNIFICANT: 0.05,\n  MARGINALLY_SIGNIFICANT: 0.1,\n  WEAKLY_SIGNIFICANT: 0.15\n};\n\n// Cluster types for LISA analysis\nexport const CLUSTER_TYPES = {\n  HIGH_HIGH: 'high-high',\n  LOW_LOW: 'low-low',\n  HIGH_LOW: 'high-low',\n  LOW_HIGH: 'low-high',\n  NOT_SIGNIFICANT: 'not_significant'\n};\n\n// Colors for different cluster types with improved contrast\nexport const CLUSTER_COLORS = {\n  [CLUSTER_TYPES.HIGH_HIGH]: '#d73027', // Hot spots (red)\n  [CLUSTER_TYPES.LOW_LOW]: '#313695', // Cold spots (blue)\n  [CLUSTER_TYPES.HIGH_LOW]: '#fdae61', // High-Low outliers (orange)\n  [CLUSTER_TYPES.LOW_HIGH]: '#74add1', // Low-High outliers (light blue)\n  [CLUSTER_TYPES.NOT_SIGNIFICANT]: '#969696' // Not significant (gray)\n};\n\n// Default metrics for spatial analysis with enhanced statistical measures\nexport const DEFAULT_SPATIAL_METRICS = {\n  globalMoranI: 0,\n  pValue: 1,\n  zScore: 0,\n  avgLocalI: 0,\n  maxLocalI: 0,\n  spatialAssociation: 0,\n  clusterStrength: 0,\n  significanceLevels: {\n    highlySignificant: 0,\n    significant: 0,\n    marginal: 0,\n    notSignificant: 0\n  },\n  robustness: {\n    variance: 0,\n    standardError: 0,\n    confidenceInterval: { lower: 0, upper: 0 }\n  }\n};\n\n// Default summary for cluster analysis with enhanced metrics\nexport const DEFAULT_CLUSTER_SUMMARY = {\n  totals: {\n    'high-high': 0,\n    'low-low': 0,\n    'high-low': 0,\n    'low-high': 0,\n    'not_significant': 0\n  },\n  significantCount: 0,\n  totalRegions: 0,\n  significanceRate: 0,\n  hotspotRate: 0,\n  coldspotRate: 0,\n  outlierRate: 0,\n  clusterStrength: 0,\n  spatialHeterogeneity: 0\n};\n\n// Enhanced PropTypes for statistical components\nexport const LocalMoranStatisticsPropType = PropTypes.shape({\n  local_i: PropTypes.number.isRequired,\n  p_value: PropTypes.number.isRequired,\n  z_score: PropTypes.number.isRequired,\n  cluster_type: PropTypes.oneOf(Object.values(CLUSTER_TYPES)).isRequired,\n  variance: PropTypes.number.isRequired,\n  spatial_lag: PropTypes.number.isRequired,\n  standardizedValue: PropTypes.number.isRequired,\n  clusterStrength: PropTypes.number.isRequired\n});\n\nexport const GlobalMoranStatisticsPropType = PropTypes.shape({\n  moran_i: PropTypes.number.isRequired,\n  p_value: PropTypes.number.isRequired,\n  z_score: PropTypes.number.isRequired,\n  significance: PropTypes.bool.isRequired,\n  variance: PropTypes.number.isRequired,\n  standardError: PropTypes.number.isRequired,\n  confidenceInterval: PropTypes.shape({\n    lower: PropTypes.number.isRequired,\n    upper: PropTypes.number.isRequired\n  }).isRequired\n});\n\nexport const ClusterAnalysisPropType = PropTypes.shape({\n  totals: PropTypes.objectOf(PropTypes.number).isRequired,\n  significantCount: PropTypes.number.isRequired,\n  totalRegions: PropTypes.number.isRequired,\n  significanceRate: PropTypes.number.isRequired,\n  hotspotRate: PropTypes.number.isRequired,\n  coldspotRate: PropTypes.number.isRequired,\n  outlierRate: PropTypes.number.isRequired,\n  clusterStrength: PropTypes.number.isRequired,\n  spatialHeterogeneity: PropTypes.number.isRequired\n});\n\nexport const SpatialMetricsPropType = PropTypes.shape({\n  globalMoranI: PropTypes.number.isRequired,\n  pValue: PropTypes.number.isRequired,\n  zScore: PropTypes.number.isRequired,\n  avgLocalI: PropTypes.number.isRequired,\n  maxLocalI: PropTypes.number.isRequired,\n  spatialAssociation: PropTypes.number.isRequired,\n  clusterStrength: PropTypes.number.isRequired,\n  significanceLevels: PropTypes.shape({\n    highlySignificant: PropTypes.number.isRequired,\n    significant: PropTypes.number.isRequired,\n    marginal: PropTypes.number.isRequired,\n    notSignificant: PropTypes.number.isRequired\n  }).isRequired,\n  robustness: PropTypes.shape({\n    variance: PropTypes.number.isRequired,\n    standardError: PropTypes.number.isRequired,\n    confidenceInterval: PropTypes.shape({\n      lower: PropTypes.number.isRequired,\n      upper: PropTypes.number.isRequired\n    }).isRequired\n  }).isRequired\n});\n\n// Component PropTypes with enhanced validation\nexport const LISAMapPropTypes = {\n  localStats: PropTypes.objectOf(LocalMoranStatisticsPropType),\n  geometry: PropTypes.shape({\n    type: PropTypes.oneOf(['FeatureCollection']).isRequired,\n    features: PropTypes.arrayOf(PropTypes.object).isRequired\n  }).isRequired,\n  selectedRegion: PropTypes.string,\n  onRegionSelect: PropTypes.func.isRequired\n};\n\nexport const MoranScatterPlotPropTypes = {\n  data: PropTypes.objectOf(LocalMoranStatisticsPropType),\n  globalMoranI: PropTypes.number.isRequired,\n  selectedRegion: PropTypes.string,\n  onPointSelect: PropTypes.func.isRequired,\n  showConfidenceIntervals: PropTypes.bool\n};\n\nexport const ClusterMatrixPropTypes = {\n  clusters: PropTypes.objectOf(PropTypes.arrayOf(\n    PropTypes.shape({\n      region: PropTypes.string.isRequired,\n      ...LocalMoranStatisticsPropType\n    })\n  )),\n  local: PropTypes.objectOf(LocalMoranStatisticsPropType),\n  selectedRegion: PropTypes.string,\n  onRegionSelect: PropTypes.func.isRequired,\n  showStrengthMetrics: PropTypes.bool\n};\n\nexport const SpatialAnalysisPanelPropTypes = {\n  global: GlobalMoranStatisticsPropType,\n  local: PropTypes.objectOf(LocalMoranStatisticsPropType),\n  selectedRegion: PropTypes.string,\n  clusters: PropTypes.objectOf(PropTypes.arrayOf(\n    PropTypes.shape({\n      region: PropTypes.string.isRequired,\n      ...LocalMoranStatisticsPropType\n    })\n  )),\n  spatialMetrics: SpatialMetricsPropType,\n  showAdvancedMetrics: PropTypes.bool\n};\n\nexport const SpatialAnalysisErrorBoundaryPropTypes = {\n  children: PropTypes.node.isRequired,\n  fallback: PropTypes.node,\n  onError: PropTypes.func\n};\n\nexport const PerformanceMonitorPanelPropTypes = {\n  refreshInterval: PropTypes.number,\n  showSuggestions: PropTypes.bool,\n  onOptimizationRequest: PropTypes.func\n};\n\nexport const SpatialOptimizationPropTypes = {\n  transformData: PropTypes.bool,\n  cacheKey: PropTypes.string,\n  optimizationLevel: PropTypes.oneOf(['low', 'medium', 'high'])\n};\n\nexport default {\n  SIGNIFICANCE_LEVELS,\n  CLUSTER_TYPES,\n  CLUSTER_COLORS,\n  DEFAULT_SPATIAL_METRICS,\n  DEFAULT_CLUSTER_SUMMARY\n};\n",
        "imports": [
          "prop-types"
        ],
        "exports": [
          "SIGNIFICANCE_LEVELS",
          "CLUSTER_TYPES",
          "CLUSTER_COLORS",
          "DEFAULT_SPATIAL_METRICS",
          "DEFAULT_CLUSTER_SUMMARY",
          "LocalMoranStatisticsPropType",
          "GlobalMoranStatisticsPropType",
          "ClusterAnalysisPropType",
          "SpatialMetricsPropType",
          "LISAMapPropTypes",
          "MoranScatterPlotPropTypes",
          "ClusterMatrixPropTypes",
          "SpatialAnalysisPanelPropTypes",
          "SpatialAnalysisErrorBoundaryPropTypes",
          "PerformanceMonitorPanelPropTypes",
          "SpatialOptimizationPropTypes",
          "default"
        ],
        "dependencies": [
          "prop-types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/types.ts",
        "content": "/**\n * Types for spatial autocorrelation analysis\n */\n\n// Significance levels for statistical tests\nexport const SIGNIFICANCE_LEVELS = {\n  HIGHLY_SIGNIFICANT: 0.01,\n  SIGNIFICANT: 0.05,\n  MARGINALLY_SIGNIFICANT: 0.1\n} as const;\n\n// Cluster types for LISA analysis\nexport const CLUSTER_TYPES = {\n  HIGH_HIGH: 'high-high',\n  LOW_LOW: 'low-low',\n  HIGH_LOW: 'high-low',\n  LOW_HIGH: 'low-high',\n  NOT_SIGNIFICANT: 'not_significant'\n} as const;\n\n// Colors for different cluster types\nexport const CLUSTER_COLORS = {\n  [CLUSTER_TYPES.HIGH_HIGH]: '#d73027', // Hot spots (red)\n  [CLUSTER_TYPES.LOW_LOW]: '#313695', // Cold spots (blue)\n  [CLUSTER_TYPES.HIGH_LOW]: '#fdae61', // High-Low outliers (orange)\n  [CLUSTER_TYPES.LOW_HIGH]: '#74add1', // Low-High outliers (light blue)\n  [CLUSTER_TYPES.NOT_SIGNIFICANT]: '#969696' // Not significant (gray)\n} as const;\n\n// Default metrics for spatial analysis\nexport const DEFAULT_SPATIAL_METRICS = {\n  globalMoranI: 0,\n  pValue: 1,\n  zScore: 0,\n  avgLocalI: 0,\n  maxLocalI: 0,\n  spatialAssociation: 0,\n  significanceLevels: {\n    highlySignificant: 0,\n    significant: 0,\n    marginal: 0,\n    notSignificant: 0\n  }\n} as const;\n\n// Default summary for cluster analysis\nexport const DEFAULT_CLUSTER_SUMMARY = {\n  totals: {\n    'high-high': 0,\n    'low-low': 0,\n    'high-low': 0,\n    'low-high': 0,\n    'not_significant': 0\n  },\n  significantCount: 0,\n  totalRegions: 0,\n  significanceRate: 0,\n  hotspotRate: 0,\n  coldspotRate: 0,\n  outlierRate: 0\n} as const;\n\n// Types for spatial data\nexport interface TimeSeriesDataPoint {\n  region: string;\n  month: string;\n  usdPrice: number;\n  conflictIntensity: number;\n  additionalProperties?: Record<string, any>;\n}\n\nexport interface GlobalMoranStatistics {\n  moran_i: number;\n  p_value: number;\n  z_score: number;\n  significance: boolean;\n}\n\nexport interface LocalMoranStatistics {\n  local_i: number;\n  p_value: number;\n  z_score: number;\n  cluster_type: keyof typeof CLUSTER_TYPES;\n  variance: number;\n  spatial_lag: number;\n}\n\nexport interface ClusterAnalysis {\n  totals: {\n    [K in keyof typeof CLUSTER_TYPES]: number;\n  };\n  significantCount: number;\n  totalRegions: number;\n  significanceRate: number;\n  hotspotRate: number;\n  coldspotRate: number;\n  outlierRate: number;\n}\n\nexport interface SpatialMetrics {\n  globalMoranI: number;\n  pValue: number;\n  zScore: number;\n  avgLocalI: number;\n  maxLocalI: number;\n  spatialAssociation: number;\n  significanceLevels: {\n    highlySignificant: number;\n    significant: number;\n    marginal: number;\n    notSignificant: number;\n  };\n}\n\nexport interface RegionMetrics extends LocalMoranStatistics {\n  isSignificant: boolean;\n  significanceLevel: string;\n  standardizedValue: number;\n}\n\nexport interface WeightsMatrix {\n  [region: string]: {\n    [neighbor: string]: number;\n  };\n}\n\nexport interface SpatialAutocorrelationState {\n  global: GlobalMoranStatistics | null;\n  local: Record<string, LocalMoranStatistics> | null;\n  clusters: Record<keyof typeof CLUSTER_TYPES, Array<LocalMoranStatistics & { region: string }>> | null;\n  geometry: any; // GeometryData type from your GIS library\n  clusterAnalysis: ClusterAnalysis | null;\n  spatialMetrics: SpatialMetrics | null;\n  getRegionMetrics: (regionId: string) => RegionMetrics | null;\n  isLoading: boolean;\n  hasError: boolean;\n}\n\n// Props for visualization components\nexport interface LISAMapProps {\n  localStats: Record<string, LocalMoranStatistics> | null;\n  geometry: any;\n  selectedRegion: string | null;\n  onRegionSelect: (region: string) => void;\n}\n\nexport interface MoranScatterPlotProps {\n  data: Record<string, LocalMoranStatistics> | null;\n  globalMoranI: number;\n  selectedRegion: string | null;\n  onPointSelect: (region: string) => void;\n}\n\nexport interface ClusterMatrixProps {\n  clusters: Record<keyof typeof CLUSTER_TYPES, Array<LocalMoranStatistics & { region: string }>> | null;\n  local: Record<string, LocalMoranStatistics> | null;\n  selectedRegion: string | null;\n  onRegionSelect: (region: string) => void;\n}\n\nexport interface SpatialAnalysisPanelProps {\n  global: GlobalMoranStatistics | null;\n  local: Record<string, LocalMoranStatistics> | null;\n  selectedRegion: string | null;\n  clusters: Record<keyof typeof CLUSTER_TYPES, Array<LocalMoranStatistics & { region: string }>> | null;\n  spatialMetrics: SpatialMetrics | null;\n}\n\n// Error boundary props\nexport interface SpatialAnalysisErrorBoundaryProps {\n  children: React.ReactNode;\n  fallback?: React.ReactNode;\n}\n\n// Performance monitor props\nexport interface PerformanceMonitorPanelProps {\n  refreshInterval?: number;\n  showSuggestions?: boolean;\n}\n\n// Spatial optimization props\nexport interface SpatialOptimizationProps {\n  transformData?: boolean;\n  cacheKey?: string;\n}\n",
        "imports": [],
        "exports": [
          "SIGNIFICANCE_LEVELS",
          "CLUSTER_TYPES",
          "CLUSTER_COLORS",
          "DEFAULT_SPATIAL_METRICS",
          "DEFAULT_CLUSTER_SUMMARY",
          "TimeSeriesDataPoint",
          "GlobalMoranStatistics",
          "LocalMoranStatistics",
          "ClusterAnalysis",
          "SpatialMetrics",
          "RegionMetrics",
          "WeightsMatrix",
          "SpatialAutocorrelationState",
          "LISAMapProps",
          "MoranScatterPlotProps",
          "ClusterMatrixProps",
          "SpatialAnalysisPanelProps",
          "SpatialAnalysisErrorBoundaryProps",
          "PerformanceMonitorPanelProps",
          "SpatialOptimizationProps"
        ],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/utils/__tests__/spatialCalculations.test.js",
        "content": "import {\n  calculateGlobalMoranI,\n  calculateLocalMoranI\n} from '../spatialCalculations';\n\ndescribe('Spatial Calculations', () => {\n  // Mock data\n  const mockData = [\n    { region: 'region1', usdPrice: 10 },\n    { region: 'region2', usdPrice: 15 },\n    { region: 'region3', usdPrice: 5 },\n    { region: 'region4', usdPrice: 20 }\n  ];\n\n  const mockWeights = {\n    'region1': { 'region2': 1, 'region3': 1, 'region4': 0 },\n    'region2': { 'region1': 1, 'region3': 0, 'region4': 1 },\n    'region3': { 'region1': 1, 'region2': 0, 'region4': 1 },\n    'region4': { 'region1': 0, 'region2': 1, 'region3': 1 }\n  };\n\n  describe('Global Moran\\'s I', () => {\n    it('should calculate global Moran\\'s I statistics', () => {\n      const result = calculateGlobalMoranI(mockData, mockWeights);\n\n      expect(result).toHaveProperty('moran_i');\n      expect(result).toHaveProperty('p_value');\n      expect(result).toHaveProperty('z_score');\n      expect(result).toHaveProperty('significance');\n\n      expect(typeof result.moran_i).toBe('number');\n      expect(typeof result.p_value).toBe('number');\n      expect(typeof result.z_score).toBe('number');\n      expect(typeof result.significance).toBe('boolean');\n    });\n\n    it('should handle null/undefined data', () => {\n      const result = calculateGlobalMoranI(null, mockWeights);\n      expect(result).toEqual({\n        moran_i: 0,\n        p_value: 0,\n        z_score: 0,\n        significance: false\n      });\n    });\n\n    it('should handle empty data array', () => {\n      const result = calculateGlobalMoranI([], mockWeights);\n      expect(result).toEqual({\n        moran_i: 0,\n        p_value: 0,\n        z_score: 0,\n        significance: false\n      });\n    });\n\n    it('should handle missing weights', () => {\n      const result = calculateGlobalMoranI(mockData, null);\n      expect(result).toEqual({\n        moran_i: 0,\n        p_value: 0,\n        z_score: 0,\n        significance: false\n      });\n    });\n\n    it('should calculate expected values for known case', () => {\n      const simpleData = [\n        { region: 'A', usdPrice: 100 },\n        { region: 'B', usdPrice: 90 }\n      ];\n      const simpleWeights = {\n        'A': { 'B': 1 },\n        'B': { 'A': 1 }\n      };\n\n      const result = calculateGlobalMoranI(simpleData, simpleWeights);\n      expect(result.moran_i).toBeCloseTo(-1, 1); // Perfect negative correlation\n      expect(result.significance).toBe(true);\n    });\n  });\n\n  describe('Local Moran\\'s I', () => {\n    it('should calculate local Moran\\'s I statistics for each region', () => {\n      const result = calculateLocalMoranI(mockData, mockWeights);\n\n      expect(Object.keys(result)).toHaveLength(mockData.length);\n      \n      Object.values(result).forEach(stats => {\n        expect(stats).toHaveProperty('local_i');\n        expect(stats).toHaveProperty('p_value');\n        expect(stats).toHaveProperty('z_score');\n        expect(stats).toHaveProperty('cluster_type');\n        expect(stats).toHaveProperty('variance');\n        expect(stats).toHaveProperty('spatial_lag');\n      });\n    });\n\n    it('should handle null/undefined data', () => {\n      const result = calculateLocalMoranI(null, mockWeights);\n      expect(result).toEqual({});\n    });\n\n    it('should handle empty data array', () => {\n      const result = calculateLocalMoranI([], mockWeights);\n      expect(result).toEqual({});\n    });\n\n    it('should handle missing weights', () => {\n      const result = calculateLocalMoranI(mockData, null);\n      expect(result).toEqual({});\n    });\n\n    it('should identify correct cluster types', () => {\n      const simpleData = [\n        { region: 'high1', usdPrice: 100 },\n        { region: 'high2', usdPrice: 95 },\n        { region: 'low1', usdPrice: 10 },\n        { region: 'low2', usdPrice: 15 }\n      ];\n\n      const simpleWeights = {\n        'high1': { 'high2': 1, 'low1': 0, 'low2': 0 },\n        'high2': { 'high1': 1, 'low1': 0, 'low2': 0 },\n        'low1': { 'high1': 0, 'high2': 0, 'low2': 1 },\n        'low2': { 'high1': 0, 'high2': 0, 'low1': 1 }\n      };\n\n      const result = calculateLocalMoranI(simpleData, simpleWeights);\n\n      expect(result.high1.cluster_type).toBe('high-high');\n      expect(result.high2.cluster_type).toBe('high-high');\n      expect(result.low1.cluster_type).toBe('low-low');\n      expect(result.low2.cluster_type).toBe('low-low');\n    });\n\n    it('should calculate spatial lag correctly', () => {\n      const simpleData = [\n        { region: 'A', usdPrice: 100 },\n        { region: 'B', usdPrice: 50 }\n      ];\n      const simpleWeights = {\n        'A': { 'B': 1 },\n        'B': { 'A': 1 }\n      };\n\n      const result = calculateLocalMoranI(simpleData, simpleWeights);\n      expect(result.A.spatial_lag).toBeDefined();\n      expect(result.B.spatial_lag).toBeDefined();\n      expect(result.A.spatial_lag).toBe(-result.B.spatial_lag); // Should be opposite for two regions\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle regions with no neighbors', () => {\n      const isolatedData = [\n        { region: 'isolated', usdPrice: 100 },\n        { region: 'connected1', usdPrice: 50 },\n        { region: 'connected2', usdPrice: 75 }\n      ];\n      const isolatedWeights = {\n        'isolated': {},\n        'connected1': { 'connected2': 1 },\n        'connected2': { 'connected1': 1 }\n      };\n\n      const result = calculateLocalMoranI(isolatedData, isolatedWeights);\n      expect(result.isolated.cluster_type).toBe('not_significant');\n    });\n\n    it('should handle extreme values', () => {\n      const extremeData = [\n        { region: 'normal', usdPrice: 100 },\n        { region: 'extreme', usdPrice: 1000000 }\n      ];\n      const weights = {\n        'normal': { 'extreme': 1 },\n        'extreme': { 'normal': 1 }\n      };\n\n      const result = calculateLocalMoranI(extremeData, weights);\n      expect(result.extreme).toBeDefined();\n      expect(result.normal).toBeDefined();\n    });\n\n    it('should handle zero values', () => {\n      const zeroData = [\n        { region: 'zero', usdPrice: 0 },\n        { region: 'nonzero', usdPrice: 100 }\n      ];\n      const weights = {\n        'zero': { 'nonzero': 1 },\n        'nonzero': { 'zero': 1 }\n      };\n\n      const result = calculateLocalMoranI(zeroData, weights);\n      expect(result.zero).toBeDefined();\n      expect(result.nonzero).toBeDefined();\n    });\n  });\n});\n",
        "imports": [
          "../spatialCalculations"
        ],
        "exports": [],
        "dependencies": [
          "../spatialCalculations"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/autocorrelation/utils/spatialCalculations.js",
        "content": "import { mean, sum } from 'd3-array';\n\n/**\n * Create spatial weights matrix from flow data with improved normalization\n */\nconst createSpatialWeightsMatrix = (flowData) => {\n  const weights = {};\n  \n  // Initialize weights matrix\n  flowData.forEach(flow => {\n    if (!weights[flow.source]) weights[flow.source] = {};\n    if (!weights[flow.target]) weights[flow.target] = {};\n  });\n\n  // Calculate max flow for normalization\n  const maxFlow = Math.max(...flowData.map(flow => flow.avg_flow));\n\n  // Fill weights matrix using normalized flow data\n  flowData.forEach(flow => {\n    // Normalize flows to [0,1] range and ensure symmetry\n    const normalizedWeight = flow.avg_flow / maxFlow;\n    weights[flow.source][flow.target] = normalizedWeight;\n    weights[flow.target][flow.source] = normalizedWeight;\n  });\n\n  // Row standardize the weights matrix\n  Object.keys(weights).forEach(region => {\n    const rowSum = Object.values(weights[region]).reduce((sum, weight) => sum + weight, 0);\n    if (rowSum > 0) {\n      Object.keys(weights[region]).forEach(neighbor => {\n        weights[region][neighbor] = weights[region][neighbor] / rowSum;\n      });\n    }\n  });\n\n  return weights;\n};\n\n/**\n * Calculate Global Moran's I statistic with improved inference\n */\nexport const calculateGlobalMoranI = (data, flowData) => {\n  if (!data?.length || !flowData?.length) {\n    return {\n      moran_i: 0,\n      p_value: 1,\n      z_score: 0,\n      significance: false\n    };\n  }\n\n  try {\n    // Create spatial weights matrix from flow data\n    const weights = createSpatialWeightsMatrix(flowData);\n\n    // Extract values and calculate mean\n    const values = data.map(d => d.usdPrice);\n    const dataMean = mean(values);\n    const deviations = values.map(val => val - dataMean);\n    \n    // Calculate numerator (spatial covariance) and denominator\n    let numerator = 0;\n    let denominator = sum(deviations.map(d => d * d));\n    let sumWeights = 0;\n\n    // Calculate Moran's I components with improved precision\n    data.forEach((observation, i) => {\n      const region = observation.region;\n      data.forEach((neighbor, j) => {\n        if (i !== j) {\n          const weight = weights[region]?.[neighbor.region] || 0;\n          numerator += weight * deviations[i] * deviations[j];\n          sumWeights += weight;\n        }\n      });\n    });\n\n    // Ensure valid denominator\n    if (Math.abs(denominator) < 1e-10) denominator = 1e-10;\n\n    // Calculate Moran's I with improved numerical stability\n    const n = data.length;\n    const moranI = (n / sumWeights) * (numerator / denominator);\n\n    // Calculate expected I and variance with improved precision\n    const expectedI = -1 / (n - 1);\n    const variance = calculateMoranVariance(n, sumWeights, weights, deviations);\n\n    // Calculate z-score and p-value with improved significance testing\n    const zScore = (moranI - expectedI) / Math.sqrt(variance);\n    const pValue = calculatePValue(zScore);\n\n    return {\n      moran_i: moranI,\n      p_value: pValue,\n      z_score: zScore,\n      significance: pValue <= 0.05\n    };\n  } catch (error) {\n    console.error('Error calculating Global Moran\\'s I:', error);\n    return {\n      moran_i: 0,\n      p_value: 1,\n      z_score: 0,\n      significance: false\n    };\n  }\n};\n\n/**\n * Calculate Local Moran's I statistics with improved inference\n */\nexport const calculateLocalMoranI = (data, flowData) => {\n  if (!data?.length || !flowData?.length) {\n    return {};\n  }\n\n  try {\n    // Create spatial weights matrix from flow data\n    const weights = createSpatialWeightsMatrix(flowData);\n\n    // Calculate global statistics with improved precision\n    const values = data.map(d => d.usdPrice);\n    const dataMean = mean(values);\n    const dataStd = calculateStandardDeviation(values);\n    const deviations = values.map(val => val - dataMean);\n\n    // Ensure valid variance\n    const variance = Math.max(dataStd * dataStd, 1e-10);\n\n    const results = {};\n\n    // Calculate local statistics for each region with improved inference\n    data.forEach((observation, i) => {\n      const region = observation.region;\n      let localI = 0;\n      let weightSum = 0;\n\n      // Calculate spatial lag with improved precision\n      data.forEach((neighbor, j) => {\n        if (i !== j) {\n          const weight = weights[region]?.[neighbor.region] || 0;\n          localI += weight * deviations[j];\n          weightSum += weight;\n        }\n      });\n\n      // Standardize local I with improved numerical stability\n      const standardizedI = (deviations[i] / variance) * localI;\n\n      // Calculate variance and z-score with improved inference\n      const localVariance = calculateLocalVariance(weights[region], deviations, variance, weightSum);\n      const zScore = standardizedI / Math.sqrt(localVariance);\n      const pValue = calculatePValue(zScore);\n\n      // Determine cluster type using standardized values\n      const clusterType = determineClusterType(\n        deviations[i] / dataStd, \n        standardizedI, \n        pValue\n      );\n\n      results[region] = {\n        local_i: standardizedI,\n        z_score: zScore,\n        p_value: pValue,\n        cluster_type: clusterType,\n        variance: localVariance,\n        spatial_lag: localI / Math.max(Math.abs(deviations[i]), 1e-10)\n      };\n    });\n\n    return results;\n  } catch (error) {\n    console.error('Error calculating Local Moran\\'s I:', error);\n    return {};\n  }\n};\n\n/**\n * Calculate standard deviation with improved numerical stability\n */\nconst calculateStandardDeviation = (values) => {\n  if (!values?.length) return 0;\n  const avg = mean(values);\n  const squareDiffs = values.map(value => Math.pow(value - avg, 2));\n  return Math.sqrt(Math.max(mean(squareDiffs), 1e-10));\n};\n\n/**\n * Calculate variance for Moran's I with improved precision\n */\nconst calculateMoranVariance = (n, sumWeights, weights, deviations) => {\n  const s1 = calculateS1(weights);\n  const s2 = calculateS2(weights);\n  \n  // Calculate moments with improved numerical stability\n  const m2 = Math.max(sum(deviations.map(d => d * d)) / n, 1e-10);\n  const m4 = Math.max(sum(deviations.map(d => d * d * d * d)) / n, 1e-10);\n\n  const term1 = n * ((n * n - 3 * n + 3) * s1 - n * s2 + 3 * sumWeights * sumWeights);\n  const term2 = (m4 / (m2 * m2)) * ((n * n - n) * s1 - 2 * n * s2 + 6 * sumWeights * sumWeights);\n  const term3 = -1 * (n - 1) * (n - 2) * (n - 3) * sumWeights * sumWeights;\n\n  return Math.max(\n    (term1 - term2 + term3) / \n    ((n - 1) * (n - 2) * (n - 3) * sumWeights * sumWeights),\n    1e-10\n  );\n};\n\n/**\n * Calculate variance for Local Moran's I with improved precision\n */\nconst calculateLocalVariance = (weights, deviations, variance, weightSum) => {\n  if (!weights || !deviations?.length) return 1e-10;\n  \n  const sumSquaredWeights = Object.values(weights).reduce((sum, w) => sum + w * w, 0);\n  return Math.max(\n    (sumSquaredWeights * (deviations.length - 1)) / \n    ((deviations.length - 2) * variance),\n    1e-10\n  );\n};\n\n/**\n * Calculate p-value from z-score with improved accuracy\n */\nconst calculatePValue = (zScore) => {\n  // Two-tailed test using normal distribution with improved precision\n  if (!isFinite(zScore)) return 1;\n  const absZ = Math.abs(zScore);\n  return 2 * (1 - pnorm(absZ));\n};\n\n/**\n * Calculate S1 statistic with improved precision\n */\nconst calculateS1 = (weights) => {\n  let s1 = 0;\n  Object.entries(weights).forEach(([region, regionWeights]) => {\n    Object.entries(regionWeights).forEach(([neighbor, weight]) => {\n      const symmetricWeight = weight + (weights[neighbor]?.[region] || 0);\n      s1 += symmetricWeight * symmetricWeight;\n    });\n  });\n  return s1 / 2;\n};\n\n/**\n * Calculate S2 statistic with improved precision\n */\nconst calculateS2 = (weights) => {\n  let s2 = 0;\n  Object.entries(weights).forEach(([region, regionWeights]) => {\n    const rowSum = Object.values(regionWeights).reduce((sum, w) => sum + w, 0);\n    const colSum = Object.entries(weights)\n      .reduce((sum, [_, neighborWeights]) => sum + (neighborWeights[region] || 0), 0);\n    s2 += (rowSum + colSum) * (rowSum + colSum);\n  });\n  return s2;\n};\n\n/**\n * Determine cluster type using standardized values\n */\nconst determineClusterType = (standardizedDeviation, localI, pValue) => {\n  if (pValue > 0.05) return 'not_significant';\n  \n  // Use standardized values for more robust classification\n  const threshold = 0;\n  if (standardizedDeviation > threshold && localI > threshold) return 'high-high';\n  if (standardizedDeviation < -threshold && localI < -threshold) return 'low-low';\n  if (standardizedDeviation > threshold && localI < -threshold) return 'high-low';\n  if (standardizedDeviation < -threshold && localI > threshold) return 'low-high';\n  \n  return 'not_significant';\n};\n\n/**\n * Standard normal cumulative distribution function with improved precision\n */\nconst pnorm = (z) => {\n  if (z < -8) return 0;\n  if (z > 8) return 1;\n  \n  // Constants for improved numerical approximation\n  const p = 0.2316419;\n  const b1 = 0.31938153;\n  const b2 = -0.356563782;\n  const b3 = 1.781477937;\n  const b4 = -1.821255978;\n  const b5 = 1.330274429;\n  \n  const a = Math.abs(z);\n  const t = 1.0 / (1.0 + a * p);\n  \n  // Calculate with improved precision\n  const b = 0.3989423 * Math.exp(-0.5 * z * z);\n  let n = ((((b5 * t + b4) * t + b3) * t + b2) * t + b1) * t;\n  n = 1.0 - b * n;\n  \n  return z < 0 ? 1 - n : n;\n};\n\nexport default {\n  calculateGlobalMoranI,\n  calculateLocalMoranI\n};\n",
        "imports": [
          "d3-array"
        ],
        "exports": [
          "calculateGlobalMoranI",
          "calculateLocalMoranI",
          "default"
        ],
        "dependencies": [
          "d3-array"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/clusters/ClusterAnalysis.js",
        "content": "// src/components/spatialAnalysis/features/clusters/ClusterAnalysis.js\n\nimport React, { useState, useCallback, useEffect } from 'react';\nimport {\n  Grid,\n  Paper,\n  Typography,\n  Box,\n  Alert,\n  useTheme,\n  Fade,\n  Button,\n  Collapse,\n  List,\n  ListItem,\n  ListItemText,\n  Divider,\n  Tooltip\n} from '@mui/material';\nimport { useSelector } from 'react-redux';\nimport MouseIcon from '@mui/icons-material/Mouse';\nimport InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\n\nimport ClusterMap from '../../organisms/ClusterMap';\nimport MetricCard from '../../atoms/MetricCard';\nimport MetricProgress from '../../molecules/MetricProgress';\nimport { useClustersWithCoordinates } from '../../../../hooks/useSpatialSelectors';\nimport { selectGeometryData } from '../../../../selectors/optimizedSelectors';\nimport { useClusterAnalysis } from '../../hooks/useClusterAnalysis';\n\n// Enhanced efficiency explanation with tooltips\nconst EfficiencyExplanation = ({ efficiencyComponents }) => {\n  const theme = useTheme();\n  \n  useEffect(() => {\n    console.debug('Efficiency Components:', efficiencyComponents);\n  }, [efficiencyComponents]);\n  \n  return (\n    <Box sx={{ \n      mt: 2,\n      p: 2,\n      bgcolor: theme.palette.grey[50],\n      borderRadius: 1,\n      boxShadow: 1\n    }}>\n      <Typography variant=\"subtitle2\" gutterBottom color=\"primary\">\n        Market Efficiency Components\n      </Typography>\n      <Grid container spacing={2}>\n        <Grid item xs={12} md={3}>\n          <Tooltip title=\"Measures the strength and density of market connections within the cluster\">\n            <Box>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                Market Connectivity (40%)\n              </Typography>\n              <Typography variant=\"body2\" fontWeight=\"medium\">\n                {(efficiencyComponents?.connectivity * 100).toFixed(1)}%\n              </Typography>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                Internal market connections\n              </Typography>\n            </Box>\n          </Tooltip>\n        </Grid>\n        <Grid item xs={12} md={3}>\n          <Tooltip title=\"Evaluates the degree of price correlation between markets in the cluster\">\n            <Box>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                Price Integration (30%)\n              </Typography>\n              <Typography variant=\"body2\" fontWeight=\"medium\">\n                {(efficiencyComponents?.priceIntegration * 100).toFixed(1)}%\n              </Typography>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                Price correlation between markets\n              </Typography>\n            </Box>\n          </Tooltip>\n        </Grid>\n        <Grid item xs={12} md={3}>\n          <Tooltip title=\"Measures the consistency and predictability of prices over time\">\n            <Box>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                Price Stability (20%)\n              </Typography>\n              <Typography variant=\"body2\" fontWeight=\"medium\">\n                {(efficiencyComponents?.stability * 100).toFixed(1)}%\n              </Typography>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                Price consistency over time\n              </Typography>\n            </Box>\n          </Tooltip>\n        </Grid>\n        <Grid item xs={12} md={3}>\n          <Tooltip title=\"Assesses the market's ability to maintain function during conflict\">\n            <Box>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                Conflict Resilience (10%)\n              </Typography>\n              <Typography variant=\"body2\" fontWeight=\"medium\">\n                {(efficiencyComponents?.conflictResilience * 100).toFixed(1)}%\n              </Typography>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                Market function under conflict\n              </Typography>\n            </Box>\n          </Tooltip>\n        </Grid>\n      </Grid>\n    </Box>\n  );\n};\n\n// Enhanced efficiency metric card\nconst ClusterEfficiencyMetric = ({ value, showTooltip = false }) => {\n  useEffect(() => {\n    console.debug('Cluster Efficiency Value:', value);\n  }, [value]);\n\n  return (\n    <MetricProgress\n      title=\"Cluster Efficiency\"\n      value={value}\n      format=\"percentage\"\n      description=\"Market integration efficiency\"\n      showTarget={false}\n      tooltip={showTooltip ? `\n        Comprehensive measure of market cluster performance:\n        • Market Connectivity (40%): Network strength\n        • Price Integration (30%): Price correlation\n        • Price Stability (20%): Temporal consistency\n        • Conflict Resilience (10%): Stress resistance\n      ` : undefined}\n    />\n  );\n};\n\nconst ClusterAnalysis = () => {\n  const theme = useTheme();\n  const [selectedClusterId, setSelectedClusterId] = useState(null);\n  const [showHelp, setShowHelp] = useState(true);\n  const [showMethodology, setShowMethodology] = useState(false);\n  \n  // Use cluster analysis hook\n  const { clusters: processedClusters, selectedCluster, metrics: overallMetrics } = useClusterAnalysis(selectedClusterId);\n  const geometry = useSelector(selectGeometryData);\n\n  // Ensure we have valid values for metrics\n  const safeMetrics = {\n    totalMarkets: overallMetrics?.totalMarkets || 0,\n    marketCoverage: overallMetrics?.marketCoverage || 0,\n    avgPrice: overallMetrics?.avgPrice || 0,\n    avgConflict: overallMetrics?.avgConflict || 0\n  };\n\n  // Hide help text when a cluster is selected\n  useEffect(() => {\n    if (selectedClusterId) {\n      setShowHelp(false);\n    }\n  }, [selectedClusterId]);\n\n  // Handle cluster selection\n  const handleClusterSelect = useCallback((clusterId) => {\n    console.debug('Selected Cluster ID:', clusterId);\n    setSelectedClusterId(clusterId);\n  }, []);\n\n  if (!processedClusters?.length) {\n    return (\n      <Alert severity=\"info\" sx={{ m: 2 }}>\n        No market cluster data available for analysis. Please ensure data is properly loaded.\n      </Alert>\n    );\n  }\n\n  return (\n    <Grid container spacing={2}>\n      {/* Overview Metrics */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2, boxShadow: 2 }}>\n          <Typography variant=\"h6\" gutterBottom color=\"primary\">\n            Market Cluster Overview\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={12} md={3}>\n              <Tooltip title=\"Total number of markets included in identified clusters\">\n                <Box>\n                  <MetricCard\n                    title=\"Total Markets\"\n                    value={safeMetrics.totalMarkets}\n                    format=\"integer\"\n                    description=\"Markets in clusters\"\n                  />\n                </Box>\n              </Tooltip>\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Tooltip title=\"Percentage of total markets that are part of identified clusters\">\n                <Box>\n                  <MetricProgress\n                    title=\"Market Coverage\"\n                    value={safeMetrics.marketCoverage}\n                    format=\"percentage\"\n                    description=\"Markets in clusters\"\n                    showTarget={false}\n                  />\n                </Box>\n              </Tooltip>\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Tooltip title=\"Average commodity price across all clustered markets\">\n                <Box>\n                  <MetricCard\n                    title=\"Average Price\"\n                    value={safeMetrics.avgPrice}\n                    format=\"currency\"\n                    description=\"Across clusters\"\n                  />\n                </Box>\n              </Tooltip>\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Tooltip title=\"Average conflict intensity affecting market clusters\">\n                <Box>\n                  <MetricCard\n                    title=\"Conflict Impact\"\n                    value={safeMetrics.avgConflict}\n                    format=\"number\"\n                    description=\"Conflict intensity\"\n                  />\n                </Box>\n              </Tooltip>\n            </Grid>\n          </Grid>\n        </Paper>\n      </Grid>\n\n      {/* Cluster Map */}\n      <Grid item xs={12}>\n        <Paper sx={{ height: 600, p: 2, position: 'relative', boxShadow: 2 }}>\n          <ClusterMap\n            clusters={processedClusters}\n            selectedClusterId={selectedClusterId}\n            onClusterSelect={handleClusterSelect}\n            geometry={geometry}\n          />\n          \n          {/* Help Text */}\n          <Fade in={showHelp}>\n            <Box\n              sx={{\n                position: 'absolute',\n                top: 16,\n                right: 16,\n                bgcolor: 'rgba(255, 255, 255, 0.95)',\n                p: 2,\n                borderRadius: 1,\n                boxShadow: 2,\n                display: 'flex',\n                alignItems: 'center',\n                gap: 1,\n                zIndex: 1000\n              }}\n            >\n              <MouseIcon color=\"primary\" />\n              <Typography variant=\"body2\" color=\"text.secondary\">\n                Click on any colored region to view detailed cluster analysis\n              </Typography>\n            </Box>\n          </Fade>\n        </Paper>\n      </Grid>\n\n      {/* Selected Cluster Details */}\n      {selectedCluster && selectedCluster.metrics && (\n        <Grid item xs={12}>\n          <Paper sx={{ p: 2, boxShadow: 2 }}>\n            <Typography variant=\"h6\" gutterBottom color=\"primary\">\n              {selectedCluster.main_market} Market Cluster Analysis\n            </Typography>\n            <Grid container spacing={2}>\n              <Grid item xs={12} md={3}>\n                <Tooltip title=\"Number of markets connected within this cluster\">\n                  <Box>\n                    <MetricCard\n                      title=\"Connected Markets\"\n                      value={selectedCluster.metrics.marketCount}\n                      format=\"integer\"\n                      description=\"Active connections\"\n                    />\n                  </Box>\n                </Tooltip>\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <ClusterEfficiencyMetric \n                  value={selectedCluster.metrics.efficiency}\n                  showTooltip={true}\n                />\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <Tooltip title=\"Average commodity price within this cluster\">\n                  <Box>\n                    <MetricCard\n                      title=\"Average Price\"\n                      value={selectedCluster.metrics.avgPrice}\n                      format=\"currency\"\n                      description=\"Cluster average\"\n                    />\n                  </Box>\n                </Tooltip>\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <Tooltip title=\"Average conflict intensity affecting this cluster\">\n                  <Box>\n                    <MetricCard\n                      title=\"Conflict Impact\"\n                      value={selectedCluster.metrics.avgConflict}\n                      format=\"number\"\n                      description=\"Local intensity\"\n                    />\n                  </Box>\n                </Tooltip>\n              </Grid>\n            </Grid>\n            \n            <EfficiencyExplanation \n              efficiencyComponents={selectedCluster.metrics.efficiencyComponents}\n            />\n\n            <Box sx={{ mt: 2, p: 2, bgcolor: theme.palette.grey[50], borderRadius: 1, boxShadow: 1 }}>\n              <Typography variant=\"body2\" color=\"text.secondary\">\n                {`This cluster contains ${selectedCluster.metrics.marketCount} interconnected markets with an efficiency rating of \n                ${(selectedCluster.metrics.efficiency * 100).toFixed(1)}%. \n                ${selectedCluster.metrics.avgConflict > 0.5 ? \n                  'High conflict intensity may be impacting market integration and efficiency.' : \n                  'Market integration remains robust under current conditions.'}`}\n              </Typography>\n            </Box>\n          </Paper>\n        </Grid>\n      )}\n\n      {/* Methodology Section */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2, boxShadow: 2 }}>\n          <Button\n            fullWidth\n            onClick={() => setShowMethodology(!showMethodology)}\n            endIcon={showMethodology ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n            startIcon={<InfoOutlinedIcon />}\n          >\n            Market Cluster Analysis Methodology\n          </Button>\n          <Collapse in={showMethodology}>\n            <Divider sx={{ my: 2 }} />\n            <Typography variant=\"subtitle1\" gutterBottom color=\"primary\">\n              Understanding Market Cluster Analysis\n            </Typography>\n            <Typography variant=\"body2\" paragraph>\n              Market clusters are identified and analyzed using a comprehensive approach that combines\n              spatial relationships, price dynamics, and conflict impact assessment:\n            </Typography>\n            <List dense>\n              <ListItem>\n                <ListItemText\n                  primary={\n                    <Typography variant=\"subtitle2\" color=\"primary\">\n                      Cluster Identification\n                    </Typography>\n                  }\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Markets are grouped based on spatial proximity, trade relationships,\n                      and price correlation patterns\n                    </Typography>\n                  }\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary={\n                    <Typography variant=\"subtitle2\" color=\"primary\">\n                      Efficiency Calculation\n                    </Typography>\n                  }\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Cluster efficiency is measured through market connectivity (40%),\n                      price integration (30%), stability (20%), and conflict resilience (10%)\n                    </Typography>\n                  }\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary={\n                    <Typography variant=\"subtitle2\" color=\"primary\">\n                      Impact Assessment\n                    </Typography>\n                  }\n                  secondary={\n                    <Typography variant=\"body2\" color=\"textSecondary\">\n                      Conflict impact is evaluated through market disruption patterns,\n                      price volatility, and trade flow changes\n                    </Typography>\n                  }\n                />\n              </ListItem>\n            </List>\n            <Box sx={{ mt: 2, p: 2, bgcolor: 'background.paper', borderRadius: 1 }}>\n              <Typography variant=\"subtitle2\" gutterBottom color=\"primary\">\n                Interpretation Guide:\n              </Typography>\n              <Typography variant=\"body2\" component=\"div\">\n                • High Efficiency (&gt;70%): Strong market integration and resilience<br/>\n                • Medium Efficiency (40-70%): Moderate market function with some constraints<br/>\n                • Low Efficiency (&lt;40%): Significant market fragmentation or disruption\n              </Typography>\n            </Box>\n          </Collapse>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default React.memo(ClusterAnalysis);\n",
        "imports": [
          "react",
          "@mui/material",
          "react-redux",
          "@mui/icons-material/Mouse",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "../../organisms/ClusterMap",
          "../../atoms/MetricCard",
          "../../molecules/MetricProgress",
          "../../../../hooks/useSpatialSelectors",
          "../../../../selectors/optimizedSelectors",
          "../../hooks/useClusterAnalysis"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "react-redux",
          "@mui/icons-material/Mouse",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "../../organisms/ClusterMap",
          "../../atoms/MetricCard",
          "../../molecules/MetricProgress",
          "../../../../hooks/useSpatialSelectors",
          "../../../../selectors/optimizedSelectors",
          "../../hooks/useClusterAnalysis"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/clusters/index.js",
        "content": "//src/components/spatialAnalysis/features/clusters/index.js\n\nexport { default as ClusterAnalysis } from './ClusterAnalysis';\nexport { ClusterTypes, DEFAULT_METRICS } from './types';\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/clusters/types.js",
        "content": "//src/components/spatialAnalysis/features/clusters/types.js\n\n/**\n * Types and constants for market cluster analysis\n */\n\n// Integration levels for market clusters\nexport const ClusterTypes = {\n  HIGH_INTEGRATION: 'high_integration',      // Strong market connections and price correlation\n  MODERATE_INTEGRATION: 'moderate_integration', // Partial market integration\n  LOW_INTEGRATION: 'low_integration',        // Weak or fragmented markets\n  TRANSITIONAL: 'transitional'               // Markets in transition\n};\n\n// Significance levels for statistical testing\nexport const SIGNIFICANCE_LEVELS = {\n  HIGH: 0.01,    // 99% confidence\n  MEDIUM: 0.05,  // 95% confidence\n  LOW: 0.1       // 90% confidence\n};\n\n// Thresholds for efficiency classification\nexport const EFFICIENCY_THRESHOLDS = {\n  HIGH: 0.7,     // High efficiency (>70%)\n  MEDIUM: 0.4,   // Medium efficiency (40-70%)\n  LOW: 0.2       // Low efficiency (<40%)\n};\n\n// Component weights for efficiency calculation\nexport const COMPONENT_WEIGHTS = {\n  CONNECTIVITY: 0.4,      // Market network strength (40%)\n  PRICE_INTEGRATION: 0.3, // Price correlation (30%)\n  STABILITY: 0.2,         // Price stability (20%)\n  RESILIENCE: 0.1        // Conflict resilience (10%)\n};\n\n// Default metrics for market clusters\nexport const DEFAULT_METRICS = {\n  // Basic metrics\n  avgPrice: 0,\n  avgConflict: 0,\n  marketCount: 0,\n  \n  // Efficiency components\n  efficiency: 0,\n  efficiencyComponents: {\n    connectivity: 0,\n    priceIntegration: 0,\n    stability: 0,\n    conflictResilience: 0\n  },\n\n  // Statistical measures\n  significance: {\n    pValue: 1,\n    confidence: 0,\n    reliability: 0\n  },\n\n  // Detailed metrics\n  details: {\n    priceVolatility: 0,\n    integrationScore: 0,\n    stabilityScore: 0,\n    resilience: 0,\n    coverage: 0,\n    dataQuality: 0\n  }\n};\n\n// Analysis parameters\nexport const ANALYSIS_PARAMS = {\n  MIN_MARKETS: 2,           // Minimum markets for valid cluster\n  MIN_DATA_POINTS: 3,       // Minimum data points for analysis\n  MAX_PRICE_VARIANCE: 10,   // Maximum acceptable price variance\n  CONFIDENCE_LEVEL: 0.95    // Default confidence level\n};\n\n// Market relationship types\nexport const MARKET_RELATIONSHIPS = {\n  LEADER: 'leader',           // Price-setting market\n  FOLLOWER: 'follower',       // Price-following market\n  INDEPENDENT: 'independent', // Autonomous market\n  ISOLATED: 'isolated'       // Disconnected market\n};\n\n// Data quality indicators\nexport const DATA_QUALITY = {\n  HIGH: 'high',       // Complete and reliable data\n  MEDIUM: 'medium',   // Partial or moderately reliable data\n  LOW: 'low',         // Limited or potentially unreliable data\n  INSUFFICIENT: 'insufficient' // Not enough data for analysis\n};\n\n// Metric calculation methods\nexport const CALCULATION_METHODS = {\n  PEARSON: 'pearson',           // Pearson correlation\n  SPEARMAN: 'spearman',         // Spearman rank correlation\n  KENDALL: 'kendall',           // Kendall rank correlation\n  CUSTOM: 'custom'              // Custom calculation method\n};\n\n// Export all types and constants\nexport default {\n  ClusterTypes,\n  SIGNIFICANCE_LEVELS,\n  EFFICIENCY_THRESHOLDS,\n  COMPONENT_WEIGHTS,\n  DEFAULT_METRICS,\n  ANALYSIS_PARAMS,\n  MARKET_RELATIONSHIPS,\n  DATA_QUALITY,\n  CALCULATION_METHODS\n};\n",
        "imports": [],
        "exports": [
          "ClusterTypes",
          "SIGNIFICANCE_LEVELS",
          "EFFICIENCY_THRESHOLDS",
          "COMPONENT_WEIGHTS",
          "DEFAULT_METRICS",
          "ANALYSIS_PARAMS",
          "MARKET_RELATIONSHIPS",
          "DATA_QUALITY",
          "CALCULATION_METHODS",
          "default"
        ],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/clusters/utils/clusterCalculations.js",
        "content": "//src/components/spatialAnalysis/features/clusters/utils/clusterCalculations.js\n\n/**\n * Market Cluster Analysis Calculations\n */\n\nimport { transformRegionName } from '../../../utils/spatialUtils';\nimport { SIGNIFICANCE_LEVELS, EFFICIENCY_THRESHOLDS, COMPONENT_WEIGHTS } from '../types';\n\n/**\n * Helper function for t-distribution probability\n */\nfunction tDistribution(t, df) {\n  // Approximation of t-distribution CDF\n  const x = df / (df + t * t);\n  return 1 - 0.5 * incompleteBeta(df/2, 0.5, x);\n}\n\n/**\n * Helper function for incomplete beta function\n */\nfunction incompleteBeta(a, b, x) {\n  // Basic approximation for incomplete beta function\n  if (x === 0) return 0;\n  if (x === 1) return 1;\n  return x ** a * (1 - x) ** b;\n}\n\n/**\n * Calculate correlation between price series with statistical validation\n */\nfunction calculateCorrelation(prices1, prices2) {\n  if (prices1.length !== prices2.length || prices1.length < 3) {\n    return { correlation: 0, significant: false };\n  }\n\n  const avg1 = prices1.reduce((a, b) => a + b, 0) / prices1.length;\n  const avg2 = prices2.reduce((a, b) => a + b, 0) / prices2.length;\n\n  let numerator = 0;\n  let denom1 = 0;\n  let denom2 = 0;\n\n  for (let i = 0; i < prices1.length; i++) {\n    const diff1 = prices1[i] - avg1;\n    const diff2 = prices2[i] - avg2;\n    numerator += diff1 * diff2;\n    denom1 += diff1 * diff1;\n    denom2 += diff2 * diff2;\n  }\n\n  const denominator = Math.sqrt(denom1 * denom2);\n  const correlation = denominator === 0 ? 0 : numerator / denominator;\n  \n  // Calculate statistical significance\n  const t = correlation * Math.sqrt((prices1.length - 2) / (1 - correlation * correlation));\n  const pValue = 2 * (1 - tDistribution(Math.abs(t), prices1.length - 2));\n\n  return {\n    correlation: (correlation + 1) / 2, // Normalize to 0-1\n    significant: pValue <= SIGNIFICANCE_LEVELS.MEDIUM,\n    details: {\n      rawCorrelation: correlation,\n      tStatistic: t,\n      pValue,\n      sampleSize: prices1.length\n    }\n  };\n}\n\n/**\n * Create optimized lookup map for time series data\n */\nfunction createTimeSeriesMap(timeSeriesData) {\n  const map = new Map();\n  timeSeriesData.forEach(d => {\n    const key = transformRegionName(d.region);\n    if (!map.has(key)) {\n      map.set(key, []);\n    }\n    map.get(key).push(d);\n  });\n  return map;\n}\n\n/**\n * Create optimized lookup map for flow data\n */\nfunction createFlowsMap(flows) {\n  const map = new Map();\n  flows.forEach(flow => {\n    const source = transformRegionName(flow.source);\n    const target = transformRegionName(flow.target);\n    const key1 = `${source}-${target}`;\n    const key2 = `${target}-${source}`;\n    map.set(key1, flow);\n    map.set(key2, flow); // Store both directions\n  });\n  return map;\n}\n\n/**\n * Calculate market connectivity metrics\n */\nfunction calculateConnectivity(markets, flowsMap) {\n  const potentialConnections = (markets.length * (markets.length - 1)) / 2;\n  let actualConnections = 0;\n  const connections = [];\n  let totalFlow = 0;\n\n  for (let i = 0; i < markets.length; i++) {\n    for (let j = i + 1; j < markets.length; j++) {\n      const key = `${markets[i]}-${markets[j]}`;\n      const reverseKey = `${markets[j]}-${markets[i]}`;\n      \n      const flow = flowsMap.get(key) || flowsMap.get(reverseKey);\n      if (flow) {\n        actualConnections++;\n        connections.push({\n          source: markets[i],\n          target: markets[j],\n          flow: flow.total_flow,\n          avgFlow: flow.avg_flow\n        });\n        totalFlow += flow.total_flow;\n      }\n    }\n  }\n\n  const score = potentialConnections > 0 ? actualConnections / potentialConnections : 0;\n  const coverage = actualConnections / markets.length;\n\n  return {\n    score,\n    details: {\n      connections,\n      coverage,\n      density: score,\n      summary: {\n        actualConnections,\n        potentialConnections,\n        totalFlow,\n        averageFlow: actualConnections > 0 ? totalFlow / actualConnections : 0\n      }\n    }\n  };\n}\n\n/**\n * Calculate market correlations\n */\nfunction calculateMarketCorrelations(marketPrices) {\n  const result = {\n    pairs: [],\n    average: 0,\n    significant: 0,\n    total: 0\n  };\n\n  let totalCorrelation = 0;\n  let correlationPairs = 0;\n\n  Object.entries(marketPrices).forEach(([m1, prices1]) => {\n    Object.entries(marketPrices).forEach(([m2, prices2]) => {\n      if (m1 < m2 && prices1.length > 1 && prices2.length > 1) {\n        const minLength = Math.min(prices1.length, prices2.length);\n        const p1 = prices1.slice(0, minLength);\n        const p2 = prices2.slice(0, minLength);\n        \n        const { correlation, significant } = calculateCorrelation(p1, p2);\n        \n        if (!isNaN(correlation)) {\n          result.pairs.push({\n            markets: [m1, m2],\n            correlation,\n            significant\n          });\n\n          totalCorrelation += correlation;\n          correlationPairs++;\n          if (significant) result.significant++;\n        }\n      }\n    });\n  });\n\n  result.average = correlationPairs > 0 ? totalCorrelation / correlationPairs : 0;\n  result.total = correlationPairs;\n\n  return result;\n}\n\n/**\n * Calculate market volatilities\n */\nfunction calculateMarketVolatilities(markets, timeSeriesMap) {\n  const volatilities = {\n    markets: [],\n    average: 0,\n    coverage: 0\n  };\n\n  let totalVolatility = 0;\n  let marketsWithData = 0;\n\n  markets.forEach(market => {\n    const marketData = timeSeriesMap.get(market) || [];\n    const prices = marketData\n      .filter(d => d.usdPrice != null && !isNaN(d.usdPrice))\n      .map(d => d.usdPrice);\n\n    if (prices.length >= 2) {\n      const avg = prices.reduce((sum, p) => sum + p, 0) / prices.length;\n      const variance = prices.reduce((sum, p) => sum + Math.pow(p - avg, 2), 0) / prices.length;\n      const volatility = Math.sqrt(variance) / avg;\n\n      volatilities.markets.push({ market, volatility });\n      totalVolatility += volatility;\n      marketsWithData++;\n    }\n  });\n\n  volatilities.average = marketsWithData > 0 ? totalVolatility / marketsWithData : 1;\n  volatilities.coverage = marketsWithData / markets.length;\n\n  return volatilities;\n}\n\n/**\n * Calculate conflict impact across markets\n */\nfunction calculateConflictResilience(markets, timeSeriesMap) {\n  const result = {\n    markets: [],\n    average: 0,\n    coverage: 0\n  };\n\n  let totalConflict = 0;\n  let marketsWithData = 0;\n\n  markets.forEach(market => {\n    const marketData = timeSeriesMap.get(market) || [];\n    const conflicts = marketData\n      .filter(d => d.conflictIntensity != null && !isNaN(d.conflictIntensity))\n      .map(d => d.conflictIntensity);\n    \n    if (conflicts.length > 0) {\n      const avgMarketConflict = conflicts.reduce((sum, c) => sum + c, 0) / conflicts.length;\n      result.markets.push({ market, conflict: avgMarketConflict });\n      totalConflict += avgMarketConflict;\n      marketsWithData++;\n    }\n  });\n\n  result.average = marketsWithData > 0 ? totalConflict / marketsWithData : 0;\n  result.coverage = marketsWithData / markets.length;\n  result.score = Math.max(0, 1 - (result.average / 10));\n\n  return result;\n}\n\n/**\n * Calculate price integration metrics\n */\nfunction calculatePriceIntegration(markets, timeSeriesMap) {\n  const marketPrices = {};\n  let totalDataPoints = 0;\n\n  markets.forEach(market => {\n    const marketData = timeSeriesMap.get(market) || [];\n    const prices = marketData\n      .filter(d => d.usdPrice != null && !isNaN(d.usdPrice))\n      .map(d => d.usdPrice);\n    \n    if (prices.length >= 3) {\n      marketPrices[market] = prices;\n      totalDataPoints += prices.length;\n    }\n  });\n\n  const correlations = calculateMarketCorrelations(marketPrices);\n  const avgPrice = Object.values(marketPrices)\n    .flat()\n    .reduce((sum, price) => sum + price, 0) / \n    Object.values(marketPrices)\n      .flat()\n      .length || 0;\n\n  return {\n    score: correlations.average,\n    avgPrice,\n    dataPoints: totalDataPoints,\n    significance: correlations.significant / correlations.total,\n    details: correlations\n  };\n}\n\n/**\n * Calculate price stability metrics\n */\nfunction calculateStability(markets, timeSeriesMap) {\n  const volatilities = calculateMarketVolatilities(markets, timeSeriesMap);\n  const score = Math.max(0, 1 - Math.min(volatilities.average, 1));\n\n  return {\n    score,\n    details: volatilities\n  };\n}\n\n/**\n * Calculate weighted efficiency score\n */\nfunction calculateEfficiencyScore(scores) {\n  return (\n    scores.connectivity * COMPONENT_WEIGHTS.CONNECTIVITY +\n    scores.priceIntegration * COMPONENT_WEIGHTS.PRICE_INTEGRATION +\n    scores.stability * COMPONENT_WEIGHTS.STABILITY +\n    scores.resilience * COMPONENT_WEIGHTS.RESILIENCE\n  );\n}\n\n/**\n * Calculate reliability score\n */\nfunction calculateReliabilityScore({ dataPoints, coverage, significance }) {\n  const dataScore = Math.min(dataPoints / 100, 1);\n  const coverageScore = coverage;\n  const significanceScore = significance;\n\n  return (dataScore + coverageScore + significanceScore) / 3;\n}\n\n/**\n * Create default metrics object\n */\nfunction createDefaultMetrics() {\n  return {\n    efficiency: 0,\n    efficiencyComponents: {\n      connectivity: 0,\n      priceIntegration: 0,\n      stability: 0,\n      conflictResilience: 0\n    },\n    avgPrice: 0,\n    avgConflict: 0,\n    marketCount: 0,\n    reliability: 0,\n    warning: 'Default metrics due to insufficient data'\n  };\n}\n\n/**\n * Calculate overall system metrics\n */\nfunction calculateOverallMetrics(clusters) {\n  return {\n    totalMarkets: clusters.reduce((sum, c) => sum + c.metrics.marketCount, 0),\n    avgPrice: clusters.reduce((sum, c) => sum + c.metrics.avgPrice, 0) / clusters.length,\n    avgConflict: clusters.reduce((sum, c) => sum + c.metrics.avgConflict, 0) / clusters.length,\n    avgEfficiency: clusters.reduce((sum, c) => sum + c.metrics.efficiency, 0) / clusters.length,\n    reliability: clusters.reduce((sum, c) => sum + (c.metrics.reliability || 0), 0) / clusters.length\n  };\n}\n\n/**\n * Calculate comprehensive metrics for market clusters\n */\nexport const calculateClusterMetrics = (clusters, timeSeriesData, flows) => {\n  // Input validation\n  if (!Array.isArray(clusters) || !clusters.length) {\n    console.error('Invalid or empty clusters array provided');\n    return { clusters: [], metrics: null, error: 'Invalid clusters data' };\n  }\n  if (!Array.isArray(timeSeriesData) || !timeSeriesData.length) {\n    console.error('Invalid or empty time series data provided');\n    return { clusters: [], metrics: null, error: 'Invalid time series data' };\n  }\n  if (!Array.isArray(flows) || !flows.length) {\n    console.error('Invalid or empty flows data provided');\n    return { clusters: [], metrics: null, error: 'Invalid flows data' };\n  }\n\n  try {\n    // Create optimized data lookups\n    const timeSeriesMap = createTimeSeriesMap(timeSeriesData);\n    const flowsMap = createFlowsMap(flows);\n\n    // Calculate enhanced cluster metrics\n    const enhancedClusters = clusters.map(cluster => {\n      const connectedMarkets = cluster.connected_markets.map(m => transformRegionName(m));\n      \n      // Skip clusters with insufficient markets\n      if (connectedMarkets.length < 2) {\n        console.warn(`Cluster ${cluster.main_market} has insufficient markets:`, connectedMarkets.length);\n        return {\n          ...cluster,\n          metrics: createDefaultMetrics(),\n          warning: 'Insufficient markets for reliable analysis'\n        };\n      }\n\n      // Calculate component scores\n      const connectivityMetrics = calculateConnectivity(connectedMarkets, flowsMap);\n      const priceMetrics = calculatePriceIntegration(connectedMarkets, timeSeriesMap);\n      const stabilityMetrics = calculateStability(connectedMarkets, timeSeriesMap);\n      const resilienceMetrics = calculateConflictResilience(connectedMarkets, timeSeriesMap);\n\n      // Calculate weighted efficiency score\n      const efficiency = calculateEfficiencyScore({\n        connectivity: connectivityMetrics.score,\n        priceIntegration: priceMetrics.score,\n        stability: stabilityMetrics.score,\n        resilience: resilienceMetrics.score\n      });\n\n      const metrics = {\n        efficiency,\n        efficiencyComponents: {\n          connectivity: connectivityMetrics.score,\n          priceIntegration: priceMetrics.score,\n          stability: stabilityMetrics.score,\n          conflictResilience: resilienceMetrics.score\n        },\n        details: {\n          connectivity: connectivityMetrics.details,\n          priceIntegration: priceMetrics.details,\n          stability: stabilityMetrics.details,\n          resilience: resilienceMetrics.details\n        },\n        avgPrice: priceMetrics.avgPrice,\n        avgConflict: resilienceMetrics.average,\n        marketCount: connectedMarkets.length,\n        reliability: calculateReliabilityScore({\n          dataPoints: priceMetrics.dataPoints,\n          coverage: connectivityMetrics.details.coverage,\n          significance: priceMetrics.significance\n        })\n      };\n\n      return { ...cluster, metrics };\n    });\n\n    // Calculate system-wide metrics\n    const overallMetrics = calculateOverallMetrics(enhancedClusters);\n\n    return { \n      clusters: enhancedClusters, \n      metrics: overallMetrics,\n      metadata: {\n        timestamp: new Date().toISOString(),\n        dataPoints: timeSeriesData.length,\n        flowCount: flows.length,\n        clusterCount: clusters.length\n      }\n    };\n  } catch (error) {\n    console.error('Error calculating cluster metrics:', error);\n    return { \n      clusters: [], \n      metrics: null, \n      error: error.message \n    };\n  }\n};\n\nexport default {\n  calculateClusterMetrics,\n  calculateCorrelation,\n  calculateConnectivity,\n  calculatePriceIntegration,\n  calculateStability,\n  calculateConflictResilience,\n  createTimeSeriesMap,\n  createFlowsMap\n};\n",
        "imports": [
          "../../../utils/spatialUtils",
          "../types"
        ],
        "exports": [
          "calculateClusterMetrics",
          "default"
        ],
        "dependencies": [
          "../../../utils/spatialUtils",
          "../types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/conflict/ConflictImpactDashboard.js",
        "content": "import React, { useState, useMemo } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  Grid,\n  Paper,\n  Typography,\n  Box,\n  Alert,\n  ToggleButtonGroup,\n  ToggleButton,\n  Divider,\n  List,\n  ListItem,\n  ListItemText\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport TimelineIcon from '@mui/icons-material/Timeline';\nimport MapIcon from '@mui/icons-material/Map';\nimport AssessmentIcon from '@mui/icons-material/Assessment';\n\nimport ConflictMap from './ConflictMap';\nimport ConflictMetricsPanel from './ConflictMetricsPanel';\nimport TimeControl from '../../molecules/TimeControl';\nimport MetricCard from '../../atoms/MetricCard';\nimport { setSelectedDate } from '../../../../slices/spatialSlice';\nimport { \n  selectDateFilteredData,\n  selectTimeSeriesMetrics \n} from '../../../../selectors/dateSpecificSelectors';\n\nconst ConflictImpactDashboard = () => {\n  const theme = useTheme();\n  const dispatch = useDispatch();\n  const [viewMode, setViewMode] = useState('map');\n  const [selectedRegion, setSelectedRegion] = useState(null);\n\n  // Get data from Redux store\n  const geometryData = useSelector(state => state.spatial.data.geometry);\n  const timeSeriesData = useSelector(state => state.spatial.data.timeSeriesData || []);\n  const marketIntegration = useSelector(state => state.spatial.data.marketIntegration || {});\n  const loading = useSelector(state => state.spatial.status.loading);\n  const error = useSelector(state => state.spatial.status.error);\n  const selectedDate = useSelector(state => state.spatial.ui.selectedDate);\n\n  // Use date-specific selectors\n  const filteredData = useSelector(state => selectDateFilteredData(state));\n  const metrics = useSelector(state => selectTimeSeriesMetrics(state));\n\n  // Get unique dates for time control\n  const dates = useMemo(() => {\n    if (!timeSeriesData?.length) return [];\n    return [...new Set(timeSeriesData.map(d => d.month))].sort();\n  }, [timeSeriesData]);\n\n  // Handle date change\n  const handleDateChange = (newDate) => {\n    dispatch(setSelectedDate(newDate));\n  };\n\n  if (loading) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>\n        <Typography>Loading conflict analysis...</Typography>\n      </Box>\n    );\n  }\n\n  if (error) {\n    return (\n      <Alert severity=\"error\" sx={{ m: 2 }}>\n        {error}\n      </Alert>\n    );\n  }\n\n  return (\n    <Grid container spacing={2}>\n      {/* Overview Metrics */}\n      <Grid item xs={12}>\n        <Grid container spacing={2}>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Average Price\"\n              value={metrics.avgPrice}\n              format=\"currency\"\n              description=\"Average market price\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Price Range\"\n              value={metrics.priceRange}\n              format=\"currency\"\n              description=\"Price range (max - min)\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Conflict Intensity\"\n              value={metrics.avgConflict}\n              format=\"number\"\n              description=\"Average conflict intensity\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Market Accessibility\"\n              value={marketIntegration?.accessibility || 0}\n              format=\"percentage\"\n              description=\"Average market accessibility\"\n            />\n          </Grid>\n        </Grid>\n      </Grid>\n\n      {/* Controls Section */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          {/* View Controls */}\n          <Box sx={{ mb: dates.length > 0 ? 2 : 0 }}>\n            <ToggleButtonGroup\n              value={viewMode}\n              exclusive\n              onChange={(e, value) => value && setViewMode(value)}\n              size=\"small\"\n            >\n              <ToggleButton value=\"map\">\n                <MapIcon sx={{ mr: 1 }} />\n                Impact Map\n              </ToggleButton>\n              <ToggleButton value=\"timeline\">\n                <TimelineIcon sx={{ mr: 1 }} />\n                Time Analysis\n              </ToggleButton>\n              <ToggleButton value=\"metrics\">\n                <AssessmentIcon sx={{ mr: 1 }} />\n                Detailed Metrics\n              </ToggleButton>\n            </ToggleButtonGroup>\n          </Box>\n\n          {/* Time Controls */}\n          {dates.length > 0 && (\n            <>\n              <Divider sx={{ my: 2 }} />\n              <Box sx={{ width: '100%' }}>\n                <TimeControl\n                  dates={dates}\n                  currentDate={selectedDate || dates[0]}\n                  onChange={handleDateChange}\n                  position={null}\n                />\n              </Box>\n            </>\n          )}\n        </Paper>\n      </Grid>\n\n      {/* Main Content */}\n      <Grid item xs={12} md={8}>\n        <Paper sx={{ p: 2, height: 600 }}>\n          <ConflictMap\n            timeSeriesData={filteredData}\n            geometry={geometryData}\n            selectedRegion={selectedRegion}\n            onRegionSelect={setSelectedRegion}\n            timeWindow={selectedDate || dates[0]}\n          />\n        </Paper>\n      </Grid>\n\n      {/* Metrics Panel */}\n      <Grid item xs={12} md={4}>\n        <ConflictMetricsPanel\n          timeSeriesData={filteredData}\n          selectedRegion={selectedRegion}\n          marketIntegration={marketIntegration}\n          timeWindow={selectedDate || dates[0]}\n        />\n      </Grid>\n\n      {/* Analysis Summary */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Typography variant=\"h6\" gutterBottom>\n            About Conflict Impact Analysis\n          </Typography>\n          <Typography paragraph>\n            This analysis examines how conflict affects market dynamics in Yemen,\n            revealing patterns of market disruption and resilience in conflict zones.\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={12} md={4}>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Impact Assessment\n              </Typography>\n              <List dense>\n                <ListItem>\n                  <ListItemText primary=\"Market accessibility changes\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Price volatility in conflict zones\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Supply chain disruptions\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Market isolation patterns\" />\n                </ListItem>\n              </List>\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Resilience Factors\n              </Typography>\n              <List dense>\n                <ListItem>\n                  <ListItemText primary=\"Alternative trade routes\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Market adaptation strategies\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Community support networks\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Recovery patterns\" />\n                </ListItem>\n              </List>\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Response Planning\n              </Typography>\n              <List dense>\n                <ListItem>\n                  <ListItemText primary=\"Critical market identification\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Intervention prioritization\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Resource allocation\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Support strategy development\" />\n                </ListItem>\n              </List>\n            </Grid>\n          </Grid>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default React.memo(ConflictImpactDashboard);\n",
        "imports": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Timeline",
          "@mui/icons-material/Map",
          "@mui/icons-material/Assessment",
          "./ConflictMap",
          "./ConflictMetricsPanel",
          "../../molecules/TimeControl",
          "../../atoms/MetricCard",
          "../../../../slices/spatialSlice",
          "../../../../selectors/dateSpecificSelectors"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Timeline",
          "@mui/icons-material/Map",
          "@mui/icons-material/Assessment",
          "./ConflictMap",
          "./ConflictMetricsPanel",
          "../../molecules/TimeControl",
          "../../atoms/MetricCard",
          "../../../../slices/spatialSlice",
          "../../../../selectors/dateSpecificSelectors"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/conflict/ConflictMap.js",
        "content": "import React, { useMemo, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, Typography } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport { GeoJSON, CircleMarker } from 'react-leaflet';\nimport chroma from 'chroma-js';\n\nimport Legend from '../../atoms/Legend';\nimport Tooltip from '../../atoms/Tooltip';\nimport MapControls from '../../molecules/MapControls';\nimport BaseMap from '../../molecules/BaseMap';\nimport { safeGeoJSONProcessor } from '../../utils/geoJSONProcessor';\nimport { transformRegionName, getRegionCoordinates } from '../../utils/spatialUtils';\n\nconst ConflictMap = ({\n  timeSeriesData,\n  geometry,\n  selectedRegion,\n  onRegionSelect,\n  timeWindow,\n  height = '100%'\n}) => {\n  const theme = useTheme();\n\n  // Create color scales\n  const conflictColorScale = useMemo(() => \n    chroma.scale(['#fee5d9', '#a50f15']).domain([0, 1]),\n    []\n  );\n\n  const marketColorScale = useMemo(() => \n    chroma.scale(['#edf8e9', '#006d2c']).domain([0, 1]),\n    []\n  );\n\n  // Process market data with conflict intensity\n  const processedData = useMemo(() => {\n    if (!timeSeriesData?.length) return null;\n\n    // Filter data by time window if provided\n    const currentData = timeWindow ? \n      timeSeriesData.filter(d => d.month === timeWindow) : \n      timeSeriesData;\n\n    if (!currentData.length) return null;\n\n    // Calculate max values for normalization\n    const maxIntensity = Math.max(...currentData.map(d => d.conflictIntensity || 0));\n    const maxPrice = Math.max(...currentData.map(d => d.usdPrice || 0));\n\n    // Process market data\n    return currentData.map(data => {\n      const coords = getRegionCoordinates(data.region);\n      if (!coords) return null;\n\n      const normalizedIntensity = maxIntensity > 0 ? \n        (data.conflictIntensity || 0) / maxIntensity : 0;\n      const normalizedPrice = maxPrice > 0 ? \n        (data.usdPrice || 0) / maxPrice : 0;\n\n      return {\n        ...data,\n        coordinates: coords,\n        normalizedIntensity,\n        normalizedPrice,\n        conflictColor: conflictColorScale(normalizedIntensity).hex(),\n        marketColor: marketColorScale(normalizedPrice).hex()\n      };\n    }).filter(Boolean);\n  }, [timeSeriesData, timeWindow, conflictColorScale, marketColorScale]);\n\n  // Process GeoJSON for regions\n  const processedGeoJSON = useMemo(() => {\n    if (!geometry) return null;\n\n    // Extract features from unified geometry or combine points and polygons\n    const features = geometry.unified?.features || [\n      ...(geometry.polygons || []),\n      ...(geometry.points || [])\n    ];\n\n    // Create a new GeoJSON object with validated features\n    const validatedGeoJSON = {\n      type: 'FeatureCollection',\n      features: features.map(feature => ({\n        type: 'Feature',\n        properties: {\n          ...feature.properties,\n          name: feature.properties?.name || '',\n          normalizedName: feature.properties?.normalizedName || \n            transformRegionName(feature.properties?.name || ''),\n          region_id: feature.properties?.region_id || feature.properties?.normalizedName\n        },\n        geometry: {\n          type: feature.geometry?.type || 'Polygon',\n          coordinates: feature.geometry?.coordinates || []\n        }\n      })),\n      crs: {\n        type: 'name',\n        properties: {\n          name: 'EPSG:4326'\n        }\n      }\n    };\n\n    return safeGeoJSONProcessor(validatedGeoJSON, 'conflict');\n  }, [geometry]);\n\n  // Style function for regions\n  const getRegionStyle = useCallback((feature) => {\n    if (!processedData) return {};\n\n    const regionData = processedData.find(d => \n      transformRegionName(d.region) === feature.properties.normalizedName\n    );\n\n    const isSelected = selectedRegion === feature.properties.region_id;\n    \n    return {\n      fillColor: regionData?.conflictColor || theme.palette.grey[300],\n      weight: isSelected ? 2 : 1,\n      opacity: 1,\n      color: isSelected ? theme.palette.secondary.main : 'white',\n      fillOpacity: regionData ? 0.7 : 0.3\n    };\n  }, [processedData, selectedRegion, theme]);\n\n  // Create legend items\n  const legendItems = useMemo(() => [\n    { color: '#a50f15', label: 'High Conflict' },\n    { color: '#fee5d9', label: 'Low Conflict' },\n    { \n      color: theme.palette.secondary.main, \n      label: 'Selected Region',\n      style: { borderWidth: 2 }\n    },\n    {\n      color: '#006d2c',\n      label: 'High Market Activity',\n      style: { borderRadius: '50%' }\n    },\n    {\n      color: '#edf8e9',\n      label: 'Low Market Activity',\n      style: { borderRadius: '50%' }\n    }\n  ], [theme]);\n\n  if (!processedData || !processedGeoJSON) {\n    return (\n      <Box \n        sx={{ \n          height,\n          display: 'flex', \n          alignItems: 'center', \n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1\n        }}\n      >\n        <Typography color=\"text.secondary\">\n          No conflict data available for visualization\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ height, position: 'relative' }}>\n      <BaseMap height={height}>\n        {/* Region polygons */}\n        <GeoJSON\n          data={processedGeoJSON}\n          style={getRegionStyle}\n          onEachFeature={(feature, layer) => {\n            layer.on({\n              click: () => onRegionSelect(feature.properties.region_id)\n            });\n\n            const regionData = processedData.find(d => \n              transformRegionName(d.region) === feature.properties.normalizedName\n            );\n\n            if (regionData) {\n              layer.bindTooltip(() => (\n                <Tooltip\n                  title={feature.properties.originalName}\n                  metrics={[\n                    {\n                      label: 'Conflict Intensity',\n                      value: regionData.conflictIntensity,\n                      format: 'number'\n                    },\n                    {\n                      label: 'Market Price',\n                      value: regionData.usdPrice,\n                      format: 'currency'\n                    },\n                    {\n                      label: 'Market Status',\n                      value: regionData.conflictIntensity > 0.5 ? \n                        'Severely Affected' : 'Operational'\n                    }\n                  ]}\n                />\n              ), { sticky: true });\n            }\n          }}\n        />\n\n        {/* Market points */}\n        {processedData.map((data, index) => (\n          <CircleMarker\n            key={index}\n            center={[data.coordinates[1], data.coordinates[0]]}\n            radius={6}\n            pathOptions={{\n              fillColor: data.marketColor,\n              color: 'white',\n              weight: 1,\n              opacity: 0.8,\n              fillOpacity: 0.6\n            }}\n          >\n            <Tooltip\n              title={data.region}\n              metrics={[\n                {\n                  label: 'Market Price',\n                  value: data.usdPrice,\n                  format: 'currency'\n                },\n                {\n                  label: 'Price Change',\n                  value: data.priceChange,\n                  format: 'percentage'\n                },\n                {\n                  label: 'Market Status',\n                  value: data.marketStatus\n                }\n              ]}\n            />\n          </CircleMarker>\n        ))}\n      </BaseMap>\n\n      <MapControls\n        onZoomIn={() => {}}\n        onZoomOut={() => {}}\n        onReset={() => {}}\n        onRefresh={() => {}}\n      />\n\n      <Legend\n        title=\"Conflict Impact\"\n        items={legendItems}\n      />\n    </Box>\n  );\n};\n\nConflictMap.propTypes = {\n  timeSeriesData: PropTypes.arrayOf(PropTypes.shape({\n    month: PropTypes.string.isRequired,\n    region: PropTypes.string.isRequired,\n    conflictIntensity: PropTypes.number,\n    usdPrice: PropTypes.number\n  })).isRequired,\n  geometry: PropTypes.shape({\n    unified: PropTypes.shape({\n      features: PropTypes.array\n    }),\n    polygons: PropTypes.array,\n    points: PropTypes.array\n  }).isRequired,\n  selectedRegion: PropTypes.string,\n  onRegionSelect: PropTypes.func,\n  timeWindow: PropTypes.string,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\n\nexport default React.memo(ConflictMap);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "react-leaflet",
          "chroma-js",
          "../../atoms/Legend",
          "../../atoms/Tooltip",
          "../../molecules/MapControls",
          "../../molecules/BaseMap",
          "../../utils/geoJSONProcessor",
          "../../utils/spatialUtils"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "react-leaflet",
          "chroma-js",
          "../../atoms/Legend",
          "../../atoms/Tooltip",
          "../../molecules/MapControls",
          "../../molecules/BaseMap",
          "../../utils/geoJSONProcessor",
          "../../utils/spatialUtils"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/conflict/ConflictMetricsPanel.js",
        "content": "import React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Paper,\n  Typography,\n  Box,\n  Divider,\n  Grid,\n  LinearProgress\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport TrendingUpIcon from '@mui/icons-material/TrendingUp';\nimport TrendingDownIcon from '@mui/icons-material/TrendingDown';\nimport WarningIcon from '@mui/icons-material/Warning';\n\nimport MetricCard from '../../atoms/MetricCard';\nimport MetricProgress from '../../molecules/MetricProgress';\n\nconst ConflictMetricsPanel = ({\n  timeSeriesData,\n  selectedRegion,\n  timeWindow,\n  marketIntegration\n}) => {\n  const theme = useTheme();\n\n  // Calculate metrics for selected region with safe defaults\n  const regionMetrics = useMemo(() => {\n    if (!selectedRegion || !timeSeriesData?.length) {\n      return {\n        currentIntensity: 0,\n        intensityTrend: 0,\n        currentPrice: 0,\n        priceTrend: 0,\n        accessibility: 0,\n        resilience: 0,\n        riskLevel: 0\n      };\n    }\n\n    // Get data for selected region\n    const regionData = timeSeriesData.filter(d => \n      d.region === selectedRegion\n    ).sort((a, b) => new Date(a.month) - new Date(b.month));\n\n    if (!regionData.length) {\n      return {\n        currentIntensity: 0,\n        intensityTrend: 0,\n        currentPrice: 0,\n        priceTrend: 0,\n        accessibility: 0,\n        resilience: 0,\n        riskLevel: 0\n      };\n    }\n\n    // Get current and previous period data\n    const currentData = regionData.find(d => d.month === timeWindow) || regionData[regionData.length - 1];\n    const previousData = regionData[regionData.length - 2];\n\n    // Ensure we have valid numbers for all metrics\n    const currentIntensity = currentData?.conflictIntensity || 0;\n    const previousIntensity = previousData?.conflictIntensity || 0;\n    const currentPrice = currentData?.usdPrice || 0;\n    const previousPrice = previousData?.usdPrice || 0;\n    const accessibility = marketIntegration?.accessibility?.[selectedRegion] || 0;\n\n    // Calculate trends with safety checks\n    const intensityTrend = previousIntensity ? \n      ((currentIntensity - previousIntensity) / previousIntensity) * 100 : 0;\n\n    const priceTrend = previousPrice ? \n      ((currentPrice - previousPrice) / previousPrice) * 100 : 0;\n\n    // Calculate market resilience\n    const resilience = calculateResilience(\n      currentIntensity,\n      accessibility,\n      priceTrend\n    );\n\n    // Ensure all values are within valid ranges\n    return {\n      currentIntensity: Math.max(0, Math.min(1, currentIntensity)),\n      intensityTrend: Math.max(-100, Math.min(100, intensityTrend)),\n      currentPrice: Math.max(0, currentPrice),\n      priceTrend: Math.max(-100, Math.min(100, priceTrend)),\n      accessibility: Math.max(0, Math.min(1, accessibility)),\n      resilience: Math.max(0, Math.min(1, resilience)),\n      riskLevel: calculateRiskLevel(currentIntensity, accessibility)\n    };\n  }, [selectedRegion, timeSeriesData, timeWindow, marketIntegration]);\n\n  // Calculate temporal patterns with safe defaults\n  const temporalPatterns = useMemo(() => {\n    if (!selectedRegion || !timeSeriesData?.length) {\n      return {\n        volatility: 0,\n        trend: 0,\n        duration: 0,\n        peakIntensity: 0\n      };\n    }\n\n    const regionData = timeSeriesData.filter(d => \n      d.region === selectedRegion\n    ).sort((a, b) => new Date(a.month) - new Date(b.month));\n\n    if (regionData.length < 2) {\n      return {\n        volatility: 0,\n        trend: 0,\n        duration: regionData.length,\n        peakIntensity: regionData[0]?.conflictIntensity || 0\n      };\n    }\n\n    // Calculate volatility with safety checks\n    const intensityValues = regionData.map(d => d.conflictIntensity || 0);\n    const meanIntensity = intensityValues.reduce((sum, val) => sum + val, 0) / \n      intensityValues.length || 1; // Avoid division by zero\n    const variance = intensityValues.reduce((sum, val) => \n      sum + Math.pow(val - meanIntensity, 2), 0\n    ) / intensityValues.length;\n    const volatility = meanIntensity ? Math.sqrt(variance) / meanIntensity : 0;\n\n    // Detect trends with safety checks\n    const recentData = regionData.slice(-6); // Last 6 months\n    const trend = calculateTrend(recentData);\n\n    return {\n      volatility: Math.max(0, Math.min(1, volatility)),\n      trend: Math.max(-100, Math.min(100, trend)),\n      duration: regionData.length,\n      peakIntensity: Math.max(0, Math.min(1, Math.max(...intensityValues)))\n    };\n  }, [selectedRegion, timeSeriesData]);\n\n  // Ensure we have valid values for display\n  const safeMetrics = {\n    currentIntensity: regionMetrics?.currentIntensity || 0,\n    intensityTrend: regionMetrics?.intensityTrend || 0,\n    accessibility: regionMetrics?.accessibility || 0,\n    resilience: regionMetrics?.resilience || 0,\n    riskLevel: regionMetrics?.riskLevel || 0\n  };\n\n  if (!selectedRegion) {\n    return (\n      <Paper sx={{ p: 2, height: '100%' }}>\n        <Typography color=\"textSecondary\" align=\"center\">\n          Select a region to view conflict impact metrics\n        </Typography>\n      </Paper>\n    );\n  }\n\n  if (!regionMetrics) {\n    return (\n      <Paper sx={{ p: 2, height: '100%' }}>\n        <Typography color=\"textSecondary\" align=\"center\">\n          No metrics available for selected region\n        </Typography>\n      </Paper>\n    );\n  }\n\n  return (\n    <Paper sx={{ p: 2, height: '100%' }}>\n      {/* Region Header */}\n      <Typography variant=\"h6\" gutterBottom>\n        {selectedRegion} Impact Analysis\n      </Typography>\n\n      {/* Current Metrics */}\n      <Grid container spacing={2}>\n        <Grid item xs={12}>\n          <MetricProgress\n            title=\"Conflict Impact\"\n            value={safeMetrics.currentIntensity}\n            target={0.5}\n            format=\"percentage\"\n            description=\"Current conflict intensity level\"\n            trend={safeMetrics.intensityTrend}\n          />\n        </Grid>\n\n        <Grid item xs={12} md={6}>\n          <MetricCard\n            title=\"Market Accessibility\"\n            value={safeMetrics.accessibility}\n            format=\"percentage\"\n            description=\"Current market access level\"\n          />\n        </Grid>\n\n        <Grid item xs={12} md={6}>\n          <MetricCard\n            title=\"Market Resilience\"\n            value={safeMetrics.resilience}\n            format=\"percentage\"\n            description=\"Market adaptation capacity\"\n          />\n        </Grid>\n      </Grid>\n\n      <Divider sx={{ my: 2 }} />\n\n      {/* Risk Assessment */}\n      <Typography variant=\"subtitle2\" gutterBottom>\n        Risk Assessment\n      </Typography>\n      <Box sx={{ mb: 2 }}>\n        <Box sx={{ \n          display: 'flex', \n          alignItems: 'center',\n          mb: 1\n        }}>\n          <WarningIcon \n            sx={{ \n              color: getRiskColor(regionMetrics.riskLevel, theme),\n              mr: 1\n            }} \n          />\n          <Typography variant=\"body2\">\n            {getRiskLabel(regionMetrics.riskLevel)}\n          </Typography>\n        </Box>\n        <LinearProgress\n          variant=\"determinate\"\n          value={regionMetrics.riskLevel * 100}\n          sx={{\n            height: 8,\n            borderRadius: 4,\n            backgroundColor: theme.palette.grey[200],\n            '& .MuiLinearProgress-bar': {\n              backgroundColor: getRiskColor(regionMetrics.riskLevel, theme)\n            }\n          }}\n        />\n      </Box>\n\n      {/* Temporal Analysis */}\n      {temporalPatterns && (\n        <>\n          <Typography variant=\"subtitle2\" gutterBottom>\n            Temporal Patterns\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={6}>\n              <Box>\n                <Typography variant=\"caption\" color=\"textSecondary\">\n                  Volatility\n                </Typography>\n                <Typography variant=\"body1\">\n                  {(temporalPatterns.volatility * 100).toFixed(1)}%\n                </Typography>\n              </Box>\n            </Grid>\n            <Grid item xs={6}>\n              <Box>\n                <Typography variant=\"caption\" color=\"textSecondary\">\n                  Duration\n                </Typography>\n                <Typography variant=\"body1\">\n                  {temporalPatterns.duration} months\n                </Typography>\n              </Box>\n            </Grid>\n          </Grid>\n\n          <Box sx={{ mt: 2 }}>\n            <Typography variant=\"caption\" color=\"textSecondary\">\n              Trend Analysis\n            </Typography>\n            <Box sx={{ \n              display: 'flex', \n              alignItems: 'center',\n              color: temporalPatterns.trend > 0 ? \n                theme.palette.error.main : \n                theme.palette.success.main\n            }}>\n              {temporalPatterns.trend > 0 ? (\n                <TrendingUpIcon sx={{ mr: 1 }} />\n              ) : (\n                <TrendingDownIcon sx={{ mr: 1 }} />\n              )}\n              <Typography variant=\"body2\">\n                {Math.abs(temporalPatterns.trend).toFixed(1)}% per month\n              </Typography>\n            </Box>\n          </Box>\n        </>\n      )}\n\n      {/* Impact Summary */}\n      <Box \n        sx={{ \n          mt: 2,\n          p: 1.5,\n          bgcolor: theme.palette.grey[50],\n          borderRadius: 1\n        }}\n      >\n        <Typography variant=\"subtitle2\" gutterBottom>\n          Impact Summary\n        </Typography>\n        <Typography variant=\"body2\" color=\"textSecondary\">\n          {generateImpactSummary(regionMetrics, temporalPatterns)}\n        </Typography>\n      </Box>\n    </Paper>\n  );\n};\n\n// Helper functions\nconst calculateResilience = (intensity, accessibility, priceTrend) => {\n  // Higher resilience when market remains accessible despite conflict\n  const baseResilience = accessibility * (1 - intensity);\n  // Adjust for price stability\n  const priceStability = 1 - Math.min(Math.abs(priceTrend) / 100, 1);\n  return (baseResilience + priceStability) / 2;\n};\n\nconst calculateRiskLevel = (intensity, accessibility) => {\n  // Risk increases with intensity and decreases with accessibility\n  return Math.min(intensity * (1 - accessibility) * 1.5, 1);\n};\n\nconst calculateTrend = (data) => {\n  if (data.length < 2) return 0;\n  \n  const firstValue = data[0].conflictIntensity || 0;\n  const lastValue = data[data.length - 1].conflictIntensity || 0;\n  const monthsDiff = data.length - 1;\n\n  return monthsDiff > 0 ? \n    ((lastValue - firstValue) / firstValue) * (100 / monthsDiff) : 0;\n};\n\nconst getRiskColor = (risk, theme) => {\n  if (risk >= 0.7) return theme.palette.error.main;\n  if (risk >= 0.4) return theme.palette.warning.main;\n  return theme.palette.success.main;\n};\n\nconst getRiskLabel = (risk) => {\n  if (risk >= 0.7) return 'High Risk - Severe Market Disruption';\n  if (risk >= 0.4) return 'Medium Risk - Significant Impact';\n  return 'Low Risk - Manageable Impact';\n};\n\nconst generateImpactSummary = (metrics, patterns) => {\n  const parts = [];\n\n  if (metrics.currentIntensity > 0.7) {\n    parts.push('Severe conflict impact with critical market disruption.');\n  } else if (metrics.currentIntensity > 0.4) {\n    parts.push('Moderate conflict impact affecting market operations.');\n  } else {\n    parts.push('Limited conflict impact with maintained market function.');\n  }\n\n  if (patterns) {\n    if (patterns.trend > 0) {\n      parts.push('Deteriorating conditions require immediate attention.');\n    } else {\n      parts.push('Showing signs of stability or improvement.');\n    }\n  }\n\n  if (metrics.resilience > 0.6) {\n    parts.push('Markets demonstrate strong resilience.');\n  } else {\n    parts.push('Support needed to enhance market resilience.');\n  }\n\n  return parts.join(' ');\n};\n\nConflictMetricsPanel.propTypes = {\n  timeSeriesData: PropTypes.arrayOf(PropTypes.shape({\n    month: PropTypes.string.isRequired,\n    region: PropTypes.string.isRequired,\n    conflictIntensity: PropTypes.number,\n    usdPrice: PropTypes.number\n  })).isRequired,\n  selectedRegion: PropTypes.string,\n  timeWindow: PropTypes.string.isRequired,\n  marketIntegration: PropTypes.shape({\n    accessibility: PropTypes.object\n  })\n};\n\nexport default React.memo(ConflictMetricsPanel);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown",
          "@mui/icons-material/Warning",
          "../../atoms/MetricCard",
          "../../molecules/MetricProgress"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown",
          "@mui/icons-material/Warning",
          "../../atoms/MetricCard",
          "../../molecules/MetricProgress"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/conflict/index.js",
        "content": "// Export all conflict analysis components\nexport { default as ConflictImpactDashboard } from './ConflictImpactDashboard';\nexport { default as ConflictMap } from './ConflictMap';\nexport { default as ConflictMetricsPanel } from './ConflictMetricsPanel';\n\n// Also export the feature as the default export\nexport { default } from './ConflictImpactDashboard';\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/flows/FlowDateControl.js",
        "content": "// src/components/spatialAnalysis/features/flows/FlowDateControl.js\n\nimport React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { \n  Box, \n  IconButton, \n  Slider, \n  Typography,\n  Paper,\n  CircularProgress\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport PlayArrowIcon from '@mui/icons-material/PlayArrow';\nimport PauseIcon from '@mui/icons-material/Pause';\nimport SkipPreviousIcon from '@mui/icons-material/SkipPrevious';\nimport SkipNextIcon from '@mui/icons-material/SkipNext';\nimport SpeedIcon from '@mui/icons-material/Speed';\nimport { debounce } from 'lodash';\n\n// Helper function to prevent default events\nconst preventEvent = (e) => {\n  if (e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n  return false;\n};\n\n// Date format utilities\nconst dateUtils = {\n  // Convert YYYY-MM to YYYY-MM-DD\n  toFlowDate: (date) => {\n    if (!date) return null;\n    return date.length === 7 ? `${date}-01` : date;\n  },\n  // Convert YYYY-MM-DD to YYYY-MM\n  toSpatialDate: (date) => {\n    if (!date) return null;\n    return date.substring(0, 7);\n  },\n  // Format date for display\n  formatDate: (date) => {\n    try {\n      // Always use YYYY-MM format for display\n      const spatialDate = dateUtils.toSpatialDate(date);\n      return new Date(`${spatialDate}-01`).toLocaleDateString('en-US', {\n        year: 'numeric',\n        month: 'short'\n      });\n    } catch (error) {\n      console.error('Error formatting date:', error);\n      return date;\n    }\n  }\n};\n\nconst FlowDateControl = ({\n  dates,\n  currentDate,\n  onChange,\n  autoPlayInterval = 1000,\n  loading = false\n}) => {\n  const theme = useTheme();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1);\n  const [sliderValue, setSliderValue] = useState(0);\n  const [internalDate, setInternalDate] = useState(currentDate);\n\n  // Refs for cleanup and state tracking\n  const intervalRef = useRef(null);\n  const lastChangeRef = useRef(null);\n\n  // Normalize all dates to YYYY-MM format for spatial slice\n  const normalizedDates = useMemo(() => \n    dates.map(dateUtils.toSpatialDate),\n    [dates]\n  );\n  const normalizedCurrentDate = useMemo(() => \n    dateUtils.toSpatialDate(currentDate),\n    [currentDate]\n  );\n\n  // Create stable onChange handler\n  const handleChange = useCallback((e, newDate) => {\n    preventEvent(e);\n    \n    const now = Date.now();\n    // Prevent rapid consecutive updates\n    if (lastChangeRef.current && now - lastChangeRef.current < 200) {\n      return;\n    }\n    lastChangeRef.current = now;\n\n    // Always pass YYYY-MM format to spatial slice\n    const spatialDate = dateUtils.toSpatialDate(newDate);\n    onChange(null, spatialDate);\n  }, [onChange]);\n\n  // Debounced onChange handler with cleanup\n  const debouncedOnChange = useMemo(\n    () => debounce(handleChange, 200, { leading: true, trailing: true }),\n    [handleChange]\n  );\n\n  // Initialize slider value based on current date\n  useEffect(() => {\n    const currentIndex = normalizedDates.indexOf(normalizedCurrentDate);\n    if (currentIndex >= 0) {\n      setSliderValue(currentIndex);\n      setInternalDate(normalizedCurrentDate);\n    } else if (dates.length > 0) {\n      setSliderValue(0);\n      const firstDate = dateUtils.toSpatialDate(dates[0]);\n      setInternalDate(firstDate);\n      handleChange(null, firstDate);\n    }\n  }, [currentDate, dates, normalizedCurrentDate, normalizedDates, handleChange]);\n\n  // Handle auto-play with cleanup\n  const handleAutoPlay = useCallback(() => {\n    if (isPlaying) {\n      setSliderValue(prev => {\n        const next = prev + 1;\n        if (next >= dates.length) {\n          setIsPlaying(false);\n          return 0;\n        }\n        const newDate = dateUtils.toSpatialDate(dates[next]);\n        setInternalDate(newDate);\n        debouncedOnChange(null, newDate);\n        return next;\n      });\n    }\n  }, [isPlaying, dates, debouncedOnChange]);\n\n  // Auto-play effect with proper cleanup\n  useEffect(() => {\n    if (isPlaying && !loading) {\n      intervalRef.current = setInterval(handleAutoPlay, autoPlayInterval / playbackSpeed);\n    }\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [isPlaying, autoPlayInterval, playbackSpeed, handleAutoPlay, loading]);\n\n  // Button handlers with event prevention\n  const handlePlayPause = useCallback((e) => {\n    preventEvent(e);\n    setIsPlaying(prev => !prev);\n  }, []);\n\n  const handlePrevious = useCallback((e) => {\n    preventEvent(e);\n    const newValue = Math.max(0, sliderValue - 1);\n    const newDate = dateUtils.toSpatialDate(dates[newValue]);\n    setSliderValue(newValue);\n    setInternalDate(newDate);\n    debouncedOnChange(null, newDate);\n  }, [sliderValue, dates, debouncedOnChange]);\n\n  const handleNext = useCallback((e) => {\n    preventEvent(e);\n    const newValue = Math.min(dates.length - 1, sliderValue + 1);\n    const newDate = dateUtils.toSpatialDate(dates[newValue]);\n    setSliderValue(newValue);\n    setInternalDate(newDate);\n    debouncedOnChange(null, newDate);\n  }, [dates.length, sliderValue, dates, debouncedOnChange]);\n\n  const handleSpeedChange = useCallback((e) => {\n    preventEvent(e);\n    setPlaybackSpeed(prev => (prev === 4 ? 1 : prev * 2));\n  }, []);\n\n  // Slider change handler with event prevention\n  const handleSliderChange = useCallback((e, value) => {\n    preventEvent(e);\n    if (value !== sliderValue) {\n      const newDate = dateUtils.toSpatialDate(dates[value]);\n      setSliderValue(value);\n      setInternalDate(newDate);\n      debouncedOnChange(null, newDate);\n    }\n  }, [dates, sliderValue, debouncedOnChange]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n      debouncedOnChange.cancel();\n    };\n  }, [debouncedOnChange]);\n\n  return (\n    <Paper\n      elevation={2}\n      sx={{\n        width: '100%',\n        backgroundColor: theme.palette.background.paper,\n        borderRadius: 1,\n        p: 2,\n        position: 'relative'\n      }}\n      onMouseDown={preventEvent}\n      onClick={preventEvent}\n    >\n      {/* Loading Indicator Overlay */}\n      {loading && (\n        <Box\n          sx={{\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            zIndex: 999,\n            backgroundColor: 'rgba(255,255,255,0.7)',\n            borderRadius: '50%',\n            p: 2\n          }}\n        >\n          <CircularProgress size={24} />\n        </Box>\n      )}\n\n      <Box sx={{ width: '100%', opacity: loading ? 0.5 : 1, transition: 'opacity 0.3s' }}>\n        <Typography \n          variant=\"subtitle2\" \n          color=\"textPrimary\"\n          sx={{ display: 'block', mb: 1, textAlign: 'center', fontWeight: 500 }}\n        >\n          {dateUtils.formatDate(dates[sliderValue])}\n        </Typography>\n\n        <Slider\n          value={sliderValue}\n          min={0}\n          max={dates.length - 1}\n          onChange={handleSliderChange}\n          onMouseDown={preventEvent}\n          disabled={loading}\n          sx={{ mb: 2, '& .MuiSlider-thumb': { width: 12, height: 12 } }}\n        />\n\n        <Box sx={{ \n          display: 'flex', \n          justifyContent: 'center', \n          gap: 1,\n          '& .MuiIconButton-root': {\n            padding: 1,\n            '&:hover': {\n              backgroundColor: 'rgba(0, 0, 0, 0.04)'\n            }\n          }\n        }}>\n          <IconButton \n            size=\"small\" \n            onClick={handlePrevious}\n            onMouseDown={preventEvent}\n            disabled={sliderValue === 0 || loading}\n            title=\"Previous\"\n          >\n            <SkipPreviousIcon fontSize=\"small\" />\n          </IconButton>\n\n          <IconButton \n            size=\"small\" \n            onClick={handlePlayPause}\n            onMouseDown={preventEvent}\n            disabled={loading}\n            title={isPlaying ? 'Pause' : 'Play'}\n          >\n            {isPlaying ? (\n              <PauseIcon fontSize=\"small\" />\n            ) : (\n              <PlayArrowIcon fontSize=\"small\" />\n            )}\n          </IconButton>\n\n          <IconButton \n            size=\"small\" \n            onClick={handleNext}\n            onMouseDown={preventEvent}\n            disabled={sliderValue === dates.length - 1 || loading}\n            title=\"Next\"\n          >\n            <SkipNextIcon fontSize=\"small\" />\n          </IconButton>\n\n          <IconButton \n            size=\"small\" \n            onClick={handleSpeedChange}\n            onMouseDown={preventEvent}\n            disabled={loading}\n            title={`Playback Speed: ${playbackSpeed}x`}\n            sx={{ position: 'relative' }}\n          >\n            <SpeedIcon fontSize=\"small\" />\n            <Typography \n              variant=\"caption\" \n              sx={{ \n                position: 'absolute',\n                bottom: 2,\n                right: 2,\n                fontSize: '0.6rem',\n                fontWeight: 'bold',\n                backgroundColor: theme.palette.background.paper,\n                borderRadius: '50%',\n                width: 12,\n                height: 12,\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center'\n              }}\n            >\n              {playbackSpeed}x\n            </Typography>\n          </IconButton>\n        </Box>\n      </Box>\n    </Paper>\n  );\n};\n\nFlowDateControl.propTypes = {\n  dates: PropTypes.arrayOf(PropTypes.string).isRequired,\n  currentDate: PropTypes.string.isRequired,\n  onChange: PropTypes.func.isRequired,\n  autoPlayInterval: PropTypes.number,\n  loading: PropTypes.bool\n};\n\nexport default React.memo(FlowDateControl);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/PlayArrow",
          "@mui/icons-material/Pause",
          "@mui/icons-material/SkipPrevious",
          "@mui/icons-material/SkipNext",
          "@mui/icons-material/Speed",
          "lodash"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/PlayArrow",
          "@mui/icons-material/Pause",
          "@mui/icons-material/SkipPrevious",
          "@mui/icons-material/SkipNext",
          "@mui/icons-material/Speed",
          "lodash"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/flows/FlowMap.js",
        "content": "// src/components/spatialAnalysis/features/flows/FlowMap.js\n\nimport React, { useMemo, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { useSelector } from 'react-redux';\nimport { Box, Typography, CircularProgress } from '@mui/material';\nimport { MapContainer, TileLayer, Polyline, CircleMarker, Popup, useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport chroma from 'chroma-js';\nimport 'leaflet/dist/leaflet.css';\nimport { TransitionGroup, CSSTransition } from 'react-transition-group';\n\nimport Legend from '../../atoms/Legend';\nimport MapControls from '../../molecules/MapControls';\nimport {\n  FLOW_COLORS,\n  VISUALIZATION_PARAMS,\n  flowValidation\n} from './types';\nimport { YEMEN_COORDINATES } from '../../../../selectors/optimizedSelectors';\nimport { selectFlowMetadata, selectFlowStatus } from '../../../../slices/flowSlice';\n\nimport './FlowMapTransitions.css';\n\nconst DEFAULT_CENTER = [15.3694, 44.191];\nconst DEFAULT_ZOOM = 5;\nconst YEMEN_BOUNDS = [\n  [12.1110 - 2, 41.8140 - 2],\n  [19.0025 + 2, 54.5305 + 2]\n];\n\n// Enhanced event prevention utility\nconst preventEvent = (e) => {\n  if (e.originalEvent) {\n    e.originalEvent.preventDefault();\n    e.originalEvent.stopPropagation();\n  } else if (e.preventDefault) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n  return false;\n};\n\n// Custom hook to handle map events\nconst useMapEvents = (map) => {\n  React.useEffect(() => {\n    if (!map) return;\n\n    const events = ['click', 'dblclick', 'dragstart', 'mousedown'];\n    events.forEach(event => {\n      map.on(event, preventEvent);\n    });\n\n    return () => {\n      events.forEach(event => {\n        map.off(event, preventEvent);\n      });\n    };\n  }, [map]);\n};\n\n// Map Controls Component with enhanced event prevention\nconst MapControlHandlers = ({ mapRef, defaultView }) => {\n  const map = useMap();\n  useMapEvents(map);\n\n  const createHandler = useCallback((action) => (e) => {\n    preventEvent(e);\n    if (!mapRef.current) return;\n    \n    switch(action) {\n      case 'zoomIn':\n        mapRef.current.setZoom(mapRef.current.getZoom() + 1);\n        break;\n      case 'zoomOut':\n        mapRef.current.setZoom(mapRef.current.getZoom() - 1);\n        break;\n      case 'reset':\n        mapRef.current.setView(defaultView.center, defaultView.zoom);\n        break;\n      case 'refresh':\n        mapRef.current.invalidateSize();\n        break;\n    }\n  }, [mapRef, defaultView]);\n\n  return (\n    <MapControls\n      onZoomIn={createHandler('zoomIn')}\n      onZoomOut={createHandler('zoomOut')}\n      onReset={createHandler('reset')}\n      onRefresh={createHandler('refresh')}\n    />\n  );\n};\n\nconst FlowMap = ({\n  flows = [],\n  selectedFlow,\n  onFlowSelect,\n  height = '100%',\n  defaultView = { center: DEFAULT_CENTER, zoom: DEFAULT_ZOOM }\n}) => {\n  const mapRef = React.useRef(null);\n  const { commodity } = useSelector(selectFlowMetadata);\n  const { loading, error } = useSelector(selectFlowStatus);\n\n  // Create color scale\n  const colorScale = useMemo(() => {\n    try {\n      return chroma.scale([FLOW_COLORS.NEUTRAL, FLOW_COLORS.POSITIVE]).domain([0, 1]).mode('lch');\n    } catch (error) {\n      console.error('Error creating color scale:', error);\n      return () => FLOW_COLORS.NEUTRAL;\n    }\n  }, []);\n\n  const { markets, connections } = useMemo(() => {\n    if (!Array.isArray(flows)) return { markets: new Map(), connections: [] };\n\n    const marketMap = new Map();\n\n    flows.forEach(flow => {\n      if (!flow?.source || !flow?.target) return;\n      const sourceCoords = YEMEN_COORDINATES[flow.source.toLowerCase()];\n      const targetCoords = YEMEN_COORDINATES[flow.target.toLowerCase()];\n\n      if (!sourceCoords || !targetCoords) return;\n\n      if (!marketMap.has(flow.source)) {\n        marketMap.set(flow.source, {\n          id: flow.source,\n          name: flow.source,\n          coordinates: sourceCoords,\n          totalFlow: 0,\n          incomingFlows: 0,\n          outgoingFlows: 0\n        });\n      }\n      const sourceMarket = marketMap.get(flow.source);\n      sourceMarket.totalFlow += flow.flow_weight;\n      sourceMarket.outgoingFlows += 1;\n\n      if (!marketMap.has(flow.target)) {\n        marketMap.set(flow.target, {\n          id: flow.target,\n          name: flow.target,\n          coordinates: targetCoords,\n          totalFlow: 0,\n          incomingFlows: 0,\n          outgoingFlows: 0\n        });\n      }\n      const targetMarket = marketMap.get(flow.target);\n      targetMarket.totalFlow += flow.flow_weight;\n      targetMarket.incomingFlows += 1;\n    });\n\n    const maxFlow = Math.max(...flows.map(f => f.flow_weight), 0);\n    const processedConnections = flows\n      .filter(flow => {\n        const s = YEMEN_COORDINATES[flow.source?.toLowerCase()];\n        const t = YEMEN_COORDINATES[flow.target?.toLowerCase()];\n        return s && t && flowValidation.isValidFlow(flow);\n      })\n      .map(flow => {\n        const normalizedFlow = flowValidation.normalizeFlow(flow, maxFlow);\n        return {\n          ...flow,\n          coordinates: {\n            source: YEMEN_COORDINATES[flow.source.toLowerCase()],\n            target: YEMEN_COORDINATES[flow.target.toLowerCase()]\n          },\n          color: colorScale(normalizedFlow).hex(),\n          width: VISUALIZATION_PARAMS.MIN_FLOW_WIDTH +\n            (normalizedFlow * (VISUALIZATION_PARAMS.MAX_FLOW_WIDTH - VISUALIZATION_PARAMS.MIN_FLOW_WIDTH)),\n          opacity: VISUALIZATION_PARAMS.MIN_OPACITY +\n            (normalizedFlow * (VISUALIZATION_PARAMS.MAX_OPACITY - VISUALIZATION_PARAMS.MIN_OPACITY)),\n          normalizedFlow\n        };\n      });\n\n    return { markets: marketMap, connections: processedConnections };\n  }, [flows, colorScale]);\n\n  // Legend items\n  const legendItems = useMemo(() => [\n    { color: FLOW_COLORS.POSITIVE, label: 'High Flow', description: 'Flow > 70%' },\n    { color: colorScale(0.5).hex(), label: 'Medium Flow', description: '40% - 70%' },\n    { color: FLOW_COLORS.NEUTRAL, label: 'Low Flow', description: '<40%' },\n    {\n      color: FLOW_COLORS.NODE.FILL,\n      label: 'Market Point',\n      style: { borderRadius: '50%', border: `2px solid ${FLOW_COLORS.NODE.BORDER}` },\n      description: 'Active market location'\n    }\n  ], [colorScale]);\n\n  // Enhanced flow selection handler with comprehensive event prevention\n  const handleFlowSelect = useCallback((e, flow) => {\n    preventEvent(e);\n    if (onFlowSelect) {\n      onFlowSelect(e, flow);\n    }\n  }, [onFlowSelect]);\n\n  if (loading) {\n    return (\n      <Box \n        sx={{ \n          height,\n          display: 'flex', \n          alignItems: 'center', \n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n          p: 2,\n          flexDirection: 'column',\n          gap: 2\n        }}\n      >\n        <CircularProgress size={40} />\n        <Typography>\n          Loading market flows for {commodity}...\n        </Typography>\n      </Box>\n    );\n  }\n\n  if (error) {\n    return (\n      <Box \n        sx={{ \n          height,\n          display: 'flex', \n          alignItems: 'center', \n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n          p: 2\n        }}\n      >\n        <Typography color=\"error\">\n          Error loading market flows: {error}\n        </Typography>\n      </Box>\n    );\n  }\n\n  if (!connections.length) {\n    return (\n      <Box \n        sx={{ \n          height,\n          display: 'flex', \n          alignItems: 'center', \n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n          p: 2\n        }}\n      >\n        <Typography color=\"text.secondary\">\n          No valid market flow data available for {commodity}.\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ height, position: 'relative' }}>\n      <MapContainer\n        center={defaultView.center}\n        zoom={defaultView.zoom}\n        style={{ height: '100%', width: '100%' }}\n        zoomControl={false}\n        maxBounds={YEMEN_BOUNDS}\n        minZoom={5}\n        maxZoom={8}\n        scrollWheelZoom\n        dragging\n        touchZoom\n        doubleClickZoom={false}\n        boxZoom={false}\n        keyboard={false}\n        bounceAtZoomLimits\n        worldCopyJump={false}\n        preferCanvas\n        ref={mapRef}\n        onClick={preventEvent}\n        onDblClick={preventEvent}\n        onMouseDown={preventEvent}\n      >\n        <TileLayer\n          url=\"https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png\"\n          attribution='&copy; OpenStreetMap, &copy; CARTO'\n        />\n\n        <MapControlHandlers mapRef={mapRef} defaultView={defaultView} />\n\n        {/* TransitionGroup for smooth flow transitions */}\n        <TransitionGroup component={null}>\n          {connections.map((flow) => {\n            const isSelected =\n              selectedFlow &&\n              selectedFlow.source === flow.source &&\n              selectedFlow.target === flow.target;\n\n            return (\n              <CSSTransition key={`${flow.source}-${flow.target}`} classNames=\"flow\" timeout={300}>\n                <Polyline\n                  positions={[\n                    [flow.coordinates.source[1], flow.coordinates.source[0]],\n                    [flow.coordinates.target[1], flow.coordinates.target[0]]\n                  ]}\n                  pathOptions={{\n                    color: isSelected ? FLOW_COLORS.SELECTED : flow.color,\n                    weight: isSelected ? flow.width * VISUALIZATION_PARAMS.SELECTION_SCALE : flow.width,\n                    opacity: isSelected ? flow.opacity * VISUALIZATION_PARAMS.SELECTION_SCALE : flow.opacity,\n                    lineCap: 'round',\n                    lineJoin: 'round',\n                    interactive: true\n                  }}\n                  eventHandlers={{\n                    click: (e) => handleFlowSelect(e, flow),\n                    mouseover: (e) => {\n                      preventEvent(e);\n                      e.target.setStyle({ weight: flow.width * 1.5 });\n                    },\n                    mouseout: (e) => {\n                      preventEvent(e);\n                      if (!isSelected) {\n                        e.target.setStyle({ weight: flow.width });\n                      }\n                    }\n                  }}\n                >\n                  <Popup>\n                    <Box sx={{ p: 1, minWidth: 200 }}>\n                      <Typography variant=\"subtitle2\" gutterBottom>\n                        Market Flow Details\n                      </Typography>\n                      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>\n                        <Typography variant=\"body2\">Source: {flow.source}</Typography>\n                        <Typography variant=\"body2\">Target: {flow.target}</Typography>\n                        <Typography variant=\"body2\">Flow Volume: {flow.flow_weight.toFixed(2)}</Typography>\n                        <Typography variant=\"body2\">Flow Strength: {(flow.normalizedFlow * 100).toFixed(1)}%</Typography>\n                        {flow.price_differential && (\n                          <Typography variant=\"body2\">\n                            Price Differential: {flow.price_differential.toFixed(2)}\n                          </Typography>\n                        )}\n                      </Box>\n                    </Box>\n                  </Popup>\n                </Polyline>\n              </CSSTransition>\n            );\n          })}\n        </TransitionGroup>\n\n        {Array.from(markets.values()).map((market) => {\n          const maxFlow = Math.max(...Array.from(markets.values()).map(m => m.totalFlow));\n          const nodeSize = flowValidation.calculateNodeSize(market.totalFlow, maxFlow);\n          return (\n            <CircleMarker\n              key={`market-${market.id}`}\n              center={[market.coordinates[1], market.coordinates[0]]}\n              radius={nodeSize}\n              pathOptions={{\n                fillColor: FLOW_COLORS.NODE.FILL,\n                color: FLOW_COLORS.NODE.BORDER,\n                weight: VISUALIZATION_PARAMS.NODE_BORDER_WIDTH,\n                opacity: VISUALIZATION_PARAMS.NODE_BORDER_OPACITY,\n                fillOpacity: VISUALIZATION_PARAMS.NODE_OPACITY\n              }}\n              eventHandlers={{\n                click: preventEvent,\n                mouseover: preventEvent,\n                mouseout: preventEvent\n              }}\n            >\n              <Popup>\n                <Box sx={{ p: 1, minWidth: 200 }}>\n                  <Typography variant=\"subtitle2\" gutterBottom>\n                    {market.name}\n                  </Typography>\n                  <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>\n                    <Typography variant=\"body2\">Total Flow: {market.totalFlow.toFixed(2)}</Typography>\n                    <Typography variant=\"body2\">Incoming: {market.incomingFlows}</Typography>\n                    <Typography variant=\"body2\">Outgoing: {market.outgoingFlows}</Typography>\n                  </Box>\n                </Box>\n              </Popup>\n            </CircleMarker>\n          );\n        })}\n      </MapContainer>\n\n      <Legend\n        title={`Market Flow Analysis - ${commodity}`}\n        items={legendItems}\n      />\n    </Box>\n  );\n};\n\nFlowMap.propTypes = {\n  flows: PropTypes.arrayOf(\n    PropTypes.shape({\n      source: PropTypes.string.isRequired,\n      target: PropTypes.string.isRequired,\n      flow_weight: PropTypes.number.isRequired,\n      price_differential: PropTypes.number,\n      metadata: PropTypes.shape({\n        valid: PropTypes.bool.isRequired,\n        processed_at: PropTypes.string.isRequired\n      }).isRequired\n    })\n  ).isRequired,\n  selectedFlow: PropTypes.shape({\n    source: PropTypes.string.isRequired,\n    target: PropTypes.string.isRequired\n  }),\n  onFlowSelect: PropTypes.func,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  defaultView: PropTypes.shape({\n    center: PropTypes.arrayOf(PropTypes.number),\n    zoom: PropTypes.number\n  })\n};\n\nexport default React.memo(FlowMap);\n",
        "imports": [
          "react",
          "prop-types",
          "react-redux",
          "@mui/material",
          "react-leaflet",
          "leaflet",
          "chroma-js",
          "leaflet/dist/leaflet.css",
          "react-transition-group",
          "../../atoms/Legend",
          "../../molecules/MapControls",
          "./types",
          "../../../../selectors/optimizedSelectors",
          "../../../../slices/flowSlice",
          "./FlowMapTransitions.css"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "react-redux",
          "@mui/material",
          "react-leaflet",
          "leaflet",
          "chroma-js",
          "leaflet/dist/leaflet.css",
          "react-transition-group",
          "../../atoms/Legend",
          "../../molecules/MapControls",
          "./types",
          "../../../../selectors/optimizedSelectors",
          "../../../../slices/flowSlice",
          "./FlowMapTransitions.css"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/flows/FlowMetricsPanel.js",
        "content": "/**\n * Market Flow Metrics Panel Component\n * \n * Provides comprehensive analysis of market flow patterns including:\n * - Network-level metrics\n * - Individual flow analysis\n * - Statistical significance testing\n * - Trend analysis\n */\n\nimport React, { useMemo, useState, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { useSelector } from 'react-redux';\nimport {\n  Paper,\n  Typography,\n  Box,\n  Divider,\n  Grid,\n  Button,\n  Collapse,\n  List,\n  ListItem,\n  ListItemText,\n  Alert,\n  CircularProgress\n} from '@mui/material';\nimport InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\n\nimport MetricCard from '../../atoms/MetricCard';\nimport MetricProgress from '../../molecules/MetricProgress';\nimport { \n  FLOW_THRESHOLDS, \n  NETWORK_THRESHOLDS,\n  FLOW_STATUS,\n  flowValidation\n} from './types';\nimport { \n  selectFlowMetrics,\n  selectFlowMetadata,\n  selectFlowStatus\n} from '../../../../slices/flowSlice';\n\n// Performance monitoring wrapper\nconst withPerformanceMonitoring = (fn, label) => (...args) => {\n  const start = performance.now();\n  try {\n    const result = fn(...args);\n    const duration = performance.now() - start;\n    if (duration > 100) { // Log if calculation takes more than 100ms\n      console.debug(`Performance: ${label} took ${duration.toFixed(2)}ms`);\n    }\n    return result;\n  } catch (error) {\n    console.error(`Error in ${label}:`, error);\n    throw error;\n  }\n};\n\n// Helper function to calculate statistical significance\nconst calculateSignificance = withPerformanceMonitoring((value, mean, stdDev) => {\n  if (!stdDev || typeof value !== 'number' || typeof mean !== 'number') {\n    return { significant: false, zScore: 0, pValue: 1 };\n  }\n  const zScore = (value - mean) / stdDev;\n  return {\n    significant: Math.abs(zScore) > 1.96, // 95% confidence level\n    zScore,\n    pValue: 2 * (1 - normalCDF(Math.abs(zScore)))\n  };\n}, 'calculateSignificance');\n\n// Helper function for normal CDF with type checking\nconst normalCDF = (x) => {\n  if (typeof x !== 'number') return 0;\n  const t = 1 / (1 + 0.2316419 * Math.abs(x));\n  const d = 0.3989423 * Math.exp(-x * x / 2);\n  const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));\n  return x > 0 ? 1 - p : p;\n};\n\n// Type validation helper\nconst isValidFlow = (flow) => {\n  return flow && \n    typeof flow.source === 'string' && \n    typeof flow.target === 'string' && \n    typeof flow.flow_weight === 'number' &&\n    flow.metadata?.valid === true;\n};\n\nconst FlowMetricsPanel = ({\n  flows = [],\n  selectedFlow,\n  timeRange\n}) => {\n  const [showMethodology, setShowMethodology] = useState(false);\n  const flowMetrics = useSelector(selectFlowMetrics);\n  const { commodity } = useSelector(selectFlowMetadata);\n  const { loading, error } = useSelector(selectFlowStatus);\n\n  // Memoized flow validation\n  const validFlows = useMemo(() => {\n    return Array.isArray(flows) ? flows.filter(isValidFlow) : [];\n  }, [flows]);\n\n  // Calculate comprehensive flow metrics with safe defaults\n  const metrics = useMemo(() => withPerformanceMonitoring(() => {\n    const defaultMetrics = {\n      basic: {\n        totalFlow: 0,\n        avgFlow: 0,\n        maxFlow: 0,\n        minFlow: 0,\n        stdDev: 0,\n        count: 0\n      },\n      distribution: {\n        q1: 0,\n        q3: 0,\n        iqr: 0,\n        skewness: 0,\n        kurtosis: 0\n      },\n      networkMetrics: {\n        density: 0,\n        connectivity: 0,\n        centralization: 0\n      }\n    };\n\n    if (!validFlows.length) {\n      return defaultMetrics;\n    }\n\n    try {\n      // Calculate basic metrics with safety checks\n      const flowValues = validFlows.map(f => flowValidation.getFlowValue(f));\n      const totalFlow = flowValues.reduce((sum, val) => sum + val, 0);\n      const avgFlow = flowValues.length > 0 ? totalFlow / flowValues.length : 0;\n      const maxFlow = Math.max(...flowValues, 0);\n      const minFlow = Math.min(...flowValues);\n\n      // Calculate standard deviation with safety checks\n      const variance = flowValues.length > 0 ?\n        flowValues.reduce((sum, val) => sum + Math.pow(val - avgFlow, 2), 0) / flowValues.length : 0;\n      const stdDev = Math.sqrt(variance);\n\n      // Calculate quartiles and IQR with safety checks\n      const sortedFlows = [...flowValues].sort((a, b) => a - b);\n      const q1 = sortedFlows[Math.floor(flowValues.length * 0.25)] || 0;\n      const q3 = sortedFlows[Math.floor(flowValues.length * 0.75)] || 0;\n      const iqr = q3 - q1;\n\n      // Network metrics with safety checks\n      const activeFlows = flowValues.filter(f => f > 0).length;\n      const maxPossibleFlows = validFlows.length * (validFlows.length - 1) / 2;\n      const flowDensity = maxPossibleFlows > 0 ? \n        Math.min(1, Math.max(0, activeFlows / maxPossibleFlows)) : 0;\n\n      // Distribution metrics with safety checks\n      const skewness = stdDev > 0 ? \n        flowValues.reduce((sum, val) => sum + Math.pow((val - avgFlow) / stdDev, 3), 0) / \n        (flowValues.length || 1) : 0;\n\n      const kurtosis = stdDev > 0 ? \n        (flowValues.reduce((sum, val) => sum + Math.pow((val - avgFlow) / stdDev, 4), 0) / \n        (flowValues.length || 1)) - 3 : 0;\n\n      return {\n        basic: {\n          totalFlow: Math.max(0, totalFlow),\n          avgFlow: Math.max(0, avgFlow),\n          maxFlow: Math.max(0, maxFlow),\n          minFlow: Math.max(0, minFlow),\n          stdDev: Math.max(0, stdDev),\n          count: validFlows.length\n        },\n        distribution: {\n          q1: Math.max(0, q1),\n          q3: Math.max(0, q3),\n          iqr: Math.max(0, iqr),\n          skewness: Math.max(-3, Math.min(3, skewness)),\n          kurtosis: Math.max(-3, Math.min(3, kurtosis))\n        },\n        networkMetrics: {\n          density: Math.min(1, Math.max(0, flowDensity)),\n          connectivity: Math.min(1, Math.max(0, validFlows.length > 0 ? activeFlows / validFlows.length : 0)),\n          centralization: Math.min(1, Math.max(0, maxPossibleFlows > 0 ? activeFlows / maxPossibleFlows : 0))\n        }\n      };\n    } catch (error) {\n      console.error('Error calculating flow metrics:', error);\n      return defaultMetrics;\n    }\n  }, 'calculateMetrics')(), [validFlows]);\n\n  // Calculate selected flow metrics with safe defaults\n  const selectedFlowMetrics = useMemo(() => withPerformanceMonitoring(() => {\n    const defaultSelectedMetrics = {\n      normalizedFlow: 0,\n      relativeStrength: 0,\n      percentile: 0,\n      significance: {\n        significant: false,\n        zScore: 0,\n        pValue: 1\n      },\n      status: FLOW_STATUS.INACTIVE,\n      metrics: {\n        zScore: 0,\n        pValue: 1,\n        standardizedValue: 0\n      }\n    };\n\n    if (!selectedFlow || !metrics || !validFlows.length) return defaultSelectedMetrics;\n\n    try {\n      const flow = validFlows.find(f => \n        f.source === selectedFlow.source && \n        f.target === selectedFlow.target\n      );\n\n      if (!flow) return defaultSelectedMetrics;\n\n      const flowValue = flowValidation.getFlowValue(flow);\n\n      // Calculate relative metrics with safety checks\n      const relativeStrength = metrics.basic.avgFlow > 0 ? \n        Math.min(1, Math.max(0, flowValue / metrics.basic.avgFlow)) : 0;\n      \n      const percentile = validFlows.length > 0 ? \n        Math.min(100, Math.max(0, \n          validFlows.filter(f => flowValidation.getFlowValue(f) <= flowValue).length / validFlows.length * 100\n        )) : 0;\n\n      // Calculate significance with safety checks\n      const significance = calculateSignificance(\n        flowValue,\n        metrics.basic.avgFlow,\n        metrics.basic.stdDev\n      );\n\n      // Calculate normalized flow with safety checks\n      const normalizedFlow = metrics.basic.maxFlow > 0 ? \n        Math.min(1, Math.max(0, flowValue / metrics.basic.maxFlow)) : 0;\n\n      // Determine flow status\n      const status = flowValidation.getFlowStatus(normalizedFlow);\n\n      return {\n        ...flow,\n        relativeStrength,\n        percentile,\n        normalizedFlow,\n        significance,\n        status,\n        metrics: {\n          zScore: Math.max(-10, Math.min(10, significance.zScore)),\n          pValue: Math.min(1, Math.max(0, significance.pValue)),\n          standardizedValue: metrics.basic.stdDev > 0 ? \n            Math.max(-10, Math.min(10, (flowValue - metrics.basic.avgFlow) / metrics.basic.stdDev)) : 0\n        }\n      };\n    } catch (error) {\n      console.error('Error calculating selected flow metrics:', error);\n      return defaultSelectedMetrics;\n    }\n  }, 'calculateSelectedFlowMetrics')(), [selectedFlow, validFlows, metrics]);\n\n  // Handle methodology toggle with event prevention\n  const handleMethodologyToggle = useCallback((e) => {\n    if (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    setShowMethodology(prev => !prev);\n  }, []);\n\n  // Ensure we have valid values for display\n  const safeMetrics = useMemo(() => ({\n    network: {\n      density: metrics?.networkMetrics?.density || 0,\n      connectivity: metrics?.networkMetrics?.connectivity || 0,\n      centralization: metrics?.networkMetrics?.centralization || 0\n    },\n    selected: {\n      normalizedFlow: selectedFlowMetrics?.normalizedFlow || 0,\n      significance: selectedFlowMetrics?.significance || { significant: false, zScore: 0, pValue: 1 }\n    }\n  }), [metrics, selectedFlowMetrics]);\n\n  if (loading) {\n    return (\n      <Paper sx={{ p: 2, height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>\n        <Box sx={{ textAlign: 'center' }}>\n          <CircularProgress size={40} sx={{ mb: 2 }} />\n          <Typography>\n            Loading flow metrics for {commodity}...\n          </Typography>\n        </Box>\n      </Paper>\n    );\n  }\n\n  if (error) {\n    return (\n      <Paper sx={{ p: 2, height: '100%' }}>\n        <Alert severity=\"error\">\n          Error loading flow metrics: {error}\n        </Alert>\n      </Paper>\n    );\n  }\n\n  if (!metrics || !metrics.basic.count) {\n    return (\n      <Paper sx={{ p: 2, height: '100%' }}>\n        <Alert severity=\"warning\">\n          No valid flow metrics available for {commodity} in {timeRange}.\n        </Alert>\n      </Paper>\n    );\n  }\n\n  return (\n    <Paper sx={{ p: 2, height: '100%', overflow: 'auto' }}>\n      {/* Network Flow Analysis */}\n      <Box sx={{ mb: 3 }}>\n        <Typography variant=\"h6\" gutterBottom>\n          Network Flow Analysis\n          {timeRange && (\n            <Typography variant=\"caption\" display=\"block\" color=\"textSecondary\">\n              {commodity} - Period: {timeRange}\n            </Typography>\n          )}\n        </Typography>\n        \n        <Grid container spacing={2}>\n          <Grid item xs={12}>\n            <MetricProgress\n              title=\"Network Flow Strength\"\n              value={safeMetrics.network.density}\n              target={NETWORK_THRESHOLDS.DENSITY.HIGH}\n              format=\"percentage\"\n              description=\"Overall network utilization\"\n              tooltip=\"Measures how close the network is to its theoretical maximum capacity\"\n            />\n          </Grid>\n          \n          <Grid item xs={12} md={6}>\n            <MetricCard\n              title=\"Flow Density\"\n              value={metrics.networkMetrics.density}\n              format=\"percentage\"\n              description=\"Active market connections\"\n              tooltip=\"Percentage of potential market connections that are active\"\n              thresholds={NETWORK_THRESHOLDS.DENSITY}\n            />\n          </Grid>\n          \n          <Grid item xs={12} md={6}>\n            <MetricCard\n              title=\"Network Connectivity\"\n              value={metrics.networkMetrics.connectivity}\n              format=\"percentage\"\n              description=\"Market integration level\"\n              tooltip=\"Degree of market integration in the network\"\n            />\n          </Grid>\n        </Grid>\n\n        <Divider sx={{ my: 2 }} />\n        \n        {/* Distribution Metrics */}\n        <Typography variant=\"subtitle1\" gutterBottom>\n          Flow Distribution\n        </Typography>\n        \n        <Grid container spacing={2}>\n          <Grid item xs={12} md={6}>\n            <MetricCard\n              title=\"Variability\"\n              value={metrics.basic.stdDev / metrics.basic.avgFlow}\n              format=\"number\"\n              description=\"Flow consistency\"\n              tooltip=\"Lower values indicate more uniform flow distribution\"\n            />\n          </Grid>\n          \n          <Grid item xs={12} md={6}>\n            <MetricCard\n              title=\"Distribution Shape\"\n              value={metrics.distribution.skewness}\n              format=\"number\"\n              description=\"Flow symmetry\"\n              tooltip=\"Positive values indicate right-skewed distribution\"\n            />\n          </Grid>\n        </Grid>\n      </Box>\n\n      {/* Selected Flow Analysis */}\n      {selectedFlowMetrics && (\n        <>\n          <Divider sx={{ my: 3 }} />\n          <Typography variant=\"h6\" gutterBottom>\n            Selected Flow Analysis\n          </Typography>\n          \n          <Typography \n            variant=\"subtitle2\" \n            color=\"textSecondary\" \n            gutterBottom\n            sx={{ mb: 2 }}\n          >\n            {selectedFlowMetrics.source} → {selectedFlowMetrics.target}\n          </Typography>\n\n          <Grid container spacing={2}>\n            <Grid item xs={12}>\n              <MetricProgress\n                title=\"Flow Strength\"\n                value={safeMetrics.selected.normalizedFlow}\n                target={FLOW_THRESHOLDS.HIGH}\n                format=\"percentage\"\n                description=\"Relative to maximum flow\"\n                tooltip=\"How strong this flow is compared to the strongest flow in the network\"\n              />\n            </Grid>\n\n            <Grid item xs={12} md={6}>\n              <MetricCard\n                title=\"Statistical Significance\"\n                value={Math.abs(selectedFlowMetrics.metrics.zScore)}\n                format=\"number\"\n                description={`p-value: ${selectedFlowMetrics.metrics.pValue.toFixed(4)}`}\n                tooltip=\"Z-score indicates deviation from mean in standard deviations\"\n              />\n            </Grid>\n\n            <Grid item xs={12} md={6}>\n              <MetricCard\n                title=\"Flow Percentile\"\n                value={selectedFlowMetrics.percentile / 100}\n                format=\"percentage\"\n                description=\"Relative ranking\"\n                tooltip=\"Percentage of flows that are weaker than this one\"\n              />\n            </Grid>\n          </Grid>\n\n          {selectedFlowMetrics.significance.significant && (\n            <Alert \n              severity=\"info\" \n              sx={{ mt: 2 }}\n              icon={<InfoOutlinedIcon />}\n            >\n              This is a statistically significant flow (p &lt; 0.05), indicating\n              a strong market connection.\n            </Alert>\n          )}\n        </>\n      )}\n\n      {/* Methodology Section */}\n      <Box sx={{ mt: 3 }}>\n        <Button\n          fullWidth\n          onClick={handleMethodologyToggle}\n          onMouseDown={(e) => e.preventDefault()}\n          endIcon={showMethodology ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n          startIcon={<InfoOutlinedIcon />}\n        >\n          Flow Analysis Methodology\n        </Button>\n        \n        <Collapse in={showMethodology}>\n          <Box sx={{ mt: 2, p: 2, bgcolor: 'background.paper', borderRadius: 1 }}>\n            <Typography variant=\"subtitle1\" gutterBottom>\n              Understanding Flow Metrics\n            </Typography>\n            \n            <List dense>\n              <ListItem>\n                <ListItemText\n                  primary=\"Network Metrics\"\n                  secondary=\"Measures overall market integration and connectivity patterns\"\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary=\"Flow Distribution\"\n                  secondary=\"Analyzes the pattern and consistency of market flows\"\n                />\n              </ListItem>\n              <ListItem>\n                <ListItemText\n                  primary=\"Statistical Significance\"\n                  secondary=\"Uses z-scores and p-values to identify important market connections\"\n                />\n              </ListItem>\n            </List>\n\n            <Typography variant=\"subtitle2\" gutterBottom sx={{ mt: 2 }}>\n              Interpretation Guide:\n            </Typography>\n            <Typography variant=\"body2\" component=\"div\">\n              • Strong Flow (&gt;{FLOW_THRESHOLDS.HIGH * 100}%): Robust market connection<br/>\n              • Medium Flow ({FLOW_THRESHOLDS.MEDIUM * 100}-{FLOW_THRESHOLDS.HIGH * 100}%): Moderate trade<br/>\n              • Weak Flow (&lt;{FLOW_THRESHOLDS.MEDIUM * 100}%): Limited market interaction\n            </Typography>\n          </Box>\n        </Collapse>\n      </Box>\n    </Paper>\n  );\n};\n\nFlowMetricsPanel.propTypes = {\n  flows: PropTypes.arrayOf(PropTypes.shape({\n    source: PropTypes.string.isRequired,\n    target: PropTypes.string.isRequired,\n    flow_weight: PropTypes.number.isRequired,\n    price_differential: PropTypes.number,\n    metadata: PropTypes.shape({\n      valid: PropTypes.bool.isRequired,\n      processed_at: PropTypes.string.isRequired\n    }).isRequired\n  })).isRequired,\n  selectedFlow: PropTypes.shape({\n    source: PropTypes.string.isRequired,\n    target: PropTypes.string.isRequired\n  }),\n  timeRange: PropTypes.string\n};\n\nexport default React.memo(FlowMetricsPanel);\n",
        "imports": [
          "react",
          "prop-types",
          "react-redux",
          "@mui/material",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "../../atoms/MetricCard",
          "../../molecules/MetricProgress",
          "./types",
          "../../../../slices/flowSlice"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "react-redux",
          "@mui/material",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "../../atoms/MetricCard",
          "../../molecules/MetricProgress",
          "./types",
          "../../../../slices/flowSlice"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/flows/FlowNetworkAnalysis.js",
        "content": "/**\n * Flow Network Analysis Component\n */\n\nimport React, { useState, useMemo, useCallback } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  Grid,\n  Paper,\n  Typography,\n  Box,\n  Alert,\n  Collapse,\n  Button,\n  List,\n  ListItem,\n  ListItemText\n} from '@mui/material';\nimport InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\n\nimport FlowMap from './FlowMap';\nimport FlowMetricsPanel from './FlowMetricsPanel';\nimport FlowDateControl from './FlowDateControl';\nimport MetricCard from '../../atoms/MetricCard';\nimport { setSelectedDate } from '../../../../slices/spatialSlice';\nimport { useFlowDataManager } from '../../../../hooks/useFlowDataManager';\nimport { selectFlowMetrics } from '../../../../slices/flowSlice';\nimport { \n  FLOW_THRESHOLDS, \n  NETWORK_THRESHOLDS,\n  FLOW_STATUS,\n  flowValidation\n} from './types';\n\n// Default map settings\nconst MAP_SETTINGS = {\n  center: [15.3694, 44.191], // Yemen center\n  zoom: 6.5\n};\n\n// Helper function to prevent default events\nconst preventEvent = (e) => {\n  if (e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n  return false;\n};\n\nconst FlowNetworkAnalysis = () => {\n  const dispatch = useDispatch();\n  \n  // Component state\n  const [selectedFlow, setSelectedFlow] = useState(null);\n  const [showMethodology, setShowMethodology] = useState(false);\n\n  // Get data from Redux\n  const selectedDate = useSelector(state => state.spatial.ui.selectedDate);\n  const selectedCommodity = useSelector(state => state.spatial.ui.selectedCommodity);\n  const flowMetrics = useSelector(selectFlowMetrics);\n  const availableDates = useSelector(state => state.spatial.data.uniqueMonths || []);\n\n  // Use the flow data manager hook\n  const {\n    flows: currentFlows,\n    metadata: { totalFlows, uniqueMarkets },\n    loading,\n    error,\n    refreshData\n  } = useFlowDataManager();\n\n  // Process flows with additional metrics\n  const processedFlows = useMemo(() => {\n    if (!currentFlows?.length) {\n      console.debug('No flows available for processing:', { date: selectedDate, commodity: selectedCommodity });\n      return [];\n    }\n\n    console.debug('Processing flows:', { \n      count: currentFlows.length, \n      date: selectedDate, \n      commodity: selectedCommodity \n    });\n\n    const maxFlow = Math.max(...currentFlows.map(f => f.flow_weight));\n\n    return currentFlows.map(flow => {\n      const normalizedFlow = flowValidation.normalizeFlow(flow, maxFlow);\n      const status = flowValidation.getFlowStatus(normalizedFlow);\n\n      return {\n        ...flow,\n        normalizedFlow,\n        normalizedPriceDiff: maxFlow > 0 ? Math.abs(flow.price_differential || 0) / maxFlow : 0,\n        status\n      };\n    });\n  }, [currentFlows, selectedDate, selectedCommodity]);\n\n  // Handle date change with event prevention\n  const handleDateChange = useCallback((e, newDate) => {\n    preventEvent(e);\n    if (newDate !== selectedDate) {\n      console.debug('Date changed:', { from: selectedDate, to: newDate, commodity: selectedCommodity });\n      // Reset selected flow when date changes\n      setSelectedFlow(null);\n      // Update the selected date in the spatial slice\n      dispatch(setSelectedDate(newDate));\n    }\n  }, [dispatch, selectedDate, selectedCommodity]);\n\n  // Handle flow selection with event prevention\n  const handleFlowSelect = useCallback((event, flow) => {\n    preventEvent(event);\n    setSelectedFlow(flow);\n  }, []);\n\n  // Handle methodology toggle with event prevention\n  const handleMethodologyToggle = useCallback((e) => {\n    preventEvent(e);\n    setShowMethodology(prev => !prev);\n  }, []);\n\n  // Handle reload with event prevention\n  const handleReload = useCallback((e) => {\n    preventEvent(e);\n    refreshData();\n  }, [refreshData]);\n\n  if (!selectedCommodity) {\n    return (\n      <Alert severity=\"warning\" sx={{ m: 2 }}>\n        Please select a commodity from the sidebar to view market flows.\n      </Alert>\n    );\n  }\n\n  if (error) {\n    return (\n      <Alert \n        severity=\"error\" \n        sx={{ m: 2 }}\n        action={\n          <Button \n            color=\"inherit\" \n            size=\"small\" \n            onClick={handleReload}\n            onMouseDown={preventEvent}\n          >\n            Reload\n          </Button>\n        }\n      >\n        Error loading flow analysis: {error}\n      </Alert>\n    );\n  }\n\n  return (\n    <Grid container spacing={2}>\n      {/* Overview Metrics */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Grid container spacing={2}>\n            <Grid item xs={12}>\n              <Typography variant=\"h6\" gutterBottom>\n                {selectedCommodity} Market Flows\n                {selectedDate && (\n                  <Typography variant=\"caption\" display=\"block\" color=\"textSecondary\">\n                    Period: {selectedDate}\n                  </Typography>\n                )}\n              </Typography>\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Box>\n                <MetricCard\n                  title=\"Total Flow Volume\"\n                  value={flowMetrics?.totalFlows || 0}\n                  format=\"number\"\n                  description=\"Sum of all market flows\"\n                />\n              </Box>\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Box>\n                <MetricCard\n                  title=\"Average Flow\"\n                  value={flowMetrics?.averageFlowWeight || 0}\n                  format=\"number\"\n                  description=\"Average flow per connection\"\n                />\n              </Box>\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Box>\n                <MetricCard\n                  title=\"Market Connectivity\"\n                  value={flowMetrics?.marketConnectivity || 0}\n                  format=\"percentage\"\n                  description=\"Network connection density\"\n                  thresholds={NETWORK_THRESHOLDS.DENSITY}\n                />\n              </Box>\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <Box>\n                <MetricCard\n                  title=\"Active Markets\"\n                  value={uniqueMarkets || 0}\n                  format=\"integer\"\n                  description=\"Unique market locations\"\n                />\n              </Box>\n            </Grid>\n          </Grid>\n        </Paper>\n      </Grid>\n\n      {/* Date Control */}\n      {availableDates.length > 0 && (\n        <Grid item xs={12}>\n          <FlowDateControl\n            dates={availableDates}\n            currentDate={selectedDate || availableDates[0]}\n            onChange={handleDateChange}\n            loading={loading}\n          />\n        </Grid>\n      )}\n\n      {/* Loading State */}\n      {loading && (\n        <Grid item xs={12}>\n          <Alert severity=\"info\">\n            Loading flow data for {selectedCommodity} ({selectedDate})...\n          </Alert>\n        </Grid>\n      )}\n\n      {/* No Data State */}\n      {!loading && !error && (!currentFlows || currentFlows.length === 0) && (\n        <Grid item xs={12}>\n          <Alert severity=\"warning\">\n            No flow data available for {selectedCommodity} in {selectedDate}\n          </Alert>\n        </Grid>\n      )}\n\n      {/* Map Visualization */}\n      {processedFlows.length > 0 && (\n        <Grid item xs={12}>\n          <Paper sx={{ p: 2, height: 500 }}>\n            <FlowMap\n              flows={processedFlows}\n              selectedFlow={selectedFlow}\n              onFlowSelect={handleFlowSelect}\n              defaultView={MAP_SETTINGS}\n            />\n          </Paper>\n        </Grid>\n      )}\n\n      {/* Metrics Panel */}\n      {processedFlows.length > 0 && (\n        <Grid item xs={12}>\n          <FlowMetricsPanel\n            flows={processedFlows}\n            selectedFlow={selectedFlow}\n            timeRange={selectedDate}\n          />\n        </Grid>\n      )}\n\n      {/* Methodology */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Button\n            fullWidth\n            onClick={handleMethodologyToggle}\n            onMouseDown={preventEvent}\n            endIcon={showMethodology ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n            startIcon={<InfoOutlinedIcon />}\n          >\n            Methodology\n          </Button>\n          <Collapse in={showMethodology}>\n            <Box sx={{ mt: 2, p: 2 }}>\n              <Typography variant=\"body2\" paragraph>\n                This analysis examines market flows across Yemen using geographic visualization\n                and statistical metrics to understand trade patterns and market integration.\n                Flow strength is represented through line thickness and color intensity,\n                while market points indicate trading locations.\n              </Typography>\n\n              <List dense>\n                <ListItem>\n                  <ListItemText\n                    primary={\n                      <Typography variant=\"subtitle2\" color=\"primary\">\n                        Flow Analysis\n                      </Typography>\n                    }\n                    secondary={\n                      <Typography variant=\"body2\" color=\"textSecondary\">\n                        Measures trade volume and consistency between markets, normalized\n                        for regional variations and market size\n                      </Typography>\n                    }\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary={\n                      <Typography variant=\"subtitle2\" color=\"primary\">\n                        Market Integration\n                      </Typography>\n                    }\n                    secondary={\n                      <Typography variant=\"body2\" color=\"textSecondary\">\n                        Evaluates market connectivity through flow density and price\n                        correlation analysis\n                      </Typography>\n                    }\n                  />\n                </ListItem>\n              </List>\n\n              <Typography variant=\"subtitle2\" gutterBottom sx={{ mt: 2 }} color=\"primary\">\n                Flow Classification:\n              </Typography>\n              <Typography variant=\"body2\" component=\"div\">\n                • Strong Flow (&gt;{FLOW_THRESHOLDS.HIGH * 100}%): Robust market connection<br/>\n                • Medium Flow ({FLOW_THRESHOLDS.MEDIUM * 100}-{FLOW_THRESHOLDS.HIGH * 100}%): Moderate trade<br/>\n                • Weak Flow (&lt;{FLOW_THRESHOLDS.MEDIUM * 100}%): Limited market interaction\n              </Typography>\n            </Box>\n          </Collapse>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default React.memo(FlowNetworkAnalysis);\n",
        "imports": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "./FlowMap",
          "./FlowMetricsPanel",
          "./FlowDateControl",
          "../../atoms/MetricCard",
          "../../../../slices/spatialSlice",
          "../../../../hooks/useFlowDataManager",
          "../../../../slices/flowSlice",
          "./types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "./FlowMap",
          "./FlowMetricsPanel",
          "./FlowDateControl",
          "../../atoms/MetricCard",
          "../../../../slices/spatialSlice",
          "../../../../hooks/useFlowDataManager",
          "../../../../slices/flowSlice",
          "./types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/flows/index.js",
        "content": "//src/components/spatialAnalysis/features/flows/index.js\n\n/**\n * Flow Analysis Components\n * \n * Provides components and utilities for market flow network visualization\n */\n\nexport { default as FlowNetworkAnalysis } from './FlowNetworkAnalysis';\nexport { default as FlowMap } from './FlowMap';\nexport { default as FlowMetricsPanel } from './FlowMetricsPanel';\nexport { \n  FLOW_THRESHOLDS,\n  FLOW_TYPES,\n  NETWORK_THRESHOLDS,\n  VISUALIZATION_PARAMS,\n  ANALYSIS_PARAMS,\n  FLOW_COLORS,\n  FLOW_STATUS,\n  flowValidation\n} from './types';\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/flows/types.js",
        "content": "/**\n * Types and constants for market flow analysis\n */\n\n// Flow strength thresholds\nexport const FLOW_THRESHOLDS = {\n  HIGH: 0.7,    // Strong market flow\n  MEDIUM: 0.4,  // Moderate market flow\n  LOW: 0.2      // Weak market flow\n};\n\n// Flow types based on characteristics\nexport const FLOW_TYPES = {\n  BIDIRECTIONAL: 'bidirectional',  // Flow in both directions\n  UNIDIRECTIONAL: 'unidirectional', // Flow in one direction\n  INTERMITTENT: 'intermittent'     // Irregular flow\n};\n\n// Network metrics thresholds\nexport const NETWORK_THRESHOLDS = {\n  DENSITY: {\n    HIGH: 0.6,    // High network density\n    MEDIUM: 0.3,  // Medium network density\n    LOW: 0.1      // Low network density\n  },\n  CENTRALITY: {\n    HIGH: 0.8,    // High centrality\n    MEDIUM: 0.5,  // Medium centrality\n    LOW: 0.2      // Low centrality\n  }\n};\n\n// Flow visualization parameters\nexport const VISUALIZATION_PARAMS = {\n  // Flow line parameters\n  MIN_FLOW_WIDTH: 1,       // Minimum flow line width\n  MAX_FLOW_WIDTH: 5,       // Maximum flow line width\n  MIN_OPACITY: 0.4,        // Minimum flow opacity\n  MAX_OPACITY: 0.8,        // Maximum flow opacity\n  \n  // Market node parameters\n  MIN_NODE_SIZE: 4,        // Minimum market node size\n  MAX_NODE_SIZE: 10,       // Maximum market node size\n  NODE_BORDER_WIDTH: 1,    // Node border width\n  NODE_OPACITY: 0.8,       // Node fill opacity\n  NODE_BORDER_OPACITY: 1,  // Node border opacity\n  \n  // Selection parameters\n  SELECTION_SCALE: 1.5,    // Scale factor for selected elements\n  HOVER_SCALE: 1.2,        // Scale factor for hovered elements\n  \n  // Animation parameters\n  ANIMATION_DURATION: 200  // Animation duration in ms\n};\n\n// Flow color scheme\nexport const FLOW_COLORS = {\n  POSITIVE: '#1976d2',    // Positive flow direction (blue)\n  NEGATIVE: '#d32f2f',    // Negative flow direction (red)\n  NEUTRAL: '#757575',     // Neutral or baseline flow (gray)\n  SELECTED: '#ffc107',    // Selected flow highlight (amber)\n  NODE: {\n    FILL: '#1976d2',      // Node fill color (blue)\n    BORDER: '#ffffff',    // Node border color (white)\n    SELECTED: '#ffc107',  // Selected node color (amber)\n    INACTIVE: '#757575'   // Inactive node color (gray)\n  }\n};\n\n// Flow status indicators\nexport const FLOW_STATUS = {\n  ACTIVE: 'Active',           // Currently active flow\n  INACTIVE: 'Inactive',       // Currently inactive flow\n  STABLE: 'Stable',          // Stable flow volume\n  PARTIAL: 'Partial'         // Partially active flow\n};\n\n// Analysis parameters\nexport const ANALYSIS_PARAMS = {\n  MIN_FLOW_VALUE: 0.1,    // Minimum significant flow value\n  MIN_CONNECTIONS: 2,     // Minimum connections for analysis\n  TIME_WINDOW: 3,         // Default time window for analysis\n  SIGNIFICANCE_LEVEL: 0.05 // Statistical significance threshold\n};\n\n// Helper functions for flow validation\nexport const flowValidation = {\n  // Filter data by date - handles multiple data structures (flows, shocks, time series)\n  filterFlowsByDate: (data, selectedDate) => {\n    if (!Array.isArray(data) || !selectedDate) {\n      console.debug('Invalid parameters for filterFlowsByDate:', { \n        hasData: Boolean(data), \n        isArray: Array.isArray(data),\n        selectedDate \n      });\n      return [];\n    }\n\n    // Convert selectedDate to YYYY-MM format if it's in YYYY-MM-DD format\n    const targetDate = selectedDate.substring(0, 7);\n\n    return data.filter(item => {\n      if (!item) return false;\n\n      // Handle different date field names\n      const itemDate = item.date || item.month || null;\n      if (!itemDate) {\n        console.debug('Missing date field in item:', item);\n        return false;\n      }\n\n      // Convert item date to YYYY-MM format for comparison\n      const normalizedDate = itemDate.substring(0, 7);\n      return normalizedDate === targetDate;\n    });\n  },\n\n  // Validate coordinates structure\n  isValidCoordinates: (coordinates) => {\n    if (!coordinates) return false;\n    \n    // Check for separate source and target coordinates\n    if (Array.isArray(coordinates.source_coordinates) && Array.isArray(coordinates.target_coordinates)) {\n      return coordinates.source_coordinates.length === 2 &&\n        coordinates.target_coordinates.length === 2 &&\n        coordinates.source_coordinates.every(coord => typeof coord === 'number' && !isNaN(coord)) &&\n        coordinates.target_coordinates.every(coord => typeof coord === 'number' && !isNaN(coord));\n    }\n\n    // Fallback to legacy format\n    return Array.isArray(coordinates.source) &&\n      Array.isArray(coordinates.target) &&\n      coordinates.source.length === 2 &&\n      coordinates.target.length === 2 &&\n      coordinates.source.every(coord => typeof coord === 'number' && !isNaN(coord)) &&\n      coordinates.target.every(coord => typeof coord === 'number' && !isNaN(coord));\n  },\n\n  // Validate basic flow structure\n  isValidFlow: (flow) => {\n    const isValid = flow && \n      typeof flow === 'object' &&\n      typeof flow.source === 'string' &&\n      typeof flow.target === 'string' &&\n      typeof flow.flow_weight === 'number' &&\n      !isNaN(flow.flow_weight) &&\n      flow.metadata?.valid;\n\n    if (!isValid && flow) {\n      console.debug('Invalid flow:', {\n        hasSource: typeof flow.source === 'string',\n        hasTarget: typeof flow.target === 'string',\n        hasFlowWeight: typeof flow.flow_weight === 'number',\n        isValidFlow: flow.metadata?.valid,\n        source: flow.source,\n        target: flow.target,\n        flow_weight: flow.flow_weight\n      });\n    }\n\n    return isValid;\n  },\n\n  // Get flow value (flow_weight)\n  getFlowValue: (flow) => {\n    if (!flow || typeof flow.flow_weight !== 'number' || isNaN(flow.flow_weight)) {\n      return 0;\n    }\n    return flow.flow_weight;\n  },\n\n  // Normalize flow value against a maximum\n  normalizeFlow: (flow, maxFlow) => {\n    const value = flowValidation.getFlowValue(flow);\n    if (!maxFlow || maxFlow <= 0) {\n      console.debug('Invalid maxFlow for normalization:', maxFlow);\n      return 0;\n    }\n    return value / maxFlow;\n  },\n\n  // Get flow status based on normalized value\n  getFlowStatus: (normalizedFlow) => {\n    if (typeof normalizedFlow !== 'number' || isNaN(normalizedFlow)) {\n      console.debug('Invalid normalizedFlow for status:', normalizedFlow);\n      return FLOW_STATUS.INACTIVE;\n    }\n\n    if (normalizedFlow >= FLOW_THRESHOLDS.HIGH) return FLOW_STATUS.ACTIVE;\n    if (normalizedFlow >= FLOW_THRESHOLDS.MEDIUM) return FLOW_STATUS.STABLE;\n    if (normalizedFlow >= FLOW_THRESHOLDS.LOW) return FLOW_STATUS.PARTIAL;\n    return FLOW_STATUS.INACTIVE;\n  },\n\n  // Calculate node size based on flow volume\n  calculateNodeSize: (totalFlow, maxFlow) => {\n    if (!maxFlow || maxFlow <= 0) return VISUALIZATION_PARAMS.MIN_NODE_SIZE;\n    const normalizedFlow = totalFlow / maxFlow;\n    return VISUALIZATION_PARAMS.MIN_NODE_SIZE + \n      (normalizedFlow * (VISUALIZATION_PARAMS.MAX_NODE_SIZE - VISUALIZATION_PARAMS.MIN_NODE_SIZE));\n  },\n\n  // Calculate flow metrics for an array of flows\n  calculateFlowMetrics: (flows) => {\n    if (!Array.isArray(flows)) {\n      console.debug('Invalid flows array for metrics calculation');\n      return null;\n    }\n\n    const validFlows = flows.filter(flowValidation.isValidFlow);\n    if (!validFlows.length) {\n      console.debug('No valid flows found for metrics calculation');\n      return null;\n    }\n\n    const flowValues = validFlows.map(flowValidation.getFlowValue);\n    const totalFlow = flowValues.reduce((sum, val) => sum + val, 0);\n    const avgFlow = totalFlow / flowValues.length;\n    const maxFlow = Math.max(...flowValues);\n    const minFlow = Math.min(...flowValues);\n\n    // Calculate standard deviation\n    const variance = flowValues.reduce((sum, val) => \n      sum + Math.pow(val - avgFlow, 2), 0) / flowValues.length;\n    const stdDev = Math.sqrt(variance);\n\n    return {\n      totalFlow,\n      avgFlow,\n      maxFlow,\n      minFlow,\n      stdDev,\n      count: validFlows.length,\n      normalized: flowValues.map(value => value / maxFlow)\n    };\n  }\n};\n\nexport default {\n  FLOW_THRESHOLDS,\n  FLOW_TYPES,\n  NETWORK_THRESHOLDS,\n  VISUALIZATION_PARAMS,\n  ANALYSIS_PARAMS,\n  FLOW_COLORS,\n  FLOW_STATUS,\n  flowValidation\n};\n",
        "imports": [],
        "exports": [
          "FLOW_THRESHOLDS",
          "FLOW_TYPES",
          "NETWORK_THRESHOLDS",
          "VISUALIZATION_PARAMS",
          "FLOW_COLORS",
          "FLOW_STATUS",
          "ANALYSIS_PARAMS",
          "flowValidation",
          "default"
        ],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/health/MarketHealthMetrics.js",
        "content": "import React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Grid,\n  Paper,\n  Typography,\n  Box,\n  Alert,\n  Divider\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\n\nimport MetricCard from '../../atoms/MetricCard';\nimport MetricProgress from '../../molecules/MetricProgress';\n\nconst MarketHealthMetrics = ({\n  timeSeriesData,\n  marketIntegration,\n  networkMetrics,\n  spatialAutocorrelation,\n  selectedRegion\n}) => {\n  const theme = useTheme();\n\n  // Calculate overall market health metrics with safe defaults\n  const healthMetrics = useMemo(() => {\n    if (!timeSeriesData?.length) {\n      return {\n        overall: 0,\n        integration: { score: 0, factors: {}, trend: 0 },\n        stability: { score: 0, factors: {}, trend: 0 },\n        resilience: { score: 0, factors: {}, trend: 0 },\n        accessibility: { score: 0, factors: {}, trend: 0 }\n      };\n    }\n\n    // Calculate integration health\n    const integration = calculateIntegrationHealth(marketIntegration);\n\n    // Calculate stability health\n    const stability = calculateStabilityHealth(timeSeriesData);\n\n    // Calculate resilience health\n    const resilience = calculateResilienceHealth(\n      networkMetrics,\n      spatialAutocorrelation\n    );\n\n    // Calculate accessibility health\n    const accessibility = calculateAccessibilityHealth(marketIntegration);\n\n    // Calculate overall health with safety checks\n    const overall = Math.max(0, Math.min(1,\n      (integration.score +\n       stability.score +\n       resilience.score +\n       accessibility.score) / 4\n    ));\n\n    return {\n      overall,\n      integration,\n      stability,\n      resilience,\n      accessibility\n    };\n  }, [timeSeriesData, marketIntegration, networkMetrics, spatialAutocorrelation]);\n\n  // Calculate regional health metrics with safe defaults\n  const regionalMetrics = useMemo(() => {\n    if (!selectedRegion || !timeSeriesData?.length) return null;\n\n    const metrics = calculateRegionalHealth(\n      selectedRegion,\n      timeSeriesData,\n      marketIntegration,\n      networkMetrics\n    );\n\n    return metrics || {\n      overall: 0,\n      marketRole: 'Unknown',\n      riskLevel: 'Unknown',\n      metrics: {}\n    };\n  }, [selectedRegion, timeSeriesData, marketIntegration, networkMetrics]);\n\n  // Ensure we have valid values for display\n  const safeMetrics = {\n    overall: healthMetrics?.overall || 0,\n    integration: healthMetrics?.integration || { score: 0, factors: {}, trend: 0 },\n    stability: healthMetrics?.stability || { score: 0, factors: {}, trend: 0 },\n    resilience: healthMetrics?.resilience || { score: 0, factors: {}, trend: 0 },\n    accessibility: healthMetrics?.accessibility || { score: 0, factors: {}, trend: 0 }\n  };\n\n  if (!timeSeriesData?.length) {\n    return (\n      <Alert severity=\"warning\" sx={{ m: 2 }}>\n        No market health data available for analysis\n      </Alert>\n    );\n  }\n\n  return (\n    <Grid container spacing={2}>\n      {/* Overall Health Score */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Typography variant=\"h6\" gutterBottom>\n            Market System Health\n          </Typography>\n          <MetricProgress\n            title=\"Overall Health Score\"\n            value={safeMetrics.overall}\n            target={0.7}\n            format=\"percentage\"\n            description=\"Composite market health indicator\"\n          />\n        </Paper>\n      </Grid>\n\n      {/* Core Health Metrics */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Typography variant=\"subtitle2\" gutterBottom>\n            Core Health Indicators\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={12} md={3}>\n              <MetricCard\n                title=\"Market Integration\"\n                value={safeMetrics.integration.score}\n                format=\"percentage\"\n                description=\"Price correlation and trade flow strength\"\n                trend={safeMetrics.integration.trend}\n              />\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <MetricCard\n                title=\"Market Stability\"\n                value={safeMetrics.stability.score}\n                format=\"percentage\"\n                description=\"Price and supply consistency\"\n                trend={safeMetrics.stability.trend}\n              />\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <MetricCard\n                title=\"Market Resilience\"\n                value={safeMetrics.resilience.score}\n                format=\"percentage\"\n                description=\"Shock absorption capacity\"\n                trend={safeMetrics.resilience.trend}\n              />\n            </Grid>\n            <Grid item xs={12} md={3}>\n              <MetricCard\n                title=\"Market Accessibility\"\n                value={safeMetrics.accessibility.score}\n                format=\"percentage\"\n                description=\"Physical and economic access\"\n                trend={safeMetrics.accessibility.trend}\n              />\n            </Grid>\n          </Grid>\n        </Paper>\n      </Grid>\n\n      {/* Detailed Analysis */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Typography variant=\"subtitle2\" gutterBottom>\n            Health Analysis Details\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={12} md={6}>\n              <Box>\n                <Typography variant=\"body2\" color=\"textSecondary\" gutterBottom>\n                  Integration Factors\n                </Typography>\n                <Box sx={{ pl: 2 }}>\n                  {Object.entries(healthMetrics.integration.factors).map(([key, value]) => (\n                    <Typography key={key} variant=\"body2\">\n                      • {key}: {(value * 100).toFixed(1)}%\n                    </Typography>\n                  ))}\n                </Box>\n              </Box>\n            </Grid>\n            <Grid item xs={12} md={6}>\n              <Box>\n                <Typography variant=\"body2\" color=\"textSecondary\" gutterBottom>\n                  Stability Factors\n                </Typography>\n                <Box sx={{ pl: 2 }}>\n                  {Object.entries(healthMetrics.stability.factors).map(([key, value]) => (\n                    <Typography key={key} variant=\"body2\">\n                      • {key}: {(value * 100).toFixed(1)}%\n                    </Typography>\n                  ))}\n                </Box>\n              </Box>\n            </Grid>\n          </Grid>\n\n          <Divider sx={{ my: 2 }} />\n\n          <Grid container spacing={2}>\n            <Grid item xs={12} md={6}>\n              <Box>\n                <Typography variant=\"body2\" color=\"textSecondary\" gutterBottom>\n                  Resilience Factors\n                </Typography>\n                <Box sx={{ pl: 2 }}>\n                  {Object.entries(healthMetrics.resilience.factors).map(([key, value]) => (\n                    <Typography key={key} variant=\"body2\">\n                      • {key}: {(value * 100).toFixed(1)}%\n                    </Typography>\n                  ))}\n                </Box>\n              </Box>\n            </Grid>\n            <Grid item xs={12} md={6}>\n              <Box>\n                <Typography variant=\"body2\" color=\"textSecondary\" gutterBottom>\n                  Accessibility Factors\n                </Typography>\n                <Box sx={{ pl: 2 }}>\n                  {Object.entries(healthMetrics.accessibility.factors).map(([key, value]) => (\n                    <Typography key={key} variant=\"body2\">\n                      • {key}: {(value * 100).toFixed(1)}%\n                    </Typography>\n                  ))}\n                </Box>\n              </Box>\n            </Grid>\n          </Grid>\n        </Paper>\n      </Grid>\n\n      {/* Regional Health Analysis */}\n      {regionalMetrics && (\n        <Grid item xs={12}>\n          <Paper sx={{ p: 2 }}>\n            <Typography variant=\"subtitle2\" gutterBottom>\n              Regional Health Analysis: {selectedRegion}\n            </Typography>\n            <Grid container spacing={2}>\n              <Grid item xs={12} md={4}>\n                <MetricCard\n                  title=\"Regional Health Score\"\n                  value={regionalMetrics.overall}\n                  format=\"percentage\"\n                  description=\"Overall regional market health\"\n                />\n              </Grid>\n              <Grid item xs={12} md={4}>\n                <MetricCard\n                  title=\"Market Role\"\n                  value={regionalMetrics.marketRole}\n                  format=\"string\"\n                  description=\"Market's role in the system\"\n                />\n              </Grid>\n              <Grid item xs={12} md={4}>\n                <MetricCard\n                  title=\"Risk Level\"\n                  value={regionalMetrics.riskLevel}\n                  format=\"string\"\n                  description=\"Current risk assessment\"\n                />\n              </Grid>\n            </Grid>\n\n            <Box sx={{ mt: 2 }}>\n              <Typography variant=\"body2\" color=\"textSecondary\" gutterBottom>\n                Key Metrics\n              </Typography>\n              <Grid container spacing={2}>\n                {Object.entries(regionalMetrics.metrics).map(([key, value]) => (\n                  <Grid item xs={6} md={3} key={key}>\n                    <Typography variant=\"caption\" color=\"textSecondary\">\n                      {key}\n                    </Typography>\n                    <Typography variant=\"body2\">\n                      {typeof value === 'number' ? \n                        `${(value * 100).toFixed(1)}%` : value}\n                    </Typography>\n                  </Grid>\n                ))}\n              </Grid>\n            </Box>\n          </Paper>\n        </Grid>\n      )}\n\n      {/* Health Summary */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Typography variant=\"subtitle2\" gutterBottom>\n            Health Assessment Summary\n          </Typography>\n          <Typography variant=\"body2\" color=\"textSecondary\">\n            {generateHealthSummary(healthMetrics, regionalMetrics)}\n          </Typography>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n};\n\n// Helper functions for health calculations\nconst calculateIntegrationHealth = (marketIntegration) => {\n  const factors = {\n    priceCorrelation: Object.values(marketIntegration?.price_correlation || {})\n      .reduce((sum, corr) => sum + Object.values(corr)\n      .reduce((s, v) => s + Math.abs(v), 0), 0) / \n      (Object.keys(marketIntegration?.price_correlation || {}).length || 1),\n    marketConnectivity: Object.values(marketIntegration?.accessibility || {})\n      .reduce((sum, val) => sum + val, 0) / \n      (Object.keys(marketIntegration?.accessibility || {}).length || 1)\n  };\n\n  return {\n    score: (factors.priceCorrelation + factors.marketConnectivity) / 2,\n    factors,\n    trend: 0 // Calculate trend if historical data available\n  };\n};\n\nconst calculateStabilityHealth = (timeSeriesData) => {\n  const factors = {\n    priceStability: calculatePriceStability(timeSeriesData),\n    supplyConsistency: calculateSupplyConsistency(timeSeriesData),\n    seasonalPattern: calculateSeasonalPattern(timeSeriesData)\n  };\n\n  return {\n    score: Object.values(factors).reduce((sum, val) => sum + val, 0) / 3,\n    factors,\n    trend: calculateStabilityTrend(timeSeriesData)\n  };\n};\n\nconst calculateResilienceHealth = (networkMetrics, spatialAutocorrelation) => {\n  const factors = {\n    networkRedundancy: networkMetrics?.clustering || 0,\n    spatialDiversity: 1 - (spatialAutocorrelation?.global?.moran_i || 0),\n    marketAdaptability: networkMetrics?.health?.resilience || 0\n  };\n\n  return {\n    score: Object.values(factors).reduce((sum, val) => sum + val, 0) / 3,\n    factors,\n    trend: 0 // Calculate trend if historical data available\n  };\n};\n\nconst calculateAccessibilityHealth = (marketIntegration) => {\n  const factors = {\n    physicalAccess: Object.values(marketIntegration?.accessibility || {})\n      .reduce((sum, val) => sum + val, 0) / \n      (Object.keys(marketIntegration?.accessibility || {}).length || 1),\n    economicAccess: 0.7, // Placeholder - implement actual calculation\n    infrastructureQuality: 0.6 // Placeholder - implement actual calculation\n  };\n\n  return {\n    score: Object.values(factors).reduce((sum, val) => sum + val, 0) / 3,\n    factors,\n    trend: 0 // Calculate trend if historical data available\n  };\n};\n\nconst calculateRegionalHealth = (\n  region,\n  timeSeriesData,\n  marketIntegration,\n  networkMetrics\n) => {\n  const regionData = timeSeriesData.filter(d => d.region === region);\n  if (!regionData.length) return null;\n\n  const metrics = {\n    priceStability: calculatePriceStability(regionData),\n    marketAccess: marketIntegration?.accessibility?.[region] || 0,\n    networkCentrality: networkMetrics?.centrality?.[region]?.degree || 0,\n    tradingVolume: calculateTradingVolume(region, timeSeriesData)\n  };\n\n  return {\n    overall: Object.values(metrics).reduce((sum, val) => \n      sum + (typeof val === 'number' ? val : 0), 0\n    ) / Object.values(metrics).length,\n    marketRole: determineMarketRole(metrics),\n    riskLevel: assessRiskLevel(metrics),\n    metrics\n  };\n};\n\n// Helper functions for specific calculations\nconst calculatePriceStability = (data) => {\n  if (!data?.length) return 0;\n  const prices = data.map(d => d.usdPrice || 0);\n  const mean = prices.reduce((sum, p) => sum + p, 0) / prices.length;\n  const variance = prices.reduce((sum, p) => \n    sum + Math.pow(p - mean, 2), 0\n  ) / prices.length;\n  return 1 - Math.min(Math.sqrt(variance) / mean, 1);\n};\n\nconst calculateSupplyConsistency = (data) => {\n  // Placeholder - implement actual supply consistency calculation\n  return 0.75;\n};\n\nconst calculateSeasonalPattern = (data) => {\n  // Placeholder - implement actual seasonal pattern calculation\n  return 0.8;\n};\n\nconst calculateStabilityTrend = (data) => {\n  // Placeholder - implement actual stability trend calculation\n  return 0.05;\n};\n\nconst calculateTradingVolume = (region, data) => {\n  // Placeholder - implement actual trading volume calculation\n  return 0.7;\n};\n\nconst determineMarketRole = (metrics) => {\n  if (metrics.networkCentrality > 0.7) return 'Hub Market';\n  if (metrics.networkCentrality > 0.4) return 'Regional Center';\n  return 'Local Market';\n};\n\nconst assessRiskLevel = (metrics) => {\n  const riskScore = (\n    (1 - metrics.priceStability) +\n    (1 - metrics.marketAccess) +\n    (1 - metrics.networkCentrality)\n  ) / 3;\n\n  if (riskScore > 0.7) return 'High Risk';\n  if (riskScore > 0.4) return 'Medium Risk';\n  return 'Low Risk';\n};\n\nconst generateHealthSummary = (health, regional) => {\n  const parts = [];\n\n  // Overall health assessment\n  if (health.overall > 0.7) {\n    parts.push('Market system shows strong overall health with robust integration and stability.');\n  } else if (health.overall > 0.4) {\n    parts.push('Market system demonstrates moderate health with areas for improvement.');\n  } else {\n    parts.push('Market system shows significant health challenges requiring attention.');\n  }\n\n  // Key strengths and weaknesses\n  const metrics = [\n    { name: 'Integration', score: health.integration.score },\n    { name: 'Stability', score: health.stability.score },\n    { name: 'Resilience', score: health.resilience.score },\n    { name: 'Accessibility', score: health.accessibility.score }\n  ];\n\n  const strengths = metrics.filter(m => m.score > 0.7)\n    .map(m => m.name.toLowerCase());\n  const weaknesses = metrics.filter(m => m.score < 0.4)\n    .map(m => m.name.toLowerCase());\n\n  if (strengths.length) {\n    parts.push(`Strong performance in ${strengths.join(', ')}.`);\n  }\n  if (weaknesses.length) {\n    parts.push(`Improvement needed in ${weaknesses.join(', ')}.`);\n  }\n\n  // Regional insight if available\n  if (regional) {\n    parts.push(`${regional.marketRole} shows ${\n      regional.overall > 0.7 ? 'strong' : \n      regional.overall > 0.4 ? 'moderate' : 'weak'\n    } health with ${regional.riskLevel.toLowerCase()} risk level.`);\n  }\n\n  return parts.join(' ');\n};\n\nMarketHealthMetrics.propTypes = {\n  timeSeriesData: PropTypes.arrayOf(PropTypes.shape({\n    month: PropTypes.string.isRequired,\n    region: PropTypes.string.isRequired,\n    usdPrice: PropTypes.number\n  })).isRequired,\n  marketIntegration: PropTypes.shape({\n    price_correlation: PropTypes.object,\n    accessibility: PropTypes.object\n  }),\n  networkMetrics: PropTypes.shape({\n    centrality: PropTypes.object,\n    clustering: PropTypes.number,\n    health: PropTypes.object\n  }),\n  spatialAutocorrelation: PropTypes.shape({\n    global: PropTypes.shape({\n      moran_i: PropTypes.number\n    })\n  }),\n  selectedRegion: PropTypes.string\n};\n\nexport default React.memo(MarketHealthMetrics);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "../../atoms/MetricCard",
          "../../molecules/MetricProgress"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "../../atoms/MetricCard",
          "../../molecules/MetricProgress"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/health/index.js",
        "content": "// Export all market health components\nexport { default as MarketHealthMetrics } from './MarketHealthMetrics';\n\n// Also export the feature as the default export\nexport { default } from './MarketHealthMetrics';\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/network/NetworkGraph.js",
        "content": "import React, { useMemo, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, Typography } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport { ForceGraph2D } from 'react-force-graph';\nimport chroma from 'chroma-js';\n\nimport { calculateNetworkMetrics } from '../../utils/networkAnalysis';\nimport { transformRegionName } from '../../utils/spatialUtils';\n\nconst NetworkGraph = ({\n  flows,\n  marketIntegration,\n  selectedNode,\n  onNodeSelect,\n  height = '100%'\n}) => {\n  const theme = useTheme();\n\n  // Process network data\n  const graphData = useMemo(() => {\n    if (!flows?.length) return { nodes: [], links: [] };\n\n    // Create nodes\n    const nodesMap = new Map();\n    flows.forEach(flow => {\n      if (!nodesMap.has(flow.source)) {\n        nodesMap.set(flow.source, {\n          id: flow.source,\n          name: flow.source,\n          value: 0\n        });\n      }\n      if (!nodesMap.has(flow.target)) {\n        nodesMap.set(flow.target, {\n          id: flow.target,\n          name: flow.target,\n          value: 0\n        });\n      }\n      nodesMap.get(flow.source).value += flow.total_flow || 0;\n      nodesMap.get(flow.target).value += flow.total_flow || 0;\n    });\n\n    // Calculate node metrics\n    const networkMetrics = calculateNetworkMetrics(flows);\n    nodesMap.forEach((node, id) => {\n      const centrality = networkMetrics.centrality[id] || {};\n      node.metrics = {\n        degree: centrality.degree || 0,\n        betweenness: centrality.betweenness || 0,\n        strength: centrality.strength || 0\n      };\n    });\n\n    // Create links\n    const links = flows.map(flow => ({\n      source: flow.source,\n      target: flow.target,\n      value: flow.total_flow || 0,\n      price_differential: flow.price_differential || 0\n    }));\n\n    return {\n      nodes: Array.from(nodesMap.values()),\n      links\n    };\n  }, [flows]);\n\n  // Create color scales\n  const nodeColorScale = useMemo(() => \n    chroma.scale(['#edf8e9', '#006d2c']).domain([0, 1]),\n    []\n  );\n\n  const linkColorScale = useMemo(() => \n    chroma.scale(['#fee5d9', '#a50f15']).domain([0, 1]),\n    []\n  );\n\n  // Calculate node and link styles\n  const getNodeColor = useCallback((node) => {\n    const maxValue = Math.max(...graphData.nodes.map(n => n.value));\n    const normalizedValue = maxValue > 0 ? node.value / maxValue : 0;\n    return nodeColorScale(normalizedValue).hex();\n  }, [graphData.nodes, nodeColorScale]);\n\n  const getLinkColor = useCallback((link) => {\n    const maxValue = Math.max(...graphData.links.map(l => l.value));\n    const normalizedValue = maxValue > 0 ? link.value / maxValue : 0;\n    return linkColorScale(normalizedValue).hex();\n  }, [graphData.links, linkColorScale]);\n\n  // Node size based on degree centrality\n  const getNodeSize = useCallback((node) => {\n    return 5 + (node.metrics.degree * 10);\n  }, []);\n\n  // Link width based on flow value\n  const getLinkWidth = useCallback((link) => {\n    const maxValue = Math.max(...graphData.links.map(l => l.value));\n    return 1 + ((link.value / maxValue) * 4);\n  }, [graphData.links]);\n\n  // Node label\n  const getNodeLabel = useCallback((node) => {\n    const metrics = node.metrics;\n    return `\n      ${node.name}\n      Degree: ${(metrics.degree * 100).toFixed(1)}%\n      Betweenness: ${(metrics.betweenness * 100).toFixed(1)}%\n      Strength: ${metrics.strength.toFixed(2)}\n    `;\n  }, []);\n\n  // Link label\n  const getLinkLabel = useCallback((link) => `\n    ${link.source.name} → ${link.target.name}\n    Flow: ${link.value.toFixed(2)}\n    Price Diff: ${(link.price_differential * 100).toFixed(1)}%\n  `, []);\n\n  if (!graphData.nodes.length) {\n    return (\n      <Box \n        sx={{ \n          height,\n          display: 'flex', \n          alignItems: 'center', \n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1\n        }}\n      >\n        <Typography color=\"text.secondary\">\n          No network data available for visualization\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ height, position: 'relative' }}>\n      <ForceGraph2D\n        graphData={graphData}\n        nodeId=\"id\"\n        nodeVal={getNodeSize}\n        nodeColor={getNodeColor}\n        nodeLabel={getNodeLabel}\n        linkSource=\"source\"\n        linkTarget=\"target\"\n        linkWidth={getLinkWidth}\n        linkColor={getLinkColor}\n        linkLabel={getLinkLabel}\n        backgroundColor={theme.palette.background.paper}\n        nodeCanvasObject={(node, ctx, globalScale) => {\n          const size = getNodeSize(node);\n          const fontSize = 12 / globalScale;\n          const isSelected = selectedNode === node.id;\n\n          // Draw node circle\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, size, 0, 2 * Math.PI);\n          ctx.fillStyle = getNodeColor(node);\n          ctx.fill();\n          ctx.strokeStyle = isSelected ? \n            theme.palette.secondary.main : \n            theme.palette.background.paper;\n          ctx.lineWidth = isSelected ? 2 : 1;\n          ctx.stroke();\n\n          // Draw node label if zoomed in or selected\n          if (globalScale > 2 || isSelected) {\n            ctx.font = `${fontSize}px Sans-Serif`;\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = theme.palette.text.primary;\n            ctx.fillText(node.name, node.x, node.y + size + fontSize);\n          }\n        }}\n        onNodeClick={node => onNodeSelect(node.id)}\n        cooldownTicks={100}\n        d3VelocityDecay={0.3}\n      />\n    </Box>\n  );\n};\n\nNetworkGraph.propTypes = {\n  flows: PropTypes.arrayOf(PropTypes.shape({\n    source: PropTypes.string.isRequired,\n    target: PropTypes.string.isRequired,\n    total_flow: PropTypes.number,\n    price_differential: PropTypes.number\n  })).isRequired,\n  marketIntegration: PropTypes.object,\n  selectedNode: PropTypes.string,\n  onNodeSelect: PropTypes.func,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\n\nexport default React.memo(NetworkGraph);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "react-force-graph",
          "chroma-js",
          "../../utils/networkAnalysis",
          "../../utils/spatialUtils"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "react-force-graph",
          "chroma-js",
          "../../utils/networkAnalysis",
          "../../utils/spatialUtils"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/network/index.js",
        "content": "// Export NetworkGraph component for use in FlowNetworkAnalysis\nexport { default } from './NetworkGraph';\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/seasonal/SeasonalLegend.js",
        "content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Paper,\n  Typography,\n  Box,\n  Divider,\n  LinearProgress\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport TrendingUpIcon from '@mui/icons-material/TrendingUp';\nimport TrendingDownIcon from '@mui/icons-material/TrendingDown';\nimport CalendarTodayIcon from '@mui/icons-material/CalendarToday';\nimport { useMemo } from 'react';\n\n\nconst SeasonalLegend = ({\n  seasonalMetrics,\n  selectedMonth,\n  selectedRegion,\n  timeSeriesData\n}) => {\n  const theme = useTheme();\n\n  // Get month name from selected month\n  const monthName = selectedMonth ? \n    new Date(selectedMonth).toLocaleString('default', { month: 'long' }) : '';\n\n  // Create seasonal pattern categories\n  const seasonalPatterns = [\n    {\n      label: 'Strong Seasonal',\n      color: '#08519c',\n      description: 'Clear and consistent annual patterns',\n      threshold: '> 70%'\n    },\n    {\n      label: 'Moderate Seasonal',\n      color: '#3182bd',\n      description: 'Notable but variable patterns',\n      threshold: '40-70%'\n    },\n    {\n      label: 'Weak Seasonal',\n      color: '#9ecae1',\n      description: 'Limited seasonal influence',\n      threshold: '20-40%'\n    },\n    {\n      label: 'Non-Seasonal',\n      color: '#f7fbff',\n      description: 'No clear seasonal patterns',\n      threshold: '< 20%'\n    }\n  ];\n\n  // Create price variation categories\n  const priceCategories = [\n    {\n      label: 'High Price',\n      color: '#006d2c',\n      description: 'Above average prices'\n    },\n    {\n      label: 'Moderate Price',\n      color: '#74c476',\n      description: 'Average price range'\n    },\n    {\n      label: 'Low Price',\n      color: '#edf8e9',\n      description: 'Below average prices'\n    }\n  ];\n\n  // Calculate peak and trough months if not provided\n  const { peakMonth, troughMonth } = useMemo(() => {\n    if (!timeSeriesData?.length) {\n      return {\n        peakMonth: { month: 0, avgPrice: 0 },\n        troughMonth: { month: 0, avgPrice: 0 }\n      };\n    }\n\n    // Group data by month\n    const monthlyData = timeSeriesData.reduce((acc, data) => {\n      const month = new Date(data.month).getMonth();\n      if (!acc[month]) acc[month] = [];\n      acc[month].push(data.usdPrice || 0);\n      return acc;\n    }, {});\n\n    // Calculate monthly averages\n    const monthlyAverages = Object.entries(monthlyData).map(([month, prices]) => ({\n      month: parseInt(month),\n      avgPrice: prices.reduce((sum, p) => sum + p, 0) / prices.length\n    }));\n\n    // Find peak and trough\n    const peak = monthlyAverages.reduce((max, curr) => \n      curr.avgPrice > max.avgPrice ? curr : max, monthlyAverages[0]);\n    const trough = monthlyAverages.reduce((min, curr) => \n      curr.avgPrice < min.avgPrice ? curr : min, monthlyAverages[0]);\n\n    return {\n      peakMonth: peak,\n      troughMonth: trough\n    };\n  }, [timeSeriesData]);\n\n  return (\n    <Paper\n      elevation={2}\n      sx={{\n        height: '100%',\n        p: 2,\n        display: 'flex',\n        flexDirection: 'column'\n      }}\n    >\n      {/* Current Period */}\n      <Box sx={{ mb: 2 }}>\n        <Typography variant=\"subtitle2\" gutterBottom>\n          Selected Period\n        </Typography>\n        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n          <CalendarTodayIcon color=\"primary\" />\n          <Typography>\n            {monthName || 'No month selected'}\n          </Typography>\n        </Box>\n      </Box>\n\n      <Divider sx={{ my: 1.5 }} />\n\n      {/* Seasonal Patterns */}\n      <Box sx={{ mb: 2 }}>\n        <Typography variant=\"subtitle2\" gutterBottom>\n          Seasonal Patterns\n        </Typography>\n        {seasonalPatterns.map((pattern, index) => (\n          <Box\n            key={index}\n            sx={{\n              display: 'flex',\n              alignItems: 'flex-start',\n              gap: 1,\n              mt: 1\n            }}\n          >\n            <Box\n              sx={{\n                width: 20,\n                height: 20,\n                backgroundColor: pattern.color,\n                borderRadius: '2px',\n                border: `1px solid ${theme.palette.divider}`,\n                flexShrink: 0,\n                mt: 0.5\n              }}\n            />\n            <Box>\n              <Typography variant=\"body2\">\n                {pattern.label}\n              </Typography>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                {pattern.description}\n              </Typography>\n              <Typography variant=\"caption\" sx={{ display: 'block' }}>\n                Seasonality: {pattern.threshold}\n              </Typography>\n            </Box>\n          </Box>\n        ))}\n      </Box>\n\n      <Divider sx={{ my: 1.5 }} />\n\n      {/* Price Variations */}\n      <Box sx={{ mb: 2 }}>\n        <Typography variant=\"subtitle2\" gutterBottom>\n          Price Variations\n        </Typography>\n        {priceCategories.map((category, index) => (\n          <Box\n            key={index}\n            sx={{\n              display: 'flex',\n              alignItems: 'center',\n              gap: 1,\n              mt: 1\n            }}\n          >\n            <Box\n              sx={{\n                width: 20,\n                height: 20,\n                backgroundColor: category.color,\n                borderRadius: '2px',\n                border: `1px solid ${theme.palette.divider}`\n              }}\n            />\n            <Box>\n              <Typography variant=\"body2\">\n                {category.label}\n              </Typography>\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                {category.description}\n              </Typography>\n            </Box>\n          </Box>\n        ))}\n      </Box>\n\n      <Divider sx={{ my: 1.5 }} />\n\n      {/* Seasonal Strength */}\n      <Box sx={{ mb: 2 }}>\n        <Typography variant=\"subtitle2\" gutterBottom>\n          Overall Seasonal Strength\n        </Typography>\n        <Box sx={{ mt: 1 }}>\n          <Box sx={{ \n            display: 'flex', \n            justifyContent: 'space-between',\n            mb: 0.5\n          }}>\n            <Typography variant=\"caption\" color=\"textSecondary\">\n              Weak\n            </Typography>\n            <Typography variant=\"caption\" color=\"textSecondary\">\n              Strong\n            </Typography>\n          </Box>\n          <LinearProgress\n            variant=\"determinate\"\n            value={(seasonalMetrics?.seasonalStrength || 0) * 100}\n            sx={{\n              height: 8,\n              borderRadius: 4,\n              backgroundColor: theme.palette.grey[200],\n              '& .MuiLinearProgress-bar': {\n                backgroundColor: '#08519c'\n              }\n            }}\n          />\n          <Typography \n            variant=\"body2\" \n            align=\"center\"\n            sx={{ mt: 0.5 }}\n          >\n            {((seasonalMetrics?.seasonalStrength || 0) * 100).toFixed(1)}%\n          </Typography>\n        </Box>\n      </Box>\n\n      {/* Monthly Trends */}\n      <Box>\n        <Typography variant=\"subtitle2\" gutterBottom>\n          Monthly Price Trends\n        </Typography>\n        <Box sx={{ \n          display: 'flex',\n          justifyContent: 'space-between',\n          mt: 1\n        }}>\n          <Box>\n            <Typography variant=\"caption\" color=\"textSecondary\">\n              Peak Month\n            </Typography>\n            <Box sx={{ \n              display: 'flex', \n              alignItems: 'center',\n              color: theme.palette.error.main\n            }}>\n              <TrendingUpIcon sx={{ mr: 0.5 }} fontSize=\"small\" />\n              <Typography variant=\"body2\">\n                {getMonthName(peakMonth.month)}\n              </Typography>\n            </Box>\n          </Box>\n          <Box>\n            <Typography variant=\"caption\" color=\"textSecondary\">\n              Trough Month\n            </Typography>\n            <Box sx={{ \n              display: 'flex', \n              alignItems: 'center',\n              color: theme.palette.success.main\n            }}>\n              <TrendingDownIcon sx={{ mr: 0.5 }} fontSize=\"small\" />\n              <Typography variant=\"body2\">\n                {getMonthName(troughMonth.month)}\n              </Typography>\n            </Box>\n          </Box>\n        </Box>\n      </Box>\n\n      {/* Legend Note */}\n      <Box\n        sx={{\n          mt: 'auto',\n          pt: 2,\n          borderTop: `1px solid ${theme.palette.divider}`\n        }}\n      >\n        <Typography variant=\"caption\" color=\"textSecondary\">\n          Click on regions to view detailed seasonal patterns and price trends.\n          Use the time control to explore monthly variations.\n        </Typography>\n      </Box>\n    </Paper>\n  );\n};\n\n// Helper function to get month name\nconst getMonthName = (monthIndex) => {\n  const months = [\n    'January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'\n  ];\n  return months[monthIndex];\n};\n\nSeasonalLegend.propTypes = {\n  seasonalMetrics: PropTypes.shape({\n    seasonalStrength: PropTypes.number,\n    trendStrength: PropTypes.number,\n    seasonalPattern: PropTypes.arrayOf(PropTypes.number),\n    regionalPatterns: PropTypes.object\n  }),\n  selectedMonth: PropTypes.string,\n  selectedRegion: PropTypes.string,\n  timeSeriesData: PropTypes.arrayOf(PropTypes.shape({\n    month: PropTypes.string.isRequired,\n    usdPrice: PropTypes.number\n  }))\n};\n\nexport default React.memo(SeasonalLegend);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown",
          "@mui/icons-material/CalendarToday",
          "react"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown",
          "@mui/icons-material/CalendarToday"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/seasonal/SeasonalMap.js",
        "content": "import React, { useMemo, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, Typography } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport { GeoJSON, CircleMarker } from 'react-leaflet';\nimport chroma from 'chroma-js';\n\nimport Legend from '../../atoms/Legend';\nimport Tooltip from '../../atoms/Tooltip';\nimport MapControls from '../../molecules/MapControls';\nimport BaseMap from '../../molecules/BaseMap';\nimport { safeGeoJSONProcessor } from '../../utils/geoJSONProcessor';\nimport { transformRegionName, getRegionCoordinates } from '../../utils/spatialUtils';\n\nconst SeasonalMap = ({\n  timeSeriesData,\n  geometry,\n  selectedRegion,\n  onRegionSelect,\n  selectedMonth,\n  seasonalMetrics,\n  height = '100%'\n}) => {\n  const theme = useTheme();\n\n  // Create color scales\n  const priceColorScale = useMemo(() => \n    chroma.scale(['#edf8e9', '#006d2c']).domain([0, 1]),\n    []\n  );\n\n  const seasonalityColorScale = useMemo(() => \n    chroma.scale(['#f7fbff', '#08519c']).domain([0, 1]),\n    []\n  );\n\n  // Process market data with seasonal patterns\n  const processedData = useMemo(() => {\n    if (!timeSeriesData?.length) return null;\n\n    // Filter data by selected month if provided\n    const monthData = selectedMonth ? \n      timeSeriesData.filter(d => d.month === selectedMonth) : \n      timeSeriesData;\n\n    if (!monthData.length) return null;\n\n    // Calculate max values for normalization\n    const maxPrice = Math.max(...monthData.map(d => d.usdPrice || 0));\n    const maxSeasonality = seasonalMetrics?.seasonalStrength || 1;\n\n    // Process market data\n    return monthData.map(data => {\n      const coords = getRegionCoordinates(data.region);\n      if (!coords) return null;\n\n      // Get regional seasonal pattern\n      const regionalPattern = seasonalMetrics?.regionalPatterns?.[data.region] || {\n        seasonalStrength: 0,\n        meanPrice: 0,\n        variance: 0\n      };\n\n      const normalizedPrice = maxPrice > 0 ? \n        (data.usdPrice || 0) / maxPrice : 0;\n      const normalizedSeasonality = maxSeasonality > 0 ? \n        regionalPattern.seasonalStrength / maxSeasonality : 0;\n\n      return {\n        ...data,\n        coordinates: coords,\n        normalizedPrice,\n        normalizedSeasonality,\n        priceColor: priceColorScale(normalizedPrice).hex(),\n        seasonalityColor: seasonalityColorScale(normalizedSeasonality).hex(),\n        seasonalMetrics: regionalPattern\n      };\n    }).filter(Boolean);\n  }, [timeSeriesData, selectedMonth, seasonalMetrics, priceColorScale, seasonalityColorScale]);\n\n  // Process GeoJSON for regions\n  const processedGeoJSON = useMemo(() => {\n    if (!geometry) return null;\n\n    // Extract features from unified geometry or combine points and polygons\n    const features = geometry.unified?.features || [\n      ...(geometry.polygons || []),\n      ...(geometry.points || [])\n    ];\n\n    // Create a new GeoJSON object with validated features\n    const validatedGeoJSON = {\n      type: 'FeatureCollection',\n      features: features.map(feature => ({\n        type: 'Feature',\n        properties: {\n          ...feature.properties,\n          name: feature.properties?.name || '',\n          normalizedName: feature.properties?.normalizedName || \n            transformRegionName(feature.properties?.name || ''),\n          region_id: feature.properties?.region_id || feature.properties?.normalizedName\n        },\n        geometry: {\n          type: feature.geometry?.type || 'Polygon',\n          coordinates: feature.geometry?.coordinates || []\n        }\n      })),\n      crs: {\n        type: 'name',\n        properties: {\n          name: 'EPSG:4326'\n        }\n      }\n    };\n\n    return safeGeoJSONProcessor(validatedGeoJSON, 'seasonal');\n  }, [geometry]);\n\n  // Style function for regions\n  const getRegionStyle = useCallback((feature) => {\n    if (!processedData) return {};\n\n    const regionData = processedData.find(d => \n      transformRegionName(d.region) === feature.properties.normalizedName\n    );\n\n    const isSelected = selectedRegion === feature.properties.region_id;\n    \n    return {\n      fillColor: regionData?.seasonalityColor || theme.palette.grey[300],\n      weight: isSelected ? 2 : 1,\n      opacity: 1,\n      color: isSelected ? theme.palette.secondary.main : 'white',\n      fillOpacity: regionData ? 0.7 : 0.3\n    };\n  }, [processedData, selectedRegion, theme]);\n\n  // Create legend items\n  const legendItems = useMemo(() => [\n    { color: '#006d2c', label: 'High Price' },\n    { color: '#edf8e9', label: 'Low Price' },\n    { color: '#08519c', label: 'Strong Seasonality' },\n    { color: '#f7fbff', label: 'Weak Seasonality' },\n    { \n      color: theme.palette.secondary.main, \n      label: 'Selected Region',\n      style: { borderWidth: 2 }\n    }\n  ], [theme]);\n\n  if (!processedData || !processedGeoJSON) {\n    return (\n      <Box \n        sx={{ \n          height,\n          display: 'flex', \n          alignItems: 'center', \n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1\n        }}\n      >\n        <Typography color=\"text.secondary\">\n          No seasonal data available for visualization\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ height, position: 'relative' }}>\n      <BaseMap height={height}>\n        {/* Region polygons */}\n        <GeoJSON\n          data={processedGeoJSON}\n          style={getRegionStyle}\n          onEachFeature={(feature, layer) => {\n            layer.on({\n              click: () => onRegionSelect(feature.properties.region_id)\n            });\n\n            const regionData = processedData.find(d => \n              transformRegionName(d.region) === feature.properties.normalizedName\n            );\n\n            if (regionData) {\n              layer.bindTooltip(() => (\n                <Tooltip\n                  title={feature.properties.originalName}\n                  metrics={[\n                    {\n                      label: 'Current Price',\n                      value: regionData.usdPrice,\n                      format: 'currency'\n                    },\n                    {\n                      label: 'Seasonality',\n                      value: regionData.seasonalMetrics.seasonalStrength,\n                      format: 'percentage'\n                    },\n                    {\n                      label: 'Price Trend',\n                      value: regionData.priceChange,\n                      format: 'percentage'\n                    }\n                  ]}\n                />\n              ), { sticky: true });\n            }\n          }}\n        />\n\n        {/* Market points */}\n        {processedData.map((data, index) => (\n          <CircleMarker\n            key={index}\n            center={[data.coordinates[1], data.coordinates[0]]}\n            radius={6}\n            pathOptions={{\n              fillColor: data.priceColor,\n              color: 'white',\n              weight: 1,\n              opacity: 0.8,\n              fillOpacity: 0.6\n            }}\n          >\n            <Tooltip\n              title={data.region}\n              metrics={[\n                {\n                  label: 'Market Price',\n                  value: data.usdPrice,\n                  format: 'currency'\n                },\n                {\n                  label: 'Seasonal Pattern',\n                  value: data.seasonalMetrics.seasonalStrength > 0.5 ? 'Strong' : 'Weak'\n                },\n                {\n                  label: 'Monthly Change',\n                  value: data.priceChange,\n                  format: 'percentage'\n                }\n              ]}\n            />\n          </CircleMarker>\n        ))}\n      </BaseMap>\n\n      <MapControls\n        onZoomIn={() => {}}\n        onZoomOut={() => {}}\n        onReset={() => {}}\n        onRefresh={() => {}}\n      />\n\n      <Legend\n        title=\"Seasonal Patterns\"\n        items={legendItems}\n      />\n    </Box>\n  );\n};\n\nSeasonalMap.propTypes = {\n  timeSeriesData: PropTypes.arrayOf(PropTypes.shape({\n    month: PropTypes.string.isRequired,\n    region: PropTypes.string.isRequired,\n    usdPrice: PropTypes.number\n  })).isRequired,\n  geometry: PropTypes.shape({\n    unified: PropTypes.shape({\n      features: PropTypes.array\n    }),\n    polygons: PropTypes.array,\n    points: PropTypes.array\n  }).isRequired,\n  selectedRegion: PropTypes.string,\n  onRegionSelect: PropTypes.func,\n  selectedMonth: PropTypes.string,\n  seasonalMetrics: PropTypes.shape({\n    seasonalStrength: PropTypes.number,\n    trendStrength: PropTypes.number,\n    seasonalPattern: PropTypes.arrayOf(PropTypes.number),\n    regionalPatterns: PropTypes.object\n  }),\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\n\nexport default React.memo(SeasonalMap);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "react-leaflet",
          "chroma-js",
          "../../atoms/Legend",
          "../../atoms/Tooltip",
          "../../molecules/MapControls",
          "../../molecules/BaseMap",
          "../../utils/geoJSONProcessor",
          "../../utils/spatialUtils"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "react-leaflet",
          "chroma-js",
          "../../atoms/Legend",
          "../../atoms/Tooltip",
          "../../molecules/MapControls",
          "../../molecules/BaseMap",
          "../../utils/geoJSONProcessor",
          "../../utils/spatialUtils"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/seasonal/SeasonalPriceMap.js",
        "content": "import React, { useState, useMemo } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  Grid,\n  Paper,\n  Typography,\n  Box,\n  Alert,\n  ToggleButtonGroup,\n  ToggleButton,\n  Divider,\n  List,\n  ListItem,\n  ListItemText\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport CalendarViewMonthIcon from '@mui/icons-material/CalendarViewMonth';\nimport TimelineIcon from '@mui/icons-material/Timeline';\nimport AssessmentIcon from '@mui/icons-material/Assessment';\n\nimport SeasonalMap from './SeasonalMap';\nimport SeasonalLegend from './SeasonalLegend';\nimport MetricCard from '../../atoms/MetricCard';\nimport TimeControl from '../../molecules/TimeControl';\nimport { setSelectedDate } from '../../../../slices/spatialSlice';\nimport { \n  selectDateFilteredData,\n  selectTimeSeriesMetrics \n} from '../../../../selectors/dateSpecificSelectors';\n\nconst SeasonalPriceMap = () => {\n  const theme = useTheme();\n  const dispatch = useDispatch();\n  const [viewMode, setViewMode] = useState('map');\n  const [selectedRegion, setSelectedRegion] = useState(null);\n\n  // Get data from Redux store\n  const geometryData = useSelector(state => state.spatial.data.geometry);\n  const timeSeriesData = useSelector(state => state.spatial.data.timeSeriesData || []);\n  const marketIntegration = useSelector(state => state.spatial.data.marketIntegration || {});\n  const seasonalAnalysis = useSelector(state => state.spatial.data.seasonalAnalysis || {});\n  const loading = useSelector(state => state.spatial.status.loading);\n  const error = useSelector(state => state.spatial.status.error);\n  const selectedDate = useSelector(state => state.spatial.ui.selectedDate);\n\n  // Use date-specific selectors\n  const filteredData = useSelector(state => selectDateFilteredData(state));\n  const metrics = useSelector(state => selectTimeSeriesMetrics(state));\n\n  // Calculate seasonal metrics\n  const seasonalMetrics = useMemo(() => {\n    if (!seasonalAnalysis || !timeSeriesData?.length) {\n      return {\n        seasonalStrength: 0,\n        trendStrength: 0,\n        peakMonth: null,\n        troughMonth: null,\n        seasonalPattern: [],\n        regionalPatterns: {}\n      };\n    }\n\n    // Group data by region\n    const regionData = timeSeriesData.reduce((acc, d) => {\n      if (!acc[d.region]) acc[d.region] = [];\n      acc[d.region].push(d);\n      return acc;\n    }, {});\n\n    // Calculate regional patterns\n    const regionalPatterns = Object.entries(regionData).reduce((acc, [region, data]) => {\n      const prices = data.map(d => d.usdPrice || 0);\n      const mean = prices.reduce((sum, p) => sum + p, 0) / prices.length;\n      const variance = prices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / prices.length;\n      \n      acc[region] = {\n        seasonalStrength: variance / mean,\n        meanPrice: mean,\n        variance\n      };\n      return acc;\n    }, {});\n\n    return {\n      ...seasonalAnalysis,\n      regionalPatterns\n    };\n  }, [seasonalAnalysis, timeSeriesData]);\n\n  // Get unique dates for time control\n  const dates = useMemo(() => {\n    if (!timeSeriesData?.length) return [];\n    return [...new Set(timeSeriesData.map(d => d.month))].sort();\n  }, [timeSeriesData]);\n\n  // Handle date change\n  const handleDateChange = (newDate) => {\n    dispatch(setSelectedDate(newDate));\n  };\n\n  if (loading) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>\n        <Typography>Loading seasonal analysis...</Typography>\n      </Box>\n    );\n  }\n\n  if (error) {\n    return (\n      <Alert severity=\"error\" sx={{ m: 2 }}>\n        {error}\n      </Alert>\n    );\n  }\n\n  return (\n    <Grid container spacing={2}>\n      {/* Overview Metrics */}\n      <Grid item xs={12}>\n        <Grid container spacing={2}>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Average Price\"\n              value={metrics.avgPrice}\n              format=\"currency\"\n              description=\"Average market price\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Price Range\"\n              value={metrics.priceRange}\n              format=\"currency\"\n              description=\"Price range (max - min)\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Market Integration\"\n              value={marketIntegration?.integration_score || 0}\n              format=\"percentage\"\n              description=\"Market integration score\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Seasonal Strength\"\n              value={seasonalMetrics.seasonalStrength || 0}\n              format=\"percentage\"\n              description=\"Seasonal pattern strength\"\n            />\n          </Grid>\n        </Grid>\n      </Grid>\n\n      {/* Controls Section */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          {/* View Controls */}\n          <Box sx={{ mb: dates.length > 0 ? 2 : 0 }}>\n            <ToggleButtonGroup\n              value={viewMode}\n              exclusive\n              onChange={(e, value) => value && setViewMode(value)}\n              size=\"small\"\n            >\n              <ToggleButton value=\"map\">\n                <CalendarViewMonthIcon sx={{ mr: 1 }} />\n                Seasonal Map\n              </ToggleButton>\n              <ToggleButton value=\"timeline\">\n                <TimelineIcon sx={{ mr: 1 }} />\n                Price Trends\n              </ToggleButton>\n              <ToggleButton value=\"analysis\">\n                <AssessmentIcon sx={{ mr: 1 }} />\n                Pattern Analysis\n              </ToggleButton>\n            </ToggleButtonGroup>\n          </Box>\n\n          {/* Time Controls */}\n          {dates.length > 0 && (\n            <>\n              <Divider sx={{ my: 2 }} />\n              <Box sx={{ width: '100%' }}>\n                <TimeControl\n                  dates={dates}\n                  currentDate={selectedDate || dates[0]}\n                  onChange={handleDateChange}\n                  position={null}\n                />\n              </Box>\n            </>\n          )}\n        </Paper>\n      </Grid>\n\n      {/* Main Content */}\n      <Grid item xs={12} md={8}>\n        <Paper sx={{ p: 2, height: 600 }}>\n          <SeasonalMap\n            timeSeriesData={filteredData}\n            geometry={geometryData}\n            selectedRegion={selectedRegion}\n            onRegionSelect={setSelectedRegion}\n            selectedMonth={selectedDate || dates[0]}\n            seasonalMetrics={seasonalMetrics}\n          />\n        </Paper>\n      </Grid>\n\n      {/* Legend and Info */}\n      <Grid item xs={12} md={4}>\n        <SeasonalLegend\n          selectedMonth={selectedDate || dates[0]}\n          seasonalMetrics={seasonalMetrics}\n          selectedRegion={selectedRegion}\n          timeSeriesData={filteredData}\n        />\n      </Grid>\n\n      {/* Analysis Summary */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Typography variant=\"h6\" gutterBottom>\n            About Seasonal Analysis\n          </Typography>\n          <Typography paragraph>\n            This analysis examines seasonal price patterns in Yemen's markets,\n            revealing cyclical variations and their impact on market dynamics.\n          </Typography>\n          <Grid container spacing={2}>\n            <Grid item xs={12} md={4}>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Seasonal Patterns\n              </Typography>\n              <List dense>\n                <ListItem>\n                  <ListItemText primary=\"Monthly price variations\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Peak and trough periods\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Regional differences\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Pattern stability\" />\n                </ListItem>\n              </List>\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Market Implications\n              </Typography>\n              <List dense>\n                <ListItem>\n                  <ListItemText primary=\"Supply chain planning\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Price forecasting\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Stock management\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Trade optimization\" />\n                </ListItem>\n              </List>\n            </Grid>\n            <Grid item xs={12} md={4}>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Response Planning\n              </Typography>\n              <List dense>\n                <ListItem>\n                  <ListItemText primary=\"Intervention timing\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Resource allocation\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Buffer stock planning\" />\n                </ListItem>\n                <ListItem>\n                  <ListItemText primary=\"Market support strategies\" />\n                </ListItem>\n              </List>\n            </Grid>\n          </Grid>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default React.memo(SeasonalPriceMap);\n",
        "imports": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/CalendarViewMonth",
          "@mui/icons-material/Timeline",
          "@mui/icons-material/Assessment",
          "./SeasonalMap",
          "./SeasonalLegend",
          "../../atoms/MetricCard",
          "../../molecules/TimeControl",
          "../../../../slices/spatialSlice",
          "../../../../selectors/dateSpecificSelectors"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/CalendarViewMonth",
          "@mui/icons-material/Timeline",
          "@mui/icons-material/Assessment",
          "./SeasonalMap",
          "./SeasonalLegend",
          "../../atoms/MetricCard",
          "../../molecules/TimeControl",
          "../../../../slices/spatialSlice",
          "../../../../selectors/dateSpecificSelectors"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/seasonal/index.js",
        "content": "// Export all seasonal analysis components\nexport { default as SeasonalPriceMap } from './SeasonalPriceMap';\nexport { default as SeasonalMap } from './SeasonalMap';\nexport { default as SeasonalLegend } from './SeasonalLegend';\n\n// Also export the feature as the default export\nexport { default } from './SeasonalPriceMap';\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/shocks/ShockLegend.js",
        "content": "import React from 'react';\nimport {\n  Paper,\n  Typography,\n  Box,\n  Divider\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport TrendingUpIcon from '@mui/icons-material/TrendingUp';\nimport TrendingDownIcon from '@mui/icons-material/TrendingDown';\n\nimport { \n  SHOCK_COLORS, \n  SHOCK_THRESHOLDS\n} from './types';\n\nconst ShockLegend = () => {\n  const theme = useTheme();\n\n  const shockTypes = [\n    {\n      type: 'Price Surge',\n      icon: <TrendingUpIcon sx={{ color: SHOCK_COLORS.PRICE_SURGE }} />,\n      color: SHOCK_COLORS.PRICE_SURGE,\n      levels: [\n        { label: 'Severe', value: `>${(SHOCK_THRESHOLDS.SEVERE * 100).toFixed(0)}%`, opacity: 1 },\n        { label: 'Moderate', value: `>${(SHOCK_THRESHOLDS.MODERATE * 100).toFixed(0)}%`, opacity: 0.7 }\n      ]\n    },\n    {\n      type: 'Price Drop',\n      icon: <TrendingDownIcon sx={{ color: SHOCK_COLORS.PRICE_DROP }} />,\n      color: SHOCK_COLORS.PRICE_DROP,\n      levels: [\n        { label: 'Severe', value: `>${(SHOCK_THRESHOLDS.SEVERE * 100).toFixed(0)}%`, opacity: 1 },\n        { label: 'Moderate', value: `>${(SHOCK_THRESHOLDS.MODERATE * 100).toFixed(0)}%`, opacity: 0.7 }\n      ]\n    }\n  ];\n\n  return (\n    <Paper\n      elevation={2}\n      sx={{\n        position: 'absolute',\n        top: theme.spacing(2),\n        right: theme.spacing(2),\n        width: 200,\n        p: 1.5,\n        backgroundColor: 'rgba(255, 255, 255, 0.95)',\n        zIndex: 400,\n        border: `1px solid ${theme.palette.divider}`,\n        boxShadow: theme.shadows[2]\n      }}\n    >\n      <Typography variant=\"subtitle2\" gutterBottom>\n        Price Shocks\n      </Typography>\n\n      {shockTypes.map((shockType, index) => (\n        <React.Fragment key={index}>\n          {index > 0 && <Divider sx={{ my: 1 }} />}\n          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>\n            {shockType.icon}\n            <Typography variant=\"body2\">\n              {shockType.type}\n            </Typography>\n          </Box>\n          {shockType.levels.map((level, levelIndex) => (\n            <Box\n              key={levelIndex}\n              sx={{\n                display: 'flex',\n                alignItems: 'center',\n                gap: 1,\n                ml: 3,\n                mt: 0.5\n              }}\n            >\n              <Box\n                sx={{\n                  width: 12,\n                  height: 12,\n                  backgroundColor: shockType.color,\n                  borderRadius: '2px',\n                  opacity: level.opacity\n                }}\n              />\n              <Typography variant=\"caption\" color=\"textSecondary\">\n                {level.label} ({level.value})\n              </Typography>\n            </Box>\n          ))}\n        </React.Fragment>\n      ))}\n\n      <Divider sx={{ my: 1 }} />\n      \n      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n        <Box\n          sx={{\n            width: 12,\n            height: 12,\n            backgroundColor: SHOCK_COLORS.PROPAGATION,\n            borderRadius: '2px'\n          }}\n        />\n        <Typography variant=\"caption\" color=\"textSecondary\">\n          Affected Region\n        </Typography>\n      </Box>\n    </Paper>\n  );\n};\n\nexport default React.memo(ShockLegend);\n",
        "imports": [
          "react",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown",
          "./types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown",
          "./types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/shocks/ShockMap.js",
        "content": "import React, { useMemo, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, Typography } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport { GeoJSON, CircleMarker } from 'react-leaflet';\nimport chroma from 'chroma-js';\n\nimport Tooltip from '../../atoms/Tooltip';\nimport MapControls from '../../molecules/MapControls';\nimport BaseMap from '../../molecules/BaseMap';\nimport { safeGeoJSONProcessor } from '../../utils/geoJSONProcessor';\nimport { transformRegionName, getRegionCoordinates } from '../../utils/spatialUtils';\nimport { \n  SHOCK_COLORS, \n  VISUALIZATION_PARAMS,\n  SHOCK_THRESHOLDS,\n  shockValidation \n} from './types';\n\nconst ShockMap = ({\n  shocks,\n  geometry,\n  selectedRegion,\n  onRegionSelect,\n  height = '100%'\n}) => {\n  const theme = useTheme();\n\n  // Create color scales for different shock types\n  const colorScales = useMemo(() => ({\n    'price_surge': chroma.scale([SHOCK_COLORS.INACTIVE, SHOCK_COLORS.PRICE_SURGE]),\n    'price_drop': chroma.scale([SHOCK_COLORS.INACTIVE, SHOCK_COLORS.PRICE_DROP])\n  }), []);\n\n  // Process shock data with coordinates\n  const processedShocks = useMemo(() => {\n    if (!shocks?.length) return [];\n\n    // Filter valid shocks\n    const validShocks = shocks.filter(shockValidation.isValidShock);\n\n    // Calculate max magnitude for each shock type\n    const maxMagnitudes = validShocks.reduce((acc, shock) => {\n      const magnitude = shockValidation.getShockMagnitude(shock);\n      if (!acc[shock.shock_type]) {\n        acc[shock.shock_type] = magnitude;\n      } else {\n        acc[shock.shock_type] = Math.max(acc[shock.shock_type], magnitude);\n      }\n      return acc;\n    }, {});\n\n    return validShocks.map(shock => {\n      const coords = getRegionCoordinates(shock.region);\n      if (!coords) return null;\n\n      const magnitude = shockValidation.getShockMagnitude(shock);\n      const normalizedMagnitude = magnitude / maxMagnitudes[shock.shock_type];\n      const colorScale = colorScales[shock.shock_type] || colorScales['price_surge'];\n      const severity = shockValidation.getShockSeverity(magnitude);\n      \n      // Calculate size based on severity and visualization params\n      const size = VISUALIZATION_PARAMS.MIN_SHOCK_SIZE + \n        (normalizedMagnitude * (VISUALIZATION_PARAMS.MAX_SHOCK_SIZE - VISUALIZATION_PARAMS.MIN_SHOCK_SIZE));\n      \n      // Calculate opacity based on severity\n      const opacity = VISUALIZATION_PARAMS.MIN_OPACITY + \n        (normalizedMagnitude * (VISUALIZATION_PARAMS.MAX_OPACITY - VISUALIZATION_PARAMS.MIN_OPACITY));\n      \n      return {\n        ...shock,\n        coordinates: coords,\n        color: colorScale(normalizedMagnitude).hex(),\n        radius: size,\n        opacity,\n        normalizedMagnitude,\n        severity\n      };\n    }).filter(Boolean);\n  }, [shocks, colorScales]);\n\n  // Process GeoJSON for regions\n  const processedGeoJSON = useMemo(() => {\n    if (!geometry) return null;\n\n    // Extract features from unified geometry or combine points and polygons\n    const features = geometry.unified?.features || [\n      ...(geometry.polygons || []),\n      ...(geometry.points || [])\n    ];\n\n    // Create a new GeoJSON object with validated features\n    const validatedGeoJSON = {\n      type: 'FeatureCollection',\n      features: features.map(feature => ({\n        type: 'Feature',\n        properties: {\n          ...feature.properties,\n          name: feature.properties?.name || '',\n          normalizedName: feature.properties?.normalizedName || \n            transformRegionName(feature.properties?.name || ''),\n          region_id: feature.properties?.region_id || feature.properties?.normalizedName\n        },\n        geometry: {\n          type: feature.geometry?.type || 'Polygon',\n          coordinates: feature.geometry?.coordinates || []\n        }\n      })),\n      crs: {\n        type: 'name',\n        properties: {\n          name: 'EPSG:4326'\n        }\n      }\n    };\n\n    return safeGeoJSONProcessor(validatedGeoJSON, 'shocks');\n  }, [geometry]);\n\n  // Style function for regions\n  const getRegionStyle = useCallback((feature) => {\n    if (!feature?.properties?.normalizedName) return {};\n\n    const isSelected = selectedRegion === feature.properties.region_id;\n    const hasShock = processedShocks.some(shock => \n      transformRegionName(shock.region) === feature.properties.normalizedName\n    );\n    \n    return {\n      fillColor: hasShock ? SHOCK_COLORS.PROPAGATION : theme.palette.grey[300],\n      weight: isSelected ? 2 : 1,\n      opacity: 1,\n      color: isSelected ? SHOCK_COLORS.SELECTED : SHOCK_COLORS.INACTIVE,\n      fillOpacity: hasShock ? VISUALIZATION_PARAMS.PROPAGATION_OPACITY : 0.3\n    };\n  }, [processedShocks, selectedRegion, theme]);\n\n  if (!processedGeoJSON) {\n    return (\n      <Box \n        sx={{ \n          height,\n          display: 'flex', \n          alignItems: 'center', \n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1\n        }}\n      >\n        <Typography color=\"text.secondary\">\n          Invalid geometry data for visualization\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ height, position: 'relative' }}>\n      <BaseMap height={height}>\n        {/* Region polygons */}\n        <GeoJSON\n          data={processedGeoJSON}\n          style={getRegionStyle}\n          onEachFeature={(feature, layer) => {\n            layer.on({\n              click: () => onRegionSelect(feature.properties.region_id)\n            });\n          }}\n        />\n\n        {/* Shock points */}\n        {processedShocks.map((shock, index) => (\n          <CircleMarker\n            key={`shock-${index}`}\n            center={[shock.coordinates[1], shock.coordinates[0]]}\n            radius={shock.radius}\n            pathOptions={{\n              fillColor: shock.color,\n              color: 'white',\n              weight: 1,\n              opacity: shock.opacity,\n              fillOpacity: shock.opacity * 0.8\n            }}\n          >\n            <Tooltip\n              title={shock.region}\n              metrics={[\n                {\n                  label: 'Magnitude',\n                  value: shock.magnitude,\n                  format: 'percentage'\n                },\n                {\n                  label: 'Severity',\n                  value: shock.severity.toUpperCase()\n                },\n                {\n                  label: 'Current Price',\n                  value: shock.current_price,\n                  format: 'number'\n                },\n                {\n                  label: 'Previous Price',\n                  value: shock.previous_price,\n                  format: 'number'\n                },\n                {\n                  label: 'Type',\n                  value: shock.shock_type.replace('_', ' ').toUpperCase()\n                }\n              ]}\n            />\n          </CircleMarker>\n        ))}\n      </BaseMap>\n\n      <MapControls\n        onZoomIn={() => {}}\n        onZoomOut={() => {}}\n        onReset={() => {}}\n        onRefresh={() => {}}\n      />\n    </Box>\n  );\n};\n\nShockMap.propTypes = {\n  shocks: PropTypes.arrayOf(PropTypes.shape({\n    region: PropTypes.string.isRequired,\n    date: PropTypes.string.isRequired,\n    magnitude: PropTypes.number,\n    current_price: PropTypes.number,\n    previous_price: PropTypes.number,\n    shock_type: PropTypes.string\n  })).isRequired,\n  geometry: PropTypes.shape({\n    unified: PropTypes.shape({\n      features: PropTypes.array\n    }),\n    polygons: PropTypes.array,\n    points: PropTypes.array\n  }).isRequired,\n  selectedRegion: PropTypes.string,\n  onRegionSelect: PropTypes.func,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\n\nexport default React.memo(ShockMap);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "react-leaflet",
          "chroma-js",
          "../../atoms/Tooltip",
          "../../molecules/MapControls",
          "../../molecules/BaseMap",
          "../../utils/geoJSONProcessor",
          "../../utils/spatialUtils",
          "./types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "react-leaflet",
          "chroma-js",
          "../../atoms/Tooltip",
          "../../molecules/MapControls",
          "../../molecules/BaseMap",
          "../../utils/geoJSONProcessor",
          "../../utils/spatialUtils",
          "./types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/shocks/ShockPropagationMap.js",
        "content": "import React, { useState } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  Grid,\n  Paper,\n  Typography,\n  Box,\n  Alert,\n  List,\n  ListItem,\n  ListItemText,\n  Collapse,\n  Button\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\n\nimport ShockMap from './ShockMap';\nimport ShockLegend from './ShockLegend';\nimport TimeControl from '../../molecules/TimeControl';\nimport MetricCard from '../../atoms/MetricCard';\nimport { setSelectedDate } from '../../../../slices/spatialSlice';\nimport { \n  selectDateFilteredShocks,\n  selectShockMetrics,\n  selectShockAnalysisData\n} from '../../../../selectors/dateSpecificSelectors';\nimport { \n  SHOCK_THRESHOLDS,\n  PROPAGATION_THRESHOLDS,\n  shockValidation \n} from './types';\n\nconst ShockPropagationMap = () => {\n  const theme = useTheme();\n  const dispatch = useDispatch();\n  const [selectedRegion, setSelectedRegion] = useState(null);\n  const [showMethodology, setShowMethodology] = useState(false);\n\n  // Get data from Redux store using selectors\n  const geometry = useSelector(state => state.spatial.data.geometry);\n  const timeSeriesData = useSelector(state => state.spatial.data.timeSeriesData || []);\n  const loading = useSelector(state => state.spatial.status.loading);\n  const error = useSelector(state => state.spatial.status.error);\n  const selectedDate = useSelector(state => state.spatial.ui.selectedDate);\n\n  // Use optimized selectors\n  const shocks = useSelector(state => selectDateFilteredShocks(state));\n  const metrics = useSelector(state => selectShockMetrics(state));\n  const analysisData = useSelector(state => selectShockAnalysisData(state));\n\n  // Get unique dates for time control\n  const dates = React.useMemo(() => {\n    if (!timeSeriesData?.length) return [];\n    return [...new Set(timeSeriesData.map(d => d.month))].sort();\n  }, [timeSeriesData]);\n\n  // Handle date change\n  const handleDateChange = (newDate) => {\n    dispatch(setSelectedDate(newDate));\n  };\n\n  if (loading) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>\n        <Typography>Loading shock analysis...</Typography>\n      </Box>\n    );\n  }\n\n  if (error) {\n    return (\n      <Alert severity=\"error\" sx={{ m: 2 }}>\n        {error}\n      </Alert>\n    );\n  }\n\n  return (\n    <Grid container spacing={2}>\n      {/* Overview Metrics */}\n      <Grid item xs={12}>\n        <Grid container spacing={2}>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Total Shocks\"\n              value={metrics.totalShocks}\n              format=\"integer\"\n              description=\"Number of detected price shocks\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Price Drops\"\n              value={metrics.priceDrops}\n              format=\"integer\"\n              description=\"Number of price drop shocks\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Price Surges\"\n              value={metrics.priceSurges}\n              format=\"integer\"\n              description=\"Number of price surge shocks\"\n            />\n          </Grid>\n          <Grid item xs={12} md={3}>\n            <MetricCard\n              title=\"Average Magnitude\"\n              value={metrics.avgMagnitude}\n              format=\"percentage\"\n              description=\"Average shock magnitude\"\n            />\n          </Grid>\n        </Grid>\n      </Grid>\n\n      {/* Controls Section */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          {dates.length > 0 && (\n            <Box sx={{ width: '100%' }}>\n              <TimeControl\n                dates={dates}\n                currentDate={selectedDate || dates[0]}\n                onChange={handleDateChange}\n                position={null}\n              />\n            </Box>\n          )}\n        </Paper>\n      </Grid>\n\n      {/* Main Map */}\n      <Grid item xs={12}>\n        <Paper \n          sx={{ \n            p: 2, \n            height: 600, \n            position: 'relative',\n            overflow: 'hidden' // Prevent legend from causing scrollbars\n          }}\n        >\n          <Box sx={{ position: 'relative', width: '100%', height: '100%' }}>\n            <ShockMap\n              shocks={shocks}\n              geometry={geometry}\n              selectedRegion={selectedRegion}\n              onRegionSelect={setSelectedRegion}\n            />\n            \n            {/* Legend positioned relative to map container */}\n            <ShockLegend />\n          </Box>\n        </Paper>\n      </Grid>\n\n      {/* Regional Analysis */}\n      {analysisData?.regionalMetrics && analysisData.regionalMetrics.length > 0 && (\n        <Grid item xs={12}>\n          <Paper sx={{ p: 2 }}>\n            <Typography variant=\"h6\" gutterBottom>\n              Regional Impact Analysis\n            </Typography>\n            <Grid container spacing={2}>\n              {analysisData.regionalMetrics.map((region) => (\n                <Grid item xs={12} md={4} key={region.region}>\n                  <Paper \n                    sx={{ \n                      p: 2, \n                      bgcolor: region.region === selectedRegion ? 'action.selected' : 'background.paper'\n                    }}\n                  >\n                    <Typography variant=\"subtitle1\" gutterBottom>\n                      {region.region}\n                    </Typography>\n                    <List dense>\n                      <ListItem>\n                        <ListItemText \n                          primary={`Shocks: ${region.shockCount}`}\n                          secondary={`${region.priceDrops} drops, ${region.priceSurges} surges`}\n                        />\n                      </ListItem>\n                      <ListItem>\n                        <ListItemText \n                          primary={`Average Magnitude: ${region.avgMagnitude.toFixed(1)}%`}\n                          secondary={`Max: ${region.maxMagnitude.toFixed(1)}%`}\n                        />\n                      </ListItem>\n                    </List>\n                  </Paper>\n                </Grid>\n              ))}\n            </Grid>\n          </Paper>\n        </Grid>\n      )}\n\n      {/* Methodology */}\n      <Grid item xs={12}>\n        <Paper sx={{ p: 2 }}>\n          <Button\n            fullWidth\n            onClick={() => setShowMethodology(!showMethodology)}\n            endIcon={showMethodology ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n            startIcon={<InfoOutlinedIcon />}\n          >\n            Methodology\n          </Button>\n          <Collapse in={showMethodology}>\n            <Box sx={{ mt: 2, p: 2 }}>\n              <Typography variant=\"body2\" paragraph>\n                This analysis employs advanced statistical methods to identify and analyze price shocks\n                across Yemen's market network. The methodology combines temporal price analysis with\n                spatial propagation patterns to understand market vulnerabilities and shock transmission\n                mechanisms.\n              </Typography>\n\n              <List dense>\n                <ListItem>\n                  <ListItemText\n                    primary={\n                      <Typography variant=\"subtitle2\" color=\"primary\">\n                        Shock Detection\n                      </Typography>\n                    }\n                    secondary={\n                      <Typography variant=\"body2\" color=\"textSecondary\">\n                        Identifies significant price changes using statistical thresholds,\n                        accounting for historical volatility and seasonal patterns\n                      </Typography>\n                    }\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary={\n                      <Typography variant=\"subtitle2\" color=\"primary\">\n                        Propagation Analysis\n                      </Typography>\n                    }\n                    secondary={\n                      <Typography variant=\"body2\" color=\"textSecondary\">\n                        Tracks shock transmission through market networks using spatial\n                        econometric techniques and network analysis\n                      </Typography>\n                    }\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary={\n                      <Typography variant=\"subtitle2\" color=\"primary\">\n                        Impact Assessment\n                      </Typography>\n                    }\n                    secondary={\n                      <Typography variant=\"body2\" color=\"textSecondary\">\n                        Evaluates market resilience and vulnerability through shock magnitude,\n                        duration, and geographic spread metrics\n                      </Typography>\n                    }\n                  />\n                </ListItem>\n              </List>\n\n              <Typography variant=\"subtitle2\" gutterBottom sx={{ mt: 2 }} color=\"primary\">\n                Shock Classification:\n              </Typography>\n              <Typography variant=\"body2\" component=\"div\">\n                • Severe Shock (&gt;{SHOCK_THRESHOLDS.SEVERE * 100}%): Major market disruption<br/>\n                • Moderate Shock ({SHOCK_THRESHOLDS.MODERATE * 100}-{SHOCK_THRESHOLDS.SEVERE * 100}%): Significant price movement<br/>\n                • Mild Shock ({SHOCK_THRESHOLDS.MILD * 100}-{SHOCK_THRESHOLDS.MODERATE * 100}%): Notable price deviation\n              </Typography>\n\n              <Typography variant=\"subtitle2\" gutterBottom sx={{ mt: 2 }} color=\"primary\">\n                Propagation Speed:\n              </Typography>\n              <Typography variant=\"body2\" component=\"div\">\n                • Fast (&lt;{PROPAGATION_THRESHOLDS.TIME.FAST} days): Rapid shock transmission<br/>\n                • Medium ({PROPAGATION_THRESHOLDS.TIME.FAST}-{PROPAGATION_THRESHOLDS.TIME.MEDIUM} days): Gradual spread<br/>\n                • Slow (&gt;{PROPAGATION_THRESHOLDS.TIME.MEDIUM} days): Delayed impact\n              </Typography>\n            </Box>\n          </Collapse>\n        </Paper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default React.memo(ShockPropagationMap);\n",
        "imports": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "./ShockMap",
          "./ShockLegend",
          "../../molecules/TimeControl",
          "../../atoms/MetricCard",
          "../../../../slices/spatialSlice",
          "../../../../selectors/dateSpecificSelectors",
          "./types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/InfoOutlined",
          "@mui/icons-material/ExpandMore",
          "@mui/icons-material/ExpandLess",
          "./ShockMap",
          "./ShockLegend",
          "../../molecules/TimeControl",
          "../../atoms/MetricCard",
          "../../../../slices/spatialSlice",
          "../../../../selectors/dateSpecificSelectors",
          "./types"
        ]
      },
      {
        "path": "components/spatialAnalysis/features/shocks/index.js",
        "content": "// Export all shock analysis components\nexport { default as ShockPropagationMap } from './ShockPropagationMap';\nexport { default as ShockMap } from './ShockMap';\nexport { default as ShockLegend } from './ShockLegend';\n\n// Also export the feature as the default export\nexport { default } from './ShockPropagationMap';\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/features/shocks/types.js",
        "content": "/**\n * Types and constants for market shock analysis\n */\n\n// Shock magnitude thresholds\nexport const SHOCK_THRESHOLDS = {\n  SEVERE: 0.25,    // 25% price change\n  MODERATE: 0.15,  // 15% price change\n  MILD: 0.10      // 10% price change\n};\n\n// Shock types based on characteristics\nexport const SHOCK_TYPES = {\n  PRICE_SURGE: 'price_surge',   // Sudden price increase\n  PRICE_DROP: 'price_drop',     // Sudden price decrease\n  VOLATILITY: 'volatility'      // High price volatility\n};\n\n// Shock propagation thresholds\nexport const PROPAGATION_THRESHOLDS = {\n  DISTANCE: {\n    HIGH: 300,    // High propagation distance (km)\n    MEDIUM: 150,  // Medium propagation distance (km)\n    LOW: 50       // Low propagation distance (km)\n  },\n  TIME: {\n    FAST: 7,      // Fast propagation (days)\n    MEDIUM: 14,   // Medium propagation (days)\n    SLOW: 30      // Slow propagation (days)\n  }\n};\n\n// Shock visualization parameters\nexport const VISUALIZATION_PARAMS = {\n  // Shock point parameters\n  MIN_SHOCK_SIZE: 6,       // Minimum shock point size\n  MAX_SHOCK_SIZE: 15,      // Maximum shock point size\n  MIN_OPACITY: 0.6,        // Minimum shock opacity\n  MAX_OPACITY: 1.0,        // Maximum shock opacity\n  \n  // Propagation parameters\n  PROPAGATION_OPACITY: 0.4,  // Propagation area opacity\n  PROPAGATION_WEIGHT: 2,     // Propagation border weight\n  \n  // Selection parameters\n  SELECTION_SCALE: 1.5,    // Scale factor for selected elements\n  HOVER_SCALE: 1.2,        // Scale factor for hovered elements\n  \n  // Animation parameters\n  ANIMATION_DURATION: 300  // Animation duration in ms\n};\n\n// Shock color scheme\nexport const SHOCK_COLORS = {\n  PRICE_SURGE: '#d32f2f',    // Price surge color (red)\n  PRICE_DROP: '#1976d2',     // Price drop color (blue)\n  VOLATILITY: '#ff9800',     // Volatility color (orange)\n  PROPAGATION: '#757575',    // Propagation color (gray)\n  SELECTED: '#ffc107',       // Selected shock highlight (amber)\n  INACTIVE: '#bdbdbd'        // Inactive shock color (light gray)\n};\n\n// Shock status indicators\nexport const SHOCK_STATUS = {\n  ACTIVE: 'Active',           // Currently active shock\n  PROPAGATING: 'Propagating', // Shock is propagating\n  DISSIPATING: 'Dissipating', // Shock is dissipating\n  RESOLVED: 'Resolved'        // Shock has resolved\n};\n\n// Analysis parameters\nexport const ANALYSIS_PARAMS = {\n  MIN_MAGNITUDE: 0.10,     // Minimum shock magnitude\n  MIN_DURATION: 1,         // Minimum shock duration (months)\n  SIGNIFICANCE_LEVEL: 0.05 // Statistical significance threshold\n};\n\n// Helper functions for shock validation and processing\nexport const shockValidation = {\n  // Filter shocks by date\n  filterShocksByDate: (shocks, selectedDate) => {\n    if (!Array.isArray(shocks) || !selectedDate) {\n      console.debug('Invalid parameters for filterShocksByDate:', { \n        hasShocks: Boolean(shocks), \n        isArray: Array.isArray(shocks),\n        selectedDate \n      });\n      return [];\n    }\n\n    // Convert selectedDate to YYYY-MM format if it's in YYYY-MM-DD format\n    const targetDate = selectedDate.substring(0, 7);\n\n    return shocks.filter(shock => {\n      if (!shock || !shock.date) {\n        console.debug('Invalid shock object:', shock);\n        return false;\n      }\n      // Convert shock date to YYYY-MM format for comparison\n      const shockDate = shock.date.substring(0, 7);\n      return shockDate === targetDate;\n    });\n  },\n\n  // Validate basic shock structure\n  isValidShock: (shock) => {\n    const isValid = shock && \n      typeof shock === 'object' &&\n      typeof shock.region === 'string' &&\n      typeof shock.date === 'string' &&\n      typeof shock.magnitude === 'number' &&\n      !isNaN(shock.magnitude) &&\n      typeof shock.shock_type === 'string' &&\n      ['price_surge', 'price_drop'].includes(shock.shock_type);\n\n    if (!isValid && shock) {\n      console.debug('Invalid shock:', {\n        hasRegion: typeof shock.region === 'string',\n        hasDate: typeof shock.date === 'string',\n        hasMagnitude: typeof shock.magnitude === 'number',\n        hasType: typeof shock.shock_type === 'string',\n        validType: ['price_surge', 'price_drop'].includes(shock.shock_type),\n        shock\n      });\n    }\n\n    return isValid;\n  },\n\n  // Get shock magnitude\n  getShockMagnitude: (shock) => {\n    if (!shock || typeof shock.magnitude !== 'number' || isNaN(shock.magnitude)) {\n      return 0;\n    }\n    return shock.magnitude;\n  },\n\n  // Get shock severity based on magnitude\n  getShockSeverity: (magnitude) => {\n    if (typeof magnitude !== 'number' || isNaN(magnitude)) {\n      console.debug('Invalid magnitude for severity:', magnitude);\n      return 'mild';\n    }\n\n    if (magnitude >= SHOCK_THRESHOLDS.SEVERE) return 'severe';\n    if (magnitude >= SHOCK_THRESHOLDS.MODERATE) return 'moderate';\n    if (magnitude >= SHOCK_THRESHOLDS.MILD) return 'mild';\n    return 'insignificant';\n  },\n\n  // Calculate shock metrics for an array of shocks\n  calculateShockMetrics: (shocks) => {\n    if (!Array.isArray(shocks)) {\n      console.debug('Invalid shocks array for metrics calculation');\n      return null;\n    }\n\n    const validShocks = shocks.filter(shockValidation.isValidShock);\n    if (!validShocks.length) {\n      console.debug('No valid shocks found for metrics calculation');\n      return null;\n    }\n\n    const magnitudes = validShocks.map(shockValidation.getShockMagnitude);\n    const avgMagnitude = magnitudes.reduce((sum, val) => sum + val, 0) / magnitudes.length;\n    const maxMagnitude = Math.max(...magnitudes);\n    const minMagnitude = Math.min(...magnitudes);\n\n    // Calculate standard deviation\n    const variance = magnitudes.reduce((sum, val) => \n      sum + Math.pow(val - avgMagnitude, 2), 0) / magnitudes.length;\n    const stdDev = Math.sqrt(variance);\n\n    // Count shock types\n    const priceSurges = validShocks.filter(s => s.shock_type === 'price_surge').length;\n    const priceDrops = validShocks.filter(s => s.shock_type === 'price_drop').length;\n\n    return {\n      totalShocks: validShocks.length,\n      avgMagnitude,\n      maxMagnitude,\n      minMagnitude,\n      stdDev,\n      priceSurges,\n      priceDrops,\n      affectedRegions: new Set(validShocks.map(s => s.region)).size\n    };\n  }\n};\n\nexport default {\n  SHOCK_THRESHOLDS,\n  SHOCK_TYPES,\n  PROPAGATION_THRESHOLDS,\n  VISUALIZATION_PARAMS,\n  SHOCK_COLORS,\n  SHOCK_STATUS,\n  ANALYSIS_PARAMS,\n  shockValidation\n};\n",
        "imports": [],
        "exports": [
          "SHOCK_THRESHOLDS",
          "SHOCK_TYPES",
          "PROPAGATION_THRESHOLDS",
          "VISUALIZATION_PARAMS",
          "SHOCK_COLORS",
          "SHOCK_STATUS",
          "ANALYSIS_PARAMS",
          "shockValidation",
          "default"
        ],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/hooks/useClusterAnalysis.js",
        "content": "// src/hooks/useClusterAnalysis.js\n\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { backgroundMonitor } from '../../../utils/backgroundMonitor';\nimport { calculateClusterMetrics } from '../features/clusters/utils/clusterCalculations';\n\nexport const useClusterAnalysis = (selectedClusterId = null) => {\n  const clusters = useSelector(state => state.spatial.data.marketClusters);\n  const flows = useSelector(state => state.spatial.data.flowMaps);\n  const timeSeriesData = useSelector(state => state.spatial.data.timeSeriesData);\n\n  return useMemo(() => {\n    const metric = backgroundMonitor.startMetric('cluster-analysis');\n\n    try {\n      if (!clusters?.length) {\n        console.debug('No clusters available for analysis');\n        return { clusters: [], selectedCluster: null };\n      }\n\n      // Debug data before calculation\n      console.debug('Cluster Analysis Input:', {\n        clustersCount: clusters.length,\n        flowsCount: flows?.length,\n        timeSeriesCount: timeSeriesData?.length,\n        sampleCluster: clusters[0],\n        sampleFlow: flows?.[0],\n        sampleTimeSeries: timeSeriesData?.[0]\n      });\n\n      // Validate input data\n      if (!Array.isArray(flows) || !flows.length) {\n        console.warn('No flow data available for cluster analysis');\n      }\n      if (!Array.isArray(timeSeriesData) || !timeSeriesData.length) {\n        console.warn('No time series data available for cluster analysis');\n      }\n\n      // Calculate metrics using centralized function\n      const { clusters: processedClusters, metrics: overallMetrics } = \n        calculateClusterMetrics(clusters, timeSeriesData, flows);\n\n      // Debug processed results\n      console.debug('Processed Clusters:', {\n        count: processedClusters.length,\n        sampleMetrics: processedClusters[0]?.metrics,\n        overallMetrics\n      });\n\n      // Find selected cluster if ID provided\n      const selectedCluster = selectedClusterId ? \n        processedClusters.find(c => c.cluster_id === selectedClusterId) : \n        null;\n\n      if (selectedCluster) {\n        console.debug('Selected Cluster Metrics:', {\n          clusterId: selectedCluster.cluster_id,\n          metrics: selectedCluster.metrics,\n          marketCount: selectedCluster.connected_markets?.length\n        });\n      }\n\n      metric.finish({ status: 'success' });\n\n      return {\n        clusters: processedClusters,\n        selectedCluster,\n        metrics: overallMetrics\n      };\n\n    } catch (error) {\n      console.error('Error in cluster analysis:', error);\n      metric.finish({ status: 'error', error: error.message });\n      return { clusters: [], selectedCluster: null, metrics: null };\n    }\n  }, [clusters, flows, timeSeriesData, selectedClusterId]);\n};\n\nexport default useClusterAnalysis;\n",
        "imports": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../features/clusters/utils/clusterCalculations"
        ],
        "exports": [
          "useClusterAnalysis",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../features/clusters/utils/clusterCalculations"
        ]
      },
      {
        "path": "components/spatialAnalysis/hooks/useConflictAnalysis.js",
        "content": "// src/components/spatialAnalysis/hooks/useConflictAnalysis.js\n\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { backgroundMonitor } from '../../../utils/backgroundMonitor';\nimport { selectConflictAnalysisData } from '../../../selectors/spatialAnalysisSelectors';\n\n/**\n * Custom hook for analyzing conflict impact on markets\n * @returns {Object} Conflict analysis results\n */\nexport const useConflictAnalysis = () => {\n  const conflictData = useSelector(selectConflictAnalysisData);\n\n  return useMemo(() => {\n    const metric = backgroundMonitor.startMetric('conflict-analysis-hook');\n\n    try {\n      if (!conflictData) {\n        return {\n          data: null,\n          loading: false,\n          error: 'No conflict data available'\n        };\n      }\n\n      const { conflictData: regionData, geometry, summary } = conflictData;\n\n      // Format data for visualization and analysis\n      const formattedData = {\n        // Regional conflict data with additional metrics\n        regions: Object.entries(regionData).map(([region, data]) => {\n          const intensities = data.intensities;\n          const trend = intensities.length > 1 ? \n            (intensities[intensities.length - 1] - intensities[0]) / intensities[0] : 0;\n\n          return {\n            region,\n            average: data.average,\n            maximum: data.max,\n            trend,\n            volatility: Math.sqrt(\n              intensities.reduce((sum, val) => \n                sum + Math.pow(val - data.average, 2), 0\n              ) / intensities.length\n            ),\n            intensity: {\n              current: intensities[intensities.length - 1],\n              historical: intensities,\n              increasing: trend > 0,\n              severity: data.average > summary.averageIntensity ? 'high' : \n                       data.average > summary.averageIntensity * 0.5 ? 'medium' : 'low'\n            }\n          };\n        }),\n\n        // Time series analysis\n        temporal: regionData[Object.keys(regionData)[0]]?.intensities.map((_, index) => {\n          const monthData = {\n            average: 0,\n            max: 0,\n            regions: {}\n          };\n\n          Object.entries(regionData).forEach(([region, data]) => {\n            const value = data.intensities[index] || 0;\n            monthData.regions[region] = value;\n            monthData.average += value;\n            monthData.max = Math.max(monthData.max, value);\n          });\n\n          monthData.average /= Object.keys(regionData).length;\n          return monthData;\n        }),\n\n        // Conflict clusters based on intensity\n        clusters: {\n          high: Object.entries(regionData)\n            .filter(([_, data]) => data.average > summary.averageIntensity)\n            .map(([region]) => region),\n          medium: Object.entries(regionData)\n            .filter(([_, data]) => \n              data.average <= summary.averageIntensity && \n              data.average > summary.averageIntensity * 0.5\n            )\n            .map(([region]) => region),\n          low: Object.entries(regionData)\n            .filter(([_, data]) => data.average <= summary.averageIntensity * 0.5)\n            .map(([region]) => region)\n        },\n\n        // Enhanced summary statistics\n        summary: {\n          ...summary,\n          volatility: Math.sqrt(\n            Object.values(regionData)\n              .reduce((sum, data) => \n                sum + Math.pow(data.average - summary.averageIntensity, 2), 0\n              ) / Object.keys(regionData).length\n          ),\n          trendDirection: Object.values(regionData)\n            .reduce((acc, data) => {\n              const trend = data.intensities[data.intensities.length - 1] - \n                          data.intensities[0];\n              return acc + (trend > 0 ? 1 : trend < 0 ? -1 : 0);\n            }, 0) > 0 ? 'increasing' : 'decreasing',\n          impactedRegions: Object.values(regionData)\n            .filter(data => data.average > summary.averageIntensity * 0.5).length\n        },\n\n        // Geometry data for mapping\n        geometry\n      };\n\n      metric.finish({ status: 'success' });\n\n      return {\n        data: formattedData,\n        loading: false,\n        error: null\n      };\n\n    } catch (error) {\n      console.error('Error in useConflictAnalysis:', error);\n      metric.finish({ status: 'error', error: error.message });\n\n      return {\n        data: null,\n        loading: false,\n        error: error.message\n      };\n    }\n  }, [conflictData]);\n};\n\nexport default useConflictAnalysis;\n",
        "imports": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors"
        ],
        "exports": [
          "useConflictAnalysis",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors"
        ]
      },
      {
        "path": "components/spatialAnalysis/hooks/useFlowAnalysis.js",
        "content": "// src/components/spatialAnalysis/hooks/useFlowAnalysis.js\n\nimport { useMemo, useCallback } from 'react';\nimport { useSelector } from 'react-redux';\nimport { backgroundMonitor } from '../../../utils/backgroundMonitor';\nimport { \n  selectFlowState,\n  selectFlowMetrics,\n  selectFlowMetadata,\n  selectFlowsByDate\n} from '../../../slices/flowSlice';\nimport { flowValidation } from '../features/flows/types';\n\n// Custom error types for better error handling\nclass FlowAnalysisError extends Error {\n  constructor(message, details = {}) {\n    super(message);\n    this.name = 'FlowAnalysisError';\n    this.details = details;\n  }\n}\n\nclass FlowValidationError extends FlowAnalysisError {\n  constructor(message, details = {}) {\n    super(message, details);\n    this.name = 'FlowValidationError';\n  }\n}\n\n// Type validation helpers\nconst isValidFlowData = (flow) => {\n  if (!flow || typeof flow !== 'object') return false;\n  return (\n    typeof flow.source === 'string' &&\n    typeof flow.target === 'string' &&\n    typeof flow.flow_weight === 'number' &&\n    !isNaN(flow.flow_weight) &&\n    flow.metadata?.valid === true\n  );\n};\n\n// Performance-optimized data processing\nconst processFlowData = (flows, maxFlow, avgFlow) => {\n  if (!Array.isArray(flows) || flows.length === 0) return [];\n  \n  return flows.map(flow => ({\n    source: flow.source,\n    target: flow.target,\n    value: flow.flow_weight,\n    average: flow.flow_weight,\n    count: 1,\n    priceDiff: flow.price_differential,\n    normalizedValue: maxFlow > 0 ? flow.flow_weight / maxFlow : 0,\n    intensity: avgFlow > 0 ? flow.flow_weight / avgFlow : 0,\n    metadata: flow.metadata,\n    source_coordinates: flow.source_coordinates,\n    target_coordinates: flow.target_coordinates\n  }));\n};\n\n// Memoized calculation functions\nconst calculateFlowStats = (validFlows) => {\n  if (!validFlows?.length) return { maxFlow: 0, avgFlow: 0 };\n  \n  const maxFlow = Math.max(...validFlows.map(flow => flow.flow_weight), 0);\n  const avgFlow = validFlows.reduce((sum, flow) => sum + flow.flow_weight, 0) / validFlows.length || 0;\n  \n  return { maxFlow, avgFlow };\n};\n\n/**\n * Custom hook for analyzing market flow data\n * Includes enhanced error handling, performance optimization, and data validation\n * @returns {Object} Flow analysis results and error handling\n */\nexport const useFlowAnalysis = () => {\n  const { status } = useSelector(selectFlowState);\n  const metrics = useSelector(selectFlowMetrics);\n  const metadata = useSelector(selectFlowMetadata);\n  const selectedCommodity = useSelector(state => state.ecm.ui.selectedCommodity);\n  const selectedDate = useSelector(state => state.spatial.ui.selectedDate);\n  const currentFlows = useSelector(state => selectFlowsByDate(state, selectedDate));\n\n  // Memoized flow validation\n  const validateFlows = useCallback((flows) => {\n    if (!Array.isArray(flows)) {\n      throw new FlowValidationError('Invalid flow data format', { \n        received: typeof flows \n      });\n    }\n\n    return flows.filter(flow => {\n      try {\n        return isValidFlowData(flow) && flowValidation.isValidFlow(flow);\n      } catch (error) {\n        console.debug('Flow validation failed:', { flow, error });\n        return false;\n      }\n    });\n  }, []);\n\n  return useMemo(() => {\n    const metric = backgroundMonitor.startMetric('flow-analysis-hook');\n    const context = { \n      commodity: selectedCommodity, \n      date: selectedDate \n    };\n\n    try {\n      // Input validation\n      if (!selectedCommodity || !selectedDate) {\n        throw new FlowAnalysisError('Missing required parameters', context);\n      }\n\n      if (!currentFlows?.length) {\n        console.debug('No flow data available:', context);\n        return {\n          data: null,\n          loading: status.loading,\n          error: `No flow data available for ${selectedCommodity} in ${selectedDate}`\n        };\n      }\n\n      // Validate and filter flows\n      const validFlows = validateFlows(currentFlows);\n\n      if (!validFlows.length) {\n        console.debug('No valid flows found:', context);\n        return {\n          data: null,\n          loading: status.loading,\n          error: `No valid flow data for ${selectedCommodity} in ${selectedDate}`\n        };\n      }\n\n      // Calculate flow statistics\n      const { maxFlow, avgFlow } = calculateFlowStats(validFlows);\n\n      // Process and format data\n      const formattedData = {\n        flows: processFlowData(validFlows, maxFlow, avgFlow),\n        summary: {\n          totalFlows: validFlows.length,\n          maxFlow,\n          averageFlowStrength: avgFlow,\n          flowDensity: metrics?.marketConnectivity || 0,\n          averageIntensity: maxFlow > 0 ? avgFlow / maxFlow : 0,\n          uniqueMarkets: metadata?.uniqueMarkets || 0,\n          dateRange: metadata?.dateRange || { start: null, end: null },\n          commodity: selectedCommodity\n        }\n      };\n\n      metric.finish({ \n        status: 'success',\n        flowCount: validFlows.length,\n        marketCount: metadata?.uniqueMarkets || 0,\n        ...context\n      });\n\n      return {\n        data: formattedData,\n        loading: status.loading,\n        error: null,\n        // Add metadata for debugging and monitoring\n        metadata: {\n          processedAt: new Date().toISOString(),\n          validFlowCount: validFlows.length,\n          totalFlowCount: currentFlows.length,\n          ...context\n        }\n      };\n\n    } catch (error) {\n      console.error('Error in useFlowAnalysis:', error);\n      \n      // Enhanced error reporting\n      const errorDetails = {\n        type: error.name || 'Unknown',\n        message: error.message,\n        details: error.details || {},\n        ...context\n      };\n\n      metric.finish({ \n        status: 'error',\n        ...errorDetails\n      });\n\n      return {\n        data: null,\n        loading: false,\n        error: error.message,\n        errorDetails\n      };\n    }\n  }, [\n    currentFlows,\n    selectedDate,\n    selectedCommodity,\n    metrics,\n    metadata,\n    status,\n    validateFlows // Include memoized validator in dependencies\n  ]);\n};\n\nexport default useFlowAnalysis;\n",
        "imports": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../slices/flowSlice",
          "../features/flows/types"
        ],
        "exports": [
          "useFlowAnalysis",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../slices/flowSlice",
          "../features/flows/types"
        ]
      },
      {
        "path": "components/spatialAnalysis/hooks/useMarketHealth.js",
        "content": "// src/components/spatialAnalysis/hooks/useMarketHealth.js\n\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { backgroundMonitor } from '../../../utils/backgroundMonitor';\nimport { selectMarketHealthData } from '../../../selectors/spatialAnalysisSelectors';\n\n/**\n * Custom hook for analyzing overall market health\n * @returns {Object} Market health analysis results\n */\nexport const useMarketHealth = () => {\n  const healthData = useSelector(selectMarketHealthData);\n\n  return useMemo(() => {\n    const metric = backgroundMonitor.startMetric('market-health-hook');\n\n    try {\n      if (!healthData) {\n        return {\n          data: null,\n          loading: false,\n          error: 'No market health data available'\n        };\n      }\n\n      const { marketHealth, summary } = healthData;\n\n      // Format data for visualization and analysis\n      const formattedData = {\n        // Market health scores with detailed metrics\n        markets: Object.entries(marketHealth).map(([region, data]) => {\n          const prices = data.prices;\n          const priceStats = calculatePriceStatistics(prices);\n\n          return {\n            region,\n            healthScore: data.healthScore,\n            metrics: {\n              priceStability: priceStats.stability,\n              shockResilience: 1 - (data.shocks / 10),\n              marketIntegration: data.flows / 10,\n              conflictImpact: 1 - (data.conflictIntensity / 10),\n              priceVolatility: priceStats.volatility,\n              trendStrength: priceStats.trend\n            },\n            classification: classifyMarketHealth(data.healthScore),\n            prices: {\n              current: prices[prices.length - 1],\n              average: priceStats.average,\n              trend: priceStats.trend,\n              volatility: priceStats.volatility\n            },\n            risks: identifyRisks(data, priceStats)\n          };\n        }),\n\n        // Health categories\n        categories: {\n          healthy: Object.entries(marketHealth)\n            .filter(([_, data]) => data.healthScore >= 0.7)\n            .map(([region]) => region),\n          vulnerable: Object.entries(marketHealth)\n            .filter(([_, data]) => data.healthScore >= 0.4 && data.healthScore < 0.7)\n            .map(([region]) => region),\n          stressed: Object.entries(marketHealth)\n            .filter(([_, data]) => data.healthScore < 0.4)\n            .map(([region]) => region)\n        },\n\n        // Regional analysis\n        regions: Object.entries(marketHealth).reduce((acc, [region, data]) => {\n          acc[region] = {\n            healthScore: data.healthScore,\n            riskLevel: calculateRiskLevel(data),\n            vulnerabilities: identifyVulnerabilities(data),\n            strengths: identifyStrengths(data)\n          };\n          return acc;\n        }, {}),\n\n        // Enhanced summary statistics\n        summary: {\n          ...summary,\n          healthDistribution: {\n            healthy: summary.healthyMarkets,\n            vulnerable: Object.values(marketHealth)\n              .filter(m => m.healthScore >= 0.4 && m.healthScore < 0.7).length,\n            stressed: Object.values(marketHealth)\n              .filter(m => m.healthScore < 0.4).length\n          },\n          systemicRisk: calculateSystemicRisk(marketHealth),\n          resilience: calculateSystemResilience(marketHealth)\n        }\n      };\n\n      metric.finish({ status: 'success' });\n\n      return {\n        data: formattedData,\n        loading: false,\n        error: null\n      };\n\n    } catch (error) {\n      console.error('Error in useMarketHealth:', error);\n      metric.finish({ status: 'error', error: error.message });\n\n      return {\n        data: null,\n        loading: false,\n        error: error.message\n      };\n    }\n  }, [healthData]);\n};\n\n// Helper functions\n\nconst calculatePriceStatistics = (prices) => {\n  const average = prices.reduce((sum, p) => sum + p, 0) / prices.length;\n  const volatility = Math.sqrt(\n    prices.reduce((sum, p) => sum + Math.pow(p - average, 2), 0) / prices.length\n  ) / average;\n  const trend = prices.length > 1 ? \n    (prices[prices.length - 1] - prices[0]) / prices[0] : 0;\n  \n  return {\n    average,\n    volatility,\n    trend,\n    stability: 1 - volatility\n  };\n};\n\nconst classifyMarketHealth = (score) => {\n  if (score >= 0.7) return 'healthy';\n  if (score >= 0.4) return 'vulnerable';\n  return 'stressed';\n};\n\nconst calculateRiskLevel = (data) => {\n  const riskFactors = [\n    data.shocks > 5,\n    data.conflictIntensity > 5,\n    data.flows < 3,\n    calculatePriceStatistics(data.prices).volatility > 0.2\n  ];\n  \n  const riskCount = riskFactors.filter(Boolean).length;\n  return riskCount >= 3 ? 'high' :\n         riskCount >= 1 ? 'medium' : 'low';\n};\n\nconst identifyRisks = (data, priceStats) => {\n  const risks = [];\n  if (data.shocks > 5) risks.push('frequent_shocks');\n  if (data.conflictIntensity > 5) risks.push('high_conflict');\n  if (data.flows < 3) risks.push('low_integration');\n  if (priceStats.volatility > 0.2) risks.push('price_volatility');\n  return risks;\n};\n\nconst identifyVulnerabilities = (data) => {\n  const vulnerabilities = [];\n  if (data.shocks > 3) vulnerabilities.push('shock_susceptibility');\n  if (data.conflictIntensity > 3) vulnerabilities.push('conflict_exposure');\n  if (data.flows < 5) vulnerabilities.push('limited_connectivity');\n  return vulnerabilities;\n};\n\nconst identifyStrengths = (data) => {\n  const strengths = [];\n  if (data.flows > 7) strengths.push('high_connectivity');\n  if (data.shocks < 3) strengths.push('shock_resistant');\n  if (data.conflictIntensity < 3) strengths.push('stable_environment');\n  return strengths;\n};\n\nconst calculateSystemicRisk = (marketHealth) => {\n  const scores = Object.values(marketHealth).map(m => m.healthScore);\n  const average = scores.reduce((sum, s) => sum + s, 0) / scores.length;\n  const correlation = calculateHealthCorrelation(Object.values(marketHealth));\n  return (1 - average) * correlation;\n};\n\nconst calculateSystemResilience = (marketHealth) => {\n  const markets = Object.values(marketHealth);\n  const healthyCount = markets.filter(m => m.healthScore >= 0.7).length;\n  const connectivity = markets.reduce((sum, m) => sum + m.flows, 0) / markets.length;\n  return (healthyCount / markets.length) * connectivity;\n};\n\nconst calculateHealthCorrelation = (markets) => {\n  // Simplified correlation calculation between market health scores\n  const scores = markets.map(m => m.healthScore);\n  const mean = scores.reduce((sum, s) => sum + s, 0) / scores.length;\n  const deviations = scores.map(s => s - mean);\n  const covariance = deviations.reduce((sum, d, i) => \n    sum + d * deviations[(i + 1) % deviations.length], 0\n  ) / scores.length;\n  const variance = deviations.reduce((sum, d) => sum + d * d, 0) / scores.length;\n  return covariance / variance;\n};\n\nexport default useMarketHealth;\n",
        "imports": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors"
        ],
        "exports": [
          "useMarketHealth",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors"
        ]
      },
      {
        "path": "components/spatialAnalysis/hooks/useSeasonalAnalysis.js",
        "content": "// src/components/spatialAnalysis/hooks/useSeasonalAnalysis.js\n\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { backgroundMonitor } from '../../../utils/backgroundMonitor';\nimport { selectSeasonalAnalysisData } from '../../../selectors/spatialAnalysisSelectors';\n\n/**\n * Custom hook for analyzing seasonal patterns in market data\n * @returns {Object} Seasonal analysis results\n */\nexport const useSeasonalAnalysis = () => {\n  const seasonalData = useSelector(selectSeasonalAnalysisData);\n\n  return useMemo(() => {\n    const metric = backgroundMonitor.startMetric('seasonal-analysis-hook');\n\n    try {\n      if (!seasonalData) {\n        return {\n          data: null,\n          loading: false,\n          error: 'No seasonal data available'\n        };\n      }\n\n      const { monthlyStats, summary } = seasonalData;\n\n      // Format data for visualization and analysis\n      const formattedData = {\n        // Monthly patterns with additional metrics\n        patterns: monthlyStats.map(month => {\n          const baselinePrice = monthlyStats.reduce((sum, m) => sum + m.averagePrice, 0) / \n                              monthlyStats.length;\n          \n          return {\n            month: month.month,\n            averagePrice: month.averagePrice,\n            volatility: month.volatility,\n            // Calculate seasonal indices\n            seasonalIndex: month.averagePrice / baselinePrice,\n            deviation: (month.averagePrice - baselinePrice) / baselinePrice,\n            isHighSeason: month.averagePrice > baselinePrice * 1.1,\n            isLowSeason: month.averagePrice < baselinePrice * 0.9\n          };\n        }),\n\n        // Seasonal characteristics\n        seasonality: {\n          highSeasons: monthlyStats\n            .filter(m => m.averagePrice > summary.highestPriceMonth.averagePrice * 0.9)\n            .map(m => m.month),\n          lowSeasons: monthlyStats\n            .filter(m => m.averagePrice < summary.lowestPriceMonth.averagePrice * 1.1)\n            .map(m => m.month),\n          peakMonth: summary.highestPriceMonth.month,\n          troughMonth: summary.lowestPriceMonth.month,\n          seasonalStrength: (\n            summary.highestPriceMonth.averagePrice - \n            summary.lowestPriceMonth.averagePrice\n          ) / summary.lowestPriceMonth.averagePrice\n        },\n\n        // Price stability analysis\n        stability: {\n          monthlyVolatility: monthlyStats.map(m => ({\n            month: m.month,\n            volatility: m.volatility\n          })),\n          mostStableMonth: monthlyStats.reduce((min, curr) => \n            curr.volatility < min.volatility ? curr : min\n          ),\n          mostVolatileMonth: monthlyStats.reduce((max, curr) => \n            curr.volatility > max.volatility ? curr : max\n          )\n        },\n\n        // Enhanced summary statistics\n        summary: {\n          ...summary,\n          averageSeasonalVariation: monthlyStats.reduce((sum, month) => {\n            const baselinePrice = monthlyStats.reduce((s, m) => s + m.averagePrice, 0) / \n                                monthlyStats.length;\n            return sum + Math.abs(month.averagePrice - baselinePrice) / baselinePrice;\n          }, 0) / monthlyStats.length,\n          seasonalityIndex: (\n            summary.highestPriceMonth.averagePrice - \n            summary.lowestPriceMonth.averagePrice\n          ) / (\n            summary.highestPriceMonth.averagePrice + \n            summary.lowestPriceMonth.averagePrice\n          ) * 2,\n          priceStability: 1 - monthlyStats.reduce((sum, m) => sum + m.volatility, 0) / \n                         monthlyStats.length\n        }\n      };\n\n      // Add seasonal cycle detection\n      const seasonalCycle = detectSeasonalCycle(formattedData.patterns);\n      formattedData.seasonality.cycle = seasonalCycle;\n\n      metric.finish({ status: 'success' });\n\n      return {\n        data: formattedData,\n        loading: false,\n        error: null\n      };\n\n    } catch (error) {\n      console.error('Error in useSeasonalAnalysis:', error);\n      metric.finish({ status: 'error', error: error.message });\n\n      return {\n        data: null,\n        loading: false,\n        error: error.message\n      };\n    }\n  }, [seasonalData]);\n};\n\n/**\n * Helper function to detect seasonal cycles in price patterns\n * @param {Array} patterns - Monthly price patterns\n * @returns {Object} Detected seasonal cycle information\n */\nconst detectSeasonalCycle = (patterns) => {\n  // Initialize cycle detection\n  const pricePattern = patterns.map(p => p.seasonalIndex);\n  const n = pricePattern.length;\n  \n  // Calculate autocorrelation for different lags\n  const correlations = [];\n  for (let lag = 1; lag <= Math.floor(n/2); lag++) {\n    let correlation = 0;\n    let count = 0;\n    \n    for (let i = 0; i < n - lag; i++) {\n      correlation += (pricePattern[i] - 1) * (pricePattern[i + lag] - 1);\n      count++;\n    }\n    \n    correlations.push({\n      lag,\n      correlation: correlation / count\n    });\n  }\n\n  // Find the strongest correlation\n  const strongestCycle = correlations.reduce((max, curr) => \n    curr.correlation > max.correlation ? curr : max\n  );\n\n  return {\n    length: strongestCycle.lag,\n    strength: strongestCycle.correlation,\n    isSignificant: strongestCycle.correlation > 0.5\n  };\n};\n\nexport default useSeasonalAnalysis;\n",
        "imports": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors"
        ],
        "exports": [
          "useSeasonalAnalysis",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors"
        ]
      },
      {
        "path": "components/spatialAnalysis/hooks/useShockAnalysis.js",
        "content": "// src/components/spatialAnalysis/hooks/useShockAnalysis.js\n\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { backgroundMonitor } from '../../../utils/backgroundMonitor';\nimport { selectShockAnalysisData } from '../../../selectors/spatialAnalysisSelectors';\n\n/**\n * Custom hook for analyzing market shocks\n * @returns {Object} Shock analysis results\n */\nexport const useShockAnalysis = () => {\n  const shockData = useSelector(selectShockAnalysisData);\n\n  return useMemo(() => {\n    const metric = backgroundMonitor.startMetric('shock-analysis-hook');\n\n    try {\n      if (!shockData) {\n        return {\n          data: null,\n          loading: false,\n          error: 'No shock data available'\n        };\n      }\n\n      const { shocks, shocksByType, geometry, summary } = shockData;\n\n      // Format data for visualization and analysis\n      const formattedData = {\n        // All shocks with additional computed fields\n        shocks: shocks.map(shock => ({\n          ...shock,\n          normalizedMagnitude: shock.magnitude / summary.averageMagnitude,\n          severity: shock.magnitude > summary.averageMagnitude * 1.5 ? 'high' :\n                   shock.magnitude > summary.averageMagnitude ? 'medium' : 'low'\n        })),\n\n        // Shocks grouped by type with summary stats\n        categories: {\n          price_drop: {\n            shocks: shocksByType.price_drop || [],\n            count: summary.priceDrops,\n            averageMagnitude: shocksByType.price_drop ?\n              shocksByType.price_drop.reduce((sum, s) => sum + s.magnitude, 0) / \n              shocksByType.price_drop.length : 0\n          },\n          price_surge: {\n            shocks: shocksByType.price_surge || [],\n            count: summary.priceSurges,\n            averageMagnitude: shocksByType.price_surge ?\n              shocksByType.price_surge.reduce((sum, s) => sum + s.magnitude, 0) / \n              shocksByType.price_surge.length : 0\n          }\n        },\n\n        // Regional analysis\n        regions: Object.values(shocks.reduce((acc, shock) => {\n          if (!acc[shock.region]) {\n            acc[shock.region] = {\n              region: shock.region,\n              shockCount: 0,\n              totalMagnitude: 0,\n              shocks: []\n            };\n          }\n          acc[shock.region].shockCount++;\n          acc[shock.region].totalMagnitude += shock.magnitude;\n          acc[shock.region].shocks.push(shock);\n          return acc;\n        }, {})).map(region => ({\n          ...region,\n          averageMagnitude: region.totalMagnitude / region.shockCount,\n          vulnerability: region.shockCount / summary.totalShocks\n        })),\n\n        // Time-based analysis\n        temporal: shocks.reduce((acc, shock) => {\n          const date = shock.date.slice(0, 7); // YYYY-MM\n          if (!acc[date]) {\n            acc[date] = {\n              date,\n              shocks: [],\n              totalMagnitude: 0\n            };\n          }\n          acc[date].shocks.push(shock);\n          acc[date].totalMagnitude += shock.magnitude;\n          return acc;\n        }, {}),\n\n        // Overall summary with additional metrics\n        summary: {\n          ...summary,\n          shockFrequency: summary.totalShocks / \n            Object.keys(shocks.reduce((acc, s) => {\n              acc[s.date.slice(0, 7)] = true;\n              return acc;\n            }, {})).length,\n          volatilityIndex: Math.sqrt(\n            shocks.reduce((sum, s) => sum + Math.pow(s.magnitude, 2), 0) / \n            shocks.length\n          )\n        },\n\n        // Geometry data for mapping\n        geometry\n      };\n\n      metric.finish({ status: 'success' });\n\n      return {\n        data: formattedData,\n        loading: false,\n        error: null\n      };\n\n    } catch (error) {\n      console.error('Error in useShockAnalysis:', error);\n      metric.finish({ status: 'error', error: error.message });\n\n      return {\n        data: null,\n        loading: false,\n        error: error.message\n      };\n    }\n  }, [shockData]);\n};\n\nexport default useShockAnalysis;\n",
        "imports": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors"
        ],
        "exports": [
          "useShockAnalysis",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors"
        ]
      },
      {
        "path": "components/spatialAnalysis/hooks/useSpatialAutocorrelation.js",
        "content": "// src/components/spatialAnalysis/hooks/useSpatialAutocorrelation.js\n\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { backgroundMonitor } from '../../../utils/backgroundMonitor';\nimport {\n  selectGlobalAutocorrelation,\n  selectLocalAutocorrelation,\n  selectSignificantClusters,\n  selectAutocorrelationSummary\n} from '../../../selectors/spatialAnalysisSelectors';\nimport { selectGeometryData } from '../../../selectors/optimizedSelectors';\n\n/**\n * Custom hook for spatial autocorrelation analysis\n * @returns {Object} Spatial autocorrelation analysis results\n */\nexport const useSpatialAutocorrelation = () => {\n  // Get data using selectors\n  const global = useSelector(selectGlobalAutocorrelation);\n  const local = useSelector(selectLocalAutocorrelation);\n  const clusters = useSelector(selectSignificantClusters);\n  const summary = useSelector(selectAutocorrelationSummary);\n  const geometry = useSelector(selectGeometryData);\n\n  return useMemo(() => {\n    const metric = backgroundMonitor.startMetric('spatial-autocorrelation-hook');\n\n    try {\n      if (!global || !local) {\n        return {\n          data: null,\n          loading: false,\n          error: 'No spatial autocorrelation data available'\n        };\n      }\n\n      // Format data for components\n      const formattedData = {\n        global: {\n          moranI: global.moran_i,\n          pValue: global.p_value,\n          zScore: global.z_score,\n          isSignificant: global.significance\n        },\n        local: Object.entries(local).map(([region, stats]) => ({\n          region,\n          localI: stats.local_i,\n          pValue: stats.p_value,\n          clusterType: stats.cluster_type,\n          zScore: stats.z_score\n        })),\n        clusters: {\n          highHigh: clusters['high-high'],\n          lowLow: clusters['low-low'],\n          highLow: clusters['high-low'],\n          lowHigh: clusters['low-high'],\n          notSignificant: clusters['not_significant']\n        },\n        summary: {\n          globalMoranI: summary.globalMoranI,\n          globalSignificance: summary.globalSignificance,\n          totalRegions: summary.totalRegions,\n          significantRegions: summary.significantRegions,\n          significanceRate: summary.significanceRate\n        },\n        geometry\n      };\n\n      metric.finish({ status: 'success' });\n\n      return {\n        data: formattedData,\n        loading: false,\n        error: null\n      };\n\n    } catch (error) {\n      console.error('Error in useSpatialAutocorrelation:', error);\n      metric.finish({ status: 'error', error: error.message });\n\n      return {\n        data: null,\n        loading: false,\n        error: error.message\n      };\n    }\n  }, [global, local, clusters, summary, geometry]);\n};\n\nexport default useSpatialAutocorrelation;\n",
        "imports": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors",
          "../../../selectors/optimizedSelectors"
        ],
        "exports": [
          "useSpatialAutocorrelation",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../utils/backgroundMonitor",
          "../../../selectors/spatialAnalysisSelectors",
          "../../../selectors/optimizedSelectors"
        ]
      },
      {
        "path": "components/spatialAnalysis/index.js",
        "content": "import SpatialAnalysis from './SpatialAnalysis';\n\n// Feature modules\nexport * from './features/clusters';\nexport * from './features/autocorrelation';\nexport * from './features/flows';\nexport * from './features/shocks';\nexport * from './features/conflict';\nexport * from './features/seasonal';\nexport * from './features/health';\n\n// Atomic components\nexport { default as Legend } from './atoms/Legend';\nexport { default as Tooltip } from './atoms/Tooltip';\nexport { default as MetricCard } from './atoms/MetricCard';\n\n// Molecular components\nexport { default as MapControls } from './molecules/MapControls';\nexport { default as TimeControl } from './molecules/TimeControl';\nexport { default as MetricProgress } from './molecules/MetricProgress';\n\n// Organism components\nexport { default as ClusterMap } from './organisms/ClusterMap';\nexport { default as LISAMap } from './organisms/LISAMap';\nexport { default as FlowMap } from './organisms/FlowMap';\n\n// Hooks\nexport { default as useClusterAnalysis } from './hooks/useClusterAnalysis.js';\nexport { default as useSpatialAutocorrelation } from './hooks/useSpatialAutocorrelation';\nexport { default as useFlowAnalysis } from './hooks/useFlowAnalysis';\nexport { default as useShockAnalysis } from './hooks/useShockAnalysis';\nexport { default as useConflictAnalysis } from './hooks/useConflictAnalysis';\nexport { default as useSeasonalAnalysis } from './hooks/useSeasonalAnalysis';\nexport { default as useMarketHealth } from './hooks/useMarketHealth';\n\n// Utilities\nexport { default as spatialUtils } from './utils/spatialUtils';\nexport { default as geoJSONProcessor } from './utils/geoJSONProcessor';\nexport { default as networkAnalysis } from './utils/networkAnalysis';\nexport { default as clusterUtils } from './utils/clusterUtils';\n\n/**\n * Yemen Market Analysis Spatial Analysis Module\n * \n * This module provides comprehensive spatial analysis tools for Yemen's market data:\n * \n * Features:\n * - Market Clustering: Identify and analyze market clusters\n * - Spatial Autocorrelation: Examine spatial price dependencies\n * - Flow Analysis: Visualize and analyze market flow networks\n * - Shock Analysis: Track price shock propagation\n * - Conflict Impact: Assess conflict effects on markets\n * - Seasonal Analysis: Analyze seasonal price patterns\n * - Market Health: Monitor overall system health\n * \n * Components:\n * - Atomic: Basic UI elements (Legend, Tooltip, MetricCard)\n * - Molecular: Common patterns (MapControls, TimeControl)\n * - Organisms: Complex visualizations (Maps, Graphs)\n * - Features: Complete analysis modules\n * \n * Hooks:\n * - Data processing and analysis hooks for each feature\n * - Shared utilities for spatial calculations\n * \n * Usage:\n * ```jsx\n * import { SpatialAnalysis } from './components/spatialAnalysis';\n * \n * const App = () => (\n *   <SpatialAnalysis\n *     timeSeriesData={data}\n *     geometryData={geometry}\n *     marketIntegration={integration}\n *   />\n * );\n * ```\n * \n * The module follows atomic design principles and provides a modular,\n * extensible architecture for spatial market analysis.\n */\n\nexport { SpatialAnalysis };\nexport default SpatialAnalysis;\n",
        "imports": [
          "./SpatialAnalysis"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "./SpatialAnalysis"
        ]
      },
      {
        "path": "components/spatialAnalysis/molecules/BaseMap.js",
        "content": "/**\n * Base Map Component\n * \n * Provides a consistent map base for all spatial visualizations with:\n * - Enforced bounds for Yemen\n * - Custom view settings\n * - Automatic bounds fitting\n * - Consistent styling\n */\n\nimport React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { MapContainer, TileLayer, useMap } from 'react-leaflet';\n\n// Yemen bounds - adjusted to be tighter around the country\nconst YEMEN_BOUNDS = [\n  [12.7, 42.6], // Southwest - adjusted north and east\n  [18.5, 53.2]  // Northeast - adjusted south and west\n];\n\nconst DEFAULT_VIEW = {\n  center: [15.3694, 47.8], // Adjusted longitude east\n  zoom: 5.5 // Default zoom for overview\n};\n\n// Map view controller component\nconst MapController = ({ defaultView, defaultBounds }) => {\n  const map = useMap();\n\n  useEffect(() => {\n    if (map) {\n      // Set max bounds\n      map.setMaxBounds(YEMEN_BOUNDS);\n      \n      // Set zoom constraints\n      map.setMinZoom(5);  // Allow more zoom out for overview\n      map.setMaxZoom(9);  // Keep max zoom consistent\n      \n      // Disable keyboard navigation\n      map.keyboard.disable();\n      \n      // Disable scroll wheel zoom\n      map.scrollWheelZoom.disable();\n      \n      // Enforce bounds on drag\n      map.on('drag', () => {\n        map.panInsideBounds(YEMEN_BOUNDS, { animate: false });\n      });\n\n      // Handle default bounds if provided\n      if (defaultBounds) {\n        try {\n          map.fitBounds(defaultBounds, {\n            padding: [20, 20],\n            maxZoom: 8,\n            animate: true,\n            duration: 1\n          });\n        } catch (error) {\n          console.warn('Error fitting to bounds:', error);\n          // Fallback to default view\n          map.setView(\n            defaultView?.center || DEFAULT_VIEW.center,\n            defaultView?.zoom || DEFAULT_VIEW.zoom,\n            { animate: true }\n          );\n        }\n      }\n      // Use default view if no bounds provided\n      else if (defaultView && defaultView.center && defaultView.zoom) {\n        map.setView(defaultView.center, defaultView.zoom, { animate: true });\n      }\n    }\n  }, [map, defaultView, defaultBounds]);\n\n  return null;\n};\n\nconst BaseMap = ({ \n  children, \n  height = '100%',\n  defaultView = DEFAULT_VIEW,\n  defaultBounds = null\n}) => {\n  return (\n    <MapContainer\n      center={defaultView.center}\n      zoom={defaultView.zoom}\n      style={{ \n        height, \n        width: '100%',\n        backgroundColor: '#f8f9fa' // Light background\n      }}\n      zoomControl={false} // We'll add custom zoom controls\n      attributionControl={false} // Remove attribution control\n    >\n      <TileLayer\n        url=\"https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png\"\n        attribution='&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>, &copy; <a href=\"https://carto.com/attribution\">CARTO</a>'\n      />\n      <MapController \n        defaultView={defaultView} \n        defaultBounds={defaultBounds}\n      />\n      {children}\n    </MapContainer>\n  );\n};\n\nBaseMap.propTypes = {\n  children: PropTypes.node,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  defaultView: PropTypes.shape({\n    center: PropTypes.arrayOf(PropTypes.number),\n    zoom: PropTypes.number\n  }),\n  defaultBounds: PropTypes.arrayOf(\n    PropTypes.arrayOf(PropTypes.number)\n  )\n};\n\nexport default BaseMap;\n",
        "imports": [
          "react",
          "prop-types",
          "react-leaflet"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "react-leaflet"
        ]
      },
      {
        "path": "components/spatialAnalysis/molecules/MapControls.js",
        "content": "/**\n * Map Controls Component\n * \n * Provides zoom and reset controls for the map visualization\n */\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Box, IconButton } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport AddIcon from '@mui/icons-material/Add';\nimport RemoveIcon from '@mui/icons-material/Remove';\nimport RefreshIcon from '@mui/icons-material/Refresh';\nimport CenterFocusStrongIcon from '@mui/icons-material/CenterFocusStrong';\n\nconst MapControls = ({\n  onZoomIn,\n  onZoomOut,\n  onReset,\n  onRefresh,\n  position = { top: 10, right: 10 }\n}) => {\n  const theme = useTheme();\n\n  return (\n    <Box\n      sx={{\n        position: 'absolute',\n        ...position,\n        zIndex: 1000,\n        backgroundColor: 'background.paper',\n        borderRadius: 1,\n        boxShadow: 2,\n        '& > button': {\n          borderRadius: 0,\n          padding: 1,\n          '&:first-of-type': {\n            borderTopLeftRadius: 4,\n            borderTopRightRadius: 4\n          },\n          '&:last-child': {\n            borderBottomLeftRadius: 4,\n            borderBottomRightRadius: 4\n          },\n          '&:not(:last-child)': {\n            borderBottom: `1px solid ${theme.palette.divider}`\n          }\n        }\n      }}\n    >\n      <IconButton \n        onClick={onZoomIn}\n        title=\"Zoom In\"\n        size=\"small\"\n      >\n        <AddIcon fontSize=\"small\" />\n      </IconButton>\n      \n      <IconButton \n        onClick={onZoomOut}\n        title=\"Zoom Out\"\n        size=\"small\"\n      >\n        <RemoveIcon fontSize=\"small\" />\n      </IconButton>\n      \n      <IconButton \n        onClick={onReset}\n        title=\"Reset View\"\n        size=\"small\"\n      >\n        <CenterFocusStrongIcon fontSize=\"small\" />\n      </IconButton>\n      \n      <IconButton \n        onClick={onRefresh}\n        title=\"Refresh Data\"\n        size=\"small\"\n      >\n        <RefreshIcon fontSize=\"small\" />\n      </IconButton>\n    </Box>\n  );\n};\n\nMapControls.propTypes = {\n  onZoomIn: PropTypes.func.isRequired,\n  onZoomOut: PropTypes.func.isRequired,\n  onReset: PropTypes.func.isRequired,\n  onRefresh: PropTypes.func.isRequired,\n  position: PropTypes.shape({\n    top: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number,\n    left: PropTypes.number\n  })\n};\n\nexport default React.memo(MapControls);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Add",
          "@mui/icons-material/Remove",
          "@mui/icons-material/Refresh",
          "@mui/icons-material/CenterFocusStrong"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/Add",
          "@mui/icons-material/Remove",
          "@mui/icons-material/Refresh",
          "@mui/icons-material/CenterFocusStrong"
        ]
      },
      {
        "path": "components/spatialAnalysis/molecules/MetricProgress.js",
        "content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport { \n  Box, \n  Typography, \n  LinearProgress, \n  CircularProgress,\n  Tooltip,\n  Paper\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport TrendingUpIcon from '@mui/icons-material/TrendingUp';\nimport TrendingDownIcon from '@mui/icons-material/TrendingDown';\nimport InfoIcon from '@mui/icons-material/Info';\n\nconst MetricProgress = ({\n  title,\n  value,\n  target,\n  trend,\n  format = 'percentage',\n  description,\n  tooltip,\n  type = 'linear',\n  size = 'medium',\n  showTarget = true,\n  className,\n  style\n}) => {\n  const theme = useTheme();\n\n  const formatValue = (val) => {\n    if (typeof val !== 'number') return val;\n    \n    switch (format) {\n      case 'percentage':\n        return `${(val * 100).toFixed(1)}%`;\n      case 'currency':\n        return `$${val.toFixed(2)}`;\n      case 'integer':\n        return Math.round(val).toString();\n      default:\n        return val.toFixed(2);\n    }\n  };\n\n  const progress = target ? (value / target) * 100 : value * 100;\n  const progressColor = getProgressColor(progress, theme);\n  \n  const TrendIcon = trend > 0 ? TrendingUpIcon : TrendingDownIcon;\n  const trendColor = trend > 0 ? theme.palette.success.main : theme.palette.error.main;\n\n  return (\n    <Paper\n      elevation={1}\n      className={className}\n      sx={{\n        p: 2,\n        height: '100%',\n        ...style\n      }}\n    >\n      <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>\n        <Typography \n          variant={size === 'small' ? 'body2' : 'subtitle2'} \n          color=\"textSecondary\"\n        >\n          {title}\n        </Typography>\n        {tooltip && (\n          <Tooltip title={tooltip} placement=\"top\">\n            <InfoIcon \n              sx={{ \n                ml: 1, \n                fontSize: size === 'small' ? '0.875rem' : '1rem',\n                color: theme.palette.text.secondary\n              }} \n            />\n          </Tooltip>\n        )}\n      </Box>\n\n      <Box sx={{ display: 'flex', alignItems: 'baseline', mb: 1 }}>\n        <Typography \n          variant={size === 'small' ? 'h6' : 'h5'} \n          component=\"div\"\n          sx={{ fontWeight: 'medium' }}\n        >\n          {formatValue(value)}\n        </Typography>\n        {trend !== undefined && (\n          <Box \n            sx={{ \n              display: 'flex', \n              alignItems: 'center', \n              ml: 1,\n              color: trendColor\n            }}\n          >\n            <TrendIcon sx={{ fontSize: size === 'small' ? '0.875rem' : '1rem' }} />\n            <Typography \n              variant={size === 'small' ? 'caption' : 'body2'} \n              component=\"span\" \n              sx={{ ml: 0.5 }}\n            >\n              {Math.abs(trend)}%\n            </Typography>\n          </Box>\n        )}\n      </Box>\n\n      {type === 'linear' ? (\n        <Box sx={{ width: '100%', position: 'relative' }}>\n          <LinearProgress\n            variant=\"determinate\"\n            value={Math.min(progress, 100)}\n            sx={{\n              height: size === 'small' ? 4 : 6,\n              borderRadius: size === 'small' ? 2 : 3,\n              backgroundColor: theme.palette.grey[200],\n              '& .MuiLinearProgress-bar': {\n                backgroundColor: progressColor\n              }\n            }}\n          />\n          {showTarget && target && (\n            <Typography \n              variant=\"caption\" \n              color=\"textSecondary\"\n              sx={{ \n                position: 'absolute',\n                right: 0,\n                top: '100%',\n                mt: 0.5\n              }}\n            >\n              Target: {formatValue(target)}\n            </Typography>\n          )}\n        </Box>\n      ) : (\n        <Box \n          sx={{ \n            position: 'relative',\n            display: 'inline-flex',\n            alignItems: 'center',\n            justifyContent: 'center'\n          }}\n        >\n          <CircularProgress\n            variant=\"determinate\"\n            value={Math.min(progress, 100)}\n            size={size === 'small' ? 40 : 56}\n            sx={{\n              color: progressColor,\n              '& .MuiCircularProgress-circle': {\n                strokeLinecap: 'round'\n              }\n            }}\n          />\n          <Typography\n            variant={size === 'small' ? 'caption' : 'body2'}\n            component=\"div\"\n            color=\"textSecondary\"\n            sx={{\n              position: 'absolute',\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center'\n            }}\n          >\n            {formatValue(value)}\n          </Typography>\n        </Box>\n      )}\n\n      {description && (\n        <Typography \n          variant={size === 'small' ? 'caption' : 'body2'} \n          color=\"textSecondary\"\n          sx={{ mt: 1 }}\n        >\n          {description}\n        </Typography>\n      )}\n    </Paper>\n  );\n};\n\nconst getProgressColor = (progress, theme) => {\n  if (progress >= 90) return theme.palette.success.main;\n  if (progress >= 60) return theme.palette.warning.main;\n  return theme.palette.error.main;\n};\n\nMetricProgress.propTypes = {\n  title: PropTypes.string.isRequired,\n  value: PropTypes.number.isRequired,\n  target: PropTypes.number,\n  trend: PropTypes.number,\n  format: PropTypes.oneOf(['number', 'percentage', 'currency', 'integer']),\n  description: PropTypes.string,\n  tooltip: PropTypes.string,\n  type: PropTypes.oneOf(['linear', 'circular']),\n  size: PropTypes.oneOf(['small', 'medium']),\n  showTarget: PropTypes.bool,\n  className: PropTypes.string,\n  style: PropTypes.object\n};\n\nexport default React.memo(MetricProgress);\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown",
          "@mui/icons-material/Info"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/TrendingUp",
          "@mui/icons-material/TrendingDown",
          "@mui/icons-material/Info"
        ]
      },
      {
        "path": "components/spatialAnalysis/molecules/TimeControl.js",
        "content": "import React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { \n  Box, \n  IconButton, \n  Slider, \n  Typography,\n  Paper\n} from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport PlayArrowIcon from '@mui/icons-material/PlayArrow';\nimport PauseIcon from '@mui/icons-material/Pause';\nimport SkipPreviousIcon from '@mui/icons-material/SkipPrevious';\nimport SkipNextIcon from '@mui/icons-material/SkipNext';\nimport SpeedIcon from '@mui/icons-material/Speed';\nimport { debounce } from 'lodash';\n\n// Helper function to normalize date to YYYY-MM format\nconst normalizeDate = (date) => {\n  try {\n    return date?.substring(0, 7);\n  } catch (error) {\n    console.error('Error normalizing date:', error);\n    return date;\n  }\n};\n\n// Helper function to format date for display\nconst formatDate = (date) => {\n  try {\n    const fullDate = `${normalizeDate(date)}-01`;\n    return new Date(fullDate).toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'short'\n    });\n  } catch (error) {\n    console.error('Error formatting date:', error);\n    return date;\n  }\n};\n\nconst TimeControl = ({\n  dates,\n  currentDate,\n  onChange,\n  autoPlayInterval = 1000,\n  position = null\n}) => {\n  const theme = useTheme();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1);\n  const [sliderValue, setSliderValue] = useState(0);\n  const [internalDate, setInternalDate] = useState(currentDate);\n\n  // Normalize all dates - memoized to prevent unnecessary recalculations\n  const normalizedDates = useMemo(() => dates.map(normalizeDate), [dates]);\n  const normalizedCurrentDate = useMemo(() => normalizeDate(currentDate), [currentDate]);\n\n  // Debounced onChange handler to prevent rapid Redux updates\n  const debouncedOnChange = useMemo(\n    () => debounce((newDate) => {\n      onChange(newDate);\n    }, 150),\n    [onChange]\n  );\n\n  // Initialize slider value based on current date\n  useEffect(() => {\n    const currentIndex = normalizedDates.indexOf(normalizedCurrentDate);\n    \n    if (currentIndex >= 0) {\n      setSliderValue(currentIndex);\n      setInternalDate(normalizedCurrentDate);\n    } else if (dates.length > 0) {\n      setSliderValue(0);\n      setInternalDate(normalizeDate(dates[0]));\n      onChange(normalizeDate(dates[0]));\n    }\n  }, [currentDate, dates, normalizedCurrentDate, normalizedDates, onChange]);\n\n  // Handle auto-play with useCallback to prevent recreation\n  const handleAutoPlay = useCallback(() => {\n    if (isPlaying) {\n      setSliderValue(prev => {\n        const next = prev + 1;\n        if (next >= dates.length) {\n          setIsPlaying(false);\n          return 0;\n        }\n        const newDate = normalizeDate(dates[next]);\n        setInternalDate(newDate);\n        debouncedOnChange(newDate);\n        return next;\n      });\n    }\n  }, [isPlaying, dates.length, debouncedOnChange]);\n\n  // Auto-play effect\n  useEffect(() => {\n    let interval;\n    if (isPlaying) {\n      interval = setInterval(handleAutoPlay, autoPlayInterval / playbackSpeed);\n    }\n    return () => clearInterval(interval);\n  }, [isPlaying, autoPlayInterval, playbackSpeed, handleAutoPlay]);\n\n  // Optimized slider change handler\n  const handleSliderChange = useCallback((_, value) => {\n    if (value !== sliderValue) {\n      const newDate = normalizeDate(dates[value]);\n      setSliderValue(value);\n      setInternalDate(newDate);\n      debouncedOnChange(newDate);\n    }\n  }, [dates, sliderValue, debouncedOnChange]);\n\n  // Memoized handlers to prevent unnecessary recreations\n  const handlePlayPause = useCallback(() => {\n    setIsPlaying(prev => !prev);\n  }, []);\n\n  const handlePrevious = useCallback(() => {\n    const newValue = Math.max(0, sliderValue - 1);\n    handleSliderChange(null, newValue);\n  }, [sliderValue, handleSliderChange]);\n\n  const handleNext = useCallback(() => {\n    const newValue = Math.min(dates.length - 1, sliderValue + 1);\n    handleSliderChange(null, newValue);\n  }, [dates.length, sliderValue, handleSliderChange]);\n\n  const handleSpeedChange = useCallback(() => {\n    setPlaybackSpeed(prev => (prev === 4 ? 1 : prev * 2));\n  }, []);\n\n  // Cleanup debounced function on unmount\n  useEffect(() => {\n    return () => {\n      debouncedOnChange.cancel();\n    };\n  }, [debouncedOnChange]);\n\n  // Memoize the rendered date to prevent unnecessary recalculations\n  const formattedDate = useMemo(() => formatDate(dates[sliderValue]), [dates, sliderValue]);\n\n  return (\n    <Paper\n      elevation={2}\n      sx={{\n        width: '100%',\n        backgroundColor: theme.palette.background.paper,\n        borderRadius: 1,\n        p: 2,\n        ...(position && {\n          position: 'absolute',\n          zIndex: 1000,\n          ...position\n        })\n      }}\n    >\n      <Box sx={{ width: '100%' }}>\n        <Typography \n          variant=\"subtitle2\" \n          color=\"textPrimary\"\n          sx={{ \n            display: 'block', \n            mb: 1, \n            textAlign: 'center',\n            fontWeight: 500\n          }}\n        >\n          {formattedDate}\n        </Typography>\n\n        <Slider\n          value={sliderValue}\n          min={0}\n          max={dates.length - 1}\n          onChange={handleSliderChange}\n          sx={{ \n            mb: 2,\n            '& .MuiSlider-thumb': {\n              width: 12,\n              height: 12\n            }\n          }}\n        />\n\n        <Box sx={{ \n          display: 'flex', \n          justifyContent: 'center', \n          gap: 1,\n          '& .MuiIconButton-root': {\n            padding: 1,\n            '&:hover': {\n              backgroundColor: 'rgba(0, 0, 0, 0.04)'\n            }\n          }\n        }}>\n          <IconButton \n            size=\"small\" \n            onClick={handlePrevious}\n            disabled={sliderValue === 0}\n            title=\"Previous\"\n          >\n            <SkipPreviousIcon fontSize=\"small\" />\n          </IconButton>\n\n          <IconButton \n            size=\"small\" \n            onClick={handlePlayPause}\n            title={isPlaying ? 'Pause' : 'Play'}\n          >\n            {isPlaying ? (\n              <PauseIcon fontSize=\"small\" />\n            ) : (\n              <PlayArrowIcon fontSize=\"small\" />\n            )}\n          </IconButton>\n\n          <IconButton \n            size=\"small\" \n            onClick={handleNext}\n            disabled={sliderValue === dates.length - 1}\n            title=\"Next\"\n          >\n            <SkipNextIcon fontSize=\"small\" />\n          </IconButton>\n\n          <IconButton \n            size=\"small\" \n            onClick={handleSpeedChange}\n            title={`Playback Speed: ${playbackSpeed}x`}\n            sx={{ position: 'relative' }}\n          >\n            <SpeedIcon fontSize=\"small\" />\n            <Typography \n              variant=\"caption\" \n              sx={{ \n                position: 'absolute',\n                bottom: 2,\n                right: 2,\n                fontSize: '0.6rem',\n                fontWeight: 'bold',\n                backgroundColor: theme.palette.background.paper,\n                borderRadius: '50%',\n                width: 12,\n                height: 12,\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center'\n              }}\n            >\n              {playbackSpeed}x\n            </Typography>\n          </IconButton>\n        </Box>\n      </Box>\n    </Paper>\n  );\n};\n\nTimeControl.propTypes = {\n  dates: PropTypes.arrayOf(PropTypes.string).isRequired,\n  currentDate: PropTypes.string.isRequired,\n  onChange: PropTypes.func.isRequired,\n  autoPlayInterval: PropTypes.number,\n  position: PropTypes.shape({\n    top: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    right: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    bottom: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    left: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    transform: PropTypes.string\n  })\n};\n\nexport default React.memo(TimeControl, (prevProps, nextProps) => {\n  // Custom comparison function for React.memo\n  return (\n    prevProps.currentDate === nextProps.currentDate &&\n    prevProps.dates.length === nextProps.dates.length &&\n    prevProps.autoPlayInterval === nextProps.autoPlayInterval &&\n    JSON.stringify(prevProps.position) === JSON.stringify(nextProps.position)\n  );\n});\n",
        "imports": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/PlayArrow",
          "@mui/icons-material/Pause",
          "@mui/icons-material/SkipPrevious",
          "@mui/icons-material/SkipNext",
          "@mui/icons-material/Speed",
          "lodash"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material",
          "@mui/material/styles",
          "@mui/icons-material/PlayArrow",
          "@mui/icons-material/Pause",
          "@mui/icons-material/SkipPrevious",
          "@mui/icons-material/SkipNext",
          "@mui/icons-material/Speed",
          "lodash"
        ]
      },
      {
        "path": "components/spatialAnalysis/organisms/ClusterMap.js",
        "content": "// src/components/spatialAnalysis/organisms/ClusterMap.js\n\nimport React, { useCallback, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { useTheme } from '@mui/material/styles';\nimport { Box, Typography } from '@mui/material';\nimport { MapContainer, TileLayer, GeoJSON, useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport './ClusterMap.css';\nimport { useWindowWidth } from '../../../hooks/useWindowWidth'; // Adjust the import path as needed\n\n// Updated Yemen's center and zoom to display a larger area\nconst DEFAULT_CENTER = [15.3694, 44.1910]; // Coordinates roughly at the center of Yemen\nconst DEFAULT_ZOOM = 6; // Set zoom level to 6\nconst BUFFER = 3; // Increased buffer to include more surrounding areas\nconst DEFAULT_BOUNDS = [\n  [12.1110 - BUFFER, 41.8140 - BUFFER], // Southwest corner with buffer\n  [19.0025 + BUFFER, 54.5305 + BUFFER], // Northeast corner with buffer\n];\n\n// Map reset component to maintain bounds (temporarily disabled)\nconst MapReset = () => {\n  const map = useMap();\n\n  useEffect(() => {\n    const resetTimeout = setTimeout(() => {\n      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);\n      // map.fitBounds(DEFAULT_BOUNDS); // Temporarily disabled\n    }, 100);\n\n    const resetView = () => {\n      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);\n      // map.fitBounds(DEFAULT_BOUNDS); // Temporarily disabled\n    };\n\n    map.on('mouseout', resetView);\n    map.on('dragend', () => {\n      if (!map.getBounds().intersects(DEFAULT_BOUNDS)) {\n        resetView();\n      }\n    });\n\n    return () => {\n      clearTimeout(resetTimeout);\n      map.off('mouseout', resetView);\n      map.off('dragend', resetView);\n    };\n  }, [map]);\n\n  return null;\n};\n\nconst ClusterMap = ({\n  clusters,\n  selectedClusterId,\n  onClusterSelect,\n  geometry,\n  height = '100%',\n}) => {\n  const theme = useTheme();\n  const windowWidth = useWindowWidth();\n\n  // Dynamically adjust the map's height based on window width for responsiveness\n  const responsiveHeight = windowWidth < 600 ? '300px' : height;\n\n  // Function to retrieve cluster information based on region\n  const getClusterByRegion = useCallback(\n    (region) => {\n      return clusters?.find(\n        (c) => c.connected_markets.includes(region) || c.main_market === region\n      );\n    },\n    [clusters]\n  );\n\n  // Style function for GeoJSON regions\n  const styleRegion = useCallback(\n    (feature) => {\n      const region = feature.properties.region_id;\n      const cluster = getClusterByRegion(region);\n      const isSelected = cluster?.cluster_id === selectedClusterId;\n\n      if (!cluster) {\n        return {\n          fillColor: theme.palette.background.paper,\n          weight: 0.5,\n          opacity: 0.3,\n          color: theme.palette.divider,\n          fillOpacity: 0.1,\n          cursor: 'default',\n        };\n      }\n\n      const baseColor =\n        cluster.cluster_id === 1\n          ? theme.palette.primary.main\n          : theme.palette.secondary.main;\n\n      return {\n        fillColor: baseColor,\n        weight: isSelected ? 2 : 1,\n        opacity: 1,\n        color: isSelected\n          ? theme.palette.common.white\n          : theme.palette.grey[400],\n        fillOpacity: isSelected ? 0.8 : 0.5,\n        cursor: 'pointer',\n      };\n    },\n    [theme, selectedClusterId, getClusterByRegion]\n  );\n\n  // Handle click events on regions\n  const onRegionClick = useCallback(\n    (feature) => {\n      const region = feature.properties.region_id;\n      const cluster = getClusterByRegion(region);\n      if (cluster) {\n        onClusterSelect(cluster.cluster_id);\n      }\n    },\n    [getClusterByRegion, onClusterSelect]\n  );\n\n  // Generate tooltip content for regions\n  const createTooltipContent = useCallback(\n    (feature) => {\n      const region = feature.properties.region_id;\n      const cluster = getClusterByRegion(region);\n\n      if (!cluster) {\n        return `\n          <div style=\"text-align: center;\">\n            <strong>${region}</strong>\n            <br />\n            <small style=\"color: ${theme.palette.text.secondary};\">\n              Not part of any cluster\n            </small>\n          </div>\n        `;\n      }\n\n      return `\n        <div style=\"text-align: center;\">\n          <strong>${region}</strong>\n          <br />\n          ${cluster.main_market} cluster\n          <br />\n          <small style=\"color: ${theme.palette.text.secondary};\">\n            Click to view details\n          </small>\n        </div>\n      `;\n    },\n    [getClusterByRegion, theme.palette.text.secondary]\n  );\n\n  // Display loading state if GeoJSON data is not available\n  if (!geometry?.unified?.features) {\n    return (\n      <Box\n        sx={{\n          height: responsiveHeight,\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n        }}\n      >\n        <Typography color=\"text.secondary\">\n          Loading Cluster Data...\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box\n      sx={{\n        height: responsiveHeight,\n        display: 'flex',\n        flexDirection: 'column',\n        position: 'relative',\n      }}\n    >\n      <MapContainer\n        center={DEFAULT_CENTER}\n        zoom={DEFAULT_ZOOM}\n        style={{ flex: 1, width: '100%' }}\n        // bounds={DEFAULT_BOUNDS} // Removed to prevent overriding center and zoom\n        maxZoom={18} // Ensure maxZoom accommodates your DEFAULT_ZOOM\n        minZoom={5}  // Ensure minZoom is set appropriately\n        zoomControl={true}\n        dragging={true}\n        touchZoom={true}\n        doubleClickZoom={true}\n        scrollWheelZoom={false}\n        boxZoom={true}\n        keyboard={true}\n        bounceAtZoomLimits={true}\n        worldCopyJump={false}\n        preferCanvas={true}\n      >\n        {/* <MapReset /> */} {/* Temporarily disabled to test zoom and center */}\n        <TileLayer\n          url=\"https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png\"\n          attribution='&copy; OpenStreetMap contributors'\n          noWrap={true}\n          maxNativeZoom={18} // Ensure this matches the maxZoom\n          maxZoom={18}\n          tileSize={256}\n          zoomOffset={0}\n          keepBuffer={8}\n        />\n        <GeoJSON\n          data={geometry.unified}\n          style={styleRegion}\n          onEachFeature={(feature, layer) => {\n            layer.on({\n              click: () => onRegionClick(feature),\n              mouseover: (e) => {\n                const cluster = getClusterByRegion(feature.properties.region_id);\n                if (cluster) {\n                  e.target.setStyle({\n                    fillOpacity: 0.8,\n                    weight: 2,\n                  });\n                }\n              },\n              mouseout: (e) => {\n                const cluster = getClusterByRegion(feature.properties.region_id);\n                if (cluster && cluster.cluster_id !== selectedClusterId) {\n                  e.target.setStyle({\n                    fillOpacity: 0.5,\n                    weight: 1,\n                  });\n                } else if (!cluster) {\n                  e.target.setStyle({\n                    fillOpacity: 0.1,\n                    weight: 0.5,\n                  });\n                }\n              },\n            });\n            layer.bindTooltip(createTooltipContent(feature), {\n              permanent: false,\n              direction: 'center',\n              className: 'custom-tooltip',\n            });\n          }}\n        />\n      </MapContainer>\n    </Box>\n  );\n};\n\nClusterMap.propTypes = {\n  clusters: PropTypes.arrayOf(\n    PropTypes.shape({\n      cluster_id: PropTypes.number.isRequired,\n      main_market: PropTypes.string.isRequired,\n      connected_markets: PropTypes.arrayOf(PropTypes.string).isRequired,\n    })\n  ),\n  selectedClusterId: PropTypes.number,\n  onClusterSelect: PropTypes.func.isRequired,\n  geometry: PropTypes.shape({\n    unified: PropTypes.object,\n  }),\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n};\n\nexport default React.memo(ClusterMap);",
        "imports": [
          "react",
          "prop-types",
          "@mui/material/styles",
          "@mui/material",
          "react-leaflet",
          "leaflet",
          "./ClusterMap.css",
          "../../../hooks/useWindowWidth"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "@mui/material/styles",
          "@mui/material",
          "react-leaflet",
          "leaflet",
          "./ClusterMap.css",
          "../../../hooks/useWindowWidth"
        ]
      },
      {
        "path": "components/spatialAnalysis/organisms/FlowMap.js",
        "content": "// src/components/spatialAnalysis/organisms/FlowMap.js\n\nimport React, { useMemo, useCallback, useRef, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { MapContainer, TileLayer, GeoJSON, Polyline, CircleMarker, useMap } from 'react-leaflet';\nimport { Box, Typography } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport chroma from 'chroma-js';\nimport L from 'leaflet';\n\nimport Legend from '../atoms/Legend';\nimport TooltipComponent from '../atoms/Tooltip';\nimport MapControls from '../molecules/MapControls';\nimport { transformRegionName } from '../utils/spatialUtils';\nimport { flowValidation } from '../features/flows/types';\n\n// LISA cluster color mapping (Assuming similar color mapping needed)\nconst LISA_COLORS = {\n  'high-high': '#d7191c', // Red for hot spots\n  'low-low': '#2c7bb6', // Blue for cold spots\n  'high-low': '#fdae61', // Orange for high-low outliers\n  'low-high': '#abd9e9', // Light blue for low-high outliers\n  'not-significant': '#eeeeee', // Grey for not significant\n};\n\n// Further adjusted default map settings for a more zoomed-out view\nconst DEFAULT_CENTER = [15.3694, 44.191]; // Yemen's geographical center\nconst DEFAULT_ZOOM = 3; // Further reduced zoom level for a more zoomed-out view\nconst BUFFER = 4; // Increased buffer around Yemen\nconst DEFAULT_BOUNDS = [\n  [12.1110 - BUFFER, 41.8140 - BUFFER], // Southwest corner with increased buffer\n  [19.0025 + BUFFER, 54.5305 + BUFFER], // Northeast corner with increased buffer\n];\n\n// Map reset component\nconst MapReset = () => {\n  const map = useMap();\n\n  useEffect(() => {\n    const resetTimeout = setTimeout(() => {\n      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);\n      map.fitBounds(DEFAULT_BOUNDS);\n    }, 100);\n\n    const resetView = () => {\n      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);\n      map.fitBounds(DEFAULT_BOUNDS);\n    };\n\n    map.on('mouseout', resetView);\n    map.on('dragend', () => {\n      if (!map.getBounds().intersects(DEFAULT_BOUNDS)) {\n        resetView();\n      }\n    });\n\n    return () => {\n      clearTimeout(resetTimeout);\n      map.off('mouseout', resetView);\n      map.off('dragend', resetView);\n    };\n  }, [map]);\n\n  return null;\n};\n\nconst FlowMap = ({\n  flows = [],\n  geometry,\n  selectedFlow,\n  onFlowSelect,\n  height = '100%',\n}) => {\n  const theme = useTheme();\n  const mapRef = useRef(null);\n\n  // Create color scale for flow strength\n  const colorScale = useMemo(\n    () =>\n      chroma\n        .scale(['#fde0dd', '#c51b8a'])\n        .domain([0, 1]),\n    []\n  );\n\n  // Process flow data with coordinates\n  const processedFlows = useMemo(() => {\n    if (!flows?.length || !geometry?.features) return [];\n\n    // Filter valid flows and get max flow\n    const validFlows = flows.filter(flow => flowValidation.isValidFlow(flow));\n    const maxFlow = Math.max(...validFlows.map(f => f.flow_weight || 0));\n\n    return validFlows\n      .map((flow) => {\n        const sourceFeature = geometry.features.find(\n          (f) =>\n            f.properties.normalizedName ===\n            transformRegionName(flow.source)\n        );\n        const targetFeature = geometry.features.find(\n          (f) =>\n            f.properties.normalizedName ===\n            transformRegionName(flow.target)\n        );\n\n        if (\n          !sourceFeature?.geometry?.coordinates ||\n          !targetFeature?.geometry?.coordinates\n        ) {\n          return null;\n        }\n\n        const normalizedFlow = flowValidation.normalizeFlow(flow, maxFlow);\n        const status = flowValidation.getFlowStatus(normalizedFlow);\n\n        return {\n          ...flow,\n          sourceCoords: sourceFeature.geometry.coordinates,\n          targetCoords: targetFeature.geometry.coordinates,\n          color: colorScale(normalizedFlow).hex(),\n          width: 1 + normalizedFlow * 4, // Scale line width based on flow strength\n          normalizedFlow,\n          status\n        };\n      })\n      .filter(Boolean);\n  }, [flows, geometry, colorScale]);\n\n  // Style function for regions\n  const getFeatureStyle = useCallback(\n    (feature) => {\n      const isEndpoint = processedFlows.some(\n        (flow) =>\n          transformRegionName(flow.source) ===\n            feature.properties.normalizedName ||\n          transformRegionName(flow.target) ===\n            feature.properties.normalizedName\n      );\n\n      return {\n        fillColor: isEndpoint\n          ? theme.palette.primary.light\n          : theme.palette.grey[300],\n        weight: 1,\n        opacity: 1,\n        color: 'white',\n        fillOpacity: isEndpoint ? 0.6 : 0.3,\n      };\n    },\n    [processedFlows, theme]\n  );\n\n  // Map control handlers\n  const handleZoomIn = useCallback(() => {\n    mapRef.current?.zoomIn();\n  }, []);\n\n  const handleZoomOut = useCallback(() => {\n    mapRef.current?.zoomOut();\n  }, []);\n\n  const handleReset = useCallback(() => {\n    if (geometry?.features?.length) {\n      const bounds = L.geoJSON(geometry).getBounds();\n      mapRef.current?.fitBounds(bounds);\n    }\n  }, [geometry]);\n\n  // Create legend items\n  const legendItems = useMemo(\n    () => [\n      { color: '#c51b8a', label: 'High Flow' },\n      { color: '#fde0dd', label: 'Low Flow' },\n      {\n        color: theme.palette.primary.light,\n        label: 'Market Point',\n        style: { borderRadius: '50%' },\n      },\n    ],\n    [theme]\n  );\n\n  if (!processedFlows.length || !geometry) {\n    return (\n      <Box\n        sx={{\n          height,\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n        }}\n      >\n        <Typography color=\"text.secondary\">\n          No flow data available for visualization\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ height, position: 'relative' }}>\n      <MapContainer\n        ref={mapRef}\n        center={DEFAULT_CENTER}\n        zoom={DEFAULT_ZOOM}\n        bounds={DEFAULT_BOUNDS}\n        style={{ height: '100%', width: '100%' }}\n        maxBounds={DEFAULT_BOUNDS}\n        minZoom={DEFAULT_ZOOM - 1}\n        maxZoom={DEFAULT_ZOOM + 7}\n        zoomControl={true}\n        dragging={true}\n        touchZoom={true}\n        doubleClickZoom={true}\n        scrollWheelZoom={true}\n        boxZoom={true}\n        keyboard={true}\n        bounceAtZoomLimits={true}\n        worldCopyJump={false}\n        preferCanvas={true}\n      >\n        <MapReset />\n        <TileLayer\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n          attribution='&copy; OpenStreetMap contributors'\n        />\n\n        <GeoJSON data={geometry} style={getFeatureStyle} />\n\n        {processedFlows.map((flow, index) => {\n          const isSelected =\n            selectedFlow &&\n            selectedFlow.source === flow.source &&\n            selectedFlow.target === flow.target;\n\n          return (\n            <React.Fragment key={index}>\n              <Polyline\n                positions={[\n                  [flow.sourceCoords[1], flow.sourceCoords[0]],\n                  [flow.targetCoords[1], flow.targetCoords[0]],\n                ]}\n                pathOptions={{\n                  color: flow.color,\n                  weight: isSelected ? flow.width * 2 : flow.width,\n                  opacity: isSelected ? 0.8 : 0.5,\n                }}\n                eventHandlers={{\n                  click: () => onFlowSelect?.(flow),\n                }}\n              >\n                <TooltipComponent\n                  title=\"Market Flow\"\n                  metrics={[\n                    {\n                      label: 'Source',\n                      value: flow.source,\n                    },\n                    {\n                      label: 'Target',\n                      value: flow.target,\n                    },\n                    {\n                      label: 'Flow Volume',\n                      value: flow.flow_weight,\n                      format: 'number',\n                    },\n                    {\n                      label: 'Flow Strength',\n                      value: flow.normalizedFlow,\n                      format: 'percentage',\n                    },\n                    {\n                      label: 'Status',\n                      value: flow.status,\n                    },\n                    {\n                      label: 'Price Differential',\n                      value: flow.price_differential || 0,\n                      format: 'percentage',\n                    },\n                  ]}\n                />\n              </Polyline>\n\n              {/* Market points */}\n              {[\n                { coords: flow.sourceCoords, name: flow.source },\n                { coords: flow.targetCoords, name: flow.target },\n              ].map((point, idx) => (\n                <CircleMarker\n                  key={`${index}-${idx}`}\n                  center={[point.coords[1], point.coords[0]]}\n                  radius={6}\n                  pathOptions={{\n                    fillColor: theme.palette.primary.light,\n                    color: 'white',\n                    weight: 1,\n                    opacity: 0.8,\n                    fillOpacity: 0.6,\n                  }}\n                >\n                  <TooltipComponent\n                    title={point.name}\n                    content=\"Market Location\"\n                  />\n                </CircleMarker>\n              ))}\n            </React.Fragment>\n          );\n        })}\n      </MapContainer>\n\n      <MapControls\n        onZoomIn={handleZoomIn}\n        onZoomOut={handleZoomOut}\n        onReset={handleReset}\n        onRefresh={() => {}}\n      />\n\n      <Legend title=\"Market Flows\" items={legendItems} />\n    </Box>\n  );\n};\n\nFlowMap.propTypes = {\n  flows: PropTypes.arrayOf(\n    PropTypes.shape({\n      source: PropTypes.string.isRequired,\n      target: PropTypes.string.isRequired,\n      flow_weight: PropTypes.number.isRequired,\n      price_differential: PropTypes.number,\n      metadata: PropTypes.shape({\n        valid: PropTypes.bool.isRequired,\n        processed_at: PropTypes.string.isRequired\n      }).isRequired\n    })\n  ),\n  geometry: PropTypes.shape({\n    type: PropTypes.string,\n    features: PropTypes.arrayOf(PropTypes.object),\n  }).isRequired,\n  selectedFlow: PropTypes.shape({\n    source: PropTypes.string.isRequired,\n    target: PropTypes.string.isRequired,\n  }),\n  onFlowSelect: PropTypes.func,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n};\n\nexport default React.memo(FlowMap);\n",
        "imports": [
          "react",
          "prop-types",
          "react-leaflet",
          "@mui/material",
          "@mui/material/styles",
          "chroma-js",
          "leaflet",
          "../atoms/Legend",
          "../atoms/Tooltip",
          "../molecules/MapControls",
          "../utils/spatialUtils",
          "../features/flows/types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "react-leaflet",
          "@mui/material",
          "@mui/material/styles",
          "chroma-js",
          "leaflet",
          "../atoms/Legend",
          "../atoms/Tooltip",
          "../molecules/MapControls",
          "../utils/spatialUtils",
          "../features/flows/types"
        ]
      },
      {
        "path": "components/spatialAnalysis/organisms/LISAMap.js",
        "content": "// src/components/spatialAnalysis/organisms/LISAMap.js\n\nimport React, { useMemo, useCallback, useRef, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { MapContainer, TileLayer, GeoJSON, useMap } from 'react-leaflet';\nimport { Box, Typography } from '@mui/material';\nimport { useTheme } from '@mui/material/styles';\nimport L from 'leaflet';\n\nimport Legend from '../atoms/Legend';\nimport TooltipComponent from '../atoms/Tooltip';\nimport MapControls from '../molecules/MapControls';\nimport { transformRegionName } from '../utils/spatialUtils';\n\n// LISA cluster color mapping\nconst LISA_COLORS = {\n  'high-high': '#d7191c', // Red for hot spots\n  'low-low': '#2c7bb6', // Blue for cold spots\n  'high-low': '#fdae61', // Orange for high-low outliers\n  'low-high': '#abd9e9', // Light blue for low-high outliers\n  'not-significant': '#eeeeee', // Grey for not significant\n};\n\n// Yemen's center with expanded bounds and buffer zone\nconst DEFAULT_CENTER = [15.3694, 44.191];\nconst DEFAULT_ZOOM = 6;\nconst BUFFER = 2; // Degrees of buffer around Yemen\nconst DEFAULT_BOUNDS = [\n  [12.1110 - BUFFER, 41.8140 - BUFFER], // Southwest corner with buffer\n  [19.0025 + BUFFER, 54.5305 + BUFFER], // Northeast corner with buffer\n];\n\n// Map reset component\nconst MapReset = () => {\n  const map = useMap();\n\n  useEffect(() => {\n    const resetTimeout = setTimeout(() => {\n      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);\n      map.fitBounds(DEFAULT_BOUNDS);\n    }, 100);\n\n    const resetView = () => {\n      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);\n      map.fitBounds(DEFAULT_BOUNDS);\n    };\n\n    map.on('mouseout', resetView);\n    map.on('dragend', () => {\n      if (!map.getBounds().intersects(DEFAULT_BOUNDS)) {\n        resetView();\n      }\n    });\n\n    return () => {\n      clearTimeout(resetTimeout);\n      map.off('mouseout', resetView);\n      map.off('dragend', resetView);\n    };\n  }, [map]);\n\n  return null;\n};\n\nconst LISAMap = ({\n  localMorans,\n  geometry,\n  height = '100%',\n  onRegionClick,\n}) => {\n  const theme = useTheme();\n  const mapRef = useRef(null);\n\n  // Process GeoJSON with LISA statistics\n  const processedGeoJSON = useMemo(() => {\n    if (!geometry?.features || !localMorans) return null;\n\n    return {\n      type: 'FeatureCollection',\n      features: geometry.features.map((feature) => {\n        const regionId = feature.properties?.region_id;\n        const moranData = localMorans[regionId] || {};\n\n        return {\n          ...feature,\n          properties: {\n            ...feature.properties,\n            cluster_type: moranData.cluster_type || 'not-significant',\n            local_i: moranData.local_i || 0,\n            p_value: moranData.p_value || 1,\n            z_score: moranData.z_score || 0,\n          },\n        };\n      }),\n    };\n  }, [geometry, localMorans]);\n\n  // Style function for GeoJSON features\n  const getFeatureStyle = useCallback(\n    (feature) => {\n      const clusterType =\n        feature.properties?.cluster_type || 'not-significant';\n\n      return {\n        fillColor: LISA_COLORS[clusterType],\n        weight: 1,\n        opacity: 1,\n        color: 'white',\n        fillOpacity: 0.7,\n      };\n    },\n    []\n  );\n\n  // Map control handlers\n  const handleZoomIn = useCallback(() => {\n    mapRef.current?.zoomIn();\n  }, []);\n\n  const handleZoomOut = useCallback(() => {\n    mapRef.current?.zoomOut();\n  }, []);\n\n  const handleReset = useCallback(() => {\n    if (geometry?.features?.length) {\n      const bounds = L.geoJSON(geometry).getBounds();\n      mapRef.current?.fitBounds(bounds);\n    }\n  }, [geometry]);\n\n  // Create legend items\n  const legendItems = useMemo(\n    () => [\n      { color: LISA_COLORS['high-high'], label: 'High-High Cluster' },\n      { color: LISA_COLORS['low-low'], label: 'Low-Low Cluster' },\n      { color: LISA_COLORS['high-low'], label: 'High-Low Outlier' },\n      { color: LISA_COLORS['low-high'], label: 'Low-High Outlier' },\n      { color: LISA_COLORS['not-significant'], label: 'Not Significant' },\n    ],\n    []\n  );\n\n  if (!processedGeoJSON) {\n    return (\n      <Box\n        sx={{\n          height,\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          bgcolor: 'background.paper',\n          borderRadius: 1,\n        }}\n      >\n        <Typography color=\"text.secondary\">\n          No LISA data available for visualization\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ height, position: 'relative' }}>\n      <MapContainer\n        ref={mapRef}\n        center={DEFAULT_CENTER}\n        zoom={DEFAULT_ZOOM}\n        bounds={DEFAULT_BOUNDS}\n        style={{ height: '100%', width: '100%' }}\n        maxBounds={DEFAULT_BOUNDS}\n        minZoom={DEFAULT_ZOOM - 1}\n        maxZoom={DEFAULT_ZOOM + 2}\n        zoomControl={true}\n        dragging={true}\n        touchZoom={true}\n        doubleClickZoom={true}\n        scrollWheelZoom={false}\n        boxZoom={true}\n        keyboard={true}\n        bounceAtZoomLimits={true}\n        worldCopyJump={false}\n        preferCanvas={true}\n      >\n        <MapReset />\n        <TileLayer\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n          attribution='&copy; OpenStreetMap contributors'\n        />\n\n        <GeoJSON\n          data={processedGeoJSON}\n          style={getFeatureStyle}\n          onEachFeature={(feature, layer) => {\n            if (onRegionClick) {\n              layer.on({\n                click: () => onRegionClick(feature.properties.region_id),\n              });\n            }\n\n            const tooltipContent = `\n              <div style=\"\n                background: ${theme.palette.background.paper};\n                padding: 8px;\n                border-radius: 4px;\n                border: 1px solid ${theme.palette.divider};\n                font-family: ${theme.typography.fontFamily};\n              \">\n                <div style=\"font-weight: 600; margin-bottom: 4px;\">\n                  ${feature.properties.originalName || feature.properties.region_id}\n                </div>\n                <div style=\"color: ${theme.palette.text.secondary};\">\n                  Cluster Type: ${feature.properties.cluster_type\n                    .replace(/-/g, ' ')\n                    .split(' ')\n                    .map(\n                      (word) =>\n                        word.charAt(0).toUpperCase() + word.slice(1)\n                    )\n                    .join('-')}\n                </div>\n                <div style=\"color: ${theme.palette.text.secondary};\">\n                  Local Moran's I: ${feature.properties.local_i}\n                </div>\n                <div style=\"color: ${theme.palette.text.secondary};\">\n                  P-Value: ${feature.properties.p_value}\n                </div>\n                <div style=\"color: ${theme.palette.text.secondary};\">\n                  Z-Score: ${feature.properties.z_score}\n                </div>\n              </div>\n            `;\n\n            layer.bindTooltip(tooltipContent, {\n              sticky: true,\n              direction: 'top',\n            });\n          }}\n        />\n      </MapContainer>\n\n      <MapControls\n        onZoomIn={handleZoomIn}\n        onZoomOut={handleZoomOut}\n        onReset={handleReset}\n        onRefresh={() => {}}\n      />\n\n      <Legend title=\"LISA Clusters\" items={legendItems} />\n    </Box>\n  );\n};\n\nLISAMap.propTypes = {\n  localMorans: PropTypes.object.isRequired,\n  geometry: PropTypes.shape({\n    type: PropTypes.string,\n    features: PropTypes.arrayOf(PropTypes.object),\n  }).isRequired,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  onRegionClick: PropTypes.func,\n};\n\nexport default React.memo(LISAMap);",
        "imports": [
          "react",
          "prop-types",
          "react-leaflet",
          "@mui/material",
          "@mui/material/styles",
          "leaflet",
          "../atoms/Legend",
          "../atoms/Tooltip",
          "../molecules/MapControls",
          "../utils/spatialUtils"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "react-leaflet",
          "@mui/material",
          "@mui/material/styles",
          "leaflet",
          "../atoms/Legend",
          "../atoms/Tooltip",
          "../molecules/MapControls",
          "../utils/spatialUtils"
        ]
      },
      {
        "path": "components/spatialAnalysis/styles/spatialAnalysisStyles.js",
        "content": "// Common styles for spatial analysis components\nconst spatialAnalysisStyles = (theme) => ({\n  // Layout styles\n  container: {\n    height: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n    overflow: 'hidden'\n  },\n  \n  content: {\n    flexGrow: 1,\n    overflow: 'auto',\n    padding: theme.spacing(2),\n    backgroundColor: theme.palette.background.default\n  },\n\n  // Map container styles\n  mapContainer: {\n    height: '100%',\n    minHeight: 400,\n    position: 'relative',\n    borderRadius: theme.shape.borderRadius,\n    overflow: 'hidden',\n    '& .leaflet-container': {\n      height: '100%',\n      width: '100%',\n      borderRadius: 'inherit'\n    }\n  },\n\n  // Card styles\n  card: {\n    height: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n    transition: theme.transitions.create(['box-shadow']),\n    '&:hover': {\n      boxShadow: theme.shadows[4]\n    }\n  },\n\n  // Metric styles\n  metricCard: {\n    padding: theme.spacing(2),\n    height: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'space-between'\n  },\n\n  metricValue: {\n    fontWeight: theme.typography.fontWeightMedium,\n    color: theme.palette.text.primary\n  },\n\n  metricTrend: {\n    display: 'flex',\n    alignItems: 'center',\n    gap: theme.spacing(0.5),\n    marginTop: theme.spacing(0.5)\n  },\n\n  // Chart styles\n  chart: {\n    width: '100%',\n    height: 400,\n    '& .recharts-wrapper': {\n      backgroundColor: theme.palette.background.paper,\n      borderRadius: theme.shape.borderRadius\n    }\n  },\n\n  // Table styles\n  table: {\n    '& .MuiTableCell-head': {\n      backgroundColor: theme.palette.background.default,\n      fontWeight: theme.typography.fontWeightMedium\n    },\n    '& .MuiTableRow-root:hover': {\n      backgroundColor: theme.palette.action.hover\n    }\n  },\n\n  // Control panel styles\n  controlPanel: {\n    position: 'absolute',\n    top: theme.spacing(2),\n    right: theme.spacing(2),\n    zIndex: 1000,\n    backgroundColor: 'rgba(255, 255, 255, 0.9)',\n    borderRadius: theme.shape.borderRadius,\n    boxShadow: theme.shadows[2]\n  },\n\n  // Legend styles\n  legend: {\n    position: 'absolute',\n    bottom: theme.spacing(2),\n    right: theme.spacing(2),\n    zIndex: 1000,\n    backgroundColor: 'rgba(255, 255, 255, 0.9)',\n    borderRadius: theme.shape.borderRadius,\n    padding: theme.spacing(1.5),\n    boxShadow: theme.shadows[2]\n  },\n\n  // Tooltip styles\n  tooltip: {\n    backgroundColor: theme.palette.background.paper,\n    padding: theme.spacing(1),\n    borderRadius: theme.shape.borderRadius,\n    boxShadow: theme.shadows[2],\n    border: `1px solid ${theme.palette.divider}`\n  },\n\n  // Analysis panel styles\n  analysisPanel: {\n    padding: theme.spacing(2),\n    height: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n    gap: theme.spacing(2)\n  },\n\n  // Network graph styles\n  networkGraph: {\n    width: '100%',\n    height: '100%',\n    minHeight: 400,\n    '& svg': {\n      backgroundColor: theme.palette.background.paper,\n      borderRadius: theme.shape.borderRadius\n    }\n  },\n\n  // Flow line styles\n  flowLine: {\n    stroke: theme.palette.primary.main,\n    strokeWidth: 2,\n    strokeOpacity: 0.6,\n    '&:hover': {\n      strokeOpacity: 0.8,\n      strokeWidth: 3\n    }\n  },\n\n  // Market point styles\n  marketPoint: {\n    fill: theme.palette.primary.main,\n    stroke: theme.palette.background.paper,\n    strokeWidth: 2,\n    '&:hover': {\n      fill: theme.palette.primary.dark\n    }\n  },\n\n  // Animation\n  fadeIn: {\n    animation: `$fadeIn 0.3s ${theme.transitions.easing.easeInOut}`\n  },\n\n  '@keyframes fadeIn': {\n    from: {\n      opacity: 0\n    },\n    to: {\n      opacity: 1\n    }\n  },\n\n  // Responsive styles\n  '@media (max-width: 960px)': {\n    controlPanel: {\n      top: 'auto',\n      bottom: theme.spacing(2),\n      right: theme.spacing(2)\n    },\n    legend: {\n      bottom: theme.spacing(2),\n      left: theme.spacing(2),\n      right: 'auto'\n    }\n  }\n});\n\nexport default spatialAnalysisStyles;\n",
        "imports": [],
        "exports": [
          "default"
        ],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/types/index.js",
        "content": "// src/components/spatialAnalysis/types/index.js\n\n/**\n * @typedef {Object} ClusterMetrics\n * @property {number} avgPrice - Average price across markets in the cluster\n * @property {number} avgConflict - Average conflict intensity in the cluster\n * @property {number} marketCount - Number of markets in the cluster\n */\n\n/**\n * @typedef {Object} Cluster\n * @property {number} cluster_id - Unique identifier for the cluster\n * @property {string} main_market - Main market in the cluster\n * @property {string[]} connected_markets - Array of connected market identifiers\n * @property {ClusterMetrics} metrics - Cluster metrics\n */\n\n/**\n * @typedef {Object} OverallMetrics\n * @property {number} totalMarkets - Total number of markets across all clusters\n * @property {number} avgPrice - Average price across all markets\n * @property {number} avgConflict - Average conflict intensity across all markets\n */\n\n/**\n * @typedef {Object} ClusterAnalysisResult\n * @property {Cluster[]} clusters - Array of analyzed clusters\n * @property {OverallMetrics} metrics - Overall analysis metrics\n * @property {boolean} loading - Loading state\n * @property {string|null} error - Error message if any\n */\n\n/**\n * @typedef {Object} GeometryData\n * @property {Object} unified - GeoJSON data for the map\n * @property {Object} points - Point data for markets\n * @property {Object} polygons - Polygon data for regions\n */\n\n// Constants\nexport const ClusterTypes = {\n  CLUSTER_1: 1,\n  CLUSTER_2: 2\n};\n\n// Default values\nexport const DEFAULT_METRICS = {\n  avgPrice: 0,\n  avgConflict: 0,\n  marketCount: 0\n};\n\nexport const DEFAULT_OVERALL_METRICS = {\n  totalMarkets: 0,\n  avgPrice: 0,\n  avgConflict: 0\n};\n",
        "imports": [],
        "exports": [
          "ClusterTypes",
          "DEFAULT_METRICS",
          "DEFAULT_OVERALL_METRICS"
        ],
        "dependencies": []
      },
      {
        "path": "components/spatialAnalysis/utils/clusterUtils.js",
        "content": "// src/components/spatialAnalysis/utils/clusterUtils.js\n\nimport { DEFAULT_METRICS } from '../types';\n\n/**\n * Calculate average metrics for a set of time series data points\n * @param {Array} timeSeriesData - Array of time series data points\n * @returns {Object} Average metrics\n */\nexport const calculateAverageMetrics = (timeSeriesData) => {\n  if (!timeSeriesData?.length) {\n    return DEFAULT_METRICS;\n  }\n\n  const sum = timeSeriesData.reduce((acc, point) => ({\n    price: acc.price + (point.usdPrice || 0),\n    conflict: acc.conflict + (point.conflictIntensity || 0)\n  }), { price: 0, conflict: 0 });\n\n  return {\n    avgPrice: sum.price / timeSeriesData.length,\n    avgConflict: sum.conflict / timeSeriesData.length\n  };\n};\n\n/**\n * Get time series data for a specific cluster\n * @param {Object} cluster - Cluster object\n * @param {Array} timeSeriesData - Complete time series data\n * @returns {Array} Filtered time series data for cluster markets\n */\nexport const getClusterTimeSeriesData = (cluster, timeSeriesData) => {\n  if (!cluster?.connected_markets || !timeSeriesData?.length) {\n    return [];\n  }\n\n  return timeSeriesData.filter(point => \n    cluster.connected_markets.includes(point.region)\n  );\n};\n\n/**\n * Format cluster data for display\n * @param {Object} cluster - Cluster object with metrics\n * @returns {Object} Formatted cluster data\n */\nexport const formatClusterData = (cluster) => {\n  if (!cluster) return null;\n\n  return {\n    title: `${cluster.main_market} Cluster`,\n    marketCount: cluster.connected_markets?.length || 0,\n    metrics: {\n      avgPrice: cluster.metrics?.avgPrice?.toFixed(2) || '0.00',\n      avgConflict: cluster.metrics?.avgConflict?.toFixed(2) || '0.00',\n      marketCount: cluster.metrics?.marketCount || 0\n    }\n  };\n};\n\n/**\n * Check if a region belongs to a cluster\n * @param {string} region - Region identifier\n * @param {Object} cluster - Cluster object\n * @returns {boolean} Whether region belongs to cluster\n */\nexport const isRegionInCluster = (region, cluster) => {\n  if (!region || !cluster?.connected_markets) {\n    return false;\n  }\n\n  return cluster.connected_markets.includes(region) || \n         cluster.main_market === region;\n};\n\n/**\n * Get cluster by region\n * @param {string} region - Region identifier\n * @param {Array} clusters - Array of clusters\n * @returns {Object|null} Cluster containing the region\n */\nexport const getClusterByRegion = (region, clusters) => {\n  if (!region || !clusters?.length) {\n    return null;\n  }\n\n  return clusters.find(cluster => \n    isRegionInCluster(region, cluster)\n  );\n};\n\nexport default {\n  calculateAverageMetrics,\n  getClusterTimeSeriesData,\n  formatClusterData,\n  isRegionInCluster,\n  getClusterByRegion\n};\n",
        "imports": [
          "../types"
        ],
        "exports": [
          "calculateAverageMetrics",
          "getClusterTimeSeriesData",
          "formatClusterData",
          "isRegionInCluster",
          "getClusterByRegion",
          "default"
        ],
        "dependencies": [
          "../types"
        ]
      },
      {
        "path": "components/spatialAnalysis/utils/geoJSONProcessor.js",
        "content": "/**\n * Utility functions for processing and validating GeoJSON data\n */\n\nimport { transformRegionName } from './spatialUtils';\n\n/**\n * Deep clone an object\n * @param {Object} obj - Object to clone\n * @returns {Object} Cloned object\n */\nconst deepClone = (obj) => {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(deepClone);\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, deepClone(value)])\n  );\n};\n\n/**\n * Normalize longitude to be within -180 to 180 range\n * @param {number} lon - Longitude value\n * @returns {number} Normalized longitude\n */\nconst normalizeLongitude = (lon) => {\n  // Handle invalid input\n  if (typeof lon !== 'number' || isNaN(lon)) return null;\n  \n  // Normalize to -180 to 180 range\n  lon = lon % 360;\n  if (lon > 180) lon -= 360;\n  if (lon < -180) lon += 360;\n  \n  return lon;\n};\n\n/**\n * Process and validate GeoJSON data\n * @param {Object} geometry - Raw GeoJSON data\n * @param {string} context - Processing context (e.g., 'clusters', 'flows')\n * @returns {Object|null} Processed GeoJSON or null if invalid\n */\nexport const safeGeoJSONProcessor = (geometry, context = 'general') => {\n  try {\n    if (!geometry || typeof geometry !== 'object') {\n      console.error('Invalid GeoJSON data provided');\n      return null;\n    }\n\n    // Create a deep copy of the geometry\n    const geometryCopy = deepClone(geometry);\n\n    // Validate GeoJSON structure\n    if (!geometryCopy.type || !geometryCopy.features) {\n      console.error('Invalid GeoJSON structure');\n      return null;\n    }\n\n    // Process features based on context\n    const processedFeatures = geometryCopy.features.map(feature => {\n      // Create a new feature object\n      const newFeature = {\n        type: 'Feature',\n        properties: { ...feature.properties } || {},\n        geometry: { ...feature.geometry }\n      };\n\n      // Ensure geometry type is capitalized\n      if (newFeature.geometry?.type) {\n        newFeature.geometry.type = \n          newFeature.geometry.type.charAt(0).toUpperCase() + \n          newFeature.geometry.type.slice(1);\n      }\n\n      // Normalize region names\n      if (newFeature.properties.name) {\n        newFeature.properties.normalizedName = transformRegionName(newFeature.properties.name);\n        newFeature.properties.originalName = newFeature.properties.name;\n      }\n\n      // Validate and normalize coordinates\n      if (newFeature.geometry?.coordinates) {\n        newFeature.geometry.coordinates = normalizeCoordinates(\n          newFeature.geometry.coordinates,\n          newFeature.geometry.type\n        );\n      }\n\n      // Add context-specific processing\n      switch (context) {\n        case 'clusters':\n          return processClusterFeature(newFeature);\n        case 'flows':\n          return processFlowFeature(newFeature);\n        case 'shocks':\n          return processShockFeature(newFeature);\n        case 'autocorrelation':\n          return processAutocorrelationFeature(newFeature);\n        default:\n          return newFeature;\n      }\n    }).filter(Boolean);\n\n    return {\n      type: 'FeatureCollection',\n      features: processedFeatures,\n      crs: geometryCopy.crs || {\n        type: 'name',\n        properties: {\n          name: 'EPSG:4326'\n        }\n      }\n    };\n  } catch (error) {\n    console.error('Error processing GeoJSON:', error);\n    return null;\n  }\n};\n\n/**\n * Normalize coordinates based on geometry type\n * @param {Array} coordinates - Raw coordinates\n * @param {string} type - Geometry type\n * @returns {Array} Normalized coordinates\n */\nconst normalizeCoordinates = (coordinates, type) => {\n  if (!Array.isArray(coordinates)) return coordinates;\n\n  const validateCoordPair = ([lon, lat]) => {\n    if (typeof lon !== 'number' || typeof lat !== 'number' ||\n        isNaN(lon) || isNaN(lat) ||\n        Math.abs(lat) > 90) {\n      return null;\n    }\n\n    // Normalize longitude to -180 to 180 range\n    const normalizedLon = normalizeLongitude(lon);\n    if (normalizedLon === null) return null;\n\n    return [normalizedLon, lat];\n  };\n\n  switch (type) {\n    case 'Point':\n      return validateCoordPair(coordinates);\n    case 'LineString':\n      return coordinates.map(validateCoordPair).filter(Boolean);\n    case 'Polygon':\n      return coordinates.map(ring => \n        ring.map(validateCoordPair).filter(Boolean)\n      );\n    case 'MultiPolygon':\n      return coordinates.map(polygon =>\n        polygon.map(ring => \n          ring.map(validateCoordPair).filter(Boolean)\n        )\n      );\n    default:\n      return coordinates;\n  }\n};\n\n/**\n * Process feature for cluster visualization\n * @param {Object} feature - GeoJSON feature\n * @returns {Object} Processed feature\n */\nconst processClusterFeature = (feature) => {\n  try {\n    return {\n      ...feature,\n      properties: {\n        ...feature.properties,\n        cluster_id: feature.properties.cluster_id || null,\n        efficiency: feature.properties.efficiency || 0,\n        market_count: feature.properties.market_count || 0\n      }\n    };\n  } catch (error) {\n    console.error('Error processing cluster feature:', error);\n    return feature;\n  }\n};\n\n/**\n * Process feature for flow visualization\n * @param {Object} feature - GeoJSON feature\n * @returns {Object} Processed feature\n */\nconst processFlowFeature = (feature) => {\n  try {\n    return {\n      ...feature,\n      properties: {\n        ...feature.properties,\n        flow_volume: feature.properties.flow_volume || 0,\n        flow_direction: feature.properties.flow_direction || 'bidirectional',\n        price_differential: feature.properties.price_differential || 0\n      }\n    };\n  } catch (error) {\n    console.error('Error processing flow feature:', error);\n    return feature;\n  }\n};\n\n/**\n * Process feature for shock visualization\n * @param {Object} feature - GeoJSON feature\n * @returns {Object} Processed feature\n */\nconst processShockFeature = (feature) => {\n  try {\n    return {\n      ...feature,\n      properties: {\n        ...feature.properties,\n        shock_magnitude: feature.properties.shock_magnitude || 0,\n        shock_type: feature.properties.shock_type || 'unknown',\n        affected_markets: feature.properties.affected_markets || []\n      }\n    };\n  } catch (error) {\n    console.error('Error processing shock feature:', error);\n    return feature;\n  }\n};\n\n/**\n * Process feature for spatial autocorrelation\n * @param {Object} feature - GeoJSON feature\n * @returns {Object} Processed feature\n */\nconst processAutocorrelationFeature = (feature) => {\n  try {\n    return {\n      ...feature,\n      properties: {\n        ...feature.properties,\n        local_i: feature.properties.local_i || 0,\n        p_value: feature.properties.p_value || 1,\n        cluster_type: feature.properties.cluster_type || 'not-significant',\n        z_score: feature.properties.z_score || 0\n      }\n    };\n  } catch (error) {\n    console.error('Error processing autocorrelation feature:', error);\n    return feature;\n  }\n};\n\n/**\n * Extract point features from GeoJSON\n * @param {Object} geojson - GeoJSON object\n * @returns {Array} Array of point features\n */\nexport const extractPointFeatures = (geojson) => {\n  if (!geojson?.features) return [];\n\n  return geojson.features.filter(feature => \n    feature.geometry?.type === 'Point'\n  ).map(feature => deepClone(feature));\n};\n\n/**\n * Extract polygon features from GeoJSON\n * @param {Object} geojson - GeoJSON object\n * @returns {Array} Array of polygon features\n */\nexport const extractPolygonFeatures = (geojson) => {\n  if (!geojson?.features) return [];\n\n  return geojson.features.filter(feature => \n    feature.geometry?.type === 'Polygon' || \n    feature.geometry?.type === 'MultiPolygon'\n  ).map(feature => deepClone(feature));\n};\n\n/**\n * Create unified GeoJSON from points and polygons\n * @param {Array} points - Point features\n * @param {Array} polygons - Polygon features\n * @returns {Object} Unified GeoJSON\n */\nexport const createUnifiedGeoJSON = (points = [], polygons = []) => {\n  return {\n    type: 'FeatureCollection',\n    features: [...points.map(deepClone), ...polygons.map(deepClone)],\n    crs: {\n      type: 'name',\n      properties: {\n        name: 'EPSG:4326'\n      }\n    }\n  };\n};\n\nexport default {\n  safeGeoJSONProcessor,\n  extractPointFeatures,\n  extractPolygonFeatures,\n  createUnifiedGeoJSON\n};\n",
        "imports": [
          "./spatialUtils"
        ],
        "exports": [
          "safeGeoJSONProcessor",
          "extractPointFeatures",
          "extractPolygonFeatures",
          "createUnifiedGeoJSON",
          "default"
        ],
        "dependencies": [
          "./spatialUtils"
        ]
      },
      {
        "path": "components/spatialAnalysis/utils/networkAnalysis.js",
        "content": "/**\n * Utility functions for network analysis and graph calculations\n */\n\nimport { calculateDistance, transformRegionName } from './spatialUtils';\n\n/**\n * Calculate network metrics for market flows\n * @param {Array} flows - Array of market flows\n * @param {Object} coordinates - Market coordinates mapping\n * @returns {Object} Network metrics\n */\nexport const calculateNetworkMetrics = (flows, coordinates) => {\n  if (!Array.isArray(flows) || !flows.length) {\n    return {\n      density: 0,\n      avgPathLength: 0,\n      clustering: 0,\n      centrality: {},\n      communities: []\n    };\n  }\n\n  try {\n    // Create adjacency matrix\n    const markets = new Set([\n      ...flows.map(f => f.source),\n      ...flows.map(f => f.target)\n    ]);\n    const marketList = Array.from(markets);\n    const n = marketList.length;\n    \n    const adjacencyMatrix = Array(n).fill().map(() => Array(n).fill(0));\n    const weightMatrix = Array(n).fill().map(() => Array(n).fill(0));\n\n    flows.forEach(flow => {\n      const sourceIdx = marketList.indexOf(flow.source);\n      const targetIdx = marketList.indexOf(flow.target);\n      if (sourceIdx >= 0 && targetIdx >= 0) {\n        adjacencyMatrix[sourceIdx][targetIdx] = 1;\n        adjacencyMatrix[targetIdx][sourceIdx] = 1; // Undirected graph\n        weightMatrix[sourceIdx][targetIdx] = flow.total_flow || 0;\n        weightMatrix[targetIdx][sourceIdx] = flow.total_flow || 0;\n      }\n    });\n\n    // Calculate metrics\n    const density = calculateNetworkDensity(adjacencyMatrix);\n    const avgPathLength = calculateAveragePathLength(adjacencyMatrix);\n    const clustering = calculateClusteringCoefficient(adjacencyMatrix);\n    const centrality = calculateCentralityMeasures(adjacencyMatrix, weightMatrix, marketList);\n    const communities = detectCommunities(adjacencyMatrix, marketList);\n\n    return {\n      density,\n      avgPathLength,\n      clustering,\n      centrality,\n      communities\n    };\n  } catch (error) {\n    console.error('Error calculating network metrics:', error);\n    return null;\n  }\n};\n\n/**\n * Calculate network density\n * @param {Array<Array<number>>} adjacencyMatrix - Network adjacency matrix\n * @returns {number} Network density\n */\nconst calculateNetworkDensity = (adjacencyMatrix) => {\n  const n = adjacencyMatrix.length;\n  if (n < 2) return 0;\n\n  const maxEdges = (n * (n - 1)) / 2;\n  const actualEdges = adjacencyMatrix.reduce((sum, row, i) => \n    sum + row.slice(i + 1).reduce((a, b) => a + b, 0), 0\n  );\n\n  return actualEdges / maxEdges;\n};\n\n/**\n * Calculate average path length using Floyd-Warshall algorithm\n * @param {Array<Array<number>>} adjacencyMatrix - Network adjacency matrix\n * @returns {number} Average path length\n */\nconst calculateAveragePathLength = (adjacencyMatrix) => {\n  const n = adjacencyMatrix.length;\n  if (n < 2) return 0;\n\n  // Initialize distance matrix\n  const dist = adjacencyMatrix.map(row => \n    row.map(val => val === 0 ? Infinity : val)\n  );\n  for (let i = 0; i < n; i++) dist[i][i] = 0;\n\n  // Floyd-Warshall algorithm\n  for (let k = 0; k < n; k++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        if (dist[i][k] !== Infinity && dist[k][j] !== Infinity) {\n          dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n  }\n\n  // Calculate average\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (dist[i][j] !== Infinity) {\n        sum += dist[i][j];\n        count++;\n      }\n    }\n  }\n\n  return count > 0 ? sum / count : 0;\n};\n\n/**\n * Calculate clustering coefficient\n * @param {Array<Array<number>>} adjacencyMatrix - Network adjacency matrix\n * @returns {number} Clustering coefficient\n */\nconst calculateClusteringCoefficient = (adjacencyMatrix) => {\n  const n = adjacencyMatrix.length;\n  if (n < 3) return 0;\n\n  let totalCoefficient = 0;\n  let validNodes = 0;\n\n  for (let i = 0; i < n; i++) {\n    const neighbors = [];\n    for (let j = 0; j < n; j++) {\n      if (adjacencyMatrix[i][j] === 1) {\n        neighbors.push(j);\n      }\n    }\n\n    if (neighbors.length < 2) continue;\n\n    let triangles = 0;\n    for (let j = 0; j < neighbors.length; j++) {\n      for (let k = j + 1; k < neighbors.length; k++) {\n        if (adjacencyMatrix[neighbors[j]][neighbors[k]] === 1) {\n          triangles++;\n        }\n      }\n    }\n\n    const maxTriangles = (neighbors.length * (neighbors.length - 1)) / 2;\n    if (maxTriangles > 0) {\n      totalCoefficient += triangles / maxTriangles;\n      validNodes++;\n    }\n  }\n\n  return validNodes > 0 ? totalCoefficient / validNodes : 0;\n};\n\n/**\n * Calculate various centrality measures\n * @param {Array<Array<number>>} adjacencyMatrix - Network adjacency matrix\n * @param {Array<Array<number>>} weightMatrix - Network weight matrix\n * @param {Array<string>} marketList - List of market names\n * @returns {Object} Centrality measures\n */\nconst calculateCentralityMeasures = (adjacencyMatrix, weightMatrix, marketList) => {\n  const n = adjacencyMatrix.length;\n  const centrality = {};\n\n  marketList.forEach((market, i) => {\n    // Degree centrality\n    const degree = adjacencyMatrix[i].reduce((a, b) => a + b, 0);\n    \n    // Weighted degree (strength)\n    const strength = weightMatrix[i].reduce((a, b) => a + b, 0);\n    \n    // Betweenness centrality (approximate)\n    const betweenness = calculateBetweennessCentrality(adjacencyMatrix, i);\n\n    centrality[market] = {\n      degree: degree / (n - 1),\n      strength: strength,\n      betweenness: betweenness\n    };\n  });\n\n  return centrality;\n};\n\n/**\n * Calculate betweenness centrality for a node\n * @param {Array<Array<number>>} adjacencyMatrix - Network adjacency matrix\n * @param {number} nodeIndex - Index of the node\n * @returns {number} Betweenness centrality\n */\nconst calculateBetweennessCentrality = (adjacencyMatrix, nodeIndex) => {\n  const n = adjacencyMatrix.length;\n  let betweenness = 0;\n\n  // For each pair of nodes\n  for (let s = 0; s < n; s++) {\n    if (s === nodeIndex) continue;\n    for (let t = s + 1; t < n; t++) {\n      if (t === nodeIndex) continue;\n\n      // Find shortest paths using BFS\n      const paths = findShortestPaths(adjacencyMatrix, s, t);\n      if (paths.length === 0) continue;\n\n      // Count paths through nodeIndex\n      const pathsThroughNode = paths.filter(path => \n        path.includes(nodeIndex)\n      ).length;\n\n      betweenness += pathsThroughNode / paths.length;\n    }\n  }\n\n  return betweenness;\n};\n\n/**\n * Find all shortest paths between two nodes using BFS\n * @param {Array<Array<number>>} adjacencyMatrix - Network adjacency matrix\n * @param {number} start - Start node index\n * @param {number} end - End node index\n * @returns {Array<Array<number>>} Array of shortest paths\n */\nconst findShortestPaths = (adjacencyMatrix, start, end) => {\n  const n = adjacencyMatrix.length;\n  const queue = [[start]];\n  const paths = [];\n  const visited = new Set();\n  let shortestLength = Infinity;\n\n  while (queue.length > 0) {\n    const path = queue.shift();\n    const node = path[path.length - 1];\n\n    if (path.length > shortestLength) break;\n\n    if (node === end) {\n      shortestLength = path.length;\n      paths.push(path);\n      continue;\n    }\n\n    for (let next = 0; next < n; next++) {\n      if (adjacencyMatrix[node][next] === 1 && !path.includes(next)) {\n        queue.push([...path, next]);\n      }\n    }\n  }\n\n  return paths;\n};\n\n/**\n * Detect communities using Louvain method\n * @param {Array<Array<number>>} adjacencyMatrix - Network adjacency matrix\n * @param {Array<string>} marketList - List of market names\n * @returns {Array<Array<string>>} Detected communities\n */\nconst detectCommunities = (adjacencyMatrix, marketList) => {\n  const n = adjacencyMatrix.length;\n  let communities = Array.from({ length: n }, (_, i) => [marketList[i]]);\n  let modularity = calculateModularity(adjacencyMatrix, communities);\n  let improved = true;\n\n  while (improved) {\n    improved = false;\n    const newCommunities = [...communities];\n\n    for (let i = 0; i < n; i++) {\n      const currentCommunity = communities.findIndex(c => \n        c.includes(marketList[i])\n      );\n      let bestModularity = modularity;\n      let bestCommunity = currentCommunity;\n\n      // Try moving node to each community\n      for (let j = 0; j < communities.length; j++) {\n        if (j === currentCommunity) continue;\n\n        // Move node\n        newCommunities[currentCommunity] = newCommunities[currentCommunity]\n          .filter(m => m !== marketList[i]);\n        newCommunities[j].push(marketList[i]);\n\n        const newModularity = calculateModularity(adjacencyMatrix, newCommunities);\n        if (newModularity > bestModularity) {\n          bestModularity = newModularity;\n          bestCommunity = j;\n          improved = true;\n        }\n\n        // Move node back\n        newCommunities[j] = newCommunities[j]\n          .filter(m => m !== marketList[i]);\n        newCommunities[currentCommunity].push(marketList[i]);\n      }\n\n      // Apply best move\n      if (bestCommunity !== currentCommunity) {\n        newCommunities[currentCommunity] = newCommunities[currentCommunity]\n          .filter(m => m !== marketList[i]);\n        newCommunities[bestCommunity].push(marketList[i]);\n        modularity = bestModularity;\n      }\n    }\n\n    communities = newCommunities.filter(c => c.length > 0);\n  }\n\n  return communities;\n};\n\n/**\n * Calculate modularity of a network partition\n * @param {Array<Array<number>>} adjacencyMatrix - Network adjacency matrix\n * @param {Array<Array<string>>} communities - Network partition\n * @returns {number} Modularity value\n */\nconst calculateModularity = (adjacencyMatrix, communities) => {\n  const n = adjacencyMatrix.length;\n  const m = adjacencyMatrix.reduce((sum, row, i) => \n    sum + row.slice(i + 1).reduce((a, b) => a + b, 0), 0\n  );\n  if (m === 0) return 0;\n\n  let modularity = 0;\n  for (const community of communities) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        if (community.includes(i) && community.includes(j)) {\n          const ki = adjacencyMatrix[i].reduce((a, b) => a + b, 0);\n          const kj = adjacencyMatrix[j].reduce((a, b) => a + b, 0);\n          modularity += adjacencyMatrix[i][j] - (ki * kj) / (2 * m);\n        }\n      }\n    }\n  }\n\n  return modularity / (2 * m);\n};\n\nexport default {\n  calculateNetworkMetrics,\n  calculateNetworkDensity,\n  calculateAveragePathLength,\n  calculateClusteringCoefficient,\n  calculateCentralityMeasures,\n  detectCommunities\n};\n",
        "imports": [
          "./spatialUtils"
        ],
        "exports": [
          "calculateNetworkMetrics",
          "default"
        ],
        "dependencies": [
          "./spatialUtils"
        ]
      },
      {
        "path": "components/spatialAnalysis/utils/spatialUtils.js",
        "content": "/**\n * Utility functions for spatial analysis and data transformations\n */\n\n// Yemen coordinates mapping - verified coordinates\nexport const YEMEN_COORDINATES = {\n  'abyan': [45.83, 13.58],\n  'aden': [45.03, 12.77],\n  'al bayda': [45.57, 14.17],\n  'al dhale\\'e': [44.73, 13.70],\n  'al hudaydah': [42.95, 14.80],\n  'al jawf': [45.50, 16.60],\n  'al maharah': [51.83, 16.52],\n  'al mahwit': [43.55, 15.47],\n  'amanat al asimah': [44.21, 15.35],\n  'amran': [43.94, 15.66],\n  'dhamar': [44.24, 14.54],\n  'hadramaut': [48.78, 15.93],\n  'hajjah': [43.60, 15.63],\n  'ibb': [44.18, 13.97],\n  'lahj': [44.88, 13.03],\n  'marib': [45.32, 15.47],\n  'raymah': [43.71, 14.68],\n  'sana\\'a': [44.21, 15.35],\n  'shabwah': [47.01, 14.53],\n  'taizz': [44.02, 13.58],\n  'socotra': [53.87, 12.47]\n};\n\n/**\n * Transform and normalize region names\n * @param {string} name - Region name to transform\n * @returns {string} Normalized region name\n */\nexport const transformRegionName = (name) => {\n  if (!name) return '';\n\n  // Special cases mapping for Yemen regions\n  const specialCases = {\n    \"'adan governorate\": \"aden\",\n    \"'adan\": \"aden\",\n    \"ʿadan\": \"aden\",\n    \"ad dali' governorate\": \"al dhale'e\",\n    \"ad dali'\": \"al dhale'e\",\n    \"ad dali\": \"al dhale'e\",\n    \"al dhale\": \"al dhale'e\",\n    \"al dhale'\": \"al dhale'e\",\n    \"sa'dah governorate\": \"saada\",\n    \"sa'dah\": \"saada\",\n    \"sadah\": \"saada\",\n    \"sa'ada\": \"saada\",\n    \"al mahrah governorate\": \"al maharah\",\n    \"al mahrah\": \"al maharah\",\n    \"al mahra\": \"al maharah\",\n    \"mahrah governorate\": \"al maharah\",\n    \"ma'rib governorate\": \"marib\",\n    \"ma'rib\": \"marib\",\n    \"mareb\": \"marib\",\n    \"socotra governorate\": \"socotra\",\n    \"soqatra\": \"socotra\",\n    \"sanʿaʾ governorate\": \"sana'a\",\n    \"san'a'\": \"sana'a\",\n    \"sana'a\": \"sana'a\",\n    \"sanaa governorate\": \"sana'a\",\n    \"ta'izz\": \"taizz\",\n    \"ta'izz governorate\": \"taizz\",\n    \"taiz\": \"taizz\"\n  };\n\n  const cleaned = name.toLowerCase()\n    .trim()\n    .replace(/\\s+/g, ' ')\n    .replace(/ governorate$/i, '')\n    .replace(/ʿ/g, \"'\")\n    .replace(/['']/g, \"'\")\n    .trim();\n\n  return specialCases[cleaned] || cleaned;\n};\n\n/**\n * Get coordinates for a region\n * @param {string} name - Region name\n * @returns {[number, number]|null} Coordinates [longitude, latitude] or null\n */\nexport const getRegionCoordinates = (name) => {\n  if (!name) return null;\n  const normalizedName = transformRegionName(name);\n  return YEMEN_COORDINATES[normalizedName] || null;\n};\n\n/**\n * Calculate geographical distance between two points using Haversine formula\n * @param {[number, number]} coord1 - [longitude, latitude] of first point\n * @param {[number, number]} coord2 - [longitude, latitude] of second point\n * @returns {number} Distance in kilometers\n */\nexport const calculateDistance = (coord1, coord2) => {\n  if (!coord1 || !coord2 || !Array.isArray(coord1) || !Array.isArray(coord2) ||\n      coord1.length !== 2 || coord2.length !== 2) {\n    return 0;\n  }\n  \n  const [lon1, lat1] = coord1;\n  const [lon2, lat2] = coord2;\n  \n  const R = 6371; // Earth's radius in kilometers\n  const toRad = (deg) => deg * Math.PI / 180;\n  \n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  \n  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n           Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * \n           Math.sin(dLon/2) * Math.sin(dLon/2);\n           \n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  return R * c;\n};\n\n/**\n * Calculate center point for a set of coordinates\n * @param {Array<[number, number]>} coordinates - Array of [longitude, latitude] coordinates\n * @returns {[number, number]|null} Center coordinates [longitude, latitude] or null\n */\nexport const calculateCenter = (coordinates) => {\n  if (!Array.isArray(coordinates) || !coordinates.length) return null;\n\n  const validCoords = coordinates.filter(coord => \n    Array.isArray(coord) && \n    coord.length === 2 &&\n    typeof coord[0] === 'number' && \n    typeof coord[1] === 'number' &&\n    !isNaN(coord[0]) && \n    !isNaN(coord[1])\n  );\n\n  if (!validCoords.length) return null;\n\n  const sum = validCoords.reduce(\n    (acc, coord) => [acc[0] + coord[0], acc[1] + coord[1]], \n    [0, 0]\n  );\n\n  return [\n    sum[0] / validCoords.length,\n    sum[1] / validCoords.length\n  ];\n};\n\n/**\n * Create spatial weights matrix based on distance threshold\n * @param {Array<[number, number]>} points - Array of [longitude, latitude] coordinates\n * @param {number} threshold - Distance threshold in kilometers\n * @returns {Array<Array<number>>} Row-standardized weights matrix\n */\nexport const createWeightsMatrix = (points, threshold = 100) => {\n  if (!Array.isArray(points) || !points.length) return [];\n\n  const n = points.length;\n  const weights = Array(n).fill().map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i !== j) {\n        const dist = calculateDistance(points[i], points[j]);\n        weights[i][j] = dist <= threshold ? 1 : 0;\n      }\n    }\n  }\n\n  // Row standardize\n  for (let i = 0; i < n; i++) {\n    const rowSum = weights[i].reduce((a, b) => a + b, 0);\n    if (rowSum > 0) {\n      weights[i] = weights[i].map(w => w / rowSum);\n    }\n  }\n\n  return weights;\n};\n\n/**\n * Calculate bounding box for a set of coordinates\n * @param {Array<[number, number]>} coordinates - Array of [longitude, latitude] coordinates\n * @returns {Object|null} Bounding box object or null\n */\nexport const calculateBoundingBox = (coordinates) => {\n  if (!Array.isArray(coordinates) || !coordinates.length) return null;\n\n  return coordinates.reduce((bounds, coord) => ({\n    minLon: Math.min(bounds.minLon, coord[0]),\n    maxLon: Math.max(bounds.maxLon, coord[0]),\n    minLat: Math.min(bounds.minLat, coord[1]),\n    maxLat: Math.max(bounds.maxLat, coord[1])\n  }), {\n    minLon: Infinity,\n    maxLon: -Infinity,\n    minLat: Infinity,\n    maxLat: -Infinity\n  });\n};\n\n/**\n * Convert UTM coordinates to latitude/longitude\n * @param {number} easting - UTM easting coordinate\n * @param {number} northing - UTM northing coordinate\n * @returns {[number, number]} [longitude, latitude] coordinates\n */\nexport const convertUTMtoLatLng = (easting, northing) => {\n  const k0 = 0.9996;\n  const a = 6378137;\n  const e = 0.081819191;\n  const e1sq = 0.006739497;\n  const falseEasting = 500000;\n  const zone = 38; // Yemen is primarily in UTM zone 38\n\n  const x = easting - falseEasting;\n  const y = northing;\n\n  const M = y / k0;\n  const mu = M / (a * (1 - e * e / 4 - 3 * e * e * e * e / 64));\n\n  const phi1 = mu + (3 * e1sq / 2 - 27 * Math.pow(e1sq, 3) / 32) * Math.sin(2 * mu);\n  const phi2 = phi1 + (21 * Math.pow(e1sq, 2) / 16 - 55 * Math.pow(e1sq, 4) / 32) * Math.sin(4 * mu);\n  const phi = phi2 + (151 * Math.pow(e1sq, 3) / 96) * Math.sin(6 * mu);\n\n  const N1 = a / Math.sqrt(1 - e * e * Math.sin(phi) * Math.sin(phi));\n  const T1 = Math.tan(phi) * Math.tan(phi);\n  const C1 = (e * e * Math.cos(phi) * Math.cos(phi)) / (1 - e * e);\n  const R1 = (a * (1 - e * e)) / Math.pow(1 - e * e * Math.sin(phi) * Math.sin(phi), 1.5);\n  const D = x / (N1 * k0);\n\n  const lat = phi - (N1 * Math.tan(phi) / R1) * (\n    (D * D) / 2 -\n    (5 + 3 * T1 + 10 * C1 - 4 * Math.pow(C1, 2) - 9 * e * e) * Math.pow(D, 4) / 24 +\n    (61 + 90 * T1 + 298 * C1 + 45 * Math.pow(T1, 2) - 252 * e * e - 3 * Math.pow(C1, 2)) * Math.pow(D, 6) / 720\n  );\n  const lon = ((zone * 6 - 183) + (D - (1 + 2 * T1 + C1) * Math.pow(D, 3) / 6 +\n    (5 - 2 * C1 + 28 * T1 - 3 * Math.pow(C1, 2) + 8 * e * e + 24 * Math.pow(T1, 2)) * Math.pow(D, 5) / 120)\n  ) / Math.cos(phi) * (180 / Math.PI);\n\n  return [lon, lat * (180 / Math.PI)];\n};\n\nexport default {\n  YEMEN_COORDINATES,\n  transformRegionName,\n  getRegionCoordinates,\n  calculateDistance,\n  calculateCenter,\n  createWeightsMatrix,\n  calculateBoundingBox,\n  convertUTMtoLatLng\n};\n",
        "imports": [],
        "exports": [
          "YEMEN_COORDINATES",
          "transformRegionName",
          "getRegionCoordinates",
          "calculateDistance",
          "calculateCenter",
          "createWeightsMatrix",
          "calculateBoundingBox",
          "convertUTMtoLatLng",
          "default"
        ],
        "dependencies": []
      },
      {
        "path": "components/utils/StateExporter.js",
        "content": "import React from 'react';\nimport { useSelector } from 'react-redux';\nimport { Fab, Tooltip } from '@mui/material';\nimport DownloadIcon from '@mui/icons-material/Download';\n\nconst StateExporter = () => {\n  const entireState = useSelector(state => state);\n\n  const exportState = () => {\n    // Create a sample of the state by taking a subset or first few items\n    const sampleState = {};\n    \n    // For each top level reducer, take a small sample\n    Object.entries(entireState).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        // If it's an array, take first 2 items\n        sampleState[key] = value.slice(0, 2);\n      } else if (typeof value === 'object' && value !== null) {\n        // If it's an object, take first 2 key-value pairs\n        const entries = Object.entries(value);\n        sampleState[key] = Object.fromEntries(entries.slice(0, 2));\n      } else {\n        // For primitive values, include as is\n        sampleState[key] = value;\n      }\n    });\n\n    // Create downloadable file\n    const dataStr = JSON.stringify(sampleState, null, 2);\n    const dataBlob = new Blob([dataStr], { type: 'application/json' });\n    const url = URL.createObjectURL(dataBlob);\n    const link = document.createElement('a');\n    link.download = 'redux-state-sample.json';\n    link.href = url;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  };\n\n  return (\n    <Tooltip title=\"Export Sample State\" placement=\"left\">\n      <Fab\n        color=\"primary\"\n        onClick={exportState}\n        sx={{\n          position: 'fixed',\n          bottom: '20px',\n          right: '20px',\n          zIndex: 1000\n        }}\n      >\n        <DownloadIcon />\n      </Fab>\n    </Tooltip>\n  );\n};\n\nexport default StateExporter;\n",
        "imports": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/icons-material/Download"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "@mui/material",
          "@mui/icons-material/Download"
        ]
      },
      {
        "path": "config/appConfig.js",
        "content": "// src/config/appConfig.js\n\nconst isDev = process.env.NODE_ENV === 'development';\nconst isGitHubPages = window.location.hostname.includes('github.io');\nconst repoName = '/Yemen_Market_Analysis'; // Add your repository name\n\nexport const config = {\n  // Set baseUrl based on environment\n  baseUrl: isGitHubPages ? repoName : '',\n  \n  // API paths with baseUrl\n  api: {\n    data: isGitHubPages ? `${repoName}/results` : '/results',\n    assets: isGitHubPages ? `${repoName}/static` : '/static',\n  },\n\n  // Map configuration\n  map: {\n    tileLayer: {\n      url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n      attribution: '© OpenStreetMap contributors',\n      options: {\n        crossOrigin: true,\n        maxZoom: 18,\n      }\n    },\n    defaultView: {\n      center: [15.5527, 48.5164],\n      zoom: 6\n    }\n  },\n\n  // CORS settings\n  cors: {\n    credentials: 'same-origin',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n    }\n  },\n\n  // Service Worker - disable for GitHub Pages\n  serviceWorker: {\n    enabled: !isDev && !isGitHubPages, // Disable for GitHub Pages\n    path: '/spatialServiceWorker.js',\n    scope: '/',\n  }\n};\n\n// Helper function to get full URL\nexport const getFullPath = (path) => {\n  return `${config.baseUrl}${path}`;\n};",
        "imports": [],
        "exports": [
          "config",
          "getFullPath"
        ],
        "dependencies": []
      },
      {
        "path": "constants/index.js",
        "content": "// src/constants/index.js\n\n// src/constants/index.js\n\nexport const VISUALIZATION_MODES = {\n  PRICES: 'prices',\n  INTEGRATION: 'integration',\n  CLUSTERS: 'clusters',\n  SHOCKS: 'shocks',\n};\n\nexport const MAP_SETTINGS = {\n  DEFAULT_CENTER: [15.3694, 44.191],\n  DEFAULT_ZOOM: 6,\n  TILE_LAYER: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n  ATTRIBUTION: '© OpenStreetMap contributors',\n};\n\nexport const COLOR_SCALES = {\n  PRICES: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15'],\n  INTEGRATION: ['#edf8e9', '#bae4b3', '#74c476', '#31a354', '#006d2c'],\n  SHOCKS: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a'],\n};\n\nexport const DEFAULT_GEOJSON = {\n  type: 'FeatureCollection',\n  features: [],\n  crs: {\n    type: 'name',\n    properties: {\n      name: 'urn:ogc:def:crs:OGC:1.3:CRS84'\n    }\n  }\n};\n\nexport const DEFAULT_VIEW = {\n  center: [15.3694, 44.191],\n  zoom: 6\n};\n  \n  \n  export const ANALYSIS_THRESHOLDS = {\n    PRICE_SHOCK: {\n      MILD: 0.15,    // 15% change\n      MODERATE: 0.25, // 25% change\n      SEVERE: 0.40    // 40% change\n    },\n    MARKET_INTEGRATION: {\n      LOW: 0.2,      // Moran's I thresholds\n      MODERATE: 0.4,\n      HIGH: 0.6\n    },\n    VOLATILITY: {\n      LOW: 0.1,      // Coefficient of variation thresholds\n      MODERATE: 0.2,\n      HIGH: 0.3\n    },\n    CLUSTER_SIZE: {\n      MIN: 2,        // Minimum markets for valid cluster\n      OPTIMAL: 5     // Optimal cluster size\n    },\n    SIGNIFICANCE: {\n      P_VALUE: 0.05  // Statistical significance threshold\n    }\n  };\n  \n  \n  export const MARKET_TYPES = {\n    HUB: 'hub',\n    PERIPHERAL: 'peripheral',\n    ISOLATED: 'isolated'\n  };\n  \n  export const TIME_RANGES = {\n    SHORT: 3,  // 3 months\n    MEDIUM: 6, // 6 months\n    LONG: 12   // 12 months\n  };\n  \n  export const COMMODITIES = {\n    FOOD: [\n      'beans_kidney_red',\n      'beans_white',\n      'wheat_flour',\n      'rice_imported',\n      'sugar',\n      'oil_vegetable'\n    ],\n    FUEL: [\n      'fuel_diesel',\n      'fuel_petrol-gasoline',\n      'fuel_gas'\n    ],\n    LABOR: [\n      'wage_qualified_labour',\n      'wage_non-qualified_labour'\n    ]\n  };\n  \n  export const DATA_FIELDS = {\n    REQUIRED: [\n      'time_series_data',\n      'market_shocks',\n      'market_clusters',\n      'flow_analysis',\n      'spatial_autocorrelation'\n    ],\n    OPTIONAL: [\n      'metadata',\n      'analysis_notes'\n    ]\n  };",
        "imports": [],
        "exports": [
          "VISUALIZATION_MODES",
          "MAP_SETTINGS",
          "COLOR_SCALES",
          "DEFAULT_GEOJSON",
          "DEFAULT_VIEW",
          "ANALYSIS_THRESHOLDS",
          "MARKET_TYPES",
          "TIME_RANGES",
          "COMMODITIES",
          "DATA_FIELDS"
        ],
        "dependencies": []
      },
      {
        "path": "context/DataContext.js",
        "content": "// src/contexts/DataContext.js\n\nimport React, { createContext, useState } from 'react';\nimport PropTypes from 'prop-types';\n\nexport const DataContext = createContext();\n\nexport const DataProvider = ({ children }) => {\n  const [selectedCommodity, setSelectedCommodity] = useState('Wheat');\n\n  return (\n    <DataContext.Provider value={{ selectedCommodity, setSelectedCommodity }}>\n      {children}\n    </DataContext.Provider>\n  );\n};\n\nDataProvider.propTypes = {\n  children: PropTypes.node.isRequired,\n};\n",
        "imports": [
          "react",
          "prop-types"
        ],
        "exports": [
          "DataContext",
          "DataProvider"
        ],
        "dependencies": [
          "react",
          "prop-types"
        ]
      },
      {
        "path": "context/SpatialDataContext.js",
        "content": "// src/context/SpatialDataContext.js\n\nimport React, { createContext, useContext } from 'react';\nimport PropTypes from 'prop-types';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { \n fetchAllSpatialData,\n fetchFlowData,\n selectSpatialData,\n selectFlowData, \n selectLoadingStatus,\n selectError\n} from '../slices/spatialSlice';\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\n\nconst SpatialDataContext = createContext(null);\n\nexport const SpatialDataProvider = ({ children }) => {\n const dispatch = useDispatch();\n const data = useSelector(selectSpatialData);\n const flowData = useSelector(selectFlowData);\n const loading = useSelector(selectLoadingStatus);\n const error = useSelector(selectError);\n\n const fetchData = React.useCallback(async (commodity, date) => {\n   const metric = backgroundMonitor.startMetric('spatial-data-fetch');\n   try {\n     await Promise.all([\n       dispatch(fetchAllSpatialData({ commodity, date })),\n       dispatch(fetchFlowData({ commodity, date }))\n     ]);\n     metric.finish({ status: 'success' });\n   } catch (err) {\n     metric.finish({ status: 'error', error: err.message });\n   }\n }, [dispatch]);\n\n const value = React.useMemo(() => ({\n   data,\n   flowData,\n   loading,\n   error,\n   fetchData\n }), [data, flowData, loading, error, fetchData]);\n\n return (\n   <SpatialDataContext.Provider value={value}>\n     {children}\n   </SpatialDataContext.Provider>\n );\n};\n\nSpatialDataProvider.propTypes = {\n children: PropTypes.node.isRequired,\n};\n\nexport const useSpatialData = () => {\n const context = useContext(SpatialDataContext);\n if (!context) {\n   throw new Error('useSpatialData must be used within a SpatialDataProvider');\n }\n return context;\n};\n\n",
        "imports": [
          "react",
          "prop-types",
          "react-redux",
          "../slices/spatialSlice",
          "../utils/backgroundMonitor"
        ],
        "exports": [
          "SpatialDataProvider",
          "useSpatialData"
        ],
        "dependencies": [
          "react",
          "prop-types",
          "react-redux",
          "../slices/spatialSlice",
          "../utils/backgroundMonitor"
        ]
      },
      {
        "path": "context/WorkerContext.js",
        "content": "// src/context/WorkerContext.js\n\nimport React, { createContext, useContext } from 'react';\nimport { useWorkerProcessor } from '@/hooks';;\n\nconst WorkerContext = createContext(null);\n\nexport const WorkerProvider = ({ children }) => {\n  const workerProcessor = useWorkerProcessor();\n  \n  return (\n    <WorkerContext.Provider value={workerProcessor}>\n      {children}\n    </WorkerContext.Provider>\n  );\n};\n\nexport const useWorker = () => {\n  const context = useContext(WorkerContext);\n  if (!context) {\n    throw new Error('useWorker must be used within a WorkerProvider');\n  }\n  return context;\n};",
        "imports": [
          "react",
          "@/hooks"
        ],
        "exports": [
          "WorkerProvider",
          "useWorker"
        ],
        "dependencies": [
          "react",
          "@/hooks"
        ]
      },
      {
        "path": "hooks/dataHooks.js",
        "content": "// Merged dataHooks.js\n\nimport { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { \n  fetchAllSpatialData, \n  fetchFlowData,\n  selectSpatialData,\n  selectFlowData,\n  selectLoadingStatus as selectSpatialLoadingStatus,\n  selectError as selectSpatialError,\n  selectRegressionAnalysis,\n  selectModelStats,\n  selectSpatialStats\n} from '../slices/spatialSlice';\nimport {\n  fetchECMData,\n  selectUnifiedData,\n  selectDirectionalData,\n  selectLoadingStatus,\n  selectError,\n  selectECMMetrics,\n  setSelectedCommodity\n} from '../slices/ecmSlice';\nimport { DEFAULT_REGRESSION_DATA } from '../types/dataTypes';\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\nimport { getDataPath, enhancedFetchJson } from '../utils/dataUtils';\nimport { dataCache } from '../utils/dataCache';\n\nexport const useSpatialData = () => {\n  const dispatch = useDispatch();\n  const data = useSelector(selectSpatialData);\n  const flowData = useSelector(selectFlowData);\n  const loading = useSelector(selectSpatialLoadingStatus);\n  const error = useSelector(selectSpatialError);\n \n  const fetchData = useCallback(async (commodity, date) => {\n    const metric = backgroundMonitor.startMetric('spatial-data-fetch');\n    try {\n      await Promise.all([\n        dispatch(fetchAllSpatialData({ commodity, date })),\n        dispatch(fetchFlowData({ commodity, date }))\n      ]);\n      metric.finish({ status: 'success' });\n    } catch (err) {\n      metric.finish({ status: 'error', error: err.message });\n      console.error('Error fetching spatial data:', err);\n    }\n  }, [dispatch]);\n \n  return { data, flowData, loading, error, fetchData };\n};\n\nexport const usePrecomputedData = (commodity, date, options = {}) => {\n  const dispatch = useDispatch();\n  const abortControllerRef = useRef(null);\n  const loadingMetricRef = useRef(null);\n\n  const loadData = useCallback(async () => {\n    if (!commodity || !date) return;\n\n    // Cancel any ongoing requests\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n\n    // Create new abort controller\n    abortControllerRef.current = new AbortController();\n\n    // Start loading metric\n    loadingMetricRef.current = backgroundMonitor.startMetric('data-load', {\n      commodity,\n      date\n    });\n\n    try {\n      // Check cache first\n      const cachedData = dataCache.get(commodity, date);\n      if (cachedData) {\n        dispatch({ type: 'data/loaded', payload: cachedData });\n        loadingMetricRef.current?.finish({ status: 'cache-hit' });\n        return;\n      }\n\n      // Load essential data first\n      const essentialData = await loadEssentialData(commodity, date, \n        abortControllerRef.current.signal);\n      dispatch({ type: 'data/essentialLoaded', payload: essentialData });\n\n      // Load visualization and analysis data in parallel\n      const [visualData, analysisData] = await Promise.all([\n        loadVisualizationData(commodity, date, abortControllerRef.current.signal),\n        loadAnalysisData(commodity, date, abortControllerRef.current.signal)\n      ]);\n\n      dispatch({ \n        type: 'data/loaded', \n        payload: { ...essentialData, ...visualData, ...analysisData }\n      });\n\n      // Cache the complete data\n      dataCache.set(commodity, date, {\n        ...essentialData,\n        ...visualData,\n        ...analysisData\n      });\n\n      loadingMetricRef.current?.finish({ status: 'success' });\n\n    } catch (error) {\n      if (error.name !== 'AbortError') {\n        console.error('Data loading failed:', error);\n        loadingMetricRef.current?.finish({ \n          status: 'error',\n          error: error.message \n        });\n      }\n    }\n  }, [commodity, date, dispatch]);\n\n  useEffect(() => {\n    loadData();\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [loadData]);\n};\n\n\nexport const useTVMIIData = () => {\n  const [tvmiiData, setTvmiiData] = useState(null);\n  const [marketPairsData, setMarketPairsData] = useState(null);\n  const [status, setStatus] = useState('idle');\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setStatus('loading');\n\n      try {\n        const tvmiiPath = getDataPath('tv_mii_results.json');\n        const marketPairsPath = getDataPath('tv_mii_market_results.json');\n\n        const [tvmiiResponse, marketPairsResponse] = await Promise.all([\n          fetch(tvmiiPath),\n          fetch(marketPairsPath),\n        ]);\n\n        if (!tvmiiResponse.ok)\n          throw new Error(`HTTP error! status: ${tvmiiResponse.status}`);\n        if (!marketPairsResponse.ok)\n          throw new Error(`HTTP error! status: ${marketPairsResponse.status}`);\n\n        const fetchedTvmiiData = await tvmiiResponse.json();\n        const fetchedMarketPairsData = await marketPairsResponse.json();\n\n        const processedTvmiiData = fetchedTvmiiData.map((item) => ({\n          ...item,\n          date: new Date(item.date),\n          tvmii: item.tv_mii || item.tvmii || item.value,\n        }));\n\n        const processedMarketPairsData = fetchedMarketPairsData.map((item) => ({\n          ...item,\n          date: new Date(item.date),\n          tvmii: item.tv_mii || item.tvmii || item.value,\n        }));\n\n        setTvmiiData(processedTvmiiData);\n        setMarketPairsData(processedMarketPairsData);\n        setStatus('succeeded');\n      } catch (err) {\n        setError(err.message);\n        setStatus('failed');\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return { tvmiiData, marketPairsData, status, error };\n};\n\nexport const usePriceDifferentialData = (selectedCommodity) => {\n  const [data, setData] = useState([]);\n  const [markets, setMarkets] = useState([]);\n  const [commodities, setCommodities] = useState([]);\n  const [status, setStatus] = useState('idle');\n  const [error, setError] = useState(null);\n\n  const processPriceDifferentialData = useCallback((jsonData, commodity) => {\n    const marketsData = jsonData.markets || {};\n    const results = [];\n\n    for (const baseMarket in marketsData) {\n      const commodityResults = marketsData[baseMarket].commodity_results || {};\n      const marketCommodityResults = commodityResults[commodity];\n\n      if (marketCommodityResults) {\n        marketCommodityResults.forEach((result) => {\n          // Include only necessary fields or all fields as needed\n          results.push(result);\n        });\n      }\n    }\n\n    return results;\n  }, []);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setStatus('loading');\n      try {\n        const path = getDataPath('price_diff_results/price_differential_results.json');\n        const response = await fetch(path);\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n\n        const jsonData = await response.json();\n\n        // Collect commodities\n        const commoditiesSet = new Set();\n        Object.values(jsonData.markets || {}).forEach((marketData) => {\n          const commodityResults = marketData.commodity_results || {};\n          Object.keys(commodityResults).forEach((commodity) => {\n            commoditiesSet.add(commodity);\n          });\n        });\n        setCommodities(Array.from(commoditiesSet));\n\n        // Process data for selected commodity\n        if (selectedCommodity) {\n          const results = processPriceDifferentialData(jsonData, selectedCommodity);\n          setData(results);\n\n          // Collect markets involved\n          const marketsSet = new Set();\n          results.forEach((result) => {\n            marketsSet.add(result.base_market);\n            marketsSet.add(result.other_market);\n          });\n          setMarkets(Array.from(marketsSet));\n        } else {\n          setData([]);\n          setMarkets([]);\n        }\n\n        setStatus('succeeded');\n      } catch (err) {\n        setError(err.message);\n        setStatus('failed');\n      }\n    };\n\n    fetchData();\n  }, [selectedCommodity, processPriceDifferentialData]);\n\n  return { data, markets, commodities, status, error };\n};\n\nexport const useECMData = (selectedCommodity) => {\n  const dispatch = useDispatch();\n  const unifiedData = useSelector(selectUnifiedData);\n  const directionalData = useSelector(selectDirectionalData);\n  const loading = useSelector(selectLoadingStatus);\n  const error = useSelector(selectError);\n  const metrics = useSelector(selectECMMetrics);\n\n  const fetchInProgress = useRef(false);\n  const initialFetch = useRef(false);\n\n  // Set selected commodity in Redux state\n  useEffect(() => {\n    if (selectedCommodity) {\n      dispatch(setSelectedCommodity(selectedCommodity));\n    }\n  }, [selectedCommodity, dispatch]);\n\n  // Handle initial data fetch\n  useEffect(() => {\n    if (fetchInProgress.current || initialFetch.current || !selectedCommodity) return;\n\n    const fetchAllData = async () => {\n      fetchInProgress.current = true;\n      try {\n        await dispatch(fetchECMData({ commodity: selectedCommodity })).unwrap();\n        initialFetch.current = true;\n      } catch (err) {\n        console.error('Error fetching ECM data:', err);\n      } finally {\n        fetchInProgress.current = false;\n      }\n    };\n\n    fetchAllData();\n  }, [dispatch, selectedCommodity]);\n\n  // Filter and process data\n  const filteredData = useMemo(() => {\n    if (!selectedCommodity) return null;\n\n    const commodityLower = selectedCommodity.toLowerCase();\n\n    const unifiedFiltered = unifiedData.filter(item => \n      item.commodity?.toLowerCase() === commodityLower\n    );\n\n    const northToSouthFiltered = directionalData.northToSouth.filter(item => \n      item.commodity?.toLowerCase() === commodityLower\n    );\n\n    const southToNorthFiltered = directionalData.southToNorth.filter(item => \n      item.commodity?.toLowerCase() === commodityLower\n    );\n\n    return {\n      unified: unifiedFiltered[0] || null,\n      directional: {\n        northToSouth: northToSouthFiltered[0] || null,\n        southToNorth: southToNorthFiltered[0] || null\n      }\n    };\n  }, [selectedCommodity, unifiedData, directionalData]);\n\n  const loadingStatus = !initialFetch.current ? 'idle' : loading ? 'loading' : error ? 'failed' : 'succeeded';\n\n  return {\n    // Return single matching records instead of arrays\n    unifiedData: filteredData?.unified || null,\n    unifiedStatus: loadingStatus,\n    unifiedError: error,\n    directionalData: filteredData?.directional || { northToSouth: null, southToNorth: null },\n    directionalStatus: loadingStatus,\n    directionalError: error,\n    metrics: selectedCommodity ? metrics : null,\n    isLoading: loading,\n    isInitialized: initialFetch.current\n  };\n};\n\nexport const useData = () => {\n  const spatialData = useSpatialData();\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n \n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        await spatialData.fetchData();\n        setLoading(false);\n      } catch (err) {\n        console.error('Error in useData:', err);\n        setError(err.message);\n        setLoading(false);\n      }\n    };\n \n    fetchData();\n  }, [spatialData]);\n \n  return { \n    data: spatialData.data, \n    loading: loading || spatialData.loading, \n    error: error || spatialData.error \n  };\n};\n\nexport const useRegressionAnalysis = (selectedCommodity) => {\n  const dispatch = useDispatch();\n  const regressionData = useSelector(state => state.spatial.data.regressionAnalysis) || DEFAULT_REGRESSION_DATA;\n  const isLoading = useSelector(state => state.spatial.status.regressionLoading);\n  const error = useSelector(state => state.spatial.status.regressionError);\n \n  useEffect(() => {\n    if (selectedCommodity) {\n      dispatch(fetchAllSpatialData({ \n        commodity: selectedCommodity, \n        regressionOnly: true \n      }));\n    }\n  }, [selectedCommodity, dispatch]);\n \n  const getResidualsForRegion = useCallback((regionId) => \n    regressionData.residuals?.byRegion?.[regionId] || [], \n    [regressionData]\n  );\n \n  const getModelFitStatistics = useCallback(() => ({\n    r_squared: regressionData.model?.r_squared || 0,\n    adj_r_squared: regressionData.model?.adj_r_squared || 0,\n    mse: regressionData.model?.mse || 0,\n    observations: regressionData.model?.observations || 0\n  }), [regressionData]);\n \n  const getSpatialStatistics = useCallback(() => ({\n    moran_i: regressionData.spatial?.moran_i || { I: 0, 'p-value': 1 },\n    vif: regressionData.spatial?.vif || []\n  }), [regressionData]);\n \n  return {\n    data: regressionData,\n    isLoading,\n    error,\n    utils: {\n      getResidualsForRegion,\n      getModelFitStatistics,\n      getSpatialStatistics\n    }\n  };\n};\n",
        "imports": [
          "react",
          "react-redux",
          "../slices/spatialSlice",
          "../slices/ecmSlice",
          "../types/dataTypes",
          "../utils/backgroundMonitor",
          "../utils/dataUtils",
          "../utils/dataCache"
        ],
        "exports": [
          "useSpatialData",
          "usePrecomputedData",
          "useTVMIIData",
          "usePriceDifferentialData",
          "useECMData",
          "useData",
          "useRegressionAnalysis"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../slices/spatialSlice",
          "../slices/ecmSlice",
          "../types/dataTypes",
          "../utils/backgroundMonitor",
          "../utils/dataUtils",
          "../utils/dataCache"
        ]
      },
      {
        "path": "hooks/index.js",
        "content": "import {\n  useData,\n  useECMData,\n  usePriceDifferentialData,\n  useTVMIIData,\n  useRegressionAnalysis\n} from './dataHooks';\n\nimport {\n  useWindowSize,\n  useBodyScrollLock,\n  useTechnicalHelp,\n  useWorkerProcessor\n} from './uiHooks';\n\n// Export all hooks\nexport {\n  // Data Analysis\n  useData,\n  useECMData,\n  usePriceDifferentialData,\n  useTVMIIData,\n  useRegressionAnalysis,\n\n  // UI & Utility\n  useWindowSize,\n  useBodyScrollLock,\n  useTechnicalHelp,\n  useWorkerProcessor,\n};\n",
        "imports": [
          "./dataHooks",
          "./uiHooks"
        ],
        "exports": [],
        "dependencies": [
          "./dataHooks",
          "./uiHooks"
        ]
      },
      {
        "path": "hooks/uiHooks.js",
        "content": "//src/hooks/uiHooks.js\n\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getMethodologyInfo, getMethodologySection } from '../utils/appUtils';\n\n/**\n * Custom hook to handle processing tasks using a Web Worker.\n */\nconst useWorkerProcessor = () => {\n  const workerRef = useRef(null);\n  const taskCallbacksRef = useRef(new Map());\n  \n  const [workerStatus, setWorkerStatus] = useState({\n    isActive: false,\n    currentTask: null,\n    progress: 0,\n  });\n\n  // Initialize the Web Worker\n  useEffect(() => {\n    // Define the worker's code as a string\n    const workerCode = `\n      self.onmessage = (event) => {\n        const { type, data, taskId } = event.data;\n        \n        try {\n          let result;\n          switch (type) {\n            case 'PROCESS_GEOJSON':\n              result = processGeoJSON(data);\n              break;\n            case 'PROCESS_FLOW_DATA':\n              result = processFlowData(data);\n              break;\n            case 'GENERATE_CSV':\n              result = generateCSV(data);\n              break;\n            case 'CALCULATE_STATISTICS':\n              result = calculateStatistics(data);\n              break;\n            default:\n              throw new Error(\\`Unknown message type: \\${type}\\`);\n          }\n          \n          self.postMessage({ type, data: result, taskId });\n        } catch (error) {\n          self.postMessage({ type: 'ERROR', error: error.message, taskId });\n        }\n      };\n\n      // Worker utility functions\n      function processGeoJSON(data) {\n        // TODO: Implement GeoJSON processing logic\n        return data;\n      }\n\n      function processFlowData(data) {\n        // TODO: Implement flow data processing logic\n        return data;\n      }\n\n      function generateCSV(data) {\n        // TODO: Implement CSV generation logic\n        return data;\n      }\n\n      function calculateStatistics(data) {\n        // TODO: Implement statistics calculation logic\n        return data;\n      }\n    `;\n\n    // Create a Blob from the worker code\n    const blob = new Blob([workerCode], { type: 'application/javascript' });\n    const workerURL = URL.createObjectURL(blob);\n    workerRef.current = new Worker(workerURL);\n\n    // Handle messages received from the worker\n    workerRef.current.onmessage = (event) => {\n      const { type, data, error, taskId } = event.data;\n\n      if (type === 'PROGRESS') {\n        setWorkerStatus((prev) => ({\n          ...prev,\n          progress: data.progress,\n        }));\n        return;\n      }\n\n      const callback = taskCallbacksRef.current.get(taskId);\n      if (callback) {\n        if (error) {\n          callback.reject(new Error(error));\n        } else {\n          callback.resolve(data);\n        }\n        taskCallbacksRef.current.delete(taskId);\n      }\n\n      // Update worker status if no pending tasks\n      if (taskCallbacksRef.current.size === 0) {\n        setWorkerStatus({\n          isActive: false,\n          currentTask: null,\n          progress: 0,\n        });\n      }\n    };\n\n    // Cleanup: Terminate the worker when the component unmounts\n    return () => {\n      if (workerRef.current) {\n        workerRef.current.terminate();\n      }\n      URL.revokeObjectURL(workerURL);\n    };\n  }, []);\n\n  /**\n   * Sends data to the worker for processing.\n   *\n   * @param {string} type - The type of processing task.\n   * @param {any} data - The data to be processed.\n   * @returns {Promise<any>} - A promise that resolves with the processed data.\n   */\n  const processData = useCallback(async (type, data) => {\n    if (!workerRef.current) {\n      throw new Error('Worker not initialized');\n    }\n\n    const taskId = uuidv4();\n    setWorkerStatus((prev) => ({\n      ...prev,\n      isActive: true,\n      currentTask: type,\n      progress: 0,\n    }));\n\n    const promise = new Promise((resolve, reject) => {\n      taskCallbacksRef.current.set(taskId, { resolve, reject });\n    });\n\n    workerRef.current.postMessage({\n      type,\n      data,\n      taskId,\n    });\n\n    return promise;\n  }, []);\n\n  // Specific processing functions\n  const processGeoJSON = useCallback(\n    (data) => processData('PROCESS_GEOJSON', data),\n    [processData]\n  );\n\n  const processFlowData = useCallback(\n    (data) => processData('PROCESS_FLOW_DATA', data),\n    [processData]\n  );\n\n  const generateCSV = useCallback(\n    (data) => processData('GENERATE_CSV', data),\n    [processData]\n  );\n\n  const calculateStatistics = useCallback(\n    (data) => processData('CALCULATE_STATISTICS', data),\n    [processData]\n  );\n\n  return {\n    workerStatus,\n    processGeoJSON,\n    processFlowData,\n    generateCSV,\n    calculateStatistics,\n  };\n};\n\n/**\n * Custom hook to get the current window size.\n *\n * @returns {{ width: number | undefined, height: number | undefined }}\n */\nfunction useWindowSize() {\n  const isClient = typeof window === 'object';\n\n  const getSize = () => ({\n    width: isClient ? window.innerWidth : undefined,\n    height: isClient ? window.innerHeight : undefined,\n  });\n\n  const [windowSize, setWindowSize] = useState(getSize);\n\n  useEffect(() => {\n    if (!isClient) return;\n\n    const handleResize = () => {\n      setWindowSize(getSize());\n    };\n\n    window.addEventListener('resize', handleResize);\n    \n    // Initialize with the current window size\n    handleResize();\n\n    // Cleanup: Remove event listener on unmount\n    return () => window.removeEventListener('resize', handleResize);\n  }, [isClient]);\n\n  return windowSize;\n}\n\n/**\n * Custom hook to provide technical help utilities based on component type.\n *\n * @param {string} componentType - The type of the component.\n * @returns {object} - An object containing methods to get tooltips, equations, concepts, and methodology.\n */\nconst useTechnicalHelp = (componentType) => {\n  const getTechnicalTooltip = useCallback(\n    (element) => {\n      const info = getMethodologyInfo(componentType);\n      return info?.tooltips?.[element] || null;\n    },\n    [componentType]\n  );\n\n  const getTechnicalEquation = useCallback(\n    (equationType) => {\n      const info = getMethodologyInfo(componentType);\n      return info?.equations?.[equationType] || null;\n    },\n    [componentType]\n  );\n\n  const getTechnicalConcept = useCallback(\n    (conceptKey) => {\n      const info = getMethodologyInfo(componentType);\n      return info?.concepts?.[conceptKey] || null;\n    },\n    [componentType]\n  );\n\n  const getMethodology = useCallback(() => {\n    return getMethodologySection(componentType);\n  }, [componentType]);\n\n  return {\n    getTechnicalTooltip,\n    getTechnicalEquation,\n    getTechnicalConcept,\n    getMethodology,\n  };\n};\n\n/**\n * Custom hook to lock or unlock body scroll.\n *\n * @param {boolean} isLocked - Whether to lock the body scroll.\n */\nconst useBodyScrollLock = (isLocked) => {\n  useEffect(() => {\n    if (isLocked) {\n      document.body.style.overflow = 'hidden';\n    } else {\n      document.body.style.overflow = '';\n    }\n\n    // Cleanup: Reset overflow when component unmounts or isLocked changes\n    return () => {\n      document.body.style.overflow = '';\n    };\n  }, [isLocked]);\n};\n\n// Export all custom hooks\nexport {\n  useWorkerProcessor,\n  useWindowSize,\n  useTechnicalHelp,\n  useBodyScrollLock,\n};",
        "imports": [
          "react",
          "uuid",
          "../utils/appUtils"
        ],
        "exports": [],
        "dependencies": [
          "react",
          "uuid",
          "../utils/appUtils"
        ]
      },
      {
        "path": "hooks/useAppState.js",
        "content": "// src/hooks/useAppState.js\n\nimport { useSelector, useDispatch } from 'react-redux';\nimport { useMemo } from 'react';\nimport _ from 'lodash';\nimport { selectError, selectCommodityInfo, initialState as spatialInitialState } from '../slices/spatialSlice';\nimport { useDashboardData } from './useDashboardData';\nimport { selectHasSeenWelcome } from '../store/welcomeModalSlice';\nimport { lightThemeWithOverrides, darkThemeWithOverrides } from '../styles/theme';\n\nconst safeSelector = (selector, defaultValue) => (state) => {\n  try {\n    return selector(state) ?? defaultValue;\n  } catch (error) {\n    console.warn(`Selector error: ${error.message}`);\n    return defaultValue;\n  }\n};\n\nexport const useAppState = () => {\n  const dispatch = useDispatch();\n  \n  // Use safe selectors with explicit default values\n  const error = useSelector(\n    safeSelector(\n      state => state.spatial?.status?.error,\n      spatialInitialState.status.error\n    ),\n    _.isEqual\n  );\n\n  const hasSeenWelcome = useSelector(\n    safeSelector(\n      state => state.welcomeModal?.hasSeenWelcome,\n      false\n    ),\n    _.isEqual\n  );\n\n  const isDarkMode = useSelector(\n    safeSelector(\n      state => state.theme?.isDarkMode,\n      false\n    ),\n    _.isEqual\n  );\n\n  // Use safe version of selectCommodityInfo\n  const commodityInfo = useSelector(\n    safeSelector(\n      selectCommodityInfo,\n      {\n        commodities: [],\n        selectedCommodity: '',\n        loading: false,\n        uniqueMonths: []\n      }\n    ),\n    _.isEqual\n  );\n\n  const spatialData = useSelector(\n    safeSelector(\n      state => state.spatial?.data,\n      spatialInitialState.data\n    ),\n    _.isEqual\n  );\n\n  const spatialLoading = useSelector(\n    safeSelector(\n      state => state.spatial?.status?.loading,\n      spatialInitialState.status.loading\n    ),\n    _.isEqual\n  );\n\n  const flowLoading = useSelector(\n    safeSelector(\n      state => state.flow?.status?.loading,\n      false\n    ),\n    _.isEqual\n  );\n\n  const storeInitialized = useSelector(\n    safeSelector(\n      state => {\n        // Check if essential slices are present\n        return Boolean(\n          state.spatial &&\n          state.theme &&\n          state.welcomeModal\n        );\n      },\n      false\n    ),\n    _.isEqual\n  );\n\n  // Memoize loading state\n  const isLoading = useMemo(() => \n    !storeInitialized || spatialLoading || flowLoading, \n    [storeInitialized, spatialLoading, flowLoading]\n  );\n\n  // Memoize theme\n  const theme = useMemo(\n    () => isDarkMode ? darkThemeWithOverrides : lightThemeWithOverrides,\n    [isDarkMode]\n  );\n\n  // Memoize commodities to prevent unnecessary re-renders\n  const commodities = useMemo(() => \n    commodityInfo.commodities || [], \n    [commodityInfo.commodities]\n  );\n\n  // Memoize data to prevent unnecessary re-renders\n  const data = useMemo(() => \n    spatialData || spatialInitialState.data,\n    [spatialData]\n  );\n\n  return {\n    dispatch,\n    data,\n    loading: isLoading,\n    error,\n    hasSeenWelcome,\n    isDarkMode,\n    commodities,\n    theme,\n    storeInitialized\n  };\n};\n",
        "imports": [
          "react-redux",
          "react",
          "lodash",
          "../slices/spatialSlice",
          "./useDashboardData",
          "../store/welcomeModalSlice",
          "../styles/theme"
        ],
        "exports": [
          "useAppState"
        ],
        "dependencies": [
          "react-redux",
          "react",
          "lodash",
          "../slices/spatialSlice",
          "./useDashboardData",
          "../store/welcomeModalSlice",
          "../styles/theme"
        ]
      },
      {
        "path": "hooks/useClusterEfficiency.js",
        "content": "// src/hooks/useClusterEfficiency.js\n\nimport { useMemo, useState, useCallback } from 'react';\nimport { useSelector } from 'react-redux';\nimport { \n  calculateEfficiencyMetrics, \n  calculateClusterHealth,\n  analyzeClusterStability,\n  generateConnectivityMatrix \n} from '../components/analysis/spatial-analysis/utils/clusterAnalysis';\n\n/**\n * Custom hook for managing cluster efficiency data and calculations\n * @param {Object} options - Configuration options\n * @returns {Object} Cluster efficiency data and utility functions\n */\nexport const useClusterEfficiency = (clusters, flowMaps) => {\n  return useMemo(() => {\n    try {\n      if (!clusters?.length) {\n        return {\n          clusters: [],\n          metrics: getDefaultMetrics()\n        };\n      }\n\n      // Process each cluster\n      const processedClusters = clusters.map(cluster => {\n        // Get connected markets, handle both potential formats\n        const markets = cluster.markets || cluster.connected_markets || [];\n        \n        // Calculate cohesion metrics with coordinate validation\n        const cohesionMetrics = calculateClusterCohesion(\n          { ...cluster, markets }, \n          flowMaps,\n          YEMEN_COORDINATES\n        );\n\n        // Calculate market isolation scores with safety checks\n        const marketIsolationScores = markets.map(market => {\n          const normalizedName = transformRegionName(market);\n          return calculateMarketIsolation(\n            normalizedName,\n            flowMaps,\n            YEMEN_COORDINATES\n          ) || { isolationScore: 1, connectionCount: 0, totalFlow: 0 };\n        });\n\n        // Calculate intercluster relationships with validation\n        const interClusterMetrics = clusters\n          .filter(c => c.cluster_id !== cluster.cluster_id)\n          .map(otherCluster => {\n            const flows = calculateInterClusterFlows(cluster, otherCluster, flowMaps);\n            return flows || { connectionDensity: 0, avgFlow: 0, totalFlow: 0 };\n          });\n\n        // Calculate efficiency metrics with proper validation\n        const metrics = {\n          efficiency: calculateEfficiencyScore(\n            cohesionMetrics,\n            marketIsolationScores,\n            interClusterMetrics\n          ),\n          internal_efficiency: calculateInternalEfficiency(cohesionMetrics),\n          external_efficiency: calculateExternalEfficiency(interClusterMetrics),\n          market_integration: calculateMarketIntegration(\n            marketIsolationScores,\n            flowMaps\n          ),\n          price_stability: calculatePriceStability(cluster, flowMaps),\n          flow_consistency: calculateFlowConsistency(cluster, flowMaps)\n        };\n\n        return {\n          ...cluster,\n          metrics,\n          cohesion: cohesionMetrics,\n          marketIsolation: marketIsolationScores,\n          interClusterRelations: interClusterMetrics\n        };\n      });\n\n      // Calculate overall metrics with validation\n      const overallMetrics = {\n        averageEfficiency: _.meanBy(processedClusters, 'metrics.efficiency') || 0,\n        totalCoverage: calculateTotalCoverage(processedClusters),\n        integrationScore: calculateOverallIntegration(processedClusters),\n        stabilityScore: calculateOverallStability(processedClusters),\n        flowConsistency: calculateOverallFlowConsistency(processedClusters)\n      };\n\n      return {\n        clusters: processedClusters,\n        metrics: overallMetrics\n      };\n\n    } catch (error) {\n      console.error('Error in cluster efficiency analysis:', error);\n      return {\n        clusters: [],\n        metrics: getDefaultMetrics()\n      };\n    }\n  }, [clusters, flowMaps]);\n};\n\nexport default useClusterEfficiency;\n",
        "imports": [
          "react",
          "react-redux",
          "../components/analysis/spatial-analysis/utils/clusterAnalysis"
        ],
        "exports": [
          "useClusterEfficiency",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../components/analysis/spatial-analysis/utils/clusterAnalysis"
        ]
      },
      {
        "path": "hooks/useDashboardData.js",
        "content": "// src/hooks/useDashboardData.js\n\nimport { useRef, useCallback, useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchAllSpatialData, initialState as spatialInitialState } from '../slices/spatialSlice';\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\nimport _ from 'lodash';\n\nexport const useDashboardData = () => {\n  const dispatch = useDispatch();\n  \n  // Use safe selectors with initial state fallbacks\n  const data = useSelector(\n    state => state.spatial?.data ?? spatialInitialState.data,\n    _.isEqual\n  );\n  \n  const loading = useSelector(\n    state => state.spatial?.status?.loading ?? spatialInitialState.status.loading,\n    _.isEqual\n  );\n  \n  const status = useSelector(\n    state => state.spatial?.status ?? spatialInitialState.status,\n    _.isEqual\n  );\n\n  const loadingRef = useRef(false);\n  const dataCache = useRef(new Map());\n  const abortControllerRef = useRef(null);\n\n  // Cleanup function to handle component unmount or re-fetch\n  const cleanup = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n    loadingRef.current = false;\n  }, []);\n\n  // Ensure cleanup on unmount\n  useEffect(() => {\n    return cleanup;\n  }, [cleanup]);\n\n  const fetchData = useCallback(async (commodity, date) => {\n    // Prevent concurrent fetches\n    if (loadingRef.current) {\n      console.debug('Fetch already in progress, skipping');\n      return;\n    }\n    \n    const cacheKey = `${commodity}_${date}`;\n    if (dataCache.current.has(cacheKey)) {\n      console.debug('Using cached data for', cacheKey);\n      return dataCache.current.get(cacheKey);\n    }\n\n    // Clean up any existing fetch\n    cleanup();\n\n    try {\n      // Create new abort controller\n      abortControllerRef.current = new AbortController();\n      loadingRef.current = true;\n      \n      const metric = backgroundMonitor.startMetric('data-fetch', {\n        commodity,\n        date,\n        timestamp: Date.now()\n      });\n\n      // Only include signal if abortControllerRef.current exists\n      const fetchOptions = {\n        commodity,\n        date,\n        ...(abortControllerRef.current ? { signal: abortControllerRef.current.signal } : {})\n      };\n\n      const result = await dispatch(fetchAllSpatialData(fetchOptions)).unwrap();\n\n      if (!result) {\n        console.warn('Fetch returned no data');\n        metric.finish({ \n          status: 'warning',\n          message: 'No data returned'\n        });\n        return spatialInitialState.data;\n      }\n\n      dataCache.current.set(cacheKey, result);\n      metric.finish({ \n        status: 'success',\n        dataPoints: result.spatialData?.timeSeriesData?.length ?? 0\n      });\n      \n      return result;\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        console.debug('Fetch aborted:', commodity, date);\n        return;\n      }\n      \n      console.error('Error fetching data:', error);\n      backgroundMonitor.startMetric('data-fetch-error', {\n        status: 'error', \n        error: error.message,\n        commodity,\n        date\n      }).finish();\n      \n      // Return initial state on error to prevent undefined data\n      return spatialInitialState.data;\n    } finally {\n      loadingRef.current = false;\n      if (abortControllerRef.current) {\n        abortControllerRef.current = null;\n      }\n    }\n  }, [dispatch, cleanup]);\n\n  return {\n    data,\n    loading,\n    status,\n    fetchData,\n    cleanup\n  };\n};\n",
        "imports": [
          "react",
          "react-redux",
          "../slices/spatialSlice",
          "../utils/backgroundMonitor",
          "lodash"
        ],
        "exports": [
          "useDashboardData"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../slices/spatialSlice",
          "../utils/backgroundMonitor",
          "lodash"
        ]
      },
      {
        "path": "hooks/useFlowDataManager.js",
        "content": "import { useEffect, useCallback, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { \n  fetchFlowData, \n  selectFlowState, \n  selectFlowStatus,\n  selectFlowsByDate \n} from '../slices/flowSlice';\n\n// Date format utilities\nconst dateUtils = {\n  // Convert YYYY-MM to YYYY-MM-DD\n  toFlowDate: (date) => {\n    if (!date) return null;\n    return date.length === 7 ? `${date}-01` : date;\n  },\n  // Convert YYYY-MM-DD to YYYY-MM\n  toSpatialDate: (date) => {\n    if (!date) return null;\n    return date.substring(0, 7);\n  },\n  // Check if dates match (ignoring day)\n  datesMatch: (date1, date2) => {\n    if (!date1 || !date2) return false;\n    return date1.substring(0, 7) === date2.substring(0, 7);\n  }\n};\n\n/**\n * Custom hook to manage flow data fetching and cleanup\n * Handles date format conversion between spatial and flow data\n */\nexport const useFlowDataManager = () => {\n  const dispatch = useDispatch();\n  const flowState = useSelector(selectFlowState);\n  const { loading, error } = useSelector(selectFlowStatus);\n  \n  // Get selected date and commodity from spatial and ecm slices\n  const selectedDate = useSelector(state => state.spatial.ui.selectedDate);\n  const selectedCommodity = useSelector(state => state.spatial.ui.selectedCommodity || state.ecm.ui.selectedCommodity);\n\n  // Get flows for current date\n  const currentFlows = useSelector(state => {\n    // Convert YYYY-MM to YYYY-MM-DD for flow data lookup\n    const flowDate = dateUtils.toFlowDate(selectedDate);\n    return selectFlowsByDate(state, flowDate);\n  });\n\n  // Refs for cleanup and state tracking\n  const lastFetchRef = useRef(null);\n  const abortControllerRef = useRef(null);\n\n  // Fetch flow data with date normalization\n  const loadData = useCallback(async () => {\n    if (!selectedCommodity || !selectedDate) {\n      console.debug('Missing required parameters:', { \n        commodity: selectedCommodity, \n        date: selectedDate \n      });\n      return;\n    }\n\n    // Convert date to flow format (YYYY-MM-DD)\n    const flowDate = dateUtils.toFlowDate(selectedDate);\n    \n    // Prevent duplicate fetches\n    const fetchKey = `${selectedCommodity}-${flowDate}`;\n    if (lastFetchRef.current === fetchKey) {\n      return;\n    }\n    lastFetchRef.current = fetchKey;\n\n    console.debug('Loading flow data:', { \n      commodity: selectedCommodity, \n      date: flowDate,\n      originalDate: selectedDate \n    });\n    \n    try {\n      // Cancel any ongoing requests\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      abortControllerRef.current = new AbortController();\n\n      await dispatch(fetchFlowData({ \n        commodity: selectedCommodity,\n        date: flowDate,\n        signal: abortControllerRef.current.signal\n      })).unwrap();\n    } catch (error) {\n      if (error.name !== 'AbortError') {\n        console.error('Error loading flow data:', error);\n      }\n    }\n  }, [selectedCommodity, selectedDate, dispatch]);\n\n  // Load data when dependencies change\n  useEffect(() => {\n    loadData();\n\n    // Cleanup function\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [loadData]);\n\n  return {\n    flows: currentFlows,\n    byDate: flowState.byDate,\n    byRegion: flowState.byRegion,\n    metadata: flowState.metadata,\n    loading,\n    error,\n    selectedCommodity,\n    selectedDate,\n    // Add helper method for manual refresh\n    refreshData: () => {\n      lastFetchRef.current = null; // Reset fetch tracking\n      loadData();\n    }\n  };\n};\n\nexport default useFlowDataManager;\n",
        "imports": [
          "react",
          "react-redux",
          "../slices/flowSlice"
        ],
        "exports": [
          "useFlowDataManager",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../slices/flowSlice"
        ]
      },
      {
        "path": "hooks/useMarketAnalysis.js",
        "content": "// src/hooks/useMarketAnalysis.js\n\nimport { useMemo } from 'react';\nimport _ from 'lodash';\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\nimport { validateNumber } from '../utils/numberValidation';\nimport { transformRegionName } from '../utils/spatialUtils';\n\nexport const useMarketAnalysis = (data) => {\n  return useMemo(() => {\n    if (!data) return null;\n\n    const metric = backgroundMonitor.startMetric('market-analysis');\n    \n    try {\n      const result = {\n        marketMetrics: calculateMarketMetrics(data),\n        timeSeriesAnalysis: analyzeTimeSeries(data.timeSeriesData),\n        spatialAnalysis: analyzeSpatialPatterns(data),\n        summaryMetrics: calculateSummaryMetrics(data)\n      };\n\n      metric.finish({ status: 'success' });\n      return result;\n\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      return null;\n    }\n  }, [data]);\n};\n\nconst calculateMarketMetrics = (data) => {\n  const { marketClusters, flowAnalysis } = data;\n\n  // Calculate market-level metrics\n  const metrics = {\n    marketCoverage: calculateMarketCoverage(marketClusters),\n    marketConnectivity: calculateMarketConnectivity(flowAnalysis),\n    marketEfficiency: calculateMarketEfficiency(marketClusters),\n    timeSeriesStats: calculateTimeSeriesStats(data.timeSeriesData)\n  };\n\n  return {\n    ...metrics,\n    overall: calculateOverallScore(metrics)\n  };\n};\n\nconst analyzeTimeSeries = (timeSeriesData) => {\n  if (!Array.isArray(timeSeriesData)) return null;\n\n  // Group by region\n  const byRegion = _.groupBy(timeSeriesData, 'region');\n\n  return Object.entries(byRegion).reduce((acc, [region, data]) => {\n    acc[region] = {\n      priceStats: calculatePriceStatistics(data),\n      volatility: calculateVolatility(data),\n      trend: calculateTrend(data),\n      seasonality: detectSeasonality(data)\n    };\n    return acc;\n  }, {});\n};\n\nconst analyzeSpatialPatterns = (data) => {\n  const { marketClusters, spatialAutocorrelation, flowAnalysis } = data;\n\n  return {\n    clusters: analyzeClusterPatterns(marketClusters),\n    spatialDependence: processSpatialAutocorrelation(spatialAutocorrelation),\n    flowPatterns: analyzeFlowPatterns(flowAnalysis)\n  };\n};\n\nconst calculateMarketCoverage = (clusters) => {\n  if (!Array.isArray(clusters)) return 0;\n\n  const uniqueMarkets = new Set();\n  clusters.forEach(cluster => {\n    uniqueMarkets.add(cluster.main_market);\n    cluster.connected_markets.forEach(market => uniqueMarkets.add(market));\n  });\n\n  return {\n    totalMarkets: uniqueMarkets.size,\n    clustersCoverage: clusters.length,\n    averageClusterSize: clusters.reduce((sum, cluster) => \n      sum + (cluster.connected_markets.length + 1), 0) / clusters.length,\n    integrationRate: clusters.length > 0 ? \n      uniqueMarkets.size / (clusters.length * 2) : 0\n  };\n};\n\nconst calculateMarketConnectivity = (flows) => {\n  if (!Array.isArray(flows)) return 0;\n\n  const marketConnections = new Map();\n  \n  flows.forEach(flow => {\n    if (!marketConnections.has(flow.source)) {\n      marketConnections.set(flow.source, new Set());\n    }\n    if (!marketConnections.has(flow.target)) {\n      marketConnections.set(flow.target, new Set());\n    }\n    \n    marketConnections.get(flow.source).add(flow.target);\n    marketConnections.get(flow.target).add(flow.source);\n  });\n\n  const totalMarkets = marketConnections.size;\n  const avgConnections = Array.from(marketConnections.values())\n    .reduce((sum, connections) => sum + connections.size, 0) / totalMarkets;\n\n  return {\n    totalConnections: flows.length,\n    averageConnections: avgConnections,\n    density: totalMarkets > 1 ? \n      flows.length / (totalMarkets * (totalMarkets - 1)) : 0,\n    isolatedMarkets: Array.from(marketConnections.values())\n      .filter(connections => connections.size === 0).length\n  };\n};\n\nconst calculateMarketEfficiency = (clusters) => {\n  if (!Array.isArray(clusters)) return {};\n\n  const efficiencyScores = clusters.map(cluster => ({\n    score: validateNumber(cluster.metrics?.efficiency, 0),\n    coverage: validateNumber(cluster.metrics?.coverage, 0),\n    connectivity: validateNumber(cluster.metrics?.connectivity, 0)\n  }));\n\n  return {\n    averageEfficiency: _.meanBy(efficiencyScores, 'score'),\n    averageCoverage: _.meanBy(efficiencyScores, 'coverage'),\n    averageConnectivity: _.meanBy(efficiencyScores, 'connectivity'),\n    distribution: {\n      high: efficiencyScores.filter(score => score.score > 0.7).length,\n      medium: efficiencyScores.filter(score => score.score > 0.4 && score.score <= 0.7).length,\n      low: efficiencyScores.filter(score => score.score <= 0.4).length\n    }\n  };\n};\n\nconst calculateTimeSeriesStats = (timeSeriesData) => {\n  if (!Array.isArray(timeSeriesData)) return {};\n\n  const priceValues = timeSeriesData.map(d => d.price).filter(Boolean);\n  const usdValues = timeSeriesData.map(d => d.usdprice).filter(Boolean);\n  const conflictValues = timeSeriesData.map(d => d.conflict_intensity).filter(Boolean);\n\n  return {\n    prices: calculateStatistics(priceValues),\n    usdPrices: calculateStatistics(usdValues),\n    conflictIntensity: calculateStatistics(conflictValues),\n    sampleSize: timeSeriesData.length,\n    timeRange: calculateTimeRange(timeSeriesData)\n  };\n};\n\nconst calculateStatistics = (values) => {\n  if (!values.length) return null;\n\n  const sorted = [...values].sort((a, b) => a - b);\n  const mean = _.mean(values);\n  const median = sorted[Math.floor(sorted.length / 2)];\n  const standardDeviation = Math.sqrt(\n    values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length\n  );\n\n  return {\n    mean,\n    median,\n    min: sorted[0],\n    max: sorted[sorted.length - 1],\n    standardDeviation,\n    coefficientOfVariation: standardDeviation / mean\n  };\n};\n\nconst calculateTimeRange = (data) => {\n  if (!data.length) return null;\n\n  const dates = data.map(d => new Date(d.date));\n  return {\n    start: new Date(Math.min(...dates)),\n    end: new Date(Math.max(...dates)),\n    duration: Math.max(...dates) - Math.min(...dates)\n  };\n};\n\nconst calculatePriceStatistics = (data) => {\n  const prices = data.map(d => d.price).filter(Boolean);\n  const usdPrices = data.map(d => d.usdprice).filter(Boolean);\n\n  return {\n    local: calculateStatistics(prices),\n    usd: calculateStatistics(usdPrices),\n    correlation: calculateCorrelation(prices, usdPrices)\n  };\n};\n\nconst calculateVolatility = (data) => {\n  const prices = data.map(d => d.price).filter(Boolean);\n  if (prices.length < 2) return null;\n\n  const returns = [];\n  for (let i = 1; i < prices.length; i++) {\n    if (prices[i-1] > 0) {\n      returns.push(Math.log(prices[i] / prices[i-1]));\n    }\n  }\n\n  return {\n    volatility: Math.sqrt(returns.reduce((sum, ret) => sum + ret * ret, 0) / returns.length),\n    maxDrawdown: calculateMaxDrawdown(prices),\n    jumpFrequency: calculateJumpFrequency(prices)\n  };\n};\n\nconst calculateTrend = (data) => {\n  const prices = data.map(d => d.price).filter(Boolean);\n  if (prices.length < 2) return null;\n\n  const xValues = Array.from({ length: prices.length }, (_, i) => i);\n  const { slope, intercept, rSquared } = calculateLinearRegression(xValues, prices);\n\n  return {\n    slope,\n    intercept,\n    rSquared,\n    direction: slope > 0 ? 'increasing' : slope < 0 ? 'decreasing' : 'stable',\n    strength: Math.abs(slope) * rSquared\n  };\n};\n\nconst detectSeasonality = (data) => {\n  const prices = data.map(d => d.price).filter(Boolean);\n  if (prices.length < 12) return null;\n\n  // Group by month\n  const months = data.reduce((acc, d) => {\n    const month = new Date(d.date).getMonth();\n    if (!acc[month]) acc[month] = [];\n    if (d.price) acc[month].push(d.price);\n    return acc;\n  }, {});\n\n  const monthlyStats = Object.entries(months).map(([month, prices]) => ({\n    month: Number(month),\n    stats: calculateStatistics(prices)\n  }));\n\n  return {\n    monthlyStats,\n    seasonalStrength: calculateSeasonalStrength(monthlyStats),\n    peakMonth: findPeakMonth(monthlyStats),\n    troughMonth: findTroughMonth(monthlyStats)\n  };\n};\n\nconst calculateOverallScore = (metrics) => {\n  const weights = {\n    coverage: 0.3,\n    connectivity: 0.3,\n    efficiency: 0.4\n  };\n\n  return (\n    metrics.marketCoverage.integrationRate * weights.coverage +\n    metrics.marketConnectivity.density * weights.connectivity +\n    metrics.marketEfficiency.averageEfficiency * weights.efficiency\n  );\n};\n\nconst calculateLinearRegression = (x, y) => {\n  const n = x.length;\n  const sumX = _.sum(x);\n  const sumY = _.sum(y);\n  const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);\n  const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);\n\n  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n\n  const yMean = sumY / n;\n  const totalSS = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);\n  const residualSS = y.reduce((sum, yi, i) => {\n    const prediction = slope * x[i] + intercept;\n    return sum + Math.pow(yi - prediction, 2);\n  }, 0);\n\n  return {\n    slope,\n    intercept,\n    rSquared: 1 - (residualSS / totalSS)\n  };\n};\n\nconst calculateCorrelation = (array1, array2) => {\n  if (array1.length !== array2.length || !array1.length) return null;\n\n  const mean1 = _.mean(array1);\n  const mean2 = _.mean(array2);\n  const deviation1 = array1.map(x => x - mean1);\n  const deviation2 = array2.map(x => x - mean2);\n\n  const sum12 = _.sum(deviation1.map((d1, i) => d1 * deviation2[i]));\n  const sum1 = Math.sqrt(_.sum(deviation1.map(d => d * d)));\n  const sum2 = Math.sqrt(_.sum(deviation2.map(d => d * d)));\n\n  return sum12 / (sum1 * sum2);\n};\n\nconst calculateMaxDrawdown = (prices) => {\n  let maxDrawdown = 0;\n  let peak = prices[0];\n\n  for (const price of prices) {\n    if (price > peak) {\n      peak = price;\n    }\n    const drawdown = (peak - price) / peak;\n    maxDrawdown = Math.max(maxDrawdown, drawdown);\n  }\n\n  return maxDrawdown;\n};\n\nconst calculateJumpFrequency = (prices) => {\n  const threshold = 0.1; // 10% change\n  let jumps = 0;\n\n  for (let i = 1; i < prices.length; i++) {\n    const change = Math.abs(prices[i] - prices[i-1]) / prices[i-1];\n    if (change > threshold) jumps++;\n  }\n\n  return jumps / (prices.length - 1);\n};",
        "imports": [
          "react",
          "lodash",
          "../utils/backgroundMonitor",
          "../utils/numberValidation",
          "../utils/spatialUtils"
        ],
        "exports": [
          "useMarketAnalysis"
        ],
        "dependencies": [
          "react",
          "lodash",
          "../utils/backgroundMonitor",
          "../utils/numberValidation",
          "../utils/spatialUtils"
        ]
      },
      {
        "path": "hooks/usePrecomputedData.js",
        "content": "// src/hooks/usePrecomputedData.js\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { precomputedDataManager } from '../utils/PrecomputedDataManager';\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\nimport { setProgress, setLoadingStage } from '../slices/spatialSlice';\n\nexport const usePrecomputedData = (commodity, date) => {\n  const dispatch = useDispatch();\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef(null);\n  const lastRequestRef = useRef({ commodity, date });\n\n  const loadData = useCallback(async (options = {}) => {\n    // Cancel any existing request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n\n    // Create new abort controller\n    abortControllerRef.current = new AbortController();\n    const metric = backgroundMonitor.startMetric('data-load');\n\n    try {\n      setLoading(true);\n      setError(null);\n      dispatch(setLoadingStage('loading'));\n      dispatch(setProgress(0));\n\n      // Load data\n      const result = await precomputedDataManager.loadData(\n        commodity,\n        date,\n        {\n          ...options,\n          signal: abortControllerRef.current.signal,\n          onProgress: (progress) => dispatch(setProgress(progress))\n        }\n      );\n\n      // Update state if request wasn't cancelled\n      if (!abortControllerRef.current.signal.aborted) {\n        setData(result);\n        dispatch(setLoadingStage('complete'));\n        dispatch(setProgress(100));\n        metric.finish({ status: 'success' });\n      }\n\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        metric.finish({ status: 'aborted' });\n        return;\n      }\n\n      setError(error.message);\n      dispatch(setLoadingStage('error'));\n      metric.finish({ status: 'error', error: error.message });\n\n    } finally {\n      if (!abortControllerRef.current.signal.aborted) {\n        setLoading(false);\n      }\n    }\n  }, [commodity, date, dispatch]);\n\n  // Load data when inputs change\n  useEffect(() => {\n    const prevRequest = lastRequestRef.current;\n    \n    if (commodity && date && (\n      commodity !== prevRequest.commodity || \n      date !== prevRequest.date\n    )) {\n      lastRequestRef.current = { commodity, date };\n      loadData();\n    }\n\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [commodity, date, loadData]);\n\n  // Expose reload method for manual refresh\n  const reload = useCallback(() => {\n    return loadData({ forceRefresh: true });\n  }, [loadData]);\n\n  return {\n    data,\n    loading,\n    error,\n    reload\n  };\n};",
        "imports": [
          "react",
          "react-redux",
          "../utils/PrecomputedDataManager",
          "../utils/backgroundMonitor",
          "../slices/spatialSlice"
        ],
        "exports": [
          "usePrecomputedData"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../utils/PrecomputedDataManager",
          "../utils/backgroundMonitor",
          "../slices/spatialSlice"
        ]
      },
      {
        "path": "hooks/useSpatialAutocorrelation.js",
        "content": "// src/components/analysis/spatial-analysis/hooks/useSpatialAutocorrelation.js\n\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { \n  selectSpatialAutocorrelation, \n  selectTimeSeriesData,\n  selectGeometryData\n} from '../../../../selectors/optimizedSelectors';\nimport { calculateLocalMorans } from '../utils/spatialAnalysis';\nimport { backgroundMonitor } from '../../../../utils/backgroundMonitor';\n\nexport const useSpatialAutocorrelation = () => {\n  const spatialAutocorrelation = useSelector(selectSpatialAutocorrelation);\n  const timeSeriesData = useSelector(selectTimeSeriesData);\n  const geometryData = useSelector(selectGeometryData);\n\n  return useMemo(() => {\n    const metric = backgroundMonitor.startMetric('spatial-autocorrelation-processing');\n\n    try {\n      if (!timeSeriesData?.length || !geometryData?.unified) {\n        return {\n          global: null,\n          local: null,\n          loading: false,\n          error: 'Missing required data'\n        };\n      }\n\n      // If we already have processed autocorrelation data, use it\n      if (spatialAutocorrelation?.global && spatialAutocorrelation?.local) {\n        metric.finish({ status: 'success', source: 'cache' });\n        return {\n          ...spatialAutocorrelation,\n          loading: false,\n          error: null\n        };\n      }\n\n      // Calculate local Moran's I if not available\n      const localResults = calculateLocalMorans(timeSeriesData, geometryData.unified);\n      \n      const results = {\n        global: {\n          moran_i: localResults.globalI,\n          z_score: localResults.zScore,\n          p_value: localResults.pValue\n        },\n        local: localResults.clusters,\n        loading: false,\n        error: null\n      };\n\n      metric.finish({ status: 'success', source: 'calculation' });\n      return results;\n\n    } catch (error) {\n      console.error('Error in spatial autocorrelation processing:', error);\n      metric.finish({ status: 'error', error: error.message });\n      return {\n        global: null,\n        local: null,\n        loading: false,\n        error: error.message\n      };\n    }\n  }, [spatialAutocorrelation, timeSeriesData, geometryData]);\n};",
        "imports": [
          "react",
          "react-redux",
          "../../../../selectors/optimizedSelectors",
          "../utils/spatialAnalysis",
          "../../../../utils/backgroundMonitor"
        ],
        "exports": [
          "useSpatialAutocorrelation"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../../../../selectors/optimizedSelectors",
          "../utils/spatialAnalysis",
          "../../../../utils/backgroundMonitor"
        ]
      },
      {
        "path": "hooks/useSpatialData.js",
        "content": "import { useEffect, useState, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { loadSpatialReducer } from '../store';\nimport { dataLoader } from '../utils/dataLoader';\nimport { \n  setProgress, \n  setLoadingStage,\n  updateData,\n  selectLoadingStatus,\n  selectSpatialData,\n  selectUIState\n} from '../slices/spatialSlice';\n\nexport function useSpatialData() {\n  const dispatch = useDispatch();\n  const loading = useSelector(selectLoadingStatus);\n  const spatialData = useSelector(selectSpatialData);\n  const uiState = useSelector(selectUIState);\n  const [error, setError] = useState(null);\n\n  const loadData = useCallback(async (commodity, date, options = {}) => {\n    try {\n      setError(null);\n      dispatch(setProgress(0));\n      dispatch(setLoadingStage('loading'));\n\n      // Ensure spatial reducer is loaded\n      await loadSpatialReducer();\n\n      // Load data with progress updates\n      const data = await dataLoader.loadSpatialData(commodity, date, {\n        ...options,\n        onProgress: (progress) => {\n          dispatch(setProgress(progress));\n        }\n      });\n\n      // Update store with loaded data\n      dispatch(updateData(data));\n      dispatch(setProgress(100));\n      dispatch(setLoadingStage('complete'));\n\n      return data;\n    } catch (err) {\n      setError(err);\n      dispatch(setLoadingStage('error'));\n      throw err;\n    }\n  }, [dispatch]);\n\n  // Load initial data if needed\n  useEffect(() => {\n    if (!spatialData && uiState.selectedCommodity && !loading && !error) {\n      loadData(uiState.selectedCommodity, uiState.selectedDate).catch(console.error);\n    }\n  }, [spatialData, uiState.selectedCommodity, uiState.selectedDate, loading, error, loadData]);\n\n  const refresh = useCallback(() => {\n    if (uiState.selectedCommodity) {\n      return loadData(uiState.selectedCommodity, uiState.selectedDate, { forceRefresh: true });\n    }\n  }, [loadData, uiState.selectedCommodity, uiState.selectedDate]);\n\n  return {\n    loading,\n    error,\n    data: spatialData,\n    loadData,\n    refresh,\n    progress: useSelector(state => state.spatial?.status?.progress || 0)\n  };\n}\n\n// Hook for regression data\nexport function useRegressionData() {\n  const dispatch = useDispatch();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const selectedCommodity = useSelector(state => state.spatial?.ui?.selectedCommodity);\n\n  const loadRegressionData = useCallback(async (commodity = selectedCommodity) => {\n    if (!commodity) return;\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      const data = await dataLoader.loadRegressionData(commodity);\n      dispatch({ type: 'spatial/updateRegressionData', payload: data });\n\n      return data;\n    } catch (err) {\n      setError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [dispatch, selectedCommodity]);\n\n  // Load initial data if needed\n  useEffect(() => {\n    if (selectedCommodity && !loading && !error) {\n      loadRegressionData().catch(console.error);\n    }\n  }, [selectedCommodity, loading, error, loadRegressionData]);\n\n  return {\n    loading,\n    error,\n    loadRegressionData\n  };\n}\n\n// Hook for managing Web Worker computations\nexport function useSpatialComputation() {\n  const [computing, setComputing] = useState(false);\n  const [error, setError] = useState(null);\n\n  const compute = useCallback(async (type, data, options = {}) => {\n    try {\n      setComputing(true);\n      setError(null);\n\n      const result = await dataLoader.computeWithWorker(type, data, options);\n      return result;\n    } catch (err) {\n      setError(err);\n      throw err;\n    } finally {\n      setComputing(false);\n    }\n  }, []);\n\n  return {\n    computing,\n    error,\n    compute\n  };\n}\n",
        "imports": [
          "react",
          "react-redux",
          "../store",
          "../utils/dataLoader",
          "../slices/spatialSlice"
        ],
        "exports": [
          "useSpatialData",
          "useRegressionData",
          "useSpatialComputation"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "../store",
          "../utils/dataLoader",
          "../slices/spatialSlice"
        ]
      },
      {
        "path": "hooks/useSpatialSelectors.js",
        "content": "// src/hooks/useSpatialSelectors.js\n\nimport { useSelector } from 'react-redux';\nimport {\n  selectSpatialDataOptimized,\n  selectMarketClusters,\n  selectMarketFlows,\n  selectTimeSeriesData,\n  selectVisualizationMode,\n  selectMarketIntegration,\n  selectGeometryData,\n  selectLoadingStatus,\n  selectSpatialAutocorrelation,\n  selectRegressionAnalysis,\n  selectSeasonalAnalysis,\n  selectMarketShocks,\n  selectSelectedCommodity,\n  selectSelectedDate,\n  selectVisualizationData,\n  selectFeatureDataWithMetrics,\n  selectClustersWithCoordinates,\n  selectFlowsWithCoordinates\n} from '../selectors/optimizedSelectors';\n\n// Centralized hooks for accessing spatial state\nexport const useSpatialData = () => useSelector(selectSpatialDataOptimized);\nexport const useMarketClusters = () => useSelector(selectMarketClusters);\nexport const useMarketFlows = () => useSelector(selectMarketFlows);\nexport const useTimeSeriesData = () => useSelector(selectTimeSeriesData);\nexport const useVisualizationMode = () => useSelector(selectVisualizationMode);\nexport const useMarketIntegration = () => useSelector(selectMarketIntegration);\nexport const useGeometryData = () => useSelector(selectGeometryData);\nexport const useLoadingStatus = () => useSelector(selectLoadingStatus);\nexport const useSpatialAutocorrelation = () => useSelector(selectSpatialAutocorrelation);\nexport const useRegressionAnalysis = () => useSelector(selectRegressionAnalysis);\nexport const useSeasonalAnalysis = () => useSelector(selectSeasonalAnalysis);\nexport const useMarketShocks = () => useSelector(selectMarketShocks);\nexport const useSelectedCommodity = () => useSelector(selectSelectedCommodity);\nexport const useSelectedDate = () => useSelector(selectSelectedDate);\nexport const useVisualizationData = () => useSelector(selectVisualizationData);\nexport const useFeatureDataWithMetrics = () => useSelector(selectFeatureDataWithMetrics);\nexport const useClustersWithCoordinates = () => useSelector(selectClustersWithCoordinates);\nexport const useFlowsWithCoordinates = () => useSelector(selectFlowsWithCoordinates);\n\n// Combined hooks for common data needs\nexport const useSpatialAnalysisData = () => {\n  const spatialData = useSpatialData();\n  const loadingStatus = useLoadingStatus();\n  const geometryData = useGeometryData();\n\n  return {\n    spatialData,\n    loadingStatus,\n    geometryData,\n    isLoading: loadingStatus.loading,\n    error: loadingStatus.error,\n    progress: loadingStatus.progress\n  };\n};\n\nexport const useMarketAnalysisData = () => {\n  const marketClusters = useMarketClusters();\n  const marketFlows = useMarketFlows();\n  const marketIntegration = useMarketIntegration();\n  const timeSeriesData = useTimeSeriesData();\n\n  return {\n    marketClusters,\n    marketFlows,\n    marketIntegration,\n    timeSeriesData\n  };\n};\n\nexport const useVisualizationState = () => {\n  const mode = useVisualizationMode();\n  const selectedCommodity = useSelectedCommodity();\n  const selectedDate = useSelectedDate();\n  const visualizationData = useVisualizationData();\n\n  return {\n    mode,\n    selectedCommodity,\n    selectedDate,\n    visualizationData\n  };\n};\n\n// Helper hook for checking data availability\nexport const useDataAvailability = () => {\n  const { spatialData, loadingStatus } = useSpatialAnalysisData();\n  \n  return {\n    isLoading: loadingStatus.loading,\n    hasData: Boolean(spatialData),\n    isError: Boolean(loadingStatus.error),\n    errorMessage: loadingStatus.error\n  };\n};\n",
        "imports": [
          "react-redux",
          "../selectors/optimizedSelectors"
        ],
        "exports": [
          "useSpatialData",
          "useMarketClusters",
          "useMarketFlows",
          "useTimeSeriesData",
          "useVisualizationMode",
          "useMarketIntegration",
          "useGeometryData",
          "useLoadingStatus",
          "useSpatialAutocorrelation",
          "useRegressionAnalysis",
          "useSeasonalAnalysis",
          "useMarketShocks",
          "useSelectedCommodity",
          "useSelectedDate",
          "useVisualizationData",
          "useFeatureDataWithMetrics",
          "useClustersWithCoordinates",
          "useFlowsWithCoordinates",
          "useSpatialAnalysisData",
          "useMarketAnalysisData",
          "useVisualizationState",
          "useDataAvailability"
        ],
        "dependencies": [
          "react-redux",
          "../selectors/optimizedSelectors"
        ]
      },
      {
        "path": "hooks/useUnifiedData.js",
        "content": "// src/hooks/useUnifiedData.js\n\nimport { useState, useCallback, useEffect } from 'react';\nimport { getDataPath } from '../utils/dataUtils';\nimport _ from 'lodash';\n\nconst calculateUnifiedRegimeData = (data) => {\n  // Group data by date and commodity\n  const groupedByDateAndCommodity = _.groupBy(data, item => \n    `${item.date}_${item.commodity}`\n  );\n\n  return Object.entries(groupedByDateAndCommodity).map(([key, items]) => {\n    // Only create unified entry if we have both north and south data\n    const northData = items.find(item => item.regime === 'north');\n    const southData = items.find(item => item.regime === 'south');\n\n    if (!northData || !southData) return null;\n\n    // Calculate averages for all metrics\n    const [date, commodity] = key.split('_');\n    return {\n      date,\n      commodity,\n      regime: 'unified',\n      price: calculateAverage([northData.price, southData.price]),\n      usdprice: calculateAverage([northData.usdprice, southData.usdprice]),\n      conflict_intensity: calculateAverage([\n        northData.conflict_intensity, \n        southData.conflict_intensity\n      ]),\n      sample_size: northData.sample_size + southData.sample_size\n    };\n  }).filter(Boolean); // Remove null entries\n};\n\nconst calculateAverage = (values) => {\n  const validValues = values.filter(v => v != null && !isNaN(v));\n  return validValues.length > 0 ? _.mean(validValues) : null;\n};\n\nconst aggregateDataByDateRegimeCommodity = (features) => {\n  // Group data by unique combinations\n  const grouped = features.reduce((acc, feature) => {\n    const props = feature.properties;\n    if (!props.date || !props.exchange_rate_regime || !props.commodity) return acc;\n\n    const normalizedCommodity = props.commodity.toLowerCase().trim();\n    const key = `${props.date}_${props.exchange_rate_regime}_${normalizedCommodity}`;\n    \n    if (!acc[key]) {\n      acc[key] = {\n        date: props.date,\n        regime: props.exchange_rate_regime.toLowerCase(),\n        commodity: normalizedCommodity,\n        prices: [],\n        usdprices: [],\n        conflict_intensities: [],\n        count: 0\n      };\n    }\n\n    if (isFinite(props.price)) {\n      acc[key].prices.push(Number(props.price));\n    }\n    if (isFinite(props.usdprice)) {\n      acc[key].usdprices.push(Number(props.usdprice));\n    }\n    if (isFinite(props.conflict_intensity)) {\n      acc[key].conflict_intensities.push(Number(props.conflict_intensity));\n    }\n    acc[key].count++;\n\n    return acc;\n  }, {});\n\n  return Object.values(grouped).map(entry => ({\n    date: entry.date,\n    regime: entry.regime,\n    commodity: entry.commodity,\n    price: entry.prices.length > 0 ? _.mean(entry.prices) : null,\n    usdprice: entry.usdprices.length > 0 ? _.mean(entry.usdprices) : null,\n    conflict_intensity: entry.conflict_intensities.length > 0 \n      ? _.mean(entry.conflict_intensities) \n      : 0,\n    sample_size: entry.count\n  }));\n};\n\nexport const useUnifiedData = () => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const fetchData = useCallback(async () => {\n    try {\n      const path = getDataPath('unified_data.geojson');\n      console.debug('Fetching unified data from:', path);\n\n      const response = await fetch(path, {\n        headers: {\n          Accept: 'application/geo+json',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const geojsonData = await response.json();\n      console.debug('GeoJSON data loaded, features count:', geojsonData.features?.length);\n\n      if (!geojsonData.features || !Array.isArray(geojsonData.features)) {\n        throw new Error(\"Invalid GeoJSON structure: 'features' array is missing\");\n      }\n\n      // Aggregate original data\n      const aggregatedData = aggregateDataByDateRegimeCommodity(geojsonData.features);\n      if (aggregatedData.length === 0) {\n        throw new Error('No valid data after aggregation');\n      }\n\n      // Calculate unified regime data\n      const unifiedData = calculateUnifiedRegimeData(aggregatedData);\n      \n      // Combine original and unified data\n      const combinedData = [...aggregatedData, ...unifiedData];\n\n      // Extract and normalize unique values\n      const uniqueCommodities = [...new Set(\n        combinedData.map(d => d.commodity.toLowerCase().trim())\n      )].sort();\n      \n      const uniqueRegimes = [...new Set(\n        combinedData.map(d => d.regime.toLowerCase().trim())\n      )].sort();\n\n      // Find min and max dates\n      const dates = combinedData.map(d => new Date(d.date));\n      const minDate = new Date(Math.min(...dates));\n      const maxDate = new Date(Math.max(...dates));\n\n      setData({\n        features: combinedData,\n        commodities: uniqueCommodities,\n        regimes: uniqueRegimes,\n        dateRange: {\n          min: minDate,\n          max: maxDate,\n        },\n      });\n\n      console.debug('Data processed successfully:', {\n        featureCount: combinedData.length,\n        commodities: uniqueCommodities,\n        regimes: uniqueRegimes,\n        dateRange: { min: minDate, max: maxDate },\n      });\n\n    } catch (err) {\n      console.error('Error in useUnifiedData:', err);\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  const getFilteredData = useCallback((commodity, selectedRegimes) => {\n    if (!data?.features || !commodity || !selectedRegimes?.length) return [];\n    \n    const normalizedCommodity = commodity.toLowerCase().trim();\n    const normalizedRegimes = selectedRegimes.map(r => r.toLowerCase().trim());\n    \n    return data.features.filter(item => \n      item.commodity === normalizedCommodity &&\n      normalizedRegimes.includes(item.regime)\n    ).sort((a, b) => new Date(a.date) - new Date(b.date));\n  }, [data]);\n\n  return {\n    data,\n    loading,\n    error,\n    refetch: fetchData,\n    getFilteredData\n  };\n};",
        "imports": [
          "react",
          "../utils/dataUtils",
          "lodash"
        ],
        "exports": [
          "useUnifiedData"
        ],
        "dependencies": [
          "react",
          "../utils/dataUtils",
          "lodash"
        ]
      },
      {
        "path": "hooks/useWindowWidth.js",
        "content": "// src/hooks/useWindowWidth.js\n\nimport { useState, useEffect } from 'react';\n\nexport const useWindowWidth = () => {\n  const [windowWidth, setWindowWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handleResize = () => {\n      setWindowWidth(window.innerWidth);\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowWidth;\n};\n",
        "imports": [
          "react"
        ],
        "exports": [
          "useWindowWidth"
        ],
        "dependencies": [
          "react"
        ]
      },
      {
        "path": "index.js",
        "content": "// src/index.js\n\nimport React, { useMemo } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport { Provider, useDispatch } from 'react-redux';\nimport PropTypes from 'prop-types';\nimport { configureAppStore, getStore } from './store/configureStore';\nimport App from './App';\nimport ReduxDebugWrapper from './utils/ReduxDebugWrapper';\nimport { setupReduxDebugger } from './utils/debugUtils';\nimport { backgroundMonitor, MetricTypes } from './utils/backgroundMonitor';\nimport { spatialHandler } from './utils/spatialDataHandler';\nimport { fetchAllSpatialData } from './slices/spatialSlice';\nimport { fetchFlowData } from './slices/flowSlice';\nimport './utils/leafletSetup';\nimport 'leaflet/dist/leaflet.css';\nimport './styles/leaflet-overrides.css';\nimport 'leaflet.markercluster/dist/MarkerCluster.css';\nimport 'leaflet.markercluster/dist/MarkerCluster.Default.css';\n\nconst DEFAULT_DATE = '2020-10-01';\nconst DEFAULT_COMMODITY = 'beans (kidney red)';\n\n// Data Loader Component\nconst DataLoader = React.memo(({ selectedCommodity, selectedDate }) => {\n  const [hasLoaded, setHasLoaded] = React.useState(false);\n  const dispatch = useDispatch();\n\n  React.useEffect(() => {\n    if (!selectedCommodity || hasLoaded) {\n      return;\n    }\n\n    let metric;\n    try {\n      metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n        component: 'data-loader',\n        commodity: selectedCommodity,\n        date: selectedDate\n      });\n    } catch (e) {\n      console.warn('Error starting metric:', e);\n    }\n\n    const loadData = async () => {\n      try {\n        // Load spatial and flow data in parallel\n        await Promise.all([\n          dispatch(fetchAllSpatialData({ \n            commodity: selectedCommodity, \n            date: selectedDate \n          })),\n          dispatch(fetchFlowData({ \n            commodity: selectedCommodity, \n            date: selectedDate \n          }))\n        ]);\n\n        setHasLoaded(true);\n        metric?.finish?.({\n          status: 'success',\n          commodity: selectedCommodity,\n          date: selectedDate,\n          timestamp: Date.now()\n        });\n      } catch (error) {\n        console.error('Error loading initial data:', error);\n        metric?.finish?.({\n          status: 'error',\n          error: error.message,\n          commodity: selectedCommodity,\n          date: selectedDate\n        });\n        \n        try {\n          backgroundMonitor.logError?.('data-load-failed', {\n            error: error.message,\n            stack: error.stack,\n            commodity: selectedCommodity,\n            date: selectedDate\n          });\n        } catch (e) {\n          console.warn('Error logging to background monitor:', e);\n        }\n      }\n    };\n\n    loadData();\n  }, [selectedCommodity, selectedDate, hasLoaded, dispatch]);\n\n  return null;\n});\n\nDataLoader.propTypes = {\n  selectedCommodity: PropTypes.string.isRequired,\n  selectedDate: PropTypes.string.isRequired,\n};\n\nDataLoader.displayName = 'DataLoader';\n\n// App Wrapper Component\nconst AppWithProviders = React.memo(({ store }) => {\n  const selectedCommodity = useMemo(() => DEFAULT_COMMODITY, []);\n  const selectedDate = useMemo(() => DEFAULT_DATE, []);\n\n  return (\n    <Provider store={store}>\n      <ReduxDebugWrapper>\n        <DataLoader \n          selectedCommodity={selectedCommodity} \n          selectedDate={selectedDate} \n        />\n        <App />\n      </ReduxDebugWrapper>\n    </Provider>\n  );\n});\n\nAppWithProviders.propTypes = {\n  store: PropTypes.object.isRequired,\n};\n\nAppWithProviders.displayName = 'AppWithProviders';\n\n// Initialize the application\nconst initializeApp = async () => {\n  const startTime = performance.now();\n  let initMetric;\n  let store;\n\n  try {\n    // Initialize background monitor first\n    try {\n      await backgroundMonitor.init();\n      initMetric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n        component: 'app',\n        startTime\n      });\n    } catch (e) {\n      console.warn('Background monitor initialization failed:', e);\n    }\n\n    // Initialize store with required reducers\n    store = await configureAppStore();\n\n    // Initialize services in development\n    if (process.env.NODE_ENV === 'development') {\n      setupReduxDebugger(store);\n\n      try {\n        backgroundMonitor.logMetric(MetricTypes.SYSTEM.INIT, {\n          timestamp: Date.now(),\n          environment: process.env.NODE_ENV,\n          config: {\n            precomputedData: true,\n            reduxDebugger: true,\n            flowManagement: true\n          }\n        });\n\n        // Setup load time monitoring\n        window.addEventListener('load', () => {\n          const loadTime = performance.now() - startTime;\n          console.debug(`[App] Initial load completed in ${loadTime.toFixed(2)}ms`);\n\n          backgroundMonitor.logMetric(MetricTypes.SYSTEM.PERFORMANCE, {\n            event: 'load-complete',\n            duration: loadTime,\n            timestamp: Date.now(),\n            metrics: {\n              loadTime,\n              cacheInitialized: Boolean(spatialHandler.geometryCache),\n              reduxStoreSize: JSON.stringify(store.getState()).length,\n              reducersLoaded: Object.keys(store.getState()).length\n            }\n          });\n        });\n      } catch (e) {\n        console.warn('Error setting up monitoring:', e);\n      }\n\n      console.debug(`\n        🚀 Yemen Market Analysis Dashboard\n        ================================\n        Environment: ${process.env.NODE_ENV}\n        Version: ${process.env.REACT_APP_VERSION || '1.0.0'}\n        Redux Debugger: Enabled\n        Precomputed Data: Initialized\n        Flow Management: Enabled\n        \n        Debug tools available:\n        - Redux DevTools\n        - Background Monitor\n        - Performance Metrics\n      `);\n    }\n\n    // Initialize geometry data\n    await spatialHandler.initializeGeometry();\n\n    // Create root and render application\n    const root = createRoot(document.getElementById('root'));\n    root.render(\n      <React.StrictMode>\n        <AppWithProviders store={store} />\n      </React.StrictMode>\n    );\n\n    initMetric?.finish?.({ \n      status: 'success',\n      initTime: performance.now() - startTime,\n      environment: process.env.NODE_ENV,\n      timestamp: Date.now()\n    });\n\n  } catch (error) {\n    console.error('Failed to initialize application:', error);\n    \n    initMetric?.finish?.({ \n      status: 'error',\n      error: error.message,\n      stack: error.stack,\n      initTime: performance.now() - startTime\n    });\n\n    try {\n      backgroundMonitor.logError(MetricTypes.SYSTEM.ERROR, {\n        component: 'app-init',\n        error: error.message,\n        stack: error.stack,\n        initTime: performance.now() - startTime\n      });\n    } catch (e) {\n      console.warn('Error logging to background monitor:', e);\n    }\n\n    // Render error state if initialization fails\n    const root = createRoot(document.getElementById('root'));\n    root.render(\n      <div style={{ \n        padding: '20px', \n        color: '#721c24', \n        backgroundColor: '#f8d7da', \n        border: '1px solid #f5c6cb',\n        borderRadius: '4px',\n        margin: '20px'\n      }}>\n        <h2>Application Initialization Failed</h2>\n        <p>Please refresh the page or contact support if the problem persists.</p>\n        {process.env.NODE_ENV === 'development' && (\n          <pre style={{ whiteSpace: 'pre-wrap' }}>{error.stack}</pre>\n        )}\n      </div>\n    );\n  }\n};\n\n// Start the application\ninitializeApp();\n",
        "imports": [
          "react",
          "react-dom/client",
          "react-redux",
          "prop-types",
          "./store/configureStore",
          "./App",
          "./utils/ReduxDebugWrapper",
          "./utils/debugUtils",
          "./utils/backgroundMonitor",
          "./utils/spatialDataHandler",
          "./slices/spatialSlice",
          "./slices/flowSlice",
          "./utils/leafletSetup",
          "leaflet/dist/leaflet.css",
          "./styles/leaflet-overrides.css",
          "leaflet.markercluster/dist/MarkerCluster.css",
          "leaflet.markercluster/dist/MarkerCluster.Default.css"
        ],
        "exports": [],
        "dependencies": [
          "react",
          "react-dom/client",
          "react-redux",
          "prop-types",
          "./store/configureStore",
          "./App",
          "./utils/ReduxDebugWrapper",
          "./utils/debugUtils",
          "./utils/backgroundMonitor",
          "./utils/spatialDataHandler",
          "./slices/spatialSlice",
          "./slices/flowSlice",
          "./utils/leafletSetup",
          "leaflet/dist/leaflet.css",
          "./styles/leaflet-overrides.css",
          "leaflet.markercluster/dist/MarkerCluster.css",
          "leaflet.markercluster/dist/MarkerCluster.Default.css"
        ]
      },
      {
        "path": "middleware/batchMiddleware.js",
        "content": "// src/middleware/batchMiddleware.js\nimport _ from 'lodash';\n\nconst BATCH_TIMEOUT = 100; // Adjust based on your needs\n\nexport const createBatchMiddleware = () => {\n  let batchedActions = [];\n  let batchTimeout = null;\n\n  return store => next => action => {\n    // Skip batching for certain critical actions\n    if (action.meta?.immediate) {\n      return next(action);\n    }\n\n    batchedActions.push(action);\n    \n    if (!batchTimeout) {\n      batchTimeout = setTimeout(() => {\n        const actions = [...batchedActions];\n        batchedActions = [];\n        batchTimeout = null;\n\n        // Group similar actions\n        const groupedActions = _.groupBy(actions, 'type');\n        \n        // For each group, only dispatch the latest action\n        Object.values(groupedActions).forEach(group => {\n          next(group[group.length - 1]);\n        });\n      }, BATCH_TIMEOUT);\n    }\n  };\n};",
        "imports": [
          "lodash"
        ],
        "exports": [
          "createBatchMiddleware"
        ],
        "dependencies": [
          "lodash"
        ]
      },
      {
        "path": "middleware/optimizedMiddleware.js",
        "content": "// src/middleware/optimizedMiddleware.js\n\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\nimport _ from 'lodash';\n\n/**\n * Creates batch processing middleware\n */\nexport const createBatchMiddleware = () => {\n  const pendingActions = new Map();\n  const BATCH_TIMEOUT = 100; // milliseconds\n\n  return store => next => action => {\n    // Skip batching for certain critical actions\n    if (action.meta?.immediate) {\n      return next(action);\n    }\n\n    const actionType = action.type;\n    if (!pendingActions.has(actionType)) {\n      pendingActions.set(actionType, []);\n      \n      // Schedule batch processing\n      setTimeout(() => {\n        const actions = pendingActions.get(actionType);\n        pendingActions.delete(actionType);\n        \n        if (actions.length === 1) {\n          // If only one action, process normally\n          next(actions[0]);\n        } else {\n          // Combine similar actions\n          const batchedAction = combineSimilarActions(actions);\n          next(batchedAction);\n        }\n      }, BATCH_TIMEOUT);\n    }\n    \n    pendingActions.get(actionType).push(action);\n  };\n};\n\n/**\n * Creates selective update middleware\n */\nexport const createSelectiveUpdateMiddleware = () => {\n  return store => next => action => {\n    const metric = backgroundMonitor.startMetric('state-update');\n    const prevState = store.getState();\n    \n    try {\n      // Process action\n      const result = next(action);\n      const nextState = store.getState();\n\n      // Calculate changed paths\n      const changes = calculateStateDiff(prevState, nextState);\n      \n      // Only notify relevant subscribers\n      if (Object.keys(changes).length > 0) {\n        notifySelectiveSubscribers(store, changes);\n      }\n\n      metric.finish({ \n        status: 'success',\n        changedPaths: Object.keys(changes).length\n      });\n\n      return result;\n\n    } catch (error) {\n      metric.finish({ \n        status: 'error',\n        error: error.message\n      });\n      throw error;\n    }\n  };\n};\n\n/**\n * Creates caching middleware\n */\nexport const createCachingMiddleware = () => {\n  return store => next => action => {\n    // Skip caching for certain actions\n    if (action.meta?.skipCache) {\n      return next(action);\n    }\n\n    const metric = backgroundMonitor.startMetric('action-caching');\n\n    try {\n      // Generate cache key\n      const cacheKey = generateCacheKey(action);\n      \n      // Check cache\n      const cachedResult = getCachedResult(cacheKey);\n      if (cachedResult) {\n        metric.finish({ status: 'cache-hit' });\n        return cachedResult;\n      }\n\n      // Process action\n      const result = next(action);\n      \n      // Cache result\n      setCacheResult(cacheKey, result);\n      \n      metric.finish({ status: 'success' });\n      return result;\n\n    } catch (error) {\n      metric.finish({ \n        status: 'error', \n        error: error.message \n      });\n      throw error;\n    }\n  };\n};\n\n/**\n * Creates performance monitoring middleware\n */\nexport const createPerformanceMiddleware = () => {\n  return store => next => action => {\n    const startTime = performance.now();\n    const metric = backgroundMonitor.startMetric('action-performance');\n\n    try {\n      const result = next(action);\n      const duration = performance.now() - startTime;\n\n      // Log performance metrics\n      metric.finish({\n        status: 'success',\n        duration,\n        action: action.type,\n        timestamp: Date.now()\n      });\n\n      // Monitor long-running actions\n      if (duration > 100) { // 100ms threshold\n        backgroundMonitor.logMetric('long-running-action', {\n          action: action.type,\n          duration,\n          timestamp: Date.now()\n        });\n      }\n\n      return result;\n\n    } catch (error) {\n      metric.finish({\n        status: 'error',\n        error: error.message,\n        action: action.type\n      });\n      throw error;\n    }\n  };\n};\n\n// Helper Functions\n\nconst combineSimilarActions = (actions) => {\n  if (!actions.length) return null;\n  if (actions.length === 1) return actions[0];\n\n  // Group by action type\n  const groups = _.groupBy(actions, action => {\n    return action.type.split('/')[0]; // Group by domain\n  });\n\n  // Combine each group\n  return Object.entries(groups).reduce((combinedAction, [domain, groupActions]) => {\n    switch (domain) {\n      case 'spatial':\n        return combineSpatialActions(groupActions);\n      case 'flow':\n        return combineFlowActions(groupActions);\n      default:\n        return groupActions[groupActions.length - 1]; // Take latest action\n    }\n  }, {});\n};\n\nconst combineSpatialActions = (actions) => {\n  return {\n    type: 'spatial/batchUpdate',\n    payload: {\n      data: mergeDataUpdates(actions),\n      ui: mergeUIUpdates(actions)\n    },\n    meta: {\n      batch: true,\n      batchSize: actions.length\n    }\n  };\n};\n\nconst combineFlowActions = (actions) => {\n  return {\n    type: 'flow/batchUpdate',\n    payload: mergeFlowUpdates(actions),\n    meta: {\n      batch: true,\n      batchSize: actions.length\n    }\n  };\n};\n\nconst mergeDataUpdates = (actions) => {\n  return actions.reduce((merged, action) => {\n    if (action.payload?.data) {\n      return {\n        ...merged,\n        ...action.payload.data\n      };\n    }\n    return merged;\n  }, {});\n};\n\nconst mergeUIUpdates = (actions) => {\n  // Take the latest UI state\n  const uiActions = actions.filter(action => action.payload?.ui);\n  if (uiActions.length) {\n    return uiActions[uiActions.length - 1].payload.ui;\n  }\n  return null;\n};\n\nconst mergeFlowUpdates = (actions) => {\n  return actions.reduce((merged, action) => {\n    if (action.payload?.flows) {\n      return {\n        ...merged,\n        flows: [...(merged.flows || []), ...action.payload.flows]\n      };\n    }\n    return merged;\n  }, {});\n};\n\nconst calculateStateDiff = (prevState, nextState, path = '') => {\n  const changes = {};\n\n  // Handle non-object types\n  if (typeof prevState !== 'object' || typeof nextState !== 'object') {\n    if (prevState !== nextState) {\n      changes[path] = { prev: prevState, next: nextState };\n    }\n    return changes;\n  }\n\n  // Handle null values\n  if (!prevState || !nextState) {\n    if (prevState !== nextState) {\n      changes[path] = { prev: prevState, next: nextState };\n    }\n    return changes;\n  }\n\n  // Compare object keys\n  const allKeys = new Set([...Object.keys(prevState), ...Object.keys(nextState)]);\n\n  for (const key of allKeys) {\n    const currentPath = path ? `${path}.${key}` : key;\n    \n    if (key in prevState && key in nextState) {\n      // Both objects have the key - compare values\n      const subChanges = calculateStateDiff(\n        prevState[key],\n        nextState[key],\n        currentPath\n      );\n      Object.assign(changes, subChanges);\n    } else {\n      // Key exists in only one object\n      changes[currentPath] = {\n        prev: prevState[key],\n        next: nextState[key]\n      };\n    }\n  }\n\n  return changes;\n};\n\nconst notifySelectiveSubscribers = (store, changes) => {\n  const subscribers = store.getSubscribers?.() || [];\n  \n  subscribers.forEach(subscriber => {\n    const relevantChanges = filterRelevantChanges(changes, subscriber.paths);\n    if (Object.keys(relevantChanges).length > 0) {\n      subscriber.callback(relevantChanges);\n    }\n  });\n};\n\nconst filterRelevantChanges = (changes, subscriberPaths) => {\n  if (!subscriberPaths?.length) return changes;\n\n  return Object.entries(changes).reduce((relevant, [path, change]) => {\n    if (subscriberPaths.some(subPath => path.startsWith(subPath))) {\n      relevant[path] = change;\n    }\n    return relevant;\n  }, {});\n};\n\n// Cache helpers\nconst CACHE_PREFIX = 'action_cache_';\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nconst generateCacheKey = (action) => {\n  const { type, payload } = action;\n  // Create unique key based on action type and payload\n  return CACHE_PREFIX + JSON.stringify({ type, payload });\n};\n\nconst getCachedResult = (key) => {\n  try {\n    const cached = sessionStorage.getItem(key);\n    if (!cached) return null;\n\n    const { result, timestamp } = JSON.parse(cached);\n    \n    // Check if cache is still valid\n    if (Date.now() - timestamp > CACHE_TTL) {\n      sessionStorage.removeItem(key);\n      return null;\n    }\n\n    return result;\n  } catch (error) {\n    return null;\n  }\n};\n\nconst setCacheResult = (key, result) => {\n  try {\n    const cache = {\n      result,\n      timestamp: Date.now()\n    };\n    sessionStorage.setItem(key, JSON.stringify(cache));\n  } catch (error) {\n    // Handle storage errors (e.g., quota exceeded)\n    console.warn('Cache storage failed:', error);\n  }\n};",
        "imports": [
          "../utils/backgroundMonitor",
          "lodash"
        ],
        "exports": [
          "createBatchMiddleware",
          "createSelectiveUpdateMiddleware",
          "createCachingMiddleware",
          "createPerformanceMiddleware"
        ],
        "dependencies": [
          "../utils/backgroundMonitor",
          "lodash"
        ]
      },
      {
        "path": "middleware/requestMiddleware.js",
        "content": "// src/middleware/requestMiddleware.js\n\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\n\n// Track in-flight requests\nconst pendingRequests = new Map();\nconst requestCache = new Map();\n\n// Cache configuration\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\nconst MAX_CACHE_SIZE = 100;\n\n// Helper to generate cache key\nconst getCacheKey = (type, params) => {\n  return `${type}:${JSON.stringify(params)}`;\n};\n\n// Helper to clean old cache entries\nconst cleanCache = () => {\n  const now = Date.now();\n  for (const [key, entry] of requestCache) {\n    if (now - entry.timestamp > CACHE_TTL) {\n      requestCache.delete(key);\n    }\n  }\n  \n  // If still over size limit, remove oldest entries\n  if (requestCache.size > MAX_CACHE_SIZE) {\n    const entries = Array.from(requestCache.entries());\n    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n    const toRemove = entries.slice(0, entries.length - MAX_CACHE_SIZE);\n    toRemove.forEach(([key]) => requestCache.delete(key));\n  }\n};\n\nexport const requestMiddleware = store => next => action => {\n  // Check if action is valid and has a type\n  if (!action || typeof action !== 'object' || !action.type || typeof action.type !== 'string') {\n    return next(action);\n  }\n\n  // Only process specific async actions\n  if (!action.type.endsWith('/pending')) {\n    return next(action);\n  }\n\n  const { type, meta } = action;\n  const baseType = type.replace('/pending', '');\n  \n  // Generate cache key from action type and parameters\n  const cacheKey = getCacheKey(baseType, meta?.arg);\n\n  // Check if request is already in flight\n  if (pendingRequests.has(cacheKey)) {\n    const metric = backgroundMonitor.startMetric('request-deduplication');\n    metric.finish({ status: 'deduped', action: baseType });\n    return pendingRequests.get(cacheKey);\n  }\n\n  // Check cache for valid response\n  const cachedResponse = requestCache.get(cacheKey);\n  if (cachedResponse && Date.now() - cachedResponse.timestamp < CACHE_TTL) {\n    const metric = backgroundMonitor.startMetric('request-cache');\n    metric.finish({ status: 'cache-hit', action: baseType });\n    return Promise.resolve(cachedResponse.data);\n  }\n\n  // Create promise for new request\n  const promise = next(action).then(response => {\n    // Cache successful response\n    requestCache.set(cacheKey, {\n      data: response,\n      timestamp: Date.now()\n    });\n    \n    // Clean up pending request\n    pendingRequests.delete(cacheKey);\n    \n    // Periodically clean cache\n    cleanCache();\n    \n    return response;\n  }).catch(error => {\n    // Clean up on error\n    pendingRequests.delete(cacheKey);\n    throw error;\n  });\n\n  // Store pending request\n  pendingRequests.set(cacheKey, promise);\n  \n  return promise;\n};\n\n// Batch related requests middleware\nconst batchWindow = 50; // 50ms window to batch requests\nlet batchTimeout = null;\nconst batchedRequests = new Map();\n\nexport const batchMiddleware = store => next => action => {\n  // Check if action is valid and has a type\n  if (!action || typeof action !== 'object' || !action.type || typeof action.type !== 'string') {\n    return next(action);\n  }\n\n  // Only batch specific data loading actions\n  const batchableActions = [\n    'spatial/fetchAllSpatialData',\n    'flow/fetchData',\n    'ecm/fetchECMData'\n  ];\n\n  if (!action.type.endsWith('/pending') || !batchableActions.includes(action.type.replace('/pending', ''))) {\n    return next(action);\n  }\n\n  const { type, meta } = action;\n  const baseType = type.replace('/pending', '');\n\n  // Add to batch\n  if (!batchedRequests.has(baseType)) {\n    batchedRequests.set(baseType, []);\n  }\n  batchedRequests.get(baseType).push({ action, next });\n\n  // Clear existing timeout\n  if (batchTimeout) {\n    clearTimeout(batchTimeout);\n  }\n\n  // Set new timeout to process batch\n  batchTimeout = setTimeout(() => {\n    const metric = backgroundMonitor.startMetric('request-batching');\n    \n    try {\n      // Process each type of batched requests\n      for (const [actionType, requests] of batchedRequests.entries()) {\n        if (requests.length > 1) {\n          // Combine parameters from all requests\n          const combinedParams = requests.reduce((acc, { action }) => ({\n            ...acc,\n            ...action.meta?.arg\n          }), {});\n\n          // Create combined action\n          const batchedAction = {\n            ...requests[0].action,\n            meta: {\n              ...requests[0].action.meta,\n              arg: combinedParams,\n              batch: true\n            }\n          };\n\n          // Execute combined request\n          const result = requests[0].next(batchedAction);\n\n          // Resolve all original requests with result\n          requests.forEach(({ action: originalAction }) => {\n            const filteredResult = filterResultForAction(result, originalAction);\n            Promise.resolve(filteredResult);\n          });\n        } else {\n          // If only one request, process normally\n          requests[0].next(requests[0].action);\n        }\n      }\n\n      metric.finish({ \n        status: 'success',\n        batchedRequests: Array.from(batchedRequests.entries()).reduce((acc, [type, reqs]) => ({\n          ...acc,\n          [type]: reqs.length\n        }), {})\n      });\n    } catch (error) {\n      metric.finish({ \n        status: 'error',\n        error: error.message\n      });\n      backgroundMonitor.logError('batch-processing', error);\n    }\n\n    // Clear batch\n    batchedRequests.clear();\n    batchTimeout = null;\n  }, batchWindow);\n\n  // Return promise that will be resolved when batch is processed\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const result = batchedRequests.get(baseType)?.find(r => \n        r.action.meta?.arg === meta?.arg\n      )?.result;\n      \n      if (result) {\n        resolve(result);\n      } else {\n        reject(new Error('Request not found in batch'));\n      }\n    }, batchWindow + 10);\n  });\n};\n\n// Helper to filter batched results for specific action\nfunction filterResultForAction(batchedResult, originalAction) {\n  // Implementation depends on your data structure\n  // This is a simplified example\n  const { commodity, date } = originalAction.meta?.arg || {};\n  \n  if (batchedResult?.payload?.data) {\n    return {\n      ...batchedResult,\n      payload: {\n        ...batchedResult.payload,\n        data: batchedResult.payload.data.filter(item => \n          item.commodity === commodity && \n          (!date || item.date === date)\n        )\n      }\n    };\n  }\n  \n  return batchedResult;\n}\n",
        "imports": [
          "../utils/backgroundMonitor"
        ],
        "exports": [
          "requestMiddleware",
          "batchMiddleware"
        ],
        "dependencies": [
          "../utils/backgroundMonitor"
        ]
      },
      {
        "path": "middleware/spatialMiddleware.js",
        "content": "// src/middleware/spatialMiddleware.js\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\n\nexport const createSpatialMiddleware = () => {\n  return store => next => action => {\n    // Monitor spatial actions\n    if (action.type?.startsWith('spatial/')) {\n      const startTime = performance.now();\n      const result = next(action);\n      const duration = performance.now() - startTime;\n\n      // Validate geometry data when received\n      if (action.type === 'spatial/fetchAllSpatialData/fulfilled') {\n        const geometryData = action.payload?.geometry;\n        \n        // Validate required geometry structure\n        if (geometryData) {\n          const validation = {\n            hasPoints: Array.isArray(geometryData.points),\n            hasPolygons: Array.isArray(geometryData.polygons),\n            hasUnified: Boolean(geometryData.unified),\n            pointCount: geometryData.points?.length || 0,\n            polygonCount: geometryData.polygons?.length || 0\n          };\n\n          // Log validation results\n          backgroundMonitor.logMetric('geometry-validation', {\n            ...validation,\n            timestamp: Date.now()\n          });\n\n          // Warn if missing required data\n          if (!validation.hasPoints || !validation.hasPolygons) {\n            console.warn('Spatial data missing required geometry properties', validation);\n          }\n        }\n      }\n\n      backgroundMonitor.logMetric('spatial-action', {\n        type: action.type,\n        duration,\n        timestamp: Date.now()\n      });\n\n      return result;\n    }\n    return next(action);\n  };\n};",
        "imports": [
          "../utils/backgroundMonitor"
        ],
        "exports": [
          "createSpatialMiddleware"
        ],
        "dependencies": [
          "../utils/backgroundMonitor"
        ]
      },
      {
        "path": "routes/AnalysisRoutes.js",
        "content": "//src/routes/AnalysisRoutes.js\n\nimport { lazy, Suspense } from 'react';\nimport LoadingSpinner from './components/common/LoadingSpinner';\n\n// Lazy load analysis components\nconst ECMAnalysis = lazy(() => import('./components/analysis/ecm/ECMAnalysis'));\nconst PriceDifferentialAnalysis = lazy(() => \n  import('./components/analysis/price-differential/PriceDifferentialAnalysis')\n);\nconst SpatialAnalysis = lazy(() => import('./components/analysis/spatial/SpatialAnalysis'));\nconst TVMIIAnalysis = lazy(() => import('./components/analysis/tvmii/TVMIIAnalysis'));\n\n// Route configuration with prefetching\nconst AnalysisComponent = ({ type, ...props }) => {\n  const components = {\n    ecm: ECMAnalysis,\n    priceDiff: PriceDifferentialAnalysis,\n    spatial: SpatialAnalysis,\n    tvmii: TVMIIAnalysis,\n  };\n\n  const Component = components[type];\n\n  return (\n    <Suspense fallback={<LoadingSpinner />}>\n      <Component {...props} />\n    </Suspense>\n  );\n};\n\n// Prefetch on hover/menu interaction\nconst prefetchComponent = (type) => {\n  switch (type) {\n    case 'ecm':\n      ECMAnalysis.preload();\n      break;\n    case 'priceDiff':\n      PriceDifferentialAnalysis.preload();\n      break;\n    // Add other cases\n  }\n};\n\nexport { AnalysisComponent, prefetchComponent };",
        "imports": [
          "react",
          "./components/common/LoadingSpinner"
        ],
        "exports": [],
        "dependencies": [
          "react",
          "./components/common/LoadingSpinner"
        ]
      },
      {
        "path": "selectors/dateSpecificSelectors.js",
        "content": "import { createSelector } from '@reduxjs/toolkit';\nimport { flowValidation } from '../components/spatialAnalysis/features/flows/types';\n\n// Base selectors\nconst selectMarketShocks = state => state.spatial.data.marketShocks || [];\nconst selectTimeSeriesData = state => state.spatial.data.timeSeriesData || [];\nconst selectSelectedDate = state => state.spatial.ui.selectedDate;\nconst selectGeometry = state => state.spatial.data.geometry;\nconst selectFlowData = state => state.spatial.data.flowData;\nconst selectFlowMaps = state => state.spatial.data.flowMaps || [];\n\n// Date-specific Time Series Selector\nexport const selectDateFilteredData = createSelector(\n  [selectTimeSeriesData, selectSelectedDate],\n  (timeSeriesData, selectedDate) => {\n    if (!timeSeriesData?.length || !selectedDate) return [];\n    return flowValidation.filterFlowsByDate(timeSeriesData, selectedDate);\n  }\n);\n\n// Enhanced flow selectors with validation\nexport const selectDateFilteredFlows = createSelector(\n  [selectFlowMaps, selectSelectedDate],\n  (flows, selectedDate) => {\n    // Early return if no flows or date\n    if (!Array.isArray(flows) || !selectedDate) {\n      console.debug('Missing flow data or date:', {\n        hasFlows: Boolean(flows),\n        selectedDate\n      });\n      return [];\n    }\n\n    // Use flowValidation helper to filter and validate flows\n    const validatedFlows = flowValidation.filterFlowsByDate(flows, selectedDate);\n\n    console.debug('Flow filtering results:', {\n      totalFlows: flows.length,\n      validatedFlows: validatedFlows.length,\n      selectedDate\n    });\n\n    return validatedFlows;\n  }\n);\n\n// Calculate flow metrics for selected date\nexport const selectDateFilteredMetrics = createSelector(\n  [selectDateFilteredFlows],\n  (flows) => {\n    if (!Array.isArray(flows) || !flows.length) {\n      console.debug('No flows available for metrics calculation');\n      return {\n        flows: {\n          total: 0,\n          average: 0,\n          count: 0,\n          maxFlow: 0,\n          minFlow: 0,\n          stdDev: 0\n        }\n      };\n    }\n\n    const metrics = flowValidation.calculateFlowMetrics(flows);\n    if (!metrics) return null;\n\n    return {\n      flows: {\n        total: metrics.totalFlow,\n        average: metrics.avgFlow,\n        count: metrics.count,\n        maxFlow: metrics.maxFlow,\n        minFlow: metrics.minFlow,\n        stdDev: metrics.stdDev\n      }\n    };\n  }\n);\n\n// Additional helper selector for flow validation\nexport const selectFlowDataStatus = createSelector(\n  [selectFlowMaps, selectSelectedDate],\n  (flows, selectedDate) => {\n    if (!Array.isArray(flows)) {\n      console.debug('Invalid flows array');\n      return {\n        hasData: false,\n        dateRange: { start: null, end: null },\n        lastUpdated: new Date().toISOString(),\n        totalFlows: 0,\n        dateFlows: 0,\n        uniqueDates: 0\n      };\n    }\n\n    // Get valid flows using flowValidation helper\n    const validFlows = flows.filter(flowValidation.isValidFlow);\n    const dateFlows = flowValidation.filterFlowsByDate(validFlows, selectedDate);\n\n    // Get unique dates\n    const dates = [...new Set(validFlows.map(f => f.date?.substring(0, 7)))].sort();\n\n    return {\n      hasData: validFlows.length > 0,\n      dateRange: {\n        start: dates[0] || null,\n        end: dates[dates.length - 1] || null\n      },\n      lastUpdated: new Date().toISOString(),\n      totalFlows: validFlows.length,\n      dateFlows: dateFlows.length,\n      uniqueDates: dates.length\n    };\n  }\n);\n\n// Date-specific Shocks Selector\nexport const selectDateFilteredShocks = createSelector(\n  [selectMarketShocks, selectSelectedDate],\n  (shocks, selectedDate) => {\n    if (!shocks?.length || !selectedDate) return [];\n    return flowValidation.filterFlowsByDate(shocks, selectedDate);\n  }\n);\n\n// Shock Metrics Selector\nexport const selectShockMetrics = createSelector(\n  [selectDateFilteredShocks],\n  (shocks) => {\n    if (!shocks?.length) return {\n      totalShocks: 0,\n      priceDrops: 0,\n      priceSurges: 0,\n      avgMagnitude: 0,\n      maxMagnitude: 0,\n      affectedRegions: new Set()\n    };\n\n    const priceDrops = shocks.filter(s => s.shock_type === 'price_drop');\n    const priceSurges = shocks.filter(s => s.shock_type === 'price_surge');\n    const avgMagnitude = shocks.reduce((sum, s) => sum + s.magnitude, 0) / shocks.length;\n    const maxMagnitude = Math.max(...shocks.map(s => s.magnitude));\n    const affectedRegions = new Set(shocks.map(s => s.region));\n\n    return {\n      totalShocks: shocks.length,\n      priceDrops: priceDrops.length,\n      priceSurges: priceSurges.length,\n      avgMagnitude,\n      maxMagnitude,\n      affectedRegions\n    };\n  }\n);\n\n// Shock Analysis Data Selector\nexport const selectShockAnalysisData = createSelector(\n  [selectDateFilteredShocks, selectGeometry, selectShockMetrics],\n  (shocks, geometry, metrics) => {\n    if (!shocks?.length || !geometry) return null;\n\n    // Group shocks by region\n    const shocksByRegion = shocks.reduce((acc, shock) => {\n      if (!acc[shock.region]) acc[shock.region] = [];\n      acc[shock.region].push(shock);\n      return acc;\n    }, {});\n\n    // Calculate regional metrics\n    const regionalMetrics = Object.entries(shocksByRegion).map(([region, regionShocks]) => {\n      const avgMagnitude = regionShocks.reduce((sum, s) => sum + s.magnitude, 0) / regionShocks.length;\n      const maxMagnitude = Math.max(...regionShocks.map(s => s.magnitude));\n      \n      return {\n        region,\n        shockCount: regionShocks.length,\n        avgMagnitude,\n        maxMagnitude,\n        priceDrops: regionShocks.filter(s => s.shock_type === 'price_drop').length,\n        priceSurges: regionShocks.filter(s => s.shock_type === 'price_surge').length\n      };\n    });\n\n    return {\n      shocks,\n      geometry,\n      metrics,\n      regionalMetrics,\n      shocksByRegion\n    };\n  }\n);\n\n// Time Series Metrics Selector\nexport const selectTimeSeriesMetrics = createSelector(\n  [selectDateFilteredData],\n  (timeData) => {\n    if (!timeData?.length) return {\n      avgPrice: 0,\n      maxPrice: 0,\n      minPrice: 0,\n      priceRange: 0,\n      avgConflict: 0,\n      maxConflict: 0\n    };\n\n    const prices = timeData.map(d => d.usdPrice || 0);\n    const conflicts = timeData.map(d => d.conflictIntensity || 0);\n\n    return {\n      avgPrice: prices.reduce((sum, p) => sum + p, 0) / prices.length,\n      maxPrice: Math.max(...prices),\n      minPrice: Math.min(...prices),\n      priceRange: Math.max(...prices) - Math.min(...prices),\n      avgConflict: conflicts.reduce((sum, c) => sum + c, 0) / conflicts.length,\n      maxConflict: Math.max(...conflicts)\n    };\n  }\n);\n\nexport default {\n  selectDateFilteredData,\n  selectDateFilteredFlows,\n  selectDateFilteredShocks,\n  selectDateFilteredMetrics,\n  selectShockMetrics,\n  selectShockAnalysisData,\n  selectTimeSeriesMetrics,\n  selectFlowDataStatus\n};\n",
        "imports": [
          "@reduxjs/toolkit",
          "../components/spatialAnalysis/features/flows/types"
        ],
        "exports": [
          "selectDateFilteredData",
          "selectDateFilteredFlows",
          "selectDateFilteredMetrics",
          "selectFlowDataStatus",
          "selectDateFilteredShocks",
          "selectShockMetrics",
          "selectShockAnalysisData",
          "selectTimeSeriesMetrics",
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "../components/spatialAnalysis/features/flows/types"
        ]
      },
      {
        "path": "selectors/optimizedSelectors.js",
        "content": "// src/selectors/optimizedSelectors.js\n\nimport { createSelector } from '@reduxjs/toolkit';\nimport { createSelectorCreator } from 'reselect';\nimport isEqual from 'lodash/isEqual';\nimport _ from 'lodash';\nimport { \n  transformRegionName, \n  getRegionCoordinates, \n  calculateCenter \n} from '../components/spatialAnalysis/utils/spatialUtils';\n\n// Custom defaultMemoize function to replicate behavior in older reselect versions\nfunction defaultMemoize(func, equalityCheck = isEqual) {\n  let lastArgs = null;\n  let lastResult = null;\n  return (...args) => {\n    if (\n      lastArgs !== null &&\n      args.length === lastArgs.length &&\n      args.every((value, index) => equalityCheck(value, lastArgs[index]))\n    ) {\n      return lastResult;\n    }\n    lastArgs = args;\n    lastResult = func(...args);\n    return lastResult;\n  };\n}\n\nconst YEMEN_COORDINATES = {\n  'abyan': [45.83, 13.58],\n  'aden': [45.03, 12.77],\n  'al bayda': [45.57, 14.17],\n  'al dhale\\'e': [44.73, 13.70],\n  'al hudaydah': [42.95, 14.80],\n  'al jawf': [45.50, 16.60],\n  'al maharah': [51.83, 16.52],\n  'al mahwit': [43.55, 15.47],\n  'amanat al asimah': [44.21, 15.35],\n  'amran': [43.94, 15.66],\n  'dhamar': [44.24, 14.54],\n  'hadramaut': [48.78, 15.93],\n  'hajjah': [43.60, 15.63],\n  'ibb': [44.18, 13.97],\n  'lahj': [44.88, 13.03],\n  'marib': [45.32, 15.47],\n  'raymah': [43.71, 14.68],\n  'sana\\'a': [44.21, 15.35],\n  'shabwah': [47.01, 14.53],\n  'taizz': [44.02, 13.58],\n  'socotra': [53.87, 12.47]\n};\n\nconst createDeepEqualSelector = createSelectorCreator(\n  defaultMemoize,\n  isEqual\n);\n\nconst selectData = state => state.spatial?.data;\nconst selectUI = state => state.spatial?.ui;\nexport const selectStatus = state => state.spatial?.status;\n\nexport const selectLoadingStatus = createSelector(\n  [selectStatus],\n  (status) => ({\n    loading: status?.loading || false,\n    stage: status?.stage || '',\n    progress: status?.progress || 0\n  })\n);\n\nconst selectSpatialData = state => state.spatial?.data;\nconst selectSpatialStatus = state => state.spatial?.status;\nconst selectSpatialUI = state => state.spatial?.ui;\n\nconst selectSpatialState = createSelector(\n  [selectSpatialData, selectSpatialStatus, selectSpatialUI],\n  (data, status, ui) => ({ data, status, ui })\n);\n\nexport const selectStage = createSelector(\n  [selectSpatialState],\n  (spatial) => spatial?.status?.stage || 'idle'\n);\n\nexport const selectTimeSeriesData = createDeepEqualSelector(\n  [selectData],\n  (data) => data?.timeSeriesData || []\n);\n\nexport const selectGeometryData = createDeepEqualSelector(\n  [selectData],\n  (data) => data?.geometry || {}\n);\n\nexport const selectMarketIntegration = createDeepEqualSelector(\n  [selectData],\n  (data) => data?.marketIntegration || {}\n);\n\nexport const selectFlowMaps = createDeepEqualSelector(\n  [selectData],\n  (data) => data?.flowMaps || []\n);\n\nexport const selectSelectedDate = createSelector(\n  [selectUI],\n  (ui) => ui?.selectedDate || ''\n);\n\nexport const selectFilteredFlowData = createDeepEqualSelector(\n  [selectFlowMaps, selectSelectedDate],\n  (flowMaps, selectedDate) => {\n    if (!Array.isArray(flowMaps) || !selectedDate) return [];\n    const targetMonth = selectedDate.substring(0, 7);\n    return flowMaps.filter(flow => flow?.date?.substring(0, 7) === targetMonth);\n  }\n);\n\nexport const selectMarketMetrics = createDeepEqualSelector(\n  [selectFilteredFlowData],\n  (flows) => {\n    if (!flows.length) return {\n      totalFlows: 0,\n      averageFlow: 0,\n      maxFlow: 0,\n      activeMarkets: 0\n    };\n\n    const flowValues = flows.map(f => f.total_flow || 0);\n    const markets = new Set();\n    flows.forEach(f => {\n      markets.add(f.source);\n      markets.add(f.target);\n    });\n\n    return {\n      totalFlows: flowValues.reduce((sum, val) => sum + val, 0),\n      averageFlow: flowValues.reduce((sum, val) => sum + val, 0) / flowValues.length,\n      maxFlow: Math.max(...flowValues),\n      activeMarkets: markets.size\n    };\n  }\n);\n\nexport const convertUTMtoLatLng = (easting, northing) => {\n  const k0 = 0.9996;\n  const a = 6378137;\n  const e = 0.081819191;\n  const e1sq = 0.006739497;\n  const falseEasting = 500000;\n  const zone = 38;\n\n  const x = easting - falseEasting;\n  const y = northing;\n\n  const M = y / k0;\n  const mu = M / (a * (1 - e * e / 4 - 3 * e * e * e * e / 64));\n\n  const phi1 = mu + (3 * e1sq / 2 - 27 * Math.pow(e1sq, 3) / 32) * Math.sin(2 * mu);\n  const phi2 = phi1 + (21 * Math.pow(e1sq, 2) / 16 - 55 * Math.pow(e1sq, 4) / 32) * Math.sin(4 * mu);\n  const phi = phi2 + (151 * Math.pow(e1sq, 3) / 96) * Math.sin(6 * mu);\n\n  const N1 = a / Math.sqrt(1 - e * e * Math.sin(phi) * Math.sin(phi));\n  const T1 = Math.tan(phi) * Math.tan(phi);\n  const C1 = (e * e * Math.cos(phi) * Math.cos(phi)) / (1 - e * e);\n  const R1 = (a * (1 - e * e)) / Math.pow(1 - e * e * Math.sin(phi) * Math.sin(phi), 1.5);\n  const D = x / (N1 * k0);\n\n  const lat = phi - (N1 * Math.tan(phi) / R1) * (\n    (D * D) / 2 -\n    (5 + 3 * T1 + 10 * C1 - 4 * Math.pow(C1, 2) - 9 * e * e) * Math.pow(D, 4) / 24 +\n    (61 + 90 * T1 + 298 * C1 + 45 * Math.pow(T1, 2) - 252 * e * e - 3 * Math.pow(C1, 2)) * Math.pow(D, 6) / 720\n  );\n  const lon = ((zone * 6 - 183) + (D - (1 + 2 * T1 + C1) * Math.pow(D, 3) / 6 +\n    (5 - 2 * C1 + 28 * T1 - 3 * Math.pow(C1, 2) + 8 * e * e + 24 * Math.pow(T1, 2)) * Math.pow(D, 5) / 120)\n  ) / Math.cos(phi) * (180 / Math.PI);\n\n  return [lon, lat];\n};\n\nconst validateCoordinates = (coords) => {\n  if (!Array.isArray(coords) || coords.length !== 2) {\n    return null;\n  }\n  \n  const [lon, lat] = coords;\n  if (typeof lon !== 'number' || typeof lat !== 'number' ||\n      isNaN(lon) || isNaN(lat) ||\n      Math.abs(lat) > 90 || Math.abs(lon) > 180) {\n    return null;\n  }\n  return [lon, lat];\n};\n\nconst calculateVolatility = (values) => {\n  if (values.length < 2) return 0;\n  try {\n    const returns = [];\n    for (let i = 1; i < values.length; i++) {\n      if (values[i-1] > 0) {\n        returns.push(Math.log(values[i] / values[i-1]));\n      }\n    }\n    if (!returns.length) return 0;\n    const meanReturn = _.mean(returns);\n    const variance = _.meanBy(returns, r => Math.pow(r - meanReturn, 2));\n    return Math.sqrt(variance);\n  } catch {\n    return 0;\n  }\n};\n\nconst calculateDistance = (coord1, coord2) => {\n  if (!coord1 || !coord2) return 0;\n  \n  const [lon1, lat1] = coord1;\n  const [lon2, lat2] = coord2;\n  \n  const R = 6371;\n  const toRad = (deg) => deg * Math.PI / 180;\n  \n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  \n  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n           Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * \n           Math.sin(dLon/2) * Math.sin(dLon/2);\n           \n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  return R * c;\n};\n\nconst calculateAverageDistance = (coordinates) => {\n  if (coordinates.length < 2) return 0;\n  try {\n    let totalDistance = 0;\n    let count = 0;\n    for (let i = 0; i < coordinates.length; i++) {\n      for (let j = i + 1; j < coordinates.length; j++) {\n        const dist = calculateDistance(coordinates[i], coordinates[j]);\n        if (typeof dist === 'number' && !isNaN(dist)) {\n          totalDistance += dist;\n          count++;\n        }\n      }\n    }\n    return count > 0 ? totalDistance / count : 0;\n  } catch {\n    return 0;\n  }\n};\n\nconst selectUiState = createSelector(\n  [selectSpatialState],\n  (spatial) => spatial?.ui || {}\n);\n\nexport const selectVisualizationMode = createSelector(\n  [selectSpatialUI],\n  (ui) => ui?.visualizationMode || 'prices'\n);\n\nexport const selectSelectedCommodity = createSelector(\n  [selectSpatialUI],\n  (ui) => ui?.selectedCommodity || ''\n);\n\nexport const selectUnifiedGeometry = createSelector(\n  [selectGeometryData],\n  (geometry) => {\n    try {\n      if (!geometry?.unified) return null;\n      return {\n        type: 'FeatureCollection',\n        features: Array.isArray(geometry.unified) ? geometry.unified : [],\n        properties: {\n          type: 'unified',\n          timestamp: Date.now()\n        }\n      };\n    } catch {\n      return null;\n    }\n  }\n);\n\nexport const selectMarketClusters = createSelector(\n  [selectSpatialData],\n  (data) => {\n    try {\n      if (!data || !Array.isArray(data.marketClusters)) {\n        return [];\n      }\n      return data.marketClusters.map(cluster => {\n        const metrics = cluster.metrics || {};\n        return {\n          ...cluster,\n          metrics: {\n            marketCount: cluster.connected_markets?.length || 0,\n            avgPrice: typeof metrics.avgPrice === 'number' ? metrics.avgPrice : 0,\n            avgConflict: typeof metrics.avgConflict === 'number' ? metrics.avgConflict : 0,\n            efficiency: typeof metrics.efficiency === 'number' ? metrics.efficiency : 0,\n            efficiencyComponents: {\n              connectivity: typeof metrics.efficiencyComponents?.connectivity === 'number' ?\n                metrics.efficiencyComponents.connectivity : 0,\n              priceIntegration: typeof metrics.efficiencyComponents?.priceIntegration === 'number' ?\n                metrics.efficiencyComponents.priceIntegration : 0,\n              stability: typeof metrics.efficiencyComponents?.stability === 'number' ?\n                metrics.efficiencyComponents.stability : 0,\n              conflictResilience: typeof metrics.efficiencyComponents?.conflictResilience === 'number' ?\n                metrics.efficiencyComponents.conflictResilience : 0\n            },\n            internal_connectivity: typeof metrics.internal_connectivity === 'number' ? metrics.internal_connectivity : 0,\n            market_coverage: typeof metrics.market_coverage === 'number' ? metrics.market_coverage : 0,\n            price_convergence: typeof metrics.price_convergence === 'number' ? metrics.price_convergence : 0\n          }\n        };\n      });\n    } catch {\n      return [];\n    }\n  }\n);\n\nexport const selectMarketFlows = createSelector(\n  [selectSpatialData],\n  (data) => {\n    try {\n      if (!data || !Array.isArray(data.flowMaps)) {\n        return [];\n      }\n      return data.flowMaps.map(flow => ({\n        ...flow,\n        source: flow.source || '',\n        target: flow.target || '',\n        total_flow: typeof flow.total_flow === 'number' ? flow.total_flow : 0,\n        avg_flow: typeof flow.avg_flow === 'number' ? flow.avg_flow : 0,\n        flow_count: typeof flow.flow_count === 'number' ? flow.flow_count : 0,\n        avg_price_differential: typeof flow.avg_price_differential === 'number' ? flow.avg_price_differential : 0\n      }));\n    } catch {\n      return [];\n    }\n  }\n);\n\nexport const selectSpatialAutocorrelation = createSelector(\n  [selectSpatialData],\n  (data) => {\n    try {\n      if (!data || !data.spatialAutocorrelation) {\n        return {\n          global: { moran_i: 0, p_value: 1, z_score: null, significance: false },\n          local: {}\n        };\n      }\n      const autocorr = data.spatialAutocorrelation;\n      return {\n        global: {\n          moran_i: typeof autocorr.global?.moran_i === 'number' ? autocorr.global.moran_i : 0,\n          p_value: typeof autocorr.global?.p_value === 'number' ? autocorr.global.p_value : 1,\n          z_score: autocorr.global?.z_score || null,\n          significance: Boolean(autocorr.global?.significance)\n        },\n        local: Object.entries(autocorr.local || {}).reduce((acc, [key, value]) => {\n          acc[key] = {\n            local_i: typeof value.local_i === 'number' ? value.local_i : 0,\n            p_value: typeof value.p_value === 'number' ? value.p_value : 1,\n            cluster_type: value.cluster_type || 'not-significant',\n            z_score: typeof value.z_score === 'number' ? value.z_score : 0\n          };\n          return acc;\n        }, {})\n      };\n    } catch {\n      return {\n        global: { moran_i: 0, p_value: 1, z_score: null, significance: false },\n        local: {}\n      };\n    }\n  }\n);\n\nexport const selectRegressionAnalysis = createSelector(\n  [selectSpatialData, selectSelectedCommodity],\n  (data, selectedCommodity) => {\n    try {\n      if (!data || !data.regressionAnalysis) return null;\n      const regression = data.regressionAnalysis;\n      const metadata = regression.metadata || {};\n      \n      // If selectedCommodity is empty but we have regression data, use the data's commodity\n      const effectiveCommodity = selectedCommodity || metadata.commodity || 'beans (kidney red)';\n      \n      // Only return null if we have a non-empty selectedCommodity that doesn't match\n      if (selectedCommodity && metadata.commodity !== selectedCommodity) {\n        return null;\n      }\n\n      return {\n        model: regression.model || {},\n        spatial: {\n          moran_i: regression.spatial?.moran_i || { I: 0, 'p-value': 1 },\n          vif: Array.isArray(regression.spatial?.vif) ? regression.spatial.vif : []\n        },\n        residuals: {\n          raw: Array.isArray(regression.residuals?.raw) ? regression.residuals.raw : [],\n          byRegion: regression.residuals?.byRegion || {},\n          stats: {\n            mean: typeof regression.residuals?.stats?.mean === 'number' ? regression.residuals.stats.mean : 0,\n            variance: typeof regression.residuals?.stats?.variance === 'number' ? regression.residuals.stats.variance : 0,\n            maxAbsolute: typeof regression.residuals?.stats?.maxAbsolute === 'number' ? regression.residuals.stats.maxAbsolute : 0\n          }\n        },\n        metadata: {\n          ...metadata,\n          commodity: effectiveCommodity,\n          timestamp: metadata.timestamp || new Date().toISOString(),\n          version: metadata.version || \"1.0\"\n        }\n      };\n    } catch {\n      return {\n        model: {},\n        spatial: { moran_i: { I: 0, 'p-value': 1 }, vif: [] },\n        residuals: { raw: [], byRegion: {}, stats: { mean: 0, variance: 0, maxAbsolute: 0 } },\n        metadata: {\n          commodity: selectedCommodity || 'beans (kidney red)',\n          timestamp: new Date().toISOString(),\n          version: \"1.0\"\n        }\n      };\n    }\n  }\n);\n\nexport const selectSeasonalAnalysis = createSelector(\n  [selectSpatialData],\n  (data) => {\n    try {\n      if (!data || !data.seasonalAnalysis) {\n        return {\n          seasonal_strength: 0,\n          trend_strength: 0,\n          peak_month: 0,\n          trough_month: 0,\n          seasonal_pattern: []\n        };\n      }\n      const seasonal = data.seasonalAnalysis;\n      return {\n        seasonal_strength: typeof seasonal.seasonal_strength === 'number' ? seasonal.seasonal_strength : 0,\n        trend_strength: typeof seasonal.trend_strength === 'number' ? seasonal.trend_strength : 0,\n        peak_month: seasonal.peak_month || 0,\n        trough_month: seasonal.trough_month || 0,\n        seasonal_pattern: Array.isArray(seasonal.seasonal_pattern) ? seasonal.seasonal_pattern : []\n      };\n    } catch {\n      return {\n        seasonal_strength: 0,\n        trend_strength: 0,\n        peak_month: 0,\n        trough_month: 0,\n        seasonal_pattern: []\n      };\n    }\n  }\n);\n\nexport const selectMarketShocks = createSelector(\n  [selectSpatialData],\n  (data) => {\n    try {\n      if (!data || !Array.isArray(data.marketShocks)) {\n        return [];\n      }\n      return data.marketShocks.map(shock => ({\n        ...shock,\n        region: shock.region || '',\n        date: shock.date || '',\n        shock_type: shock.shock_type || '',\n        magnitude: typeof shock.magnitude === 'number' ? shock.magnitude : 0,\n        current_price: typeof shock.current_price === 'number' ? shock.current_price : 0,\n        previous_price: typeof shock.previous_price === 'number' ? shock.previous_price : 0\n      }));\n    } catch {\n      return [];\n    }\n  }\n);\n\nfunction calculateSpatialDispersion(coordinates) {\n  if (!coordinates?.length || coordinates.length < 2) return 0;\n  try {\n    const center = calculateCenter(coordinates);\n    if (!center) return 0;\n    const distances = coordinates.map(coord => calculateDistance(coord, center));\n    return Math.sqrt(\n      distances.reduce((sum, dist) => sum + Math.pow(dist, 2), 0) / distances.length\n    );\n  } catch {\n    return 0;\n  }\n}\n\nfunction calculateBoundingBox(coordinates) {\n  if (!coordinates?.length) return null;\n  try {\n    return coordinates.reduce((bounds, coord) => ({\n      minLon: Math.min(bounds.minLon, coord[0]),\n      maxLon: Math.max(bounds.maxLon, coord[0]),\n      minLat: Math.min(bounds.minLat, coord[1]),\n      maxLat: Math.max(bounds.maxLat, coord[1])\n    }), {\n      minLon: Infinity,\n      maxLon: -Infinity,\n      minLat: Infinity,\n      maxLat: -Infinity\n    });\n  } catch {\n    return null;\n  }\n}\n\nexport const selectClustersWithCoordinates = createSelector(\n  [selectMarketClusters, selectGeometryData],\n  (clusters, geometry) => {\n    try {\n      if (!clusters?.length || !geometry?.points) {\n        return [];\n      }\n\n      const coordMap = new Map();\n      geometry.points.forEach(point => {\n        const normalizedName = transformRegionName(\n          point.properties?.normalizedName || \n          point.properties?.region_id || \n          point.properties?.name\n        );\n        if (normalizedName && Array.isArray(point.coordinates)) {\n          coordMap.set(normalizedName, validateCoordinates(point.coordinates));\n        }\n      });\n\n      return clusters.map(cluster => {\n        const marketCoords = (cluster.connected_markets || [])\n          .map(market => {\n            const normalizedName = transformRegionName(market);\n            const coordinates = coordMap.get(normalizedName) || \n                                getRegionCoordinates(normalizedName);\n            return {\n              name: market,\n              normalizedName,\n              coordinates,\n              isMainMarket: market === cluster.main_market\n            };\n          })\n          .filter(m => m.coordinates);\n\n        const center = calculateCenter(marketCoords.map(m => m.coordinates));\n        const avgDistance = calculateAverageDistance(marketCoords.map(m => m.coordinates));\n        const spatialCoverage = cluster.connected_markets.length ? \n          marketCoords.length / cluster.connected_markets.length : 0;\n\n        return {\n          ...cluster,\n          cluster_id: cluster.cluster_id,\n          main_market: cluster.main_market,\n          connected_markets: cluster.connected_markets,\n          markets: marketCoords,\n          center: center || [0, 0],\n          metrics: {\n            efficiency: typeof cluster.metrics?.efficiency === 'number' ? cluster.metrics.efficiency : 0,\n            efficiencyComponents: {\n              connectivity: typeof cluster.metrics?.efficiencyComponents?.connectivity === 'number' ?\n                cluster.metrics.efficiencyComponents.connectivity : 0,\n              priceIntegration: typeof cluster.metrics?.efficiencyComponents?.priceIntegration === 'number' ?\n                cluster.metrics.efficiencyComponents.priceIntegration : 0,\n              stability: typeof cluster.metrics?.efficiencyComponents?.stability === 'number' ?\n                cluster.metrics.efficiencyComponents.stability : 0,\n              conflictResilience: typeof cluster.metrics?.efficiencyComponents?.conflictResilience === 'number' ?\n                cluster.metrics.efficiencyComponents.conflictResilience : 0\n            },\n            marketCount: cluster.connected_markets?.length || 0,\n            avgPrice: typeof cluster.metrics?.avgPrice === 'number' ? \n              cluster.metrics.avgPrice : 0,\n            avgConflict: typeof cluster.metrics?.avgConflict === 'number' ? \n              cluster.metrics.avgConflict : 0,\n            internal_connectivity: typeof cluster.metrics?.internal_connectivity === 'number' ? \n              cluster.metrics.internal_connectivity : 0,\n            market_coverage: typeof cluster.metrics?.market_coverage === 'number' ? \n              cluster.metrics.market_coverage : 0,\n            price_convergence: typeof cluster.metrics?.price_convergence === 'number' ? \n              cluster.metrics.price_convergence : 0,\n            priceVolatility: typeof cluster.metrics?.priceVolatility === 'number' ?\n              cluster.metrics.priceVolatility : 0,\n            priceRange: typeof cluster.metrics?.priceRange === 'number' ?\n              cluster.metrics.priceRange : 0,\n            minPrice: typeof cluster.metrics?.minPrice === 'number' ?\n              cluster.metrics.minPrice : 0,\n            maxPrice: typeof cluster.metrics?.maxPrice === 'number' ?\n              cluster.metrics.maxPrice : 0,\n            flowDensity: typeof cluster.metrics?.flowDensity === 'number' ?\n              cluster.metrics.flowDensity : 0,\n            avgFlowStrength: typeof cluster.metrics?.avgFlowStrength === 'number' ?\n              cluster.metrics.avgFlowStrength : 0,\n            totalFlows: typeof cluster.metrics?.totalFlows === 'number' ?\n              cluster.metrics.totalFlows : 0,\n            spatial_coverage: spatialCoverage,\n            avg_distance: avgDistance,\n            spatial_metrics: {\n              centerLat: center ? center[1] : 0,\n              centerLon: center ? center[0] : 0,\n              boundingBox: calculateBoundingBox(marketCoords.map(m => m.coordinates)),\n              marketDensity: marketCoords.length / (avgDistance || 1),\n              spatialDispersion: calculateSpatialDispersion(marketCoords.map(m => m.coordinates))\n            },\n            timeSeriesCompleteness: typeof cluster.metrics?.timeSeriesCompleteness === 'number' ?\n              cluster.metrics.timeSeriesCompleteness : 0,\n            lastUpdateTimestamp: cluster.metrics?.lastUpdateTimestamp || null,\n            stabilityScore: typeof cluster.metrics?.stabilityScore === 'number' ?\n              cluster.metrics.stabilityScore : 0,\n            integrationScore: typeof cluster.metrics?.integrationScore === 'number' ?\n              cluster.metrics.integrationScore : 0,\n            performanceScore: typeof cluster.metrics?.performanceScore === 'number' ?\n              cluster.metrics.performanceScore : 0,\n            active: typeof cluster.metrics?.active === 'boolean' ?\n              cluster.metrics.active : true,\n            lastCalculated: cluster.metrics?.lastCalculated || new Date().toISOString(),\n            dataQualityScore: typeof cluster.metrics?.dataQualityScore === 'number' ?\n              cluster.metrics.dataQualityScore : 1\n          }\n        };\n      });\n    } catch {\n      return [];\n    }\n  }\n);\n\nexport const selectFeatureDataWithMetrics = createSelector(\n  [selectGeometryData, selectTimeSeriesData],\n  (geometry, timeSeriesData) => {\n    if (!geometry?.points || !Array.isArray(timeSeriesData)) {\n      return null;\n    }\n    try {\n      const timeSeriesByRegion = _.groupBy(timeSeriesData, 'region');\n      const regionalMetrics = Object.entries(timeSeriesByRegion).reduce((acc, [region, data]) => {\n        const prices = data.map(d => d.usdPrice).filter(p => typeof p === 'number');\n        const conflicts = data.map(d => d.conflictIntensity).filter(c => typeof c === 'number');\n        acc[region] = {\n          averagePrice: prices.length ? _.mean(prices) : 0,\n          priceVolatility: prices.length > 1 ? calculateVolatility(prices) : 0,\n          conflictIntensity: conflicts.length ? _.mean(conflicts) : 0,\n          dataPoints: data.length,\n          lastUpdate: data.reduce((latest, point) => {\n            const date = point.additionalProperties?.date;\n            return date && (!latest || new Date(date) > new Date(latest)) ? date : latest;\n          }, null)\n        };\n        return acc;\n      }, {});\n\n      const processedPoints = geometry.points.map(point => {\n        const regionId = transformRegionName(\n          point.properties?.normalizedName || \n          point.properties?.region_id || \n          point.properties?.name\n        );\n\n        return {\n          ...point,\n          properties: {\n            ...point.properties,\n            metrics: regionalMetrics[regionId] || {\n              averagePrice: 0,\n              priceVolatility: 0,\n              conflictIntensity: 0,\n              dataPoints: 0,\n              lastUpdate: null\n            },\n            region_id: regionId,\n            coordinates: validateCoordinates(point.coordinates)\n          }\n        };\n      });\n\n      return {\n        points: processedPoints,\n        metrics: regionalMetrics,\n        timestamp: Date.now()\n      };\n    } catch {\n      return null;\n    }\n  }\n);\n\nexport const selectAutocorrelationMetrics = createSelector(\n  [selectSpatialAutocorrelation],\n  (autocorrelation) => {\n    if (!autocorrelation?.local) return null;\n    try {\n      const clusters = Object.values(autocorrelation.local);\n      const clusterTypes = clusters.map(c => c.cluster_type);\n      return {\n        highHigh: clusterTypes.filter(t => t === 'high-high').length,\n        lowLow: clusterTypes.filter(t => t === 'low-low').length,\n        highLow: clusterTypes.filter(t => t === 'high-low').length,\n        lowHigh: clusterTypes.filter(t => t === 'low-high').length,\n        notSignificant: clusterTypes.filter(t => t === 'not-significant').length,\n        totalClusters: clusters.length,\n        globalIndex: autocorrelation.global?.moran_i || 0,\n        significance: autocorrelation.global?.p_value < 0.05\n      };\n    } catch {\n      return {\n        highHigh: 0,\n        lowLow: 0,\n        highLow: 0,\n        lowHigh: 0,\n        notSignificant: 0,\n        totalClusters: 0,\n        globalIndex: 0,\n        significance: false\n      };\n    }\n  }\n);\n\nconst calculateEnhancedMetrics = (clusters, flows, integration, autocorrelation) => {\n  try {\n    const clusterMetrics = clusters?.map(c => c.metrics) || [];\n    return {\n      marketEfficiency: {\n        average: _.meanBy(clusterMetrics, 'efficiency') || 0,\n        max: _.maxBy(clusterMetrics, 'efficiency')?.efficiency || 0,\n        min: _.minBy(clusterMetrics, 'efficiency')?.efficiency || 0\n      },\n      connectivity: {\n        flowDensity: integration?.flow_density || 0,\n        averageConnectivity: _.meanBy(clusterMetrics, 'internal_connectivity') || 0\n      },\n      spatial: {\n        globalMoransI: autocorrelation?.global?.moran_i || 0,\n        clusterCount: clusters?.length || 0,\n        significantClusters: Object.values(autocorrelation?.local || {})\n          .filter(c => c.p_value < 0.05).length\n      },\n      coverage: {\n        totalMarkets: _.sumBy(clusters, c => c.connected_markets?.length || 0),\n        averageCoverage: _.meanBy(clusterMetrics, 'market_coverage') || 0\n      }\n    };\n  } catch {\n    return {\n      marketEfficiency: { average: 0, max: 0, min: 0 },\n      connectivity: { flowDensity: 0, averageConnectivity: 0 },\n      spatial: { globalMoransI: 0, clusterCount: 0, significantClusters: 0 },\n      coverage: { totalMarkets: 0, averageCoverage: 0 }\n    };\n  }\n};\n\nconst getDefaultMetrics = () => ({\n  marketEfficiency: { average: 0, max: 0, min: 0 },\n  connectivity: { flowDensity: 0, averageConnectivity: 0 },\n  spatial: { globalMoransI: 0, clusterCount: 0, significantClusters: 0 },\n  coverage: { totalMarkets: 0, averageCoverage: 0 }\n});\n\nexport const selectVisualizationData = createSelector(\n  [selectFeatureDataWithMetrics, selectMarketFlows, selectMarketClusters],\n  (featureData, flows, clusters) => {\n    try {\n      const processedFlows = (flows || []).map(flow => ({\n        ...flow,\n        coordinates: {\n          source: getRegionCoordinates(flow.source),\n          target: getRegionCoordinates(flow.target)\n        },\n        normalized: {\n          source: transformRegionName(flow.source),\n          target: transformRegionName(flow.target)\n        }\n      }));\n\n      const processedClusters = (clusters || []).map(cluster => {\n        const marketCoords = (cluster.connected_markets || [])\n          .map(market => ({\n            name: market,\n            coordinates: getRegionCoordinates(market)\n          }))\n          .filter(m => m.coordinates);\n\n        return {\n          ...cluster,\n          markets: marketCoords,\n          center: calculateCenter(marketCoords.map(m => m.coordinates)) || [0, 0]\n        };\n      });\n\n      return {\n        features: featureData?.points || [],\n        flows: processedFlows,\n        clusters: processedClusters,\n        timestamp: Date.now()\n      };\n    } catch {\n      return {\n        features: [],\n        flows: [],\n        clusters: [],\n        timestamp: Date.now()\n      };\n    }\n  }\n);\n\nexport const selectSpatialDataOptimized = createSelector(\n  [\n    selectUnifiedGeometry,\n    selectMarketClusters,\n    selectMarketFlows,\n    selectTimeSeriesData,\n    selectMarketShocks,\n    selectMarketIntegration,\n    selectSpatialAutocorrelation,\n    selectRegressionAnalysis,\n    selectSeasonalAnalysis,\n  ],\n  (\n    geometry,\n    clusters,\n    flows,\n    timeSeriesData,\n    shocks,\n    integration,\n    autocorrelation,\n    regression,\n    seasonal\n  ) => {\n    try {\n      const spatial_analysis_results = Array.isArray(regression?.spatial_analysis_results)\n        ? regression.spatial_analysis_results.map(result => ({\n            ...result,\n            residual: Array.isArray(result.residual) ? result.residual : [],\n            coefficients: result.coefficients || {},\n            moran_i: result.moran_i || { I: null, 'p-value': null },\n          }))\n        : [];\n\n      const uniqueMonths = timeSeriesData\n        ? _.uniq(timeSeriesData.map(d => d.month))\n            .filter(Boolean)\n            .sort((a, b) => new Date(a) - new Date(b))\n        : [];\n\n      const metrics = calculateEnhancedMetrics(\n        clusters,\n        flows,\n        integration,\n        autocorrelation\n      );\n\n      return {\n        geometry,\n        marketClusters: clusters,\n        flowMaps: flows,\n        timeSeriesData,\n        marketShocks: shocks,\n        marketIntegration: integration,\n        spatialAutocorrelation: autocorrelation,\n        regressionAnalysis: {\n          ...regression,\n          spatial_analysis_results\n        },\n        seasonalAnalysis: seasonal,\n        uniqueMonths,\n        metrics,\n        timestamp: Date.now()\n      };\n    } catch {\n      return {\n        geometry: null,\n        marketClusters: [],\n        flowMaps: [],\n        timeSeriesData: [],\n        marketShocks: [],\n        marketIntegration: { price_correlation: {}, flow_density: 0 },\n        spatialAutocorrelation: { global: { moran_i: 0 }, local: {} },\n        regressionAnalysis: { model: {}, residuals: [], spatial_analysis_results: [] },\n        seasonalAnalysis: { seasonal_pattern: [] },\n        uniqueMonths: [],\n        metrics: getDefaultMetrics(),\n        timestamp: Date.now()\n      };\n    }\n  }\n);\n\nexport const selectFlowsWithCoordinates = createSelector(\n  [selectMarketFlows, selectGeometryData],\n  (flows, geometry) => {\n    try {\n      if (!flows || !geometry?.points) {\n        return [];\n      }\n\n      const pointsMap = new Map();\n      geometry.points.forEach(point => {\n        const names = [\n          point.properties?.name,\n          point.properties?.normalizedName,\n          point.properties?.region_id\n        ].filter(Boolean).map(name => transformRegionName(name));\n        const coords = Array.isArray(point.coordinates) && point.coordinates.length === 2\n          ? point.coordinates\n          : getRegionCoordinates(names[0]);\n        names.forEach(name => {\n          if (name && !pointsMap.has(name)) {\n            pointsMap.set(name, coords ? validateCoordinates(coords) : null);\n          }\n        });\n      });\n\n      return flows.map(flow => {\n        const sourceNormalized = transformRegionName(flow.source);\n        const targetNormalized = transformRegionName(flow.target);\n\n        const sourceCoords = pointsMap.get(sourceNormalized) || getRegionCoordinates(flow.source);\n        const targetCoords = pointsMap.get(targetNormalized) || getRegionCoordinates(flow.target);\n\n        return {\n          ...flow,\n          source_normalized: sourceNormalized,\n          target_normalized: targetNormalized,\n          sourceCoordinates: sourceCoords || [0, 0],\n          targetCoordinates: targetCoords || [0, 0],\n          flow_strength: typeof flow.total_flow === 'number' ? flow.total_flow : 0,\n          price_differential: typeof flow.avg_price_differential === 'number' ? \n            flow.avg_price_differential : 0\n        };\n      });\n    } catch {\n      return [];\n    }\n  }\n);\n\nexport const utils = {\n  calculateDistance,\n  validateCoordinates,\n  calculateVolatility,\n  calculateAverageDistance,\n  calculateEnhancedMetrics,\n  getDefaultMetrics\n};\n\nexport { YEMEN_COORDINATES };\n\nexport default {\n  selectLoadingStatus,\n  selectStage,\n  selectTimeSeriesData,\n  selectGeometryData,\n  selectMarketIntegration,\n  selectFlowMaps,\n  selectSelectedDate,\n  selectFilteredFlowData,\n  selectMarketMetrics\n};\n",
        "imports": [
          "@reduxjs/toolkit",
          "reselect",
          "lodash/isEqual",
          "lodash",
          "../components/spatialAnalysis/utils/spatialUtils"
        ],
        "exports": [
          "selectStatus",
          "selectLoadingStatus",
          "selectStage",
          "selectTimeSeriesData",
          "selectGeometryData",
          "selectMarketIntegration",
          "selectFlowMaps",
          "selectSelectedDate",
          "selectFilteredFlowData",
          "selectMarketMetrics",
          "convertUTMtoLatLng",
          "selectVisualizationMode",
          "selectSelectedCommodity",
          "selectUnifiedGeometry",
          "selectMarketClusters",
          "selectMarketFlows",
          "selectSpatialAutocorrelation",
          "selectRegressionAnalysis",
          "selectSeasonalAnalysis",
          "selectMarketShocks",
          "selectClustersWithCoordinates",
          "selectFeatureDataWithMetrics",
          "selectAutocorrelationMetrics",
          "selectVisualizationData",
          "selectSpatialDataOptimized",
          "selectFlowsWithCoordinates",
          "utils",
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "reselect",
          "lodash/isEqual",
          "lodash",
          "../components/spatialAnalysis/utils/spatialUtils"
        ]
      },
      {
        "path": "selectors/spatialAnalysisSelectors.js",
        "content": "// src/selectors/spatialAnalysisSelectors.js\n\nimport { createSelector } from '@reduxjs/toolkit';\nimport {\n  selectTimeSeriesData,\n  selectMarketClusters,\n  selectGeometryData,\n  selectSpatialAutocorrelation as optimizedSelectSpatialAutocorrelation,\n  selectMarketShocks,\n  selectMarketFlows,\n  selectMarketIntegration,\n  selectSeasonalAnalysis\n} from './optimizedSelectors';\nimport { DEFAULT_METRICS, DEFAULT_OVERALL_METRICS } from '../components/spatialAnalysis/types';\n\n// Base selectors with memoization\nconst selectSpatialState = createSelector(\n  state => state.spatialAnalysis,\n  spatialAnalysis => spatialAnalysis || {}\n);\n\n// Time series data selector\nexport const selectTimeSeriesDataSelector = createSelector(\n  [selectSpatialState],\n  spatialState => spatialState.timeSeriesData || []\n);\n\n// Spatial autocorrelation selectors\nexport const selectSpatialAutocorrelationSelector = createSelector(\n  [selectSpatialState],\n  spatialState => spatialState.spatialAutocorrelation || {\n    global: null,\n    local: null\n  }\n);\n\n// Global Autocorrelation Selector\nexport const selectGlobalAutocorrelation = createSelector(\n  [selectSpatialAutocorrelationSelector],\n  autocorrelation => autocorrelation.global || {\n    moran_i: 0,\n    p_value: null,\n    z_score: null,\n    significance: false\n  }\n);\n\n// Local Autocorrelation Selector\nexport const selectLocalAutocorrelation = createSelector(\n  [selectSpatialAutocorrelationSelector],\n  autocorrelation => autocorrelation.local || {}\n);\n\n// Significant Clusters Selector\nexport const selectSignificantClusters = createSelector(\n  [selectLocalAutocorrelation],\n  local => {\n    const clusters = {\n      'high-high': [],\n      'low-low': [],\n      'high-low': [],\n      'low-high': [],\n      'not_significant': []\n    };\n\n    if (!local) return clusters;\n\n    Object.entries(local).forEach(([region, stats]) => {\n      const type = stats.cluster_type || 'not_significant';\n      clusters[type].push({\n        region,\n        ...stats\n      });\n    });\n\n    return clusters;\n  }\n);\n\n// Autocorrelation Summary Selector\nexport const selectAutocorrelationSummary = createSelector(\n  [selectGlobalAutocorrelation, selectLocalAutocorrelation],\n  (global, local) => {\n    const localCount = Object.keys(local).length;\n    const significantCount = Object.values(local).filter(\n      stats => stats.p_value && stats.p_value < 0.05\n    ).length;\n\n    return {\n      globalMoranI: global.moran_i,\n      globalSignificance: global.significance,\n      totalRegions: localCount,\n      significantRegions: significantCount,\n      significanceRate: localCount ? (significantCount / localCount) * 100 : 0\n    };\n  }\n);\n\n// Autocorrelation By Region Selector\nexport const selectAutocorrelationByRegion = createSelector(\n  [selectLocalAutocorrelation, (_, regionId) => regionId],\n  (local, regionId) => local[regionId] || null\n);\n\n// Cluster Analysis Selectors\nexport const selectEnhancedClusters = createSelector(\n  [selectMarketClusters, selectTimeSeriesDataSelector],\n  (clusters, timeSeriesData) => {\n    if (!clusters?.length || !timeSeriesData?.length) return [];\n\n    return clusters.map(cluster => {\n      const clusterData = timeSeriesData.filter(d => \n        cluster.connected_markets.includes(d.region)\n      );\n\n      if (!clusterData.length) {\n        return {\n          ...cluster,\n          metrics: DEFAULT_METRICS\n        };\n      }\n\n      const avgPrice = clusterData.reduce((sum, d) => sum + (d.usdPrice || 0), 0) / clusterData.length;\n      const avgConflict = clusterData.reduce((sum, d) => sum + (d.conflictIntensity || 0), 0) / clusterData.length;\n\n      return {\n        ...cluster,\n        metrics: {\n          avgPrice,\n          avgConflict,\n          marketCount: cluster.connected_markets.length\n        }\n      };\n    });\n  }\n);\n\n// Overall Metrics Selector\nexport const selectOverallMetrics = createSelector(\n  [selectEnhancedClusters],\n  (clusters) => {\n    if (!clusters?.length) return DEFAULT_OVERALL_METRICS;\n\n    const totalMarkets = clusters.reduce((sum, c) => sum + c.metrics.marketCount, 0);\n    const avgPrice = clusters.reduce((sum, c) => sum + c.metrics.avgPrice, 0) / clusters.length;\n    const avgConflict = clusters.reduce((sum, c) => sum + c.metrics.avgConflict, 0) / clusters.length;\n\n    return {\n      totalMarkets,\n      avgPrice,\n      avgConflict\n    };\n  }\n);\n\n// Cluster Analysis Data Selector\nexport const selectClusterAnalysisData = createSelector(\n  [selectEnhancedClusters, selectOverallMetrics, selectGeometryData],\n  (clusters, metrics, geometry) => ({\n    clusters,\n    metrics,\n    geometry\n  })\n);\n\n// Flow Analysis Selector\nexport const selectFlowAnalysisData = createSelector(\n  [selectMarketFlows, selectGeometryData],\n  (flows, geometry) => {\n    if (!flows?.length) return null;\n\n    const flowData = flows.map(flow => ({\n      source: flow.source,\n      target: flow.target,\n      totalFlow: flow.total_flow || flow.value,\n      avgFlow: flow.avg_flow || flow.average,\n      flowCount: flow.flow_count || flow.count,\n      avgPriceDifferential: flow.avg_price_differential || flow.priceDiff\n    }));\n\n    return {\n      flows: flowData,\n      geometry,\n      summary: {\n        totalFlows: flowData.length,\n        averageFlowStrength: flowData.reduce((sum, f) => sum + f.avgFlow, 0) / flowData.length,\n        maxFlow: Math.max(...flowData.map(f => f.totalFlow))\n      }\n    };\n  }\n);\n\n// Shock Analysis Selector\nexport const selectShockAnalysisData = createSelector(\n  [selectMarketShocks, selectGeometryData],\n  (shocks, geometry) => {\n    if (!shocks?.length) return null;\n\n    const shocksByType = shocks.reduce((acc, shock) => {\n      const type = shock.shock_type;\n      if (!acc[type]) acc[type] = [];\n      acc[type].push(shock);\n      return acc;\n    }, {});\n\n    return {\n      shocks,\n      shocksByType,\n      geometry,\n      summary: {\n        totalShocks: shocks.length,\n        priceDrops: shocks.filter(s => s.shock_type === 'price_drop').length,\n        priceSurges: shocks.filter(s => s.shock_type === 'price_surge').length,\n        averageMagnitude: shocks.reduce((sum, s) => sum + s.magnitude, 0) / shocks.length\n      }\n    };\n  }\n);\n\n// Conflict Analysis Selector\nexport const selectConflictAnalysisData = createSelector(\n  [selectTimeSeriesDataSelector, selectGeometryData],\n  (timeSeriesData, geometry) => {\n    if (!timeSeriesData?.length) return null;\n\n    const conflictData = timeSeriesData.reduce((acc, entry) => {\n      if (!acc[entry.region]) {\n        acc[entry.region] = {\n          intensities: [],\n          average: 0,\n          max: 0\n        };\n      }\n      acc[entry.region].intensities.push(entry.conflictIntensity || 0);\n      return acc;\n    }, {});\n\n    Object.keys(conflictData).forEach(region => {\n      const intensities = conflictData[region].intensities;\n      conflictData[region].average = intensities.reduce((sum, val) => sum + val, 0) / intensities.length;\n      conflictData[region].max = Math.max(...intensities);\n    });\n\n    return {\n      conflictData,\n      geometry,\n      summary: {\n        averageIntensity: Object.values(conflictData)\n          .reduce((sum, r) => sum + r.average, 0) / Object.keys(conflictData).length,\n        maxIntensity: Math.max(...Object.values(conflictData).map(r => r.max))\n      }\n    };\n  }\n);\n\n// Seasonal Analysis Selector\nexport const selectSeasonalAnalysisData = createSelector(\n  [selectTimeSeriesDataSelector],\n  (timeSeriesData) => {\n    if (!timeSeriesData?.length) return null;\n\n    const monthlyData = timeSeriesData.reduce((acc, entry) => {\n      const month = entry.month.split('-')[1];\n      if (!acc[month]) acc[month] = [];\n      acc[month].push(entry.usdPrice);\n      return acc;\n    }, {});\n\n    const monthlyStats = Object.entries(monthlyData).map(([month, prices]) => ({\n      month,\n      averagePrice: prices.reduce((sum, p) => sum + p, 0) / prices.length,\n      volatility: Math.sqrt(\n        prices.reduce((sum, p) => sum + Math.pow(p - (prices.reduce((a, b) => a + b, 0) / prices.length), 2), 0) / prices.length\n      ) / (prices.reduce((a, b) => a + b, 0) / prices.length)\n    }));\n\n    return {\n      monthlyStats,\n      summary: {\n        highestPriceMonth: monthlyStats.reduce((max, curr) => \n          curr.averagePrice > max.averagePrice ? curr : max\n        ),\n        lowestPriceMonth: monthlyStats.reduce((min, curr) => \n          curr.averagePrice < min.averagePrice ? curr : min\n        )\n      }\n    };\n  }\n);\n\n// Network Analysis Selector\nexport const selectNetworkAnalysisData = createSelector(\n  [selectMarketFlows, selectMarketClusters],\n  (flows, clusters) => {\n    if (!flows?.length || !clusters?.length) return null;\n\n    const nodes = clusters.map(cluster => ({\n      id: cluster.region,\n      label: cluster.main_market,\n      group: cluster.cluster_id,\n      markets: cluster.connected_markets.length\n    }));\n\n    const edges = flows.map(flow => ({\n      from: flow.source,\n      to: flow.target,\n      value: flow.total_flow || flow.value,\n      title: `Flow: ${(flow.total_flow || flow.value).toFixed(2)}`\n    }));\n\n    return {\n      network: { nodes, edges },\n      summary: {\n        nodes: nodes.length,\n        edges: edges.length,\n        density: nodes.length > 1 ? (2 * edges.length) / (nodes.length * (nodes.length - 1)) : 0\n      }\n    };\n  }\n);\n\n// Market Health Selector\nexport const selectMarketHealthData = createSelector(\n  [selectTimeSeriesDataSelector, selectMarketShocks, selectMarketFlows],\n  (timeSeriesData, shocks, flows) => {\n    if (!timeSeriesData?.length) return null;\n\n    const marketHealth = {};\n\n    timeSeriesData.forEach(entry => {\n      if (!marketHealth[entry.region]) {\n        marketHealth[entry.region] = {\n          prices: [],\n          shocks: 0,\n          flows: 0,\n          conflictIntensity: 0\n        };\n      }\n      marketHealth[entry.region].prices.push(entry.usdPrice);\n      marketHealth[entry.region].conflictIntensity = entry.conflictIntensity || 0;\n    });\n\n    shocks.forEach(shock => {\n      if (marketHealth[shock.region]) {\n        marketHealth[shock.region].shocks++;\n      }\n    });\n\n    flows.forEach(flow => {\n      if (marketHealth[flow.source]) marketHealth[flow.source].flows++;\n      if (marketHealth[flow.target]) marketHealth[flow.target].flows++;\n    });\n\n    Object.keys(marketHealth).forEach(region => {\n      const health = marketHealth[region];\n      const averagePrice = health.prices.reduce((sum, p) => sum + p, 0) / health.prices.length;\n      const variance = health.prices.reduce((sum, p) => sum + Math.pow(p - averagePrice, 2), 0) / health.prices.length;\n      const priceStability = 1 - (Math.sqrt(variance) / averagePrice);\n\n      marketHealth[region].healthScore = (\n        (priceStability * 0.4) +\n        ((health.shocks < 10 ? (1 - health.shocks / 10) : 0) * 0.3) +\n        ((health.flows / 10) * 0.2) +\n        ((1 - (health.conflictIntensity / 10)) * 0.1)\n      );\n    });\n\n    const totalRegions = Object.keys(marketHealth).length;\n    const totalHealth = Object.values(marketHealth).reduce((sum, m) => sum + m.healthScore, 0);\n    const averageHealth = totalRegions ? totalHealth / totalRegions : 0;\n    const healthyMarkets = Object.values(marketHealth).filter(m => m.healthScore > 0.7).length;\n\n    return {\n      marketHealth,\n      summary: {\n        averageHealth,\n        healthyMarkets\n      }\n    };\n  }\n);\n\n// Export default object with all selectors\nexport default {\n  // Base Selectors\n  selectSpatialState,\n  selectTimeSeriesData: selectTimeSeriesDataSelector,\n  selectSpatialAutocorrelation: selectSpatialAutocorrelationSelector,\n\n  // Cluster Analysis\n  selectEnhancedClusters,\n  selectOverallMetrics,\n  selectClusterAnalysisData,\n\n  // Spatial Autocorrelation\n  selectGlobalAutocorrelation,\n  selectLocalAutocorrelation,\n  selectAutocorrelationByRegion,\n  selectSignificantClusters,\n  selectAutocorrelationSummary,\n\n  // Flow Analysis\n  selectFlowAnalysisData,\n\n  // Shock Analysis\n  selectShockAnalysisData,\n\n  // Conflict Analysis\n  selectConflictAnalysisData,\n\n  // Seasonal Analysis\n  selectSeasonalAnalysisData,\n\n  // Network Analysis\n  selectNetworkAnalysisData,\n\n  // Market Health\n  selectMarketHealthData,\n\n  // Re-exported Selectors from analysisSelectors (ensure no duplicates)\n  // Add them here only if they are NOT defined above\n  // Example:\n  // someOtherSelector: analysisSelectSomeOtherSelector,\n};\n",
        "imports": [
          "@reduxjs/toolkit",
          "./optimizedSelectors",
          "../components/spatialAnalysis/types"
        ],
        "exports": [
          "selectTimeSeriesDataSelector",
          "selectSpatialAutocorrelationSelector",
          "selectGlobalAutocorrelation",
          "selectLocalAutocorrelation",
          "selectSignificantClusters",
          "selectAutocorrelationSummary",
          "selectAutocorrelationByRegion",
          "selectEnhancedClusters",
          "selectOverallMetrics",
          "selectClusterAnalysisData",
          "selectFlowAnalysisData",
          "selectShockAnalysisData",
          "selectConflictAnalysisData",
          "selectSeasonalAnalysisData",
          "selectNetworkAnalysisData",
          "selectMarketHealthData",
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "./optimizedSelectors",
          "../components/spatialAnalysis/types"
        ]
      },
      {
        "path": "setupPolyfills.js",
        "content": "console.log('Loading polyfills...');\n\n// Set up setImmediate polyfill\nif (!global.setImmediate) {\n  global.setImmediate = (callback, ...args) => setTimeout(callback, 0, ...args);\n}\n\n// Set up clearImmediate polyfill\nif (!global.clearImmediate) {\n  global.clearImmediate = id => clearTimeout(id);\n}\n\nconsole.log('Polyfills loaded successfully');\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "setupTests.js",
        "content": "// src/setupTests.js\nimport '@testing-library/jest-dom';\nimport 'jest-styled-components';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\n// Mock react-router-dom\njest.mock('react-router-dom', () => ({\n  ...jest.requireActual('react-router-dom'),\n  Link: ({ children, to }) => <a href={to}>{children}</a>\n}));\n\n// Mock react-icons\njest.mock('react-icons/fa', () => ({\n  FaChartBar: () => <span data-testid=\"chart-icon\" />,\n  FaDollarSign: () => <span data-testid=\"dollar-icon\" />,\n  FaMapMarkedAlt: () => <span data-testid=\"map-icon\" />,\n}));\n",
        "imports": [
          "@testing-library/jest-dom",
          "jest-styled-components",
          "prop-types",
          "react"
        ],
        "exports": [],
        "dependencies": [
          "@testing-library/jest-dom",
          "jest-styled-components",
          "prop-types",
          "react"
        ]
      },
      {
        "path": "slices/ecmSlice.js",
        "content": "import { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';\nimport { createSelectorCreator, lruMemoize } from 'reselect';\nimport _ from 'lodash';\nimport { getDataPath } from '../utils/dataUtils';\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\n\nconst createDeepEqualSelector = createSelectorCreator(\n  lruMemoize,\n  _.isEqual\n);\n\nexport const initialState = {\n  data: {\n    unified: [],\n    directional: {\n      northToSouth: [],\n      southToNorth: []\n    },\n    residuals: null,\n    commodities: [],\n    cache: {}\n  },\n  status: {\n    loading: false,\n    error: null,\n    lastUpdated: null,\n    retryCount: 0\n  },\n  ui: {\n    selectedCommodity: null,\n    selectedRegime: 'unified',\n    selectedDirection: 'northToSouth'\n  }\n};\n\nexport const fetchECMData = createAsyncThunk(\n  'ecm/fetchData',\n  async ({ commodity }, { rejectWithValue }) => {\n    const metric = backgroundMonitor.startMetric('ecm-data-fetch');\n    try {\n      const paths = {\n        unified: getDataPath('ecm/ecm_analysis_results.json'),\n        northToSouth: getDataPath('ecm/ecm_results_north_to_south.json'),\n        southToNorth: getDataPath('ecm/ecm_results_south_to_north.json')\n      };\n\n      const [unifiedData, northToSouthData, southToNorthData] = await Promise.all([\n        fetch(paths.unified).then(r => r.json()),\n        fetch(paths.northToSouth).then(r => r.json()),\n        fetch(paths.southToNorth).then(r => r.json())\n      ]);\n\n      metric.finish({ status: 'success' });\n\n      return {\n        unified: unifiedData,\n        directional: {\n          northToSouth: northToSouthData,\n          southToNorth: southToNorthData\n        }\n      };\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nconst ecmSlice = createSlice({\n  name: 'ecm',\n  initialState,\n  reducers: {\n    setSelectedCommodity(state, action) {\n      state.ui.selectedCommodity = action.payload;\n    },\n    setSelectedRegime(state, action) {\n      state.ui.selectedRegime = action.payload;\n    },\n    setSelectedDirection(state, action) {\n      state.ui.selectedDirection = action.payload;\n    },\n    clearCache(state) {\n      state.data.cache = {};\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchECMData.pending, (state) => {\n        state.status.loading = true;\n        state.status.error = null;\n      })\n      .addCase(fetchECMData.fulfilled, (state, action) => {\n        state.data.unified = action.payload.unified;\n        state.data.directional.northToSouth = action.payload.directional.northToSouth;\n        state.data.directional.southToNorth = action.payload.directional.southToNorth;\n        state.status.loading = false;\n        state.status.error = null;\n        state.status.lastUpdated = new Date().toISOString();\n      })\n      .addCase(fetchECMData.rejected, (state, action) => {\n        state.status.loading = false;\n        state.status.error = action.payload;\n      });\n  }\n});\n\nconst selectECMState = state => state?.ecm || initialState;\nconst selectECMData = state => state?.ecm?.data || initialState.data;\nconst selectECMStatus = state => state?.ecm?.status || initialState.status;\nconst selectECMUI = state => state?.ecm?.ui || initialState.ui;\n\nexport const selectLoadingStatus = createSelector(\n  [selectECMStatus],\n  status => status.loading\n);\n\nexport const selectError = createSelector(\n  [selectECMStatus],\n  status => status.error\n);\n\nexport const selectUnifiedData = createDeepEqualSelector(\n  [selectECMData],\n  data => data.unified || []\n);\n\nexport const selectDirectionalData = createDeepEqualSelector(\n  [selectECMData],\n  data => ({\n    northToSouth: data.directional.northToSouth || [],\n    southToNorth: data.directional.southToNorth || []\n  })\n);\n\nexport const selectECMMetrics = createDeepEqualSelector(\n  [selectUnifiedData, selectDirectionalData, selectECMUI],\n  (unifiedData, directionalData, ui) => {\n    let data;\n    if (ui.selectedRegime === 'unified') {\n      data = unifiedData;\n    } else {\n      data = directionalData[ui.selectedDirection];\n    }\n\n    if (!data?.length || !ui.selectedCommodity) return null;\n\n    const selectedData = data.find(item => \n      item.commodity?.toLowerCase() === ui.selectedCommodity?.toLowerCase()\n    );\n    \n    if (!selectedData) return null;\n\n    return {\n      alpha: selectedData.alpha,\n      beta: selectedData.beta,\n      gamma: selectedData.gamma,\n      diagnostics: selectedData.diagnostics,\n      spatialAutocorrelation: selectedData.spatial_autocorrelation,\n      aic: selectedData.aic,\n      bic: selectedData.bic,\n      hqic: selectedData.hqic\n    };\n  }\n);\n\nexport const {\n  setSelectedCommodity,\n  setSelectedRegime,\n  setSelectedDirection,\n  clearCache\n} = ecmSlice.actions;\n\nexport default ecmSlice.reducer;",
        "imports": [
          "@reduxjs/toolkit",
          "reselect",
          "lodash",
          "../utils/dataUtils",
          "../utils/backgroundMonitor"
        ],
        "exports": [
          "initialState",
          "fetchECMData",
          "selectLoadingStatus",
          "selectError",
          "selectUnifiedData",
          "selectDirectionalData",
          "selectECMMetrics",
          null,
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "reselect",
          "lodash",
          "../utils/dataUtils",
          "../utils/backgroundMonitor"
        ]
      },
      {
        "path": "slices/flowSlice.js",
        "content": "// src/slices/flowSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { createSelector } from 'reselect';\nimport Papa from 'papaparse';\nimport _ from 'lodash';\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\nimport { convertUTMtoLatLng } from '../utils/coordinateUtils';\nimport { \n  getNetworkDataPath, \n  enhancedFetchJson, \n  retryWithBackoff \n} from '../utils/dataUtils';\n\n// Date format utilities\nconst dateUtils = {\n  // Convert YYYY-MM to YYYY-MM-DD\n  toFlowDate: (date) => {\n    if (!date) return null;\n    return date.length === 7 ? `${date}-01` : date;\n  },\n  // Convert YYYY-MM-DD to YYYY-MM\n  toSpatialDate: (date) => {\n    if (!date) return null;\n    return date.substring(0, 7);\n  },\n  // Check if dates match (ignoring day)\n  datesMatch: (date1, date2) => {\n    if (!date1 || !date2) return false;\n    return date1.substring(0, 7) === date2.substring(0, 7);\n  }\n};\n\n// Initial state\nconst initialState = {\n  flows: [],\n  byDate: {},\n  byRegion: {},\n  metadata: {\n    lastUpdated: null,\n    dateRange: {\n      start: null,\n      end: null\n    },\n    commodity: null,\n    totalFlows: 0,\n    uniqueMarkets: 0,\n    dataQuality: {\n      validFlows: 0,\n      invalidFlows: 0,\n      processingErrors: []\n    }\n  },\n  status: {\n    loading: false,\n    error: null,\n    lastFetch: null,\n    loadedData: {},\n    processingProgress: 0\n  }\n};\n\n// Validation utilities\nconst flowValidation = {\n  isValidFlow: (flow) => {\n    return flow &&\n      typeof flow.source === 'string' &&\n      typeof flow.target === 'string' &&\n      typeof flow.flow_weight === 'number' &&\n      !isNaN(flow.flow_weight) &&\n      flow.flow_weight >= 0;\n  },\n  isValidDate: (date) => {\n    if (!date) return false;\n    const parsed = new Date(date);\n    return parsed instanceof Date && !isNaN(parsed);\n  }\n};\n\n// Async thunk for loading flow data\nexport const fetchFlowData = createAsyncThunk(\n  'flow/fetchData',\n  async ({ commodity, date }, { getState, rejectWithValue, dispatch }) => {\n    const metric = backgroundMonitor.startMetric('flow-data-fetch');\n    const errors = [];\n    \n    try {\n      // Ensure date is in YYYY-MM-DD format for flow data\n      const flowDate = dateUtils.toFlowDate(date);\n      \n      if (!commodity || !flowDate) {\n        throw new Error('Invalid parameters', { commodity, date });\n      }\n\n      console.debug('Fetching flow data for:', { commodity, date: flowDate });\n\n      const flowDataPath = getNetworkDataPath('time_varying_flows.csv');\n\n      const response = await retryWithBackoff(async () => {\n        const res = await fetch(flowDataPath);\n        if (!res.ok) throw new Error(`HTTP error ${res.status}`);\n        return res.text();\n      });\n\n      const data = await new Promise((resolve, reject) => {\n        Papa.parse(response, {\n          header: true,\n          dynamicTyping: true,\n          skipEmptyLines: true,\n          complete: (results) => resolve(results),\n          error: (error) => reject(error)\n        });\n      });\n\n      // Filter for matching commodity and date\n      const filteredData = data.data.filter(flow => {\n        const commodityMatch = flow.commodity?.toLowerCase() === commodity?.toLowerCase();\n        const dateMatch = dateUtils.datesMatch(flow.date, flowDate);\n        return commodityMatch && dateMatch;\n      });\n\n      console.debug('Filtered data:', {\n        total: data.data.length,\n        filtered: filteredData.length,\n        commodity,\n        date: flowDate\n      });\n\n      // Process flows\n      const processedFlows = filteredData\n        .map(flow => {\n          try {\n            if (!flowValidation.isValidFlow(flow)) return null;\n\n            const sourceCoords = convertUTMtoLatLng(flow.source_lng, flow.source_lat);\n            const targetCoords = convertUTMtoLatLng(flow.target_lng, flow.target_lat);\n\n            return {\n              id: `${flow.source}-${flow.target}-${flow.date}`,\n              date: flow.date,\n              source: flow.source,\n              target: flow.target,\n              source_coordinates: sourceCoords,\n              target_coordinates: targetCoords,\n              price_differential: Number(flow.price_differential) || 0,\n              source_price: Number(flow.source_price) || 0,\n              target_price: Number(flow.target_price) || 0,\n              flow_weight: Number(flow.flow_weight) || 0,\n              metadata: {\n                processed_at: new Date().toISOString(),\n                valid: true\n              }\n            };\n          } catch (error) {\n            errors.push({ flow, error: error.message });\n            return null;\n          }\n        })\n        .filter(Boolean);\n\n      // Group flows\n      const byDate = _.groupBy(processedFlows, flow => dateUtils.toSpatialDate(flow.date));\n      const byRegion = _.groupBy(processedFlows, 'source');\n\n      // Calculate metadata\n      const uniqueMarkets = new Set([\n        ...processedFlows.map(f => f.source),\n        ...processedFlows.map(f => f.target)\n      ]);\n\n      const result = {\n        flows: processedFlows,\n        byDate,\n        byRegion,\n        metadata: {\n          lastUpdated: new Date().toISOString(),\n          dateRange: {\n            start: dateUtils.toSpatialDate(flowDate),\n            end: dateUtils.toSpatialDate(flowDate)\n          },\n          commodity,\n          totalFlows: processedFlows.length,\n          uniqueMarkets: uniqueMarkets.size,\n          dataQuality: {\n            validFlows: processedFlows.length,\n            invalidFlows: filteredData.length - processedFlows.length,\n            processingErrors: errors\n          }\n        }\n      };\n\n      metric.finish({ \n        status: 'success',\n        flowCount: processedFlows.length,\n        commodity,\n        date: flowDate\n      });\n\n      return result;\n\n    } catch (error) {\n      console.error('Error fetching flow data:', error);\n      metric.finish({ \n        status: 'error',\n        error: error.message,\n        commodity,\n        date\n      });\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\n// Slice\nconst flowSlice = createSlice({\n  name: 'flow',\n  initialState,\n  reducers: {\n    clearFlowData: () => initialState,\n    updateFlowMetrics: (state, action) => {\n      state.metadata = {\n        ...state.metadata,\n        ...action.payload\n      };\n    },\n    resetFlowError: (state) => {\n      state.status.error = null;\n    },\n    updateProgress: (state, action) => {\n      state.status.processingProgress = action.payload;\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchFlowData.pending, (state) => {\n        state.status.loading = true;\n        state.status.error = null;\n        state.status.processingProgress = 0;\n      })\n      .addCase(fetchFlowData.fulfilled, (state, action) => {\n        const { flows, byDate, byRegion, metadata } = action.payload;\n        state.flows = flows;\n        state.byDate = byDate;\n        state.byRegion = byRegion;\n        state.metadata = {\n          ...metadata,\n          lastUpdated: new Date().toISOString()\n        };\n        state.status = {\n          loading: false,\n          error: null,\n          lastFetch: new Date().toISOString(),\n          loadedData: {\n            ...state.status.loadedData,\n            [`${metadata.commodity}-${metadata.dateRange.start}`]: true\n          },\n          processingProgress: 1\n        };\n      })\n      .addCase(fetchFlowData.rejected, (state, action) => {\n        state.status = {\n          ...state.status,\n          loading: false,\n          error: action.payload,\n          lastFetch: new Date().toISOString(),\n          processingProgress: 0\n        };\n      });\n  }\n});\n\n// Optimized selectors\nconst selectFlowDomain = state => state.flow || initialState;\nconst selectFlowsArray = state => selectFlowDomain(state).flows;\nconst selectFlowsByDateMap = state => selectFlowDomain(state).byDate;\nconst selectFlowsByRegionMap = state => selectFlowDomain(state).byRegion;\nconst selectFlowMetadataState = state => selectFlowDomain(state).metadata;\nconst selectFlowStatusState = state => selectFlowDomain(state).status;\n\nexport const selectFlowState = createSelector(\n  [selectFlowDomain],\n  flowState => ({\n    ...flowState,\n    metadata: {\n      ...flowState.metadata,\n      lastChecked: new Date().toISOString()\n    }\n  })\n);\n\nexport const selectFlowStatus = createSelector(\n  [selectFlowStatusState],\n  status => ({\n    loading: status.loading,\n    error: status.error,\n    progress: status.processingProgress\n  })\n);\n\nexport const selectFlowMetadata = createSelector(\n  [selectFlowMetadataState],\n  metadata => ({\n    ...metadata,\n    lastChecked: new Date().toISOString()\n  })\n);\n\nexport const selectFlowsByDate = createSelector(\n  [selectFlowsByDateMap, (_, date) => date],\n  (byDate, date) => {\n    if (!date) return [];\n    // Convert input date to spatial format for lookup\n    const spatialDate = dateUtils.toSpatialDate(date);\n    return byDate[spatialDate] || [];\n  }\n);\n\nexport const selectFlowsByRegion = createSelector(\n  [selectFlowsByRegionMap, (_, region) => region],\n  (byRegion, region) => byRegion[region] || []\n);\n\nexport const selectFlowMetrics = createSelector(\n  [selectFlowsArray, selectFlowMetadataState],\n  (flows, metadata) => {\n    if (!flows.length) return null;\n\n    const validFlows = flows.filter(flow => flow.flow_weight > 0);\n    const totalWeight = validFlows.reduce((sum, flow) => sum + flow.flow_weight, 0);\n    const avgWeight = validFlows.length > 0 ? totalWeight / validFlows.length : 0;\n\n    return {\n      totalFlows: validFlows.length,\n      averageFlowWeight: avgWeight,\n      maxPriceDifferential: Math.max(...validFlows.map(f => f.price_differential || 0)),\n      averagePriceDifferential: validFlows.reduce((sum, f) => sum + (f.price_differential || 0), 0) / validFlows.length,\n      marketConnectivity: metadata.uniqueMarkets > 0\n        ? validFlows.length / metadata.uniqueMarkets\n        : 0,\n      dataQuality: metadata.dataQuality\n    };\n  }\n);\n\nexport const { \n  clearFlowData, \n  updateFlowMetrics, \n  resetFlowError,\n  updateProgress \n} = flowSlice.actions;\n\nexport default flowSlice.reducer;\n",
        "imports": [
          "@reduxjs/toolkit",
          "reselect",
          "papaparse",
          "lodash",
          "../utils/backgroundMonitor",
          "../utils/coordinateUtils",
          "../utils/dataUtils"
        ],
        "exports": [
          "fetchFlowData",
          "selectFlowState",
          "selectFlowStatus",
          "selectFlowMetadata",
          "selectFlowsByDate",
          "selectFlowsByRegion",
          "selectFlowMetrics",
          null,
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "reselect",
          "papaparse",
          "lodash",
          "../utils/backgroundMonitor",
          "../utils/coordinateUtils",
          "../utils/dataUtils"
        ]
      },
      {
        "path": "slices/index.js",
        "content": "// src/slices/index.js\n\nexport { default as themeReducer, toggleDarkMode, setDarkMode, selectIsDarkMode } from './themeSlice';\nexport { default as ecmReducer, fetchECMData } from './ecmSlice';\nexport { default as priceDiffReducer, fetchPriceDiffData } from './priceDiffSlice';\nexport { default as spatialReducer, fetchSpatialData } from './spatialSlice';",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "slices/priceDiffSlice.js",
        "content": "// src/slices/priceDiffSlice.js\n\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { getDataPath } from '../utils/dataUtils';\n\nexport const fetchPriceDiffData = createAsyncThunk(\n  'priceDiff/fetchData',\n  async (_, { rejectWithValue }) => {\n    try {\n      const response = await fetch(getDataPath('price_diff_results/price_differential_results.json'));\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nconst initialState = {\n  data: null,\n  status: 'idle',\n  error: null\n};\n\nconst priceDiffSlice = createSlice({\n  name: 'priceDiff',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchPriceDiffData.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(fetchPriceDiffData.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        state.data = action.payload;\n      })\n      .addCase(fetchPriceDiffData.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.payload || action.error.message;\n      });\n  }\n});\n\nexport default priceDiffSlice.reducer;",
        "imports": [
          "@reduxjs/toolkit",
          "../utils/dataUtils"
        ],
        "exports": [
          "fetchPriceDiffData",
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "../utils/dataUtils"
        ]
      },
      {
        "path": "slices/spatialSlice.js",
        "content": "// src/slices/spatialSlice.js\n\nimport { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';\nimport { createSelectorCreator, lruMemoize } from 'reselect';\nimport _ from 'lodash';\nimport { spatialHandler } from '../utils/spatialDataHandler';\nimport { DEFAULT_REGRESSION_DATA } from '../types/dataTypes';\nimport { backgroundMonitor } from '../utils/backgroundMonitor';\nimport { workerManager } from '../workers/enhancedWorkerSystem';\nimport {\n  calculatePriceTrend,\n  detectSeasonality,\n  detectOutliers,\n  calculateVolatility,\n  calculateIntegration,\n  calculateClusterEfficiency,\n  calculateCenterOfMass,\n  calculateBoundingBox,\n  findNeighboringRegions\n} from '../utils/marketAnalysisUtils';\nimport { DEFAULT_VIEW } from '../constants/index';\n\n// Custom Selector Creator with lodash's isEqual for deep comparison\nconst createDeepEqualSelector = createSelectorCreator(\n  lruMemoize,\n  _.isEqual\n);\n\n// Memoization Configuration\nconst memoizationConfig = {\n  resultEqualityCheck: _.isEqual,\n  maxSize: 50,\n  defaultValue: null\n};\n\n// Helper function for processing flow data\nconst processFlowData = (flows) => {\n  if (!Array.isArray(flows)) return {\n    flows: [],\n    byDate: {},\n    metadata: {\n      lastUpdated: new Date().toISOString(),\n      dateRange: { start: null, end: null }\n    }\n  };\n\n  // Group flows by date and validate each flow\n  const byDate = flows.reduce((acc, flow) => {\n    // Ensure flow has required fields\n    if (!flow.source || !flow.target || !flow.flow_weight) return acc;\n    \n    const date = flow.date || flow.month;\n    if (!date) return acc;\n    \n    // Format date to YYYY-MM\n    const formattedDate = date.substring(0, 7);\n    \n    if (!acc[formattedDate]) {\n      acc[formattedDate] = [];\n    }\n    \n    // Add validated flow to the date group\n    acc[formattedDate].push({\n      source: flow.source,\n      target: flow.target,\n      flow_weight: Number(flow.flow_weight) || 0,\n      price_differential: Number(flow.price_differential) || 0,\n      source_price: Number(flow.source_price) || 0,\n      target_price: Number(flow.target_price) || 0,\n      total_flow: Number(flow.total_flow || flow.flow_weight) || 0,\n      avg_flow: Number(flow.avg_flow || flow.total_flow || flow.flow_weight) || 0,\n      flow_count: Number(flow.flow_count) || 1,\n      date: formattedDate\n    });\n    \n    return acc;\n  }, {});\n\n  // Calculate date range\n  const dates = Object.keys(byDate).sort();\n  const dateRange = {\n    start: dates[0] || null,\n    end: dates[dates.length - 1] || null\n  };\n\n  // Flatten flows for the flows array\n  const allFlows = Object.values(byDate).flat();\n\n  return {\n    flows: allFlows,\n    byDate,\n    metadata: {\n      lastUpdated: new Date().toISOString(),\n      dateRange,\n      totalFlows: allFlows.length,\n      uniqueDates: dates.length\n    }\n  };\n};\n\n// Initial State with All Required Properties Initialized\nexport const initialState = {\n  data: {\n    geometry: {\n      polygons: null,\n      points: null,\n      unified: null\n    },\n    flowMaps: [],\n    timeSeriesData: [],\n    marketClusters: [],\n    marketShocks: [],\n    spatialAutocorrelation: {},\n    seasonalAnalysis: null,\n    marketIntegration: null,\n    regressionAnalysis: {\n      ...DEFAULT_REGRESSION_DATA,\n      metadata: {\n        ...DEFAULT_REGRESSION_DATA.metadata,\n        commodity: \"beans (kidney red)\", // Set default commodity\n        timestamp: new Date().toISOString(),\n        version: \"1.0\"\n      },\n      model: {\n        ...DEFAULT_REGRESSION_DATA.model,\n        coefficients: { spatial_lag_price: 0 },\n        p_values: { spatial_lag_price: 1 }\n      },\n      residuals: {\n        raw: [],\n        byRegion: {},\n        stats: { mean: 0, variance: 0, maxAbsolute: 0 }\n      },\n      spatial: {\n        moran_i: { I: 0, 'p-value': 1 },\n        vif: []\n      }\n    },\n    uniqueMonths: [],\n    visualizationData: {\n      prices: null,\n      integration: null,\n      clusters: null,\n      shocks: null\n    },\n    metadata: null,\n    cache: {},\n    flowData: {\n      flows: [],\n      byDate: {},\n      metadata: {\n        lastUpdated: null,\n        dateRange: {\n          start: null,\n          end: null\n        }\n      }\n    },\n    spatialAnalysis: {\n      moranI: null,\n      clusters: [],\n      regressionResults: null\n    },\n    commodities: []\n  },\n  status: {\n    loading: false,\n    error: null,\n    progress: 0,\n    stage: 'idle',\n    geometryLoading: false,\n    geometryError: null,\n    regressionLoading: false,\n    regressionError: null,\n    visualizationLoading: false,\n    visualizationError: null,\n    dataFetching: false,\n    dataCaching: false,\n    lastUpdated: null,\n    retryCount: 0,\n    lastError: null\n  },\n  ui: {\n    selectedCommodity: 'beans (kidney red)', // Set default commodity\n    selectedDate: '',\n    selectedRegimes: ['unified'],\n    selectedRegion: null,\n    view: DEFAULT_VIEW,\n    activeLayers: [],\n    visualizationMode: 'prices',\n    analysisFilters: {\n      minMarketCount: 0,\n      minFlowWeight: 0,\n      shockThreshold: 0\n    }\n  }\n};\n\n// Async Thunks\n\nexport const fetchFlowData = createAsyncThunk(\n  'spatial/fetchFlowData',\n  async ({ commodity, date }, { getState, rejectWithValue }) => {\n    const metric = backgroundMonitor.startMetric('flow-data-fetch');\n    try {\n      const response = await spatialHandler.loadFlowDataWithRecovery(commodity);\n      metric.finish({ status: 'success' });\n      return response;\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const fetchAllSpatialData = createAsyncThunk(\n  'spatial/fetchAllSpatialData',\n  async ({\n    commodity,\n    date,\n    visualizationMode,\n    filters,\n    skipGeometry = false,\n    regressionOnly = false,\n    visualizationOnly = false,\n    forceRefresh = false,\n    signal // Add signal parameter\n  }, { getState, rejectWithValue }) => {\n    const metric = backgroundMonitor.startMetric('spatial-data-fetch');\n    const state = getState();\n    const cacheKey = `${commodity}_${date}`;\n\n    try {\n      let result = {\n        geometry: null,\n        spatialData: null,\n        regressionData: null,\n        visualizationData: null,\n        metadata: {\n          commodity,\n          date,\n          timestamp: new Date().toISOString()\n        }\n      };\n\n      // Handle regression-only request\n      if (regressionOnly) {\n        try {\n          const regressionData = await spatialHandler.loadRegressionAnalysis(commodity, signal);\n          result.regressionData = regressionData;\n        } catch (error) {\n          if (error.name === 'AbortError') {\n            throw error;\n          }\n          console.warn('Regression analysis fetch failed:', error);\n          result.regressionData = DEFAULT_REGRESSION_DATA;\n        }\n        metric.finish({ status: 'success' });\n        return result;\n      }\n\n      // Handle visualization-only request\n      if (visualizationOnly && visualizationMode) {\n        try {\n          const visualizationData = await spatialHandler.processVisualizationData(\n            state.spatial?.data,\n            visualizationMode,\n            filters\n          );\n          result.visualizationData = {\n            mode: visualizationMode,\n            data: visualizationData\n          };\n        } catch (error) {\n          if (error.name === 'AbortError') {\n            throw error;\n          }\n          console.warn('Visualization processing failed:', error);\n        }\n        metric.finish({ status: 'success' });\n        return result;\n      }\n\n      // Standard full data load\n      if (!skipGeometry) {\n        await Promise.all([\n          spatialHandler.initializeGeometry(signal),\n          spatialHandler.initializePoints(signal)\n        ]);\n\n        result.geometry = {\n          polygons: Array.from(spatialHandler.geometryCache.values()),\n          points: Array.from(spatialHandler.pointCache.values()),\n          unified: await spatialHandler.createUnifiedGeoJSON([], signal)\n        };\n      }\n\n      // Get spatial data using the enhanced method\n      const spatialData = await spatialHandler.getSpatialData(commodity, date, signal);\n      \n      result.spatialData = {\n        timeSeriesData: spatialData.timeSeriesData || [],\n        flowMaps: spatialData.flowMaps || [],\n        marketClusters: spatialData.marketClusters || [],\n        marketShocks: spatialData.marketShocks || [],\n        spatialAutocorrelation: spatialData.spatialAutocorrelation || {},\n        seasonalAnalysis: spatialData.seasonalAnalysis || {},\n        marketIntegration: spatialData.marketIntegration || {},\n        uniqueMonths: [...new Set(spatialData.timeSeriesData?.map(d => d.month) || [])].sort(),\n        commodities: spatialData.commodities || []\n      };\n\n      // Update cache\n      result.cacheTimestamp = Date.now();\n      const updatedResult = {\n        ...result,\n        cacheKey\n      };\n\n      metric.finish({ status: 'success' });\n      return updatedResult;\n\n    } catch (error) {\n      // Don't log AbortError as it's an expected case\n      if (error.name === 'AbortError') {\n        metric.finish({ status: 'aborted' });\n        throw error;\n      }\n\n      const enhancedError = {\n        message: error.message,\n        details: {\n          params: { commodity, date },\n          state: getState().spatial?.status,\n          timestamp: Date.now()\n        }\n      };\n      backgroundMonitor.logError('spatial-data-fetch', enhancedError);\n      metric.finish({ status: 'error', error: error.message });\n      return rejectWithValue(enhancedError);\n    }\n  }\n);\n\n// Compatibility exports for backward compatibility\nexport const fetchSpatialData = ({ commodity, date }) => {\n  return fetchAllSpatialData({ commodity, date });\n};\n\nexport const fetchRegressionAnalysis = ({ selectedCommodity }) => {\n  return fetchAllSpatialData({\n    commodity: selectedCommodity,\n    skipGeometry: true,\n    regressionOnly: true\n  });\n};\n\nexport const fetchVisualizationData = ({ mode, filters }) => {\n  return fetchAllSpatialData({\n    visualizationMode: mode,\n    filters,\n    visualizationOnly: true\n  });\n};\n\n// Base Selectors with Safe Fallbacks\nconst selectSpatialState = (state) => {\n  if (!state.spatial) {\n    console.warn('Spatial state is undefined, using initial state');\n    return initialState;\n  }\n  return state.spatial;\n};\n\nconst selectData = createSelector(\n  [selectSpatialState],\n  (spatial) => spatial.data || initialState.data\n);\n\nconst selectStatus = createSelector(\n  [selectSpatialState],\n  (spatial) => spatial.status || initialState.status\n);\n\nconst selectUI = createSelector(\n  [selectSpatialState],\n  (spatial) => spatial.ui || initialState.ui\n);\n\n// Safe selector creator with error handling\nconst createSafeSelector = (selectors, combiner) => \n  createDeepEqualSelector(selectors, (...args) => {\n    try {\n      return combiner(...args);\n    } catch (error) {\n      console.warn('Selector error:', error);\n      return null;\n    }\n  });\n\n// Update handleSpatialError to use safe state access\nexport const handleSpatialError = createAsyncThunk(\n  'spatial/handleError',\n  async (error, { dispatch, getState, rejectWithValue }) => {\n    const state = getState();\n    const spatialState = selectSpatialState(state);\n    \n    const enhancedError = {\n      originalError: error,\n      state: {\n        status: spatialState.status,\n        ui: spatialState.ui\n      },\n      timestamp: Date.now()\n    };\n\n    backgroundMonitor.logError('spatial-error', enhancedError);\n\n    const retryCount = spatialState.status.retryCount || 0;\n    if (retryCount < 3) {\n      dispatch(setRetryCount(retryCount + 1));\n      return dispatch(\n        fetchAllSpatialData({\n          commodity: spatialState.ui.selectedCommodity,\n          date: spatialState.ui.selectedDate,\n          forceRefresh: true\n        })\n      );\n    }\n\n    return rejectWithValue(enhancedError);\n  }\n);\n\n// Batch Update Thunk remains unchanged\nexport const batchUpdateSpatialState = createAsyncThunk(\n  'spatial/batchUpdate',\n  async (updates, { dispatch }) => {\n    const metric = backgroundMonitor.startMetric('batch-update');\n\n    try {\n      const { geometry, data, ui } = updates;\n\n      // Perform updates in order\n      if (geometry) dispatch(updateGeometry(geometry));\n      if (data) dispatch(updateData(data));\n      if (ui) dispatch(updateUI(ui));\n\n      metric.finish({ status: 'success' });\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      throw error;\n    }\n  }\n);\n\n// Base Selectors\nexport const selectLoadingStatus = createSelector(\n  [selectStatus],\n  (status) => Boolean(status.loading)\n);\n\nexport const selectUniqueMonths = createSelector(\n  [selectData],\n  (data) => data.uniqueMonths || []\n);\n\n// Optimized Selectors\nexport const selectSpatialData = createSafeSelector(\n  [selectData],\n  (data) => {\n    return {\n      geometry: data.geometry || {},\n      flowMaps: data.flowMaps || [],\n      timeSeriesData: data.timeSeriesData || [],\n      marketClusters: data.marketClusters || [],\n      marketShocks: data.marketShocks || [],\n      commodities: data.commodities || [],\n      spatialAutocorrelation: data.spatialAutocorrelation || {},\n      seasonalAnalysis: data.seasonalAnalysis || null,\n      marketIntegration: data.marketIntegration || null,\n      regressionAnalysis: data.regressionAnalysis || null,\n      uniqueMonths: data.uniqueMonths || [],\n      visualizationData: data.visualizationData || {}\n    };\n  }\n);\n\nexport const selectUIState = createDeepEqualSelector(\n  [selectUI],\n  (ui) => ({\n    selectedCommodity: ui.selectedCommodity || '',\n    selectedDate: ui.selectedDate || '',\n    selectedRegimes: ui.selectedRegimes || ['unified'],\n    selectedRegion: ui.selectedRegion || null,\n    view: ui.view,\n    activeLayers: ui.activeLayers || [],\n    visualizationMode: ui.visualizationMode || null,\n    analysisFilters: ui.analysisFilters || {}\n  })\n);\n\nexport const selectTimeSeriesData = createDeepEqualSelector(\n  [\n    (state) => selectSpatialState(state)?.data?.timeSeriesData || [],\n    (state) => selectSpatialState(state)?.ui?.selectedRegimes || ['unified'],\n    (state) => selectSpatialState(state)?.ui?.selectedDate || ''\n  ],\n  (timeSeriesData, selectedRegimes, selectedDate) => \n    timeSeriesData.filter(d => \n      (!selectedDate || d.month === selectedDate) &&\n      (!selectedRegimes.length || selectedRegimes.includes(d.regime))\n    )\n);\n\nexport const selectFilteredClusters = createDeepEqualSelector(\n  [\n    (state) => selectSpatialState(state)?.data?.marketClusters || [],\n    (state) => selectSpatialState(state)?.ui?.selectedRegion\n  ],\n  (clusters, selectedRegion) => {\n    if (!selectedRegion) return clusters;\n    return clusters.filter(c => \n      c.main_market === selectedRegion || \n      c.connected_markets?.includes(selectedRegion)\n    );\n  }\n);\n\nexport const selectDetailedMetrics = createDeepEqualSelector(\n  [\n    selectTimeSeriesData,\n    (state) => selectSpatialState(state)?.data?.regressionAnalysis || DEFAULT_REGRESSION_DATA,\n    selectUIState\n  ],\n  (timeData, regressionData, ui) => {\n    if (!timeData.length || !regressionData) return null;\n\n    return {\n      priceStats: {\n        trend: calculatePriceTrend(timeData),\n        seasonality: detectSeasonality(timeData),\n        outliers: detectOutliers(timeData)\n      },\n      spatialDependence: {\n        moranI: _.get(regressionData, 'spatial.moran_i.I', 0),\n        pValue: _.get(regressionData, 'spatial.moran_i[\"p-value\"]', 1),\n        spatialLag: _.get(regressionData, 'model.coefficients.spatial_lag_price', 0)\n      },\n      modelFit: {\n        rSquared: _.get(regressionData, 'model.r_squared', 0),\n        adjRSquared: _.get(regressionData, 'model.adj_r_squared', 0),\n        mse: _.get(regressionData, 'model.mse', 0),\n        observations: _.get(regressionData, 'model.observations', 0)\n      }\n    };\n  }\n);\n\n// Additional Selectors\nexport const selectMarketClusters = (state) => selectSpatialState(state)?.data?.marketClusters;\nexport const selectSpatialAutocorrelation = (state) => selectSpatialState(state)?.data?.spatialAutocorrelation;\nexport const selectMarketIntegration = (state) => selectSpatialState(state)?.data?.marketIntegration;\nexport const selectSeasonalAnalysis = (state) => selectSpatialState(state)?.data?.seasonalAnalysis;\nexport const selectMarketShocks = (state) => selectSpatialState(state)?.data?.marketShocks;\nexport const selectGeoJSON = (state) => selectSpatialState(state)?.data?.geometry?.unified;\nexport const selectMetadata = (state) => selectSpatialState(state)?.data?.metadata;\nexport const selectFlowMaps = (state) => selectSpatialState(state)?.data?.flowMaps;\nexport const selectResiduals = (state) => selectSpatialState(state)?.data?.regressionAnalysis?.residuals;\nexport const selectRegressionAnalysis = (state) => selectSpatialState(state)?.data?.regressionAnalysis;\nexport const selectModelStats = (state) => selectSpatialState(state)?.data?.regressionAnalysis?.model;\nexport const selectSpatialStats = (state) => selectSpatialState(state)?.data?.regressionAnalysis?.spatial;\nexport const selectActiveLayers = (state) => selectSpatialState(state)?.ui?.activeLayers;\nexport const selectAnalysisFilters = (state) => selectSpatialState(state)?.ui?.analysisFilters;\nexport const selectGeometryData = (state) => selectSpatialState(state)?.data?.geometry;\nexport const selectError = (state) => selectSpatialState(state)?.status?.error;\nexport const selectSelectedCommodity = (state) => selectSpatialState(state)?.ui?.selectedCommodity;\nexport const selectSelectedDate = (state) => selectSpatialState(state)?.ui?.selectedDate;\nexport const selectVisualizationMode = (state) => selectSpatialState(state)?.ui?.visualizationMode;\n\nexport const selectGeometryWithCache = createDeepEqualSelector(\n  [selectGeometryData, (_, options) => options],\n  (geometry, options = {}) => {\n    if (options.skipCache) return geometry;\n    return geometry?.cached || geometry;\n  }\n);\n\nexport const selectRegionIntegration = createDeepEqualSelector(\n  [selectMarketIntegration, selectUIState],\n  (integration, ui) => integration?.price_correlation?.[ui.selectedRegion] || {}\n);\n\nexport const selectRegionShocks = createDeepEqualSelector(\n  [selectMarketShocks, selectUIState],\n  (shocks, ui) => (shocks || []).filter(shock => shock.region === ui.selectedRegion)\n);\n\nexport const selectTimeSeriesWithFilters = createDeepEqualSelector(\n  [\n    selectTimeSeriesData,\n    (state) => selectSpatialState(state)?.ui?.selectedRegimes,\n    (state) => selectSpatialState(state)?.ui?.selectedDate\n  ],\n  (timeSeriesData, selectedRegimes, selectedDate) => {\n    if (!timeSeriesData) return [];\n    return timeSeriesData.filter(d => \n      (!selectedDate || d.month === selectedDate) &&\n      (!selectedRegimes.length || selectedRegimes.includes(d.regime))\n    );\n  }\n);\n\nexport const selectMarketMetrics = createDeepEqualSelector(\n  [selectTimeSeriesData, selectUIState],\n  (timeSeriesData, ui) => {\n    if (!timeSeriesData?.length) return null;\n\n    const filteredData = timeSeriesData.filter(d => \n      ui.selectedRegimes.includes(d.regime)\n    );\n\n    if (!filteredData.length) return null;\n\n    return {\n      averagePrice: filteredData.reduce((acc, d) => acc + (d.avgUsdPrice || 0), 0) / filteredData.length,\n      volatility: filteredData.reduce((acc, d) => acc + (d.volatility || 0), 0) / filteredData.length,\n      conflictIntensity: filteredData.reduce((acc, d) => acc + (d.conflict_intensity || 0), 0) / filteredData.length\n    };\n  }\n);\n\nexport const selectMarketIntegrationMetrics = createDeepEqualSelector(\n  [selectSpatialData],\n  (data) => data?.marketIntegration\n);\n\nexport const selectSpatialPatterns = createDeepEqualSelector(\n  [selectSpatialData],\n  (data) => ({\n    clusters: data?.marketClusters,\n    autocorrelation: data?.spatialAutocorrelation,\n    flows: data?.flowMaps\n  })\n);\n\nexport const selectResidualsByRegion = createDeepEqualSelector(\n  [selectResiduals, (_, regionId) => regionId],\n  (residuals, regionId) => residuals?.byRegion?.[regionId] || []\n);\n\nexport const selectRegressionMetrics = createDeepEqualSelector(\n  [selectModelStats],\n  (model) => ({\n    r_squared: model?.r_squared || 0,\n    adjRSquared: model?.adj_r_squared || 0,\n    mse: model?.mse || 0,\n    observations: model?.observations || 0\n  })\n);\n\nexport const selectSpatialMetrics = createDeepEqualSelector(\n  [selectSpatialStats],\n  (spatial) => ({\n    moran_i: spatial?.moran_i || { I: 0, 'p-value': 0 },\n    vif: spatial?.vif || []\n  })\n);\n\nexport const selectFilteredMarketData = createDeepEqualSelector(\n  [selectSpatialData, selectAnalysisFilters],\n  (data, filters) => {\n    if (!data) return null;\n    \n    return {\n      marketClusters: (data.marketClusters || []).filter(\n        cluster => cluster.market_count >= (filters.minMarketCount || 0)\n      ),\n      flowMaps: (data.flowMaps || []).filter(\n        flow => flow.flow_weight >= (filters.minFlowWeight || 0)\n      ),\n      marketShocks: (data.marketShocks || []).filter(\n        shock => Math.abs(shock.magnitude) >= (filters.shockThreshold || 0)\n      )\n    };\n  }\n);\n\nexport const selectRegionGeometry = createDeepEqualSelector(\n  [selectGeoJSON, selectUIState],\n  (geoJSON, ui) => {\n    if (!geoJSON?.features || !ui.selectedRegion) return null;\n    return geoJSON.features.find(f => \n      f.properties.region_id === ui.selectedRegion\n    );\n  }\n);\n\nexport const selectRegionWithTimeData = createDeepEqualSelector(\n  [selectGeoJSON, selectTimeSeriesData, selectUIState],\n  (geoJSON, timeData, ui) => {\n    if (!geoJSON?.features || !ui.selectedRegion) return null;\n    \n    const feature = geoJSON.features.find(f => \n      f.properties.region_id === ui.selectedRegion\n    );\n    \n    if (!feature) return null;\n\n    const regionTimeData = timeData.filter(d => \n      d.region === ui.selectedRegion || \n      d.admin1 === ui.selectedRegion\n    );\n\n    return {\n      ...feature,\n      properties: {\n        ...feature.properties,\n        timeData: regionTimeData\n      }\n    };\n  }\n);\n\nexport const selectMarketConnections = createDeepEqualSelector(\n  [selectFlowMaps, selectUIState],\n  (flows, ui) => {\n    if (!flows || !ui.selectedRegion) return [];\n    \n    return flows.filter(flow => \n      flow.source === ui.selectedRegion || \n      flow.target === ui.selectedRegion\n    ).map(flow => ({\n      ...flow,\n      isSource: flow.source === ui.selectedRegion,\n      coordinates: flow.source === ui.selectedRegion ? \n        flow.target_coordinates : \n        flow.source_coordinates\n    }));\n  }\n);\n\nexport const selectActiveRegionData = createDeepEqualSelector(\n  [\n    selectRegionWithTimeData,\n    selectMarketConnections,\n    selectRegionIntegration,\n    selectRegionShocks\n  ],\n  (geometry, connections, integration, shocks) => ({\n    geometry,\n    connections,\n    integration,\n    shocks,\n    hasData: Boolean(geometry && geometry.properties.timeData.length)\n  })\n);\n\nexport const selectActiveRegionDataOptimized = createDeepEqualSelector(\n  [\n    selectActiveRegionData,\n    selectGeometryData,\n    selectUIState\n  ],\n  (regionData, geometryData, ui) => {\n    if (!regionData?.geometry || !geometryData) return null;\n\n    // Calculate geometric properties\n    try {\n      const center = calculateCenterOfMass(regionData.geometry);\n      const bounds = calculateBoundingBox(regionData.geometry);\n      const neighbors = findNeighboringRegions(\n        regionData.geometry, \n        ui.selectedRegion,\n        geometryData.polygons\n      );\n\n      return {\n        ...regionData,\n        computedMetrics: {\n          centerOfMass: center,\n          boundingBox: bounds,\n          neighbors,\n          hasComputedMetrics: true\n        }\n      };\n    } catch (error) {\n      console.warn('Error computing geometric metrics:', error);\n      return {\n        ...regionData,\n        computedMetrics: {\n          centerOfMass: null,\n          boundingBox: null,\n          neighbors: [],\n          hasComputedMetrics: false,\n          error: error.message\n        }\n      };\n    }\n  }\n);\n\nexport const selectGeometryStatus = createDeepEqualSelector(\n  [selectGeometryData],\n  (geometry) => ({\n    hasPolygons: Boolean(geometry?.polygons),\n    hasPoints: Boolean(geometry?.points),\n    hasUnified: Boolean(geometry?.unified),\n    isComplete: Boolean(\n      geometry?.polygons && \n      geometry?.points && \n      geometry?.unified\n    )\n  })\n);\n\nexport const selectFlowData = createDeepEqualSelector(\n  [selectSpatialData],\n  (data) => data?.flowData?.flows || []\n);\n\nexport const selectSpatialAnalysisResults = createDeepEqualSelector(\n  [selectSpatialData],\n  (data) => data?.spatialAnalysis || null\n);\n\nexport const selectFlowMetadata = createDeepEqualSelector(\n  [selectSpatialData],\n  (data) => data?.flowData?.metadata || null\n);\n\nexport const selectFlowsByRegion = createDeepEqualSelector(\n  [selectFlowData, (_, regionId) => regionId],\n  (flows, regionId) => flows.filter(flow => \n    flow.source === regionId || flow.target === regionId\n  )\n);\n\nexport const selectCommodityInfo = createDeepEqualSelector(\n  [\n    (state) => selectSpatialState(state)?.data?.commodities || [],\n    (state) => selectSpatialState(state)?.ui?.selectedCommodity || '',\n    selectLoadingStatus,\n    selectUniqueMonths\n  ],\n  (commodities, selectedCommodity, loading, uniqueMonths) => ({\n    commodities: [...(commodities || [])],\n    selectedCommodity: selectedCommodity || '',\n    loading: loading || false,\n    uniqueMonths: [...(uniqueMonths || [])]\n  })\n);\n\n// Metrics Cache and Helper\nconst metricsCache = new Map();\n\n// Helper to clear cache and terminate workers when needed\nexport const clearGeometricCache = () => {\n  metricsCache.clear();\n  Object.values(workerManager.workers).forEach(worker => {\n    if (worker) worker.terminate();\n  });\n};\n\n// Create Slice\nconst spatialSlice = createSlice({\n  name: 'spatial',\n  initialState,\n  reducers: {\n    setProgress: (state, action) => {\n      state.status.progress = action.payload;\n    },\n    setLoadingStage: (state, action) => {\n      state.status.stage = action.payload;\n    },\n    setView: (state, action) => {\n      state.ui.view = action.payload;\n    },\n    setSelectedCommodity(state, action) {\n      state.ui.selectedCommodity = action.payload;\n    },\n    setSelectedDate(state, action) {\n      state.ui.selectedDate = action.payload;\n    },\n    setVisualizationMode(state, action) {\n      state.ui.visualizationMode = action.payload;\n    },\n    setSelectedRegion: (state, action) => {\n      state.ui.selectedRegion = action.payload;\n    },\n    setSelectedRegimes: (state, action) => {\n      state.ui.selectedRegimes = action.payload;\n    },\n    setActiveLayers: (state, action) => {\n      state.ui.activeLayers = action.payload;\n    },\n    resetVisualizationData: (state) => {\n      state.data.visualizationData = initialState.data.visualizationData;\n    },\n    setRetryCount: (state, action) => {\n      state.status.retryCount = action.payload;\n    },\n    updateGeometry: (state, action) => {\n      state.data.geometry = action.payload;\n    },\n    updateData: (state, action) => {\n      state.data = { ...state.data, ...action.payload };\n    },\n    updateUI: (state, action) => {\n      state.ui = { ...state.ui, ...action.payload };\n    },\n    // Add any additional reducers if necessary\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchAllSpatialData.pending, (state, action) => {\n        const { regressionOnly, visualizationOnly } = action.meta.arg;\n        state.status.loading = !regressionOnly && !visualizationOnly;\n        state.status.regressionLoading = regressionOnly;\n        state.status.visualizationLoading = visualizationOnly;\n        state.status.error = null;\n        state.status.dataFetching = true;\n      })\n      .addCase(fetchAllSpatialData.fulfilled, (state, action) => {\n        const {\n          geometry,\n          spatialData,\n          regressionData,\n          visualizationData,\n          metadata,\n          cacheKey,\n          cacheTimestamp\n        } = action.payload;\n        const { regressionOnly, visualizationOnly, commodity } = action.meta.arg;\n      \n        // Update commodities from spatialData\n        if (spatialData?.commodities?.length > 0) {\n          state.data.commodities = [...new Set([\n            ...(state.data.commodities || []),\n            ...spatialData.commodities\n          ])].sort();\n        }\n\n        // Process flow data if available\n        if (spatialData?.flowMaps) {\n          state.data.flowData = processFlowData(spatialData.flowMaps);\n        }\n\n        // Update regression data if available\n        if (regressionData) {\n          const currentCommodity = commodity || state.ui.selectedCommodity;\n          state.data.regressionAnalysis = {\n            ...regressionData,\n            model: regressionData.model || {},\n            spatial: regressionData.spatial || { moran_i: { I: 0, 'p-value': 1 }, vif: [] },\n            residuals: regressionData.residuals || { raw: [], byRegion: {}, stats: {} },\n            metadata: {\n              commodity: currentCommodity,\n              timestamp: new Date().toISOString(),\n              version: \"1.0\"\n            }\n          };\n        }\n\n        // Handle regression-only fulfillment\n        if (regressionOnly) {\n          state.status.regressionLoading = false;\n          state.status.dataFetching = false;\n          return;\n        }\n\n        // Handle visualization-only fulfillment\n        if (visualizationOnly) {\n          if (visualizationData) {\n            state.data.visualizationData[visualizationData.mode] = visualizationData.data;\n          }\n          state.status.visualizationLoading = false;\n          state.status.dataFetching = false;\n          return;\n        }\n\n        // Update geometry if available\n        if (geometry) {\n          state.data.geometry = geometry;\n        }\n\n        // Update spatial data\n        if (spatialData) {\n          state.data = {\n            ...state.data,\n            timeSeriesData: spatialData.timeSeriesData || [],\n            flowMaps: spatialData.flowMaps || [],\n            marketClusters: spatialData.marketClusters || [],\n            marketShocks: spatialData.marketShocks || [],\n            spatialAutocorrelation: spatialData.spatialAutocorrelation || {\n              global: {},\n              local: {}\n            },\n            seasonalAnalysis: spatialData.seasonalAnalysis || {},\n            marketIntegration: spatialData.marketIntegration || {},\n            uniqueMonths: spatialData.uniqueMonths || []\n          };\n        }\n\n        // Update metadata\n        if (metadata) {\n          state.data.metadata = metadata;\n          state.ui.selectedCommodity = metadata.commodity;\n          state.ui.selectedDate = metadata.date;\n        }\n\n        // Update cache if cacheKey is present\n        if (cacheKey) {\n          state.data.cache[cacheKey] = {\n            geometry: state.data.geometry,\n            spatialData: {\n              timeSeriesData: state.data.timeSeriesData,\n              flowMaps: state.data.flowMaps,\n              marketClusters: state.data.marketClusters,\n              marketShocks: state.data.marketShocks,\n              spatialAutocorrelation: state.data.spatialAutocorrelation,\n              seasonalAnalysis: state.data.seasonalAnalysis,\n              marketIntegration: state.data.marketIntegration,\n              uniqueMonths: state.data.uniqueMonths\n            },\n            regressionData: state.data.regressionAnalysis,\n            visualizationData,\n            metadata,\n            cacheTimestamp\n          };\n          state.status.lastUpdated = cacheTimestamp;\n        }\n\n        // Update status\n        state.status = {\n          ...state.status,\n          loading: false,\n          dataFetching: false,\n          error: null,\n          progress: 100,\n          stage: 'complete',\n          geometryLoading: false,\n          regressionLoading: false,\n          visualizationLoading: false\n        };\n      })\n      .addCase(fetchAllSpatialData.rejected, (state, action) => {\n        state.status.loading = false;\n        state.status.error = action.payload;\n        state.status.stage = 'error';\n        state.status.geometryLoading = false;\n        state.status.regressionLoading = false;\n        state.status.visualizationLoading = false;\n        state.status.dataFetching = false;\n        state.status.lastError = action.payload;\n      })\n      .addCase(fetchFlowData.pending, (state) => {\n        state.status.dataFetching = true;\n        state.status.error = null;\n      })\n      .addCase(fetchFlowData.fulfilled, (state, action) => {\n        state.data.flowData = processFlowData(action.payload);\n        state.status.dataFetching = false;\n        state.status.error = null;\n      })\n      .addCase(fetchFlowData.rejected, (state, action) => {\n        state.status.dataFetching = false;\n        state.status.error = action.payload;\n      });\n  }\n});\n\n// Export actions\nexport const {\n  setProgress,\n  setLoadingStage,\n  setView,\n  setSelectedCommodity,\n  setSelectedDate,\n  setVisualizationMode,\n  setSelectedRegion,\n  setSelectedRegimes,\n  setActiveLayers,\n  resetVisualizationData,\n  setRetryCount,\n  updateGeometry,\n  updateData,\n  updateUI\n} = spatialSlice.actions;\n\n// Export the reducer\nexport default spatialSlice.reducer;",
        "imports": [
          "@reduxjs/toolkit",
          "reselect",
          "lodash",
          "../utils/spatialDataHandler",
          "../types/dataTypes",
          "../utils/backgroundMonitor",
          "../workers/enhancedWorkerSystem",
          "../utils/marketAnalysisUtils",
          "../constants/index"
        ],
        "exports": [
          "initialState",
          "fetchFlowData",
          "fetchAllSpatialData",
          "fetchSpatialData",
          "fetchRegressionAnalysis",
          "fetchVisualizationData",
          "handleSpatialError",
          "batchUpdateSpatialState",
          "selectLoadingStatus",
          "selectUniqueMonths",
          "selectSpatialData",
          "selectUIState",
          "selectTimeSeriesData",
          "selectFilteredClusters",
          "selectDetailedMetrics",
          "selectMarketClusters",
          "selectSpatialAutocorrelation",
          "selectMarketIntegration",
          "selectSeasonalAnalysis",
          "selectMarketShocks",
          "selectGeoJSON",
          "selectMetadata",
          "selectFlowMaps",
          "selectResiduals",
          "selectRegressionAnalysis",
          "selectModelStats",
          "selectSpatialStats",
          "selectActiveLayers",
          "selectAnalysisFilters",
          "selectGeometryData",
          "selectError",
          "selectSelectedCommodity",
          "selectSelectedDate",
          "selectVisualizationMode",
          "selectGeometryWithCache",
          "selectRegionIntegration",
          "selectRegionShocks",
          "selectTimeSeriesWithFilters",
          "selectMarketMetrics",
          "selectMarketIntegrationMetrics",
          "selectSpatialPatterns",
          "selectResidualsByRegion",
          "selectRegressionMetrics",
          "selectSpatialMetrics",
          "selectFilteredMarketData",
          "selectRegionGeometry",
          "selectRegionWithTimeData",
          "selectMarketConnections",
          "selectActiveRegionData",
          "selectActiveRegionDataOptimized",
          "selectGeometryStatus",
          "selectFlowData",
          "selectSpatialAnalysisResults",
          "selectFlowMetadata",
          "selectFlowsByRegion",
          "selectCommodityInfo",
          "clearGeometricCache",
          null,
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "reselect",
          "lodash",
          "../utils/spatialDataHandler",
          "../types/dataTypes",
          "../utils/backgroundMonitor",
          "../workers/enhancedWorkerSystem",
          "../utils/marketAnalysisUtils",
          "../constants/index"
        ]
      },
      {
        "path": "slices/themeSlice.js",
        "content": "// src/slices/themeSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n  isDarkMode: false\n};\n\nconst themeSlice = createSlice({\n  name: 'theme',\n  initialState,\n  reducers: {\n    toggleDarkMode(state) {\n      state.isDarkMode = !state.isDarkMode;\n    }\n  }\n});\n\nexport const { toggleDarkMode } = themeSlice.actions;\nexport default themeSlice.reducer;",
        "imports": [
          "@reduxjs/toolkit"
        ],
        "exports": [
          null,
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit"
        ]
      },
      {
        "path": "store/configureStore.js",
        "content": "// src/store/configureStore.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport spatialReducer from '../slices/spatialSlice';\nimport themeReducer from '../slices/themeSlice';\nimport welcomeModalReducer from './welcomeModalSlice';\nimport ecmReducer from '../slices/ecmSlice';\nimport flowReducer from '../slices/flowSlice';\nimport { createBatchMiddleware } from '../middleware/batchMiddleware';\nimport { createSpatialMiddleware } from '../middleware/spatialMiddleware';\nimport { spatialHandler } from '../utils/spatialDataHandler';\nimport { backgroundMonitor, MetricTypes } from '../utils/backgroundMonitor';\n\nlet store = null;\n\nexport const configureAppStore = async () => {\n  if (store) {\n    return store;\n  }\n\n  // Start store configuration metric\n  const configMetric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n    component: 'store',\n    timestamp: Date.now()\n  });\n\n  try {\n    // Initialize middleware\n    const spatialMiddleware = createSpatialMiddleware();\n    const batchMiddleware = createBatchMiddleware();\n\n    const ignoredPaths = {\n      spatial: [\n        'spatial.data.flowData',\n        'spatial.data.spatialAnalysis',\n        'spatial.data.cache',\n        'spatial.data.geometry',\n        'spatial.data.visualizationData',\n        'spatial.data.regressionAnalysis',\n        'spatial.data.marketClusters',\n        'spatial.data.flowMaps',\n        'spatial.data.marketShocks',\n        'spatial.data.timeSeriesData',\n        'spatial.data.spatialAutocorrelation',\n        'spatial.data.seasonalAnalysis',\n        'spatial.data.marketIntegration',\n        'spatial.data.uniqueMonths'\n      ],\n      flow: [\n        'flow.flows',\n        'flow.byDate',\n        'flow.byRegion',\n        'flow.metadata'\n      ],\n      ecm: [\n        'ecm.data.unified',\n        'ecm.data.directional',\n        'ecm.data.residuals',\n        'ecm.data.cache'\n      ]\n    };\n\n    const ignoredActions = {\n      spatial: [\n        'spatial/fetchAllSpatialData/fulfilled',\n        'spatial/fetchFlowData/fulfilled',\n        'spatial/batchUpdate',\n        'spatial/updateGeometry',\n        'spatial/updateData',\n        'spatial/updateUI'\n      ],\n      flow: [\n        'flow/fetchData/fulfilled',\n        'flow/fetchData/pending',\n        'flow/updateFlowMetrics'\n      ],\n      ecm: [\n        'ecm/fetchECMData/fulfilled',\n        'ecm/fetchECMData/pending',\n        'ecm/setSelectedCommodity'\n      ]\n    };\n\n    store = configureStore({\n      reducer: {\n        spatial: spatialReducer,\n        theme: themeReducer,\n        welcomeModal: welcomeModalReducer,\n        ecm: ecmReducer,\n        flow: flowReducer\n      },\n      middleware: (getDefaultMiddleware) => {\n        const defaultMiddleware = getDefaultMiddleware({\n          serializableCheck: {\n            warnAfter: 5000,\n            ignoredPaths: [...ignoredPaths.spatial, ...ignoredPaths.flow, ...ignoredPaths.ecm],\n            ignoredActions: [...ignoredActions.spatial, ...ignoredActions.flow, ...ignoredActions.ecm]\n          },\n          immutableCheck: {\n            warnAfter: 1000,\n            ignoredPaths: [\n              'spatial.data',\n              'spatial.status',\n              'spatial.ui.view',\n              'spatial.data.cache',\n              'spatial.data.geometry',\n              'flow.flows',\n              'flow.byDate',\n              'flow.byRegion',\n              'ecm.data',\n              'ecm.status',\n              'ecm.data.cache'\n            ]\n          },\n          thunk: {\n            extraArgument: {\n              spatialHandler,\n              backgroundMonitor,\n              MetricTypes\n            },\n            timeout: 30000\n          }\n        });\n\n        const middleware = [\n          ...defaultMiddleware,\n          batchMiddleware,\n          spatialMiddleware\n        ];\n\n        // Add development tools\n        if (process.env.NODE_ENV === 'development') {\n          const { createLogger } = require('redux-logger');\n          const logger = createLogger({\n            collapsed: true,\n            duration: true,\n            timestamp: true,\n            colors: {\n              title: (action) => action.error ? 'red' : 'blue',\n              prevState: () => '#9E9E9E',\n              action: () => '#03A9F4',\n              nextState: () => '#4CAF50',\n              error: () => '#F20404'\n            },\n            predicate: (getState, action) => {\n              if (!action || typeof action !== 'object' || !action.type) {\n                return false;\n              }\n              const skippedActions = [\n                'spatial/setProgress',\n                'spatial/setLoadingStage',\n                'spatial/updateCache',\n                'spatial/updateProgress',\n                'flow/updateFlowMetrics',\n                'ecm/updateCache'\n              ];\n              return !skippedActions.includes(action.type);\n            },\n            actionTransformer: (action) => {\n              if (!action || typeof action !== 'object') {\n                return action;\n              }\n\n              const transformers = {\n                'spatial/fetchAllSpatialData/fulfilled': (payload) => ({\n                  type: 'SPATIAL_DATA',\n                  geometry: {\n                    pointCount: payload?.geometry?.points?.length,\n                    polygonCount: payload?.geometry?.polygons?.length,\n                    hasUnified: !!payload?.geometry?.unified\n                  }\n                }),\n                'flow/fetchData/fulfilled': (payload) => ({\n                  type: 'FLOW_DATA',\n                  flowCount: payload?.flows?.length || 0,\n                  dateRange: payload?.metadata?.dateRange,\n                  uniqueMarkets: payload?.metadata?.uniqueMarkets\n                }),\n                'ecm/fetchECMData/fulfilled': (payload) => ({\n                  type: 'ECM_DATA',\n                  unifiedCount: payload?.unified?.length || 0,\n                  directionalCount: {\n                    northToSouth: payload?.directional?.northToSouth?.length || 0,\n                    southToNorth: payload?.directional?.southToNorth?.length || 0\n                  }\n                })\n              };\n\n              if (action.type && transformers[action.type]) {\n                return {\n                  ...action,\n                  payload: transformers[action.type](action.payload)\n                };\n              }\n              return action;\n            }\n          });\n          middleware.push(logger);\n        }\n\n        return middleware;\n      },\n      devTools: process.env.NODE_ENV === 'development' && {\n        maxAge: 50,\n        trace: true,\n        traceLimit: 25,\n        actionsBlacklist: [\n          'spatial/setProgress',\n          'spatial/setLoadingStage',\n          'flow/updateFlowMetrics',\n          'ecm/updateCache'\n        ]\n      }\n    });\n\n    // Add development tools\n    if (process.env.NODE_ENV === 'development') {\n      const monitorHealth = backgroundMonitor.checkHealth();\n      \n      window.__REDUX_STORE__ = store;\n      window.__REDUX_DEBUGGER__ = {\n        getState: () => store.getState(),\n        dispatch: store.dispatch,\n        spatialData: {\n          getGeometry: () => store.getState().spatial.data.geometry,\n          validateGeometry: () => {\n            const geometry = store.getState().spatial.data.geometry;\n            return {\n              hasPoints: Array.isArray(geometry?.points),\n              hasPolygons: Array.isArray(geometry?.polygons),\n              hasUnified: Boolean(geometry?.unified),\n              pointCount: geometry?.points?.length || 0,\n              polygonCount: geometry?.polygons?.length || 0\n            };\n          }\n        },\n        flowData: {\n          getState: () => store.getState().flow,\n          validateData: () => {\n            const flowState = store.getState().flow;\n            return {\n              hasFlows: Array.isArray(flowState?.flows),\n              flowCount: flowState?.flows?.length || 0,\n              uniqueMarkets: flowState?.metadata?.uniqueMarkets || 0,\n              dateRange: flowState?.metadata?.dateRange,\n              loadingStatus: flowState?.status?.loading,\n              error: flowState?.status?.error\n            };\n          }\n        },\n        ecmData: {\n          getState: () => store.getState().ecm,\n          validateData: () => {\n            const ecmState = store.getState().ecm;\n            return {\n              hasUnifiedData: Array.isArray(ecmState?.data?.unified),\n              hasDirectionalData: Boolean(ecmState?.data?.directional),\n              commodityCount: ecmState?.data?.commodities?.length || 0,\n              loadingStatus: ecmState?.status?.loading,\n              error: ecmState?.status?.error\n            };\n          }\n        },\n        monitor: {\n          health: monitorHealth,\n          getActionLog: () => backgroundMonitor.getMetrics(MetricTypes.SYSTEM.PERFORMANCE),\n          getFlowMetrics: () => backgroundMonitor.getMetrics(MetricTypes.FLOW.DATA_LOAD),\n          getSpatialMetrics: () => backgroundMonitor.getMetrics(MetricTypes.SPATIAL.DATA_LOAD),\n          getErrors: () => backgroundMonitor.getErrors(),\n          clearMetrics: () => backgroundMonitor.clearMetrics()\n        }\n      };\n    }\n\n    // Verify store initialization\n    const initialState = store.getState();\n    if (!initialState.spatial || !initialState.theme || !initialState.welcomeModal) {\n      throw new Error('Store initialization failed: missing required reducers');\n    }\n\n    configMetric.finish({\n      status: 'success',\n      reducerCount: Object.keys(store.getState()).length,\n      middlewareCount: store.middleware?.length || 0\n    });\n\n    return store;\n  } catch (error) {\n    configMetric.finish({\n      status: 'error',\n      error: error.message\n    });\n    throw error;\n  }\n};\n\n// Export a function to get the store instance\nexport const getStore = () => {\n  if (!store) {\n    throw new Error('Store has not been initialized. Call configureAppStore() first.');\n  }\n  return store;\n};\n\nexport default {\n  configureAppStore,\n  getStore\n};\n",
        "imports": [
          "@reduxjs/toolkit",
          "../slices/spatialSlice",
          "../slices/themeSlice",
          "./welcomeModalSlice",
          "../slices/ecmSlice",
          "../slices/flowSlice",
          "../middleware/batchMiddleware",
          "../middleware/spatialMiddleware",
          "../utils/spatialDataHandler",
          "../utils/backgroundMonitor"
        ],
        "exports": [
          "configureAppStore",
          "getStore",
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "../slices/spatialSlice",
          "../slices/themeSlice",
          "./welcomeModalSlice",
          "../slices/ecmSlice",
          "../slices/flowSlice",
          "../middleware/batchMiddleware",
          "../middleware/spatialMiddleware",
          "../utils/spatialDataHandler",
          "../utils/backgroundMonitor"
        ]
      },
      {
        "path": "store/createStore.js",
        "content": "// src/store/createStore.js\n\nimport { configureStore, combineReducers } from '@reduxjs/toolkit';\nimport { createLogger } from 'redux-logger';\nimport themeReducer from '../slices/themeSlice';\nimport welcomeModalReducer from './welcomeModalSlice';\nimport { backgroundMonitor, MetricTypes } from '../utils/backgroundMonitor';\n\n// Essential reducers loaded immediately\nconst CRITICAL_REDUCERS = {\n  theme: themeReducer,\n  welcomeModal: welcomeModalReducer\n};\n\n// Create a reducer manager for dynamic reducer injection\nexport function createReducerManager(initialReducers) {\n  const reducers = { ...initialReducers };\n  let combinedReducer = combineReducers(reducers);\n  let keysToRemove = [];\n\n  return {\n    getReducerMap: () => reducers,\n\n    reduce: (state, action) => {\n      if (keysToRemove.length > 0) {\n        state = { ...state };\n        for (const key of keysToRemove) {\n          delete state[key];\n        }\n        keysToRemove = [];\n      }\n      return combinedReducer(state, action);\n    },\n\n    add: (key, reducer) => {\n      if (!key || reducers[key]) return;\n      const metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n        action: 'add-reducer',\n        reducer: key\n      });\n\n      try {\n        reducers[key] = reducer;\n        combinedReducer = combineReducers(reducers);\n        metric.finish({ status: 'success' });\n      } catch (error) {\n        metric.finish({ status: 'error', error: error.message });\n        throw error;\n      }\n    },\n\n    remove: (key) => {\n      if (!key || !reducers[key]) return;\n      const metric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n        action: 'remove-reducer',\n        reducer: key\n      });\n      try {\n        delete reducers[key];\n        keysToRemove.push(key);\n        combinedReducer = combineReducers(reducers);\n        metric.finish({ status: 'success' });\n      } catch (error) {\n        metric.finish({ status: 'error', error: error.message });\n        throw error;\n      }\n    }\n  };\n}\n\nconst STATE_PERSISTENCE_CONFIG = {\n  whitelist: ['theme', 'welcomeModal'],\n  storage: window.localStorage,\n  key: 'yemen-market-analysis'\n};\n\n// Load persisted state\nfunction loadPersistedState() {\n  try {\n    const serializedState = STATE_PERSISTENCE_CONFIG.storage.getItem(STATE_PERSISTENCE_CONFIG.key);\n    return serializedState ? JSON.parse(serializedState) : {};\n  } catch (error) {\n    backgroundMonitor.logError('state-load-error', error);\n    return {};\n  }\n}\n\n// Persist state on changes\nfunction setupPersistence(store) {\n  store.subscribe(() => {\n    const state = store.getState();\n    const persistedData = {};\n\n    STATE_PERSISTENCE_CONFIG.whitelist.forEach(key => {\n      if (state[key]) {\n        persistedData[key] = state[key];\n      }\n    });\n\n    try {\n      STATE_PERSISTENCE_CONFIG.storage.setItem(\n        STATE_PERSISTENCE_CONFIG.key,\n        JSON.stringify(persistedData)\n      );\n    } catch (error) {\n      backgroundMonitor.logError('state-persistence-error', error);\n    }\n  });\n}\n\nexport function configureAppStore(preloadedState = {}) {\n  const configMetric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n    component: 'store-config'\n  });\n\n  try {\n    const reducerManager = createReducerManager(CRITICAL_REDUCERS);\n    const isDevelopment = process.env.NODE_ENV === 'development';\n\n    const middleware = (getDefaultMiddleware) => {\n      const defaultMiddleware = getDefaultMiddleware({\n        thunk: {\n          extraArgument: { backgroundMonitor, MetricTypes },\n          timeout: 30000\n        },\n        serializableCheck: {\n          warnAfter: 2000\n        },\n        immutableCheck: {\n          warnAfter: 1000\n        }\n      });\n\n      const middlewareList = [...defaultMiddleware];\n\n      if (isDevelopment) {\n        const logger = createLogger({\n          collapsed: true,\n          duration: true,\n          timestamp: true,\n          colors: {\n            title: action => (action.error ? 'red' : 'blue'),\n            prevState: () => '#9E9E9E',\n            action: () => '#03A9F4',\n            nextState: () => '#4CAF50',\n            error: () => '#F20404'\n          },\n          predicate: (getState, action) => !!action.type // log all actions in dev for now\n        });\n\n        middlewareList.push(logger);\n      }\n\n      return middlewareList;\n    };\n\n    const store = configureStore({\n      reducer: reducerManager.reduce,\n      middleware,\n      preloadedState: {\n        ...preloadedState,\n        ...loadPersistedState()\n      },\n      devTools: isDevelopment && {\n        maxAge: 50,\n        trace: true,\n        traceLimit: 25\n      }\n    });\n\n    store.reducerManager = reducerManager;\n\n    // Allow lazy loading reducers\n    store.injectReducer = async (key, asyncReducer) => {\n      const injectMetric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n        action: 'inject-reducer',\n        reducer: key\n      });\n\n      try {\n        if (store.reducerManager.getReducerMap()[key]) {\n          injectMetric.finish({ status: 'skipped', reason: 'already-exists' });\n          return;\n        }\n\n        const reducer = await asyncReducer();\n        store.reducerManager.add(key, reducer.default || reducer);\n        injectMetric.finish({ status: 'success' });\n        return reducer;\n      } catch (error) {\n        injectMetric.finish({ status: 'error', error: error.message });\n        throw error;\n      }\n    };\n\n    setupPersistence(store);\n\n    configMetric.finish({\n      status: 'success',\n      reducerCount: Object.keys(reducerManager.getReducerMap()).length\n    });\n\n    return store;\n  } catch (error) {\n    configMetric.finish({ status: 'error', error: error.message });\n    throw error;\n  }\n}\n\nexport default configureAppStore;",
        "imports": [
          "@reduxjs/toolkit",
          "redux-logger",
          "../slices/themeSlice",
          "./welcomeModalSlice",
          "../utils/backgroundMonitor"
        ],
        "exports": [
          "createReducerManager",
          "configureAppStore",
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "redux-logger",
          "../slices/themeSlice",
          "./welcomeModalSlice",
          "../utils/backgroundMonitor"
        ]
      },
      {
        "path": "store/index.js",
        "content": "// src/store/index.js\n\nimport configureAppStore from './createStore';\nimport { backgroundMonitor, MetricTypes } from '../utils/backgroundMonitor';\nimport themeReducer from '../slices/themeSlice';\n\n// Initialize store with critical reducers\nlet store = null;\n\nexport const initializeStore = async () => {\n  const initMetric = backgroundMonitor.startMetric(MetricTypes.SYSTEM.INIT, {\n    component: 'store'\n  });\n\n  try {\n    store = configureAppStore({\n      theme: themeReducer\n    });\n\n    // Lazy load additional reducers only when needed\n    // Example: Load spatial reducer on-demand\n    // await store.injectReducer('spatial', () => import('../slices/spatialSlice'));\n\n    initMetric.finish({\n      status: 'success',\n      reducerCount: Object.keys(store.reducerManager.getReducerMap()).length\n    });\n\n    return store;\n  } catch (error) {\n    initMetric.finish({ status: 'error', error: error.message });\n    throw error;\n  }\n};\n\nexport const getStore = () => {\n  if (!store) {\n    throw new Error('Store not initialized. Call initializeStore() first.');\n  }\n  return store;\n};",
        "imports": [
          "./createStore",
          "../utils/backgroundMonitor",
          "../slices/themeSlice"
        ],
        "exports": [
          "initializeStore",
          "getStore"
        ],
        "dependencies": [
          "./createStore",
          "../utils/backgroundMonitor",
          "../slices/themeSlice"
        ]
      },
      {
        "path": "store/welcomeModalSlice.js",
        "content": "// src/store/welcomeModalSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n  hasSeenWelcome: localStorage.getItem('hasSeenWelcome') === 'true'\n};\n\nconst welcomeModalSlice = createSlice({\n  name: 'welcomeModal',\n  initialState,\n  reducers: {\n    setHasSeenWelcome: (state, action) => {\n      state.hasSeenWelcome = true;\n      if (action.payload) {\n        localStorage.setItem('hasSeenWelcome', 'true');\n      }\n    }\n  }\n});\n\nexport const { setHasSeenWelcome } = welcomeModalSlice.actions;\nexport const selectHasSeenWelcome = (state) => state.welcomeModal.hasSeenWelcome;\nexport default welcomeModalSlice.reducer;",
        "imports": [
          "@reduxjs/toolkit"
        ],
        "exports": [
          null,
          "selectHasSeenWelcome",
          "default"
        ],
        "dependencies": [
          "@reduxjs/toolkit"
        ]
      },
      {
        "path": "styles/LayoutStyles.js",
        "content": "// src/styles/LayoutStyles.js\n\nimport { styled } from '@mui/material/styles';\nimport { Box } from '@mui/material';\n\nexport const drawerWidth = 240;\n\nexport const LayoutContainer = styled(Box)(({ theme }) => ({\n  display: 'flex',\n  minHeight: '100vh',\n  width: '100%',\n  flexDirection: 'row', // Default layout is row\n  [theme.breakpoints.down('sm')]: {\n    flexDirection: 'column', // Stack elements vertically on small screens\n  },\n}));\n\nexport const MainContent = styled('main')(({ theme }) => ({\n  flexGrow: 1,\n  overflow: 'auto',\n  display: 'flex',\n  flexDirection: 'column',\n  [theme.breakpoints.down('sm')]: {\n    width: '100%',\n  },\n}));\n\nexport const SidebarWrapper = styled(Box)(({ theme, open }) => ({\n  width: open ? drawerWidth : 0,\n  flexShrink: 0,\n  transition: theme.transitions.create(['width', 'height'], {\n    easing: theme.transitions.easing.sharp,\n    duration: theme.transitions.duration.standard,\n  }),\n  [theme.breakpoints.down('sm')]: {\n    width: '100%',\n    height: open ? 'auto' : 0, // Control the height on small screens\n    overflow: 'hidden', // Hide content when closed\n  },\n}));\n",
        "imports": [
          "@mui/material/styles",
          "@mui/material"
        ],
        "exports": [
          "drawerWidth",
          "LayoutContainer",
          "MainContent",
          "SidebarWrapper"
        ],
        "dependencies": [
          "@mui/material/styles",
          "@mui/material"
        ]
      },
      {
        "path": "styles/analysisStyles.js",
        "content": "// src/styles/analysisStyles.js\n\nimport { alpha } from '@mui/material/styles';\n\nexport const analysisStyles = (theme) => ({\n  root: {\n    marginTop: theme.spacing(4),\n    padding: theme.spacing(4),\n    width: '100%',\n    backgroundColor: theme.palette.background.paper,\n    borderRadius: theme.shape.borderRadius,\n    boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n  },\n  header: {\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    flexDirection: { xs: 'column', sm: 'row' },\n    padding: theme.spacing(3),\n    backgroundColor: theme.palette.background.paper,\n    borderBottom: `1px solid ${theme.palette.divider}`,\n    marginBottom: theme.spacing(4),\n  },\n  title: {\n    fontFamily: '\"Merriweather\", serif',\n    fontWeight: 700,\n    fontSize: '1.75rem',\n    color: theme.palette.primary.main,\n    display: 'flex',\n    alignItems: 'center',\n    gap: theme.spacing(1),\n    marginBottom: theme.spacing(1),\n  },\n  subtitle: {\n    color: theme.palette.text.secondary,\n    fontSize: '1rem',\n    marginBottom: theme.spacing(2),\n  },\n  infoIcon: {\n    color: theme.palette.info.main,\n    '&:hover': {\n      color: theme.palette.info.dark,\n    },\n  },\n  controlsContainer: {\n    display: 'flex',\n    flexDirection: { xs: 'column', sm: 'row' },\n    gap: theme.spacing(2),\n    alignItems: 'center',\n    marginTop: { xs: theme.spacing(2), sm: 0 },\n    padding: theme.spacing(2),\n    backgroundColor: alpha(theme.palette.background.default, 0.5),\n    borderRadius: theme.shape.borderRadius,\n  },\n  toggleGroup: {\n    backgroundColor: theme.palette.background.paper,\n    borderRadius: theme.shape.borderRadius,\n    '& .MuiToggleButton-root': {\n      padding: '8px 16px',\n      border: `1px solid ${theme.palette.divider}`,\n      '&.Mui-selected': {\n        backgroundColor: theme.palette.primary.main,\n        color: theme.palette.primary.contrastText,\n        fontWeight: 600,\n        '&:hover': {\n          backgroundColor: theme.palette.primary.dark,\n        },\n      },\n    },\n  },\n  downloadButton: {\n    backgroundColor: theme.palette.success.main,\n    color: theme.palette.common.white,\n    '&:hover': {\n      backgroundColor: theme.palette.success.dark,\n    },\n  },\n  resultsContainer: {\n    marginTop: theme.spacing(4),\n  },\n  sectionTitle: {\n    fontFamily: '\"Merriweather\", serif',\n    color: theme.palette.primary.main,\n    fontSize: '1.25rem',\n    fontWeight: 700,\n    marginBottom: theme.spacing(3),\n    paddingBottom: theme.spacing(1),\n    borderBottom: `2px solid ${alpha(theme.palette.primary.main, 0.1)}`,\n  },\n  insightCard: {\n    padding: theme.spacing(3),\n    height: '100%',\n    backgroundColor: theme.palette.background.paper,\n    borderRadius: theme.shape.borderRadius,\n    boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n    transition: 'box-shadow 0.3s ease-in-out',\n    '&:hover': {\n      boxShadow: '0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23)',\n    },\n  },\n  insightHeader: {\n    display: 'flex',\n    alignItems: 'center',\n    gap: theme.spacing(2),\n    marginBottom: theme.spacing(2),\n    '& .MuiSvgIcon-root': {\n      fontSize: '2rem',\n      color: theme.palette.primary.main,\n    },\n  },\n  insightValue: {\n    color: theme.palette.primary.main,\n    fontWeight: 700,\n    fontSize: '2rem',\n    marginBottom: theme.spacing(1),\n  },\n  chartPaper: {\n    padding: theme.spacing(3),\n    marginBottom: theme.spacing(4),\n    backgroundColor: theme.palette.background.paper,\n    borderRadius: theme.shape.borderRadius,\n    boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n  },\n  chartTitle: {\n    fontFamily: '\"Merriweather\", serif',\n    fontSize: '1.1rem',\n    fontWeight: 600,\n    color: theme.palette.text.primary,\n    marginBottom: theme.spacing(2),\n  },\n  chartDescription: {\n    color: theme.palette.text.secondary,\n    fontSize: '0.875rem',\n    marginTop: theme.spacing(2),\n    padding: theme.spacing(2),\n    backgroundColor: alpha(theme.palette.background.default, 0.5),\n    borderRadius: theme.shape.borderRadius,\n    border: `1px solid ${theme.palette.divider}`,\n  },\n  interpretationGuide: {\n    marginTop: theme.spacing(4),\n    padding: theme.spacing(3),\n    backgroundColor: alpha(theme.palette.info.main, 0.03),\n    borderRadius: theme.shape.borderRadius,\n    border: `1px solid ${alpha(theme.palette.info.main, 0.1)}`,\n  },\n  methodologyNote: {\n    marginTop: theme.spacing(2),\n    padding: theme.spacing(2),\n    backgroundColor: alpha(theme.palette.background.default, 0.5),\n    borderRadius: theme.shape.borderRadius,\n    fontSize: '0.875rem',\n    color: theme.palette.text.secondary,\n  },\n  alert: {\n    marginBottom: theme.spacing(2),\n    '& .MuiAlert-icon': {\n      fontSize: '1.5rem',\n    },\n  },\n  divider: {\n    margin: theme.spacing(4, 0),\n  },\n});\n\nexport const chartStyles = (theme) => ({\n  chartContainer: {\n    marginTop: theme.spacing(3),\n    padding: theme.spacing(3),\n    backgroundColor: theme.palette.background.paper,\n    borderRadius: theme.shape.borderRadius,\n    boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n  },\n  tooltip: {\n    backgroundColor: alpha(theme.palette.background.paper, 0.95),\n    padding: theme.spacing(1.5),\n    border: `1px solid ${theme.palette.divider}`,\n    boxShadow: theme.shadows[2],\n  },\n});\n",
        "imports": [
          "@mui/material/styles"
        ],
        "exports": [
          "analysisStyles",
          "chartStyles"
        ],
        "dependencies": [
          "@mui/material/styles"
        ]
      },
      {
        "path": "styles/theme.js",
        "content": "// src/styles/theme.js\n\nimport { createTheme, alpha } from '@mui/material/styles';\n\nconst baseTheme = {\n  breakpoints: {\n    values: {\n      xs: 0,\n      sm: 600,\n      md: 960,\n      lg: 1280,\n      xl: 1920,\n    },\n  },\n  typography: {\n    fontFamily: '\"Roboto\", \"Helvetica Neue\", \"Arial\", sans-serif',\n    h1: {\n      fontFamily: '\"Roboto\", \"Helvetica Neue\", \"Arial\", sans-serif',\n      fontWeight: 700,\n    },\n    h2: {\n      fontFamily: '\"Roboto\", \"Helvetica Neue\", \"Arial\", sans-serif',\n      fontWeight: 700,\n    },\n    h3: {\n      fontFamily: '\"Roboto\", \"Helvetica Neue\", \"Arial\", sans-serif',\n      fontWeight: 700,\n    },\n    h4: {\n      fontFamily: '\"Roboto\", \"Helvetica Neue\", \"Arial\", sans-serif',\n      fontWeight: 700,\n    },\n    h5: {\n      fontFamily: '\"Roboto\", \"Helvetica Neue\", \"Arial\", sans-serif',\n      fontWeight: 700,\n    },\n    h6: {\n      fontFamily: '\"Roboto\", \"Helvetica Neue\", \"Arial\", sans-serif',\n      fontWeight: 700,\n    },\n    subtitle1: {\n      fontWeight: 600,\n    },\n    body1: {\n      fontSize: '1rem',\n      lineHeight: 1.7,\n    },\n    body2: {\n      fontSize: '0.875rem',\n      lineHeight: 1.7,\n    },\n  },\n  shape: {\n    borderRadius: 4,\n  },\n  spacing: 8,\n};\n\n// World Bank style color palette\nconst worldBankColors = {\n  primary: {\n    main: '#002244', // World Bank Blue\n    light: '#003366',\n    dark: '#001a33',\n    contrastText: '#ffffff',\n  },\n  secondary: {\n    main: '#009FDA', // World Bank Light Blue\n    light: '#33b1e1',\n    dark: '#006e98',\n    contrastText: '#ffffff',\n  },\n  success: {\n    main: '#4C9F38', // World Bank Green\n    light: '#6ab553',\n    dark: '#357027',\n  },\n  warning: {\n    main: '#F0AB00', // World Bank Yellow\n    light: '#ffbe2f',\n    dark: '#b88000',\n  },\n  error: {\n    main: '#E73F3F', // World Bank Red\n    light: '#eb6565',\n    dark: '#c62828',\n  },\n  info: {\n    main: '#0077BB', // World Bank Info Blue\n    light: '#3391c9',\n    dark: '#005282',\n  },\n};\n\n// Light Theme Configuration\nconst lightTheme = createTheme({\n  ...baseTheme,\n  palette: {\n    mode: 'light',\n    ...worldBankColors,\n    background: {\n      default: '#f8f9fa',\n      paper: '#ffffff',\n      sidebar: '#ffffff',\n    },\n    text: {\n      primary: '#1a1a1a',\n      secondary: '#4f4f4f',\n    },\n    divider: 'rgba(0, 0, 0, 0.12)',\n    action: {\n      hover: alpha('#000000', 0.04),\n      selected: alpha(worldBankColors.primary.main, 0.08),\n      selectedOpacity: 0.08,\n      focus: alpha(worldBankColors.primary.main, 0.12),\n    },\n  },\n});\n\n// Dark Theme Configuration\nconst darkTheme = createTheme({\n  ...baseTheme,\n  palette: {\n    mode: 'dark',\n    ...worldBankColors,\n    background: {\n      default: '#1a1a1a',\n      paper: '#262626',\n      sidebar: '#1e1e1e',\n    },\n    text: {\n      primary: '#ffffff',\n      secondary: '#b3b3b3',\n    },\n    divider: 'rgba(255, 255, 255, 0.12)',\n    action: {\n      hover: alpha('#ffffff', 0.08),\n      selected: alpha(worldBankColors.primary.light, 0.16),\n      selectedOpacity: 0.16,\n      focus: alpha(worldBankColors.primary.light, 0.12),\n    },\n  },\n});\n\n// Theme Overrides\nconst themeOverrides = {\n  components: {\n    MuiCssBaseline: {\n      styleOverrides: (theme) => ({\n        ':root': {\n          '--mui-palette-primary-main': theme.palette.primary.main,\n          '--mui-palette-background-paper': theme.palette.background.paper,\n          '--mui-palette-background-default': theme.palette.background.default,\n          '--mui-palette-text-primary': theme.palette.text.primary,\n          '--mui-palette-text-secondary': theme.palette.text.secondary,\n          '--mui-palette-action-hover': theme.palette.action.hover,\n          '--mui-shadow-1': theme.shadows[1],\n          '--mui-shadow-2': theme.shadows[2],\n        },\n      }),\n    },\n    MuiDrawer: {\n      styleOverrides: {\n        paper: ({ theme }) => ({\n          backgroundColor: theme.palette.background.sidebar,\n          backgroundImage: 'none',\n          '& .MuiDivider-root': {\n            borderColor: theme.palette.divider,\n          },\n        }),\n      },\n    },\n    MuiListItemButton: {\n      styleOverrides: {\n        root: ({ theme }) => ({\n          '&.Mui-selected': {\n            backgroundColor: theme.palette.action.selected,\n            '&:hover': {\n              backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + 0.04),\n            },\n          },\n          '&:hover': {\n            backgroundColor: theme.palette.action.hover,\n          },\n        }),\n      },\n    },\n    MuiSelect: {\n      styleOverrides: {\n        icon: ({ theme }) => ({\n          color: theme.palette.text.secondary,\n        }),\n      },\n    },\n    MuiButton: {\n      styleOverrides: {\n        root: {\n          textTransform: 'none',\n          borderRadius: 4,\n          fontWeight: 600,\n          padding: '8px 24px',\n        },\n        contained: {\n          boxShadow: 'none',\n          '&:hover': {\n            boxShadow: '0 2px 4px rgba(0,0,0,0.15)',\n          },\n        },\n        outlined: ({ theme }) => ({\n          borderColor: theme.palette.divider,\n          '&:hover': {\n            borderColor: theme.palette.primary.main,\n            backgroundColor: alpha(theme.palette.primary.main, 0.04),\n          },\n        }),\n      },\n    },\n    MuiPaper: {\n      styleOverrides: {\n        root: {\n          borderRadius: 4,\n          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n        },\n        elevation1: {\n          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n        },\n      },\n    },\n    MuiCard: {\n      styleOverrides: {\n        root: {\n          borderRadius: 4,\n          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n        },\n      },\n    },\n    MuiTypography: {\n      styleOverrides: {\n        root: {\n          '&.MuiTypography-h1, &.MuiTypography-h2, &.MuiTypography-h3, &.MuiTypography-h4, &.MuiTypography-h5, &.MuiTypography-h6': {\n            fontFamily: '\"Roboto\", \"Helvetica Neue\", \"Arial\", sans-serif',\n            marginBottom: '0.5em',\n          },\n        },\n      },\n    },\n    MuiToggleButton: {\n      styleOverrides: {\n        root: {\n          fontWeight: 600,\n          '&.Mui-selected': {\n            backgroundColor: worldBankColors.primary.main,\n            color: '#ffffff',\n            '&:hover': {\n              backgroundColor: worldBankColors.primary.dark,\n            },\n          },\n        },\n      },\n    },\n    // Chart theme overrides\n    MuiChart: {\n      styleOverrides: {\n        root: (theme) => ({\n          '& .recharts-cartesian-grid-horizontal line, & .recharts-cartesian-grid-vertical line': {\n            stroke: theme.palette.divider,\n          },\n          '& .recharts-text': {\n            fill: theme.palette.text.primary,\n          },\n          '& .recharts-legend-item-text': {\n            color: theme.palette.text.primary,\n          },\n          '& .recharts-tooltip': {\n            backgroundColor: theme.palette.background.paper,\n            border: `1px solid ${theme.palette.divider}`,\n            boxShadow: theme.shadows[2],\n          },\n        }),\n      },\n    },\n  },\n};\n\n// Export Themes\nexport const lightThemeWithOverrides = createTheme(lightTheme, themeOverrides);\nexport const darkThemeWithOverrides = createTheme(darkTheme, themeOverrides);\n\nexport default lightThemeWithOverrides;\n",
        "imports": [
          "@mui/material/styles"
        ],
        "exports": [
          "lightThemeWithOverrides",
          "darkThemeWithOverrides",
          "default"
        ],
        "dependencies": [
          "@mui/material/styles"
        ]
      },
      {
        "path": "types/dataTypes.js",
        "content": "// src/types/dataTypes.js\n\n/**\n * Default regression analysis data structure\n */\nexport const DEFAULT_REGRESSION_DATA = {\n  model: {\n    coefficients: {},\n    r_squared: 0,\n    adj_r_squared: 0,\n    f_statistic: 0,\n    p_value: 1,\n    observations: 0,\n    mse: 0\n  },\n  spatial: {\n    moran_i: {\n      I: 0,\n      'p-value': 1\n    },\n    vif: []\n  },\n  residuals: {\n    raw: [],\n    byRegion: {},\n    stats: {\n      mean: 0,\n      variance: 0,\n      maxAbsolute: 0\n    }\n  },\n  metadata: {\n    timestamp: null,\n    version: '1.0',\n    commodity: '',\n    period: {\n      start: null,\n      end: null\n    }\n  }\n};\n\n/**\n * Validate regression data structure\n * @param {Object} data - Data to validate\n * @returns {boolean} Whether the data is valid\n */\nexport const isValidRegressionData = (data) => {\n  if (!data || typeof data !== 'object') return false;\n\n  // Check model properties\n  const hasValidModel = data.model && \n    typeof data.model === 'object' &&\n    typeof data.model.coefficients === 'object' &&\n    typeof data.model.r_squared === 'number' &&\n    typeof data.model.adj_r_squared === 'number' &&\n    typeof data.model.f_statistic === 'number' &&\n    typeof data.model.p_value === 'number' &&\n    typeof data.model.observations === 'number' &&\n    typeof data.model.mse === 'number';\n\n  if (!hasValidModel) return false;\n\n  // Check spatial properties\n  const hasValidSpatial = data.spatial &&\n    typeof data.spatial === 'object' &&\n    data.spatial.moran_i &&\n    typeof data.spatial.moran_i.I === 'number' &&\n    typeof data.spatial.moran_i['p-value'] === 'number' &&\n    Array.isArray(data.spatial.vif);\n\n  if (!hasValidSpatial) return false;\n\n  // Check residuals properties\n  const hasValidResiduals = data.residuals &&\n    typeof data.residuals === 'object' &&\n    Array.isArray(data.residuals.raw) &&\n    typeof data.residuals.byRegion === 'object' &&\n    data.residuals.stats &&\n    typeof data.residuals.stats.mean === 'number' &&\n    typeof data.residuals.stats.variance === 'number' &&\n    typeof data.residuals.stats.maxAbsolute === 'number';\n\n  if (!hasValidResiduals) return false;\n\n  // Check metadata properties\n  const hasValidMetadata = data.metadata &&\n    typeof data.metadata === 'object' &&\n    typeof data.metadata.version === 'string' &&\n    typeof data.metadata.commodity === 'string' &&\n    data.metadata.period &&\n    typeof data.metadata.period === 'object';\n\n  return hasValidMetadata;\n};\n\n/**\n * Market cluster data structure\n */\nexport const MARKET_CLUSTER_TYPE = {\n  cluster_id: '',\n  main_market: '',\n  connected_markets: [],\n  metrics: {\n    efficiency: 0,\n    internal_connectivity: 0,\n    market_coverage: 0,\n    price_convergence: 0,\n    stability: 0\n  }\n};\n\n/**\n * Market flow data structure\n */\nexport const MARKET_FLOW_TYPE = {\n  source: '',\n  target: '',\n  total_flow: 0,\n  avg_flow: 0,\n  flow_count: 0,\n  avg_price_differential: 0\n};\n\n/**\n * Market shock data structure\n */\nexport const MARKET_SHOCK_TYPE = {\n  region: '',\n  date: '',\n  shock_type: '',\n  magnitude: 0,\n  current_price: 0,\n  previous_price: 0\n};\n\n/**\n * Time series data point structure\n */\nexport const TIME_SERIES_TYPE = {\n  region: '',\n  month: '',\n  usdPrice: 0,\n  conflictIntensity: 0,\n  additionalProperties: {\n    date: null,\n    residual: 0\n  }\n};\n\n/**\n * Geometry data structure\n */\nexport const GEOMETRY_TYPE = {\n  points: [],\n  polygons: [],\n  unified: null,\n  metadata: {\n    lastUpdated: null,\n    version: '1.0'\n  }\n};\n\n/**\n * Market integration data structure\n */\nexport const MARKET_INTEGRATION_TYPE = {\n  price_correlation: {},\n  flow_density: 0,\n  accessibility: {},\n  integration_score: 0\n};\n\n/**\n * Spatial autocorrelation data structure\n */\nexport const SPATIAL_AUTOCORRELATION_TYPE = {\n  global: {\n    moran_i: 0,\n    p_value: 1,\n    z_score: null,\n    significance: false\n  },\n  local: {}\n};\n\n/**\n * Visualization data structure\n */\nexport const VISUALIZATION_DATA_TYPE = {\n  prices: null,\n  integration: null,\n  clusters: null,\n  shocks: null\n};\n\n/**\n * Status data structure\n */\nexport const STATUS_TYPE = {\n  loading: false,\n  error: null,\n  progress: 0,\n  stage: 'idle',\n  geometryLoading: false,\n  regressionLoading: false,\n  visualizationLoading: false,\n  dataFetching: false,\n  dataCaching: false,\n  lastUpdated: null,\n  retryCount: 0,\n  lastError: null\n};\n\n// Export all types\nexport const types = {\n  DEFAULT_REGRESSION_DATA,\n  MARKET_CLUSTER_TYPE,\n  MARKET_FLOW_TYPE,\n  MARKET_SHOCK_TYPE,\n  TIME_SERIES_TYPE,\n  GEOMETRY_TYPE,\n  MARKET_INTEGRATION_TYPE,\n  SPATIAL_AUTOCORRELATION_TYPE,\n  VISUALIZATION_DATA_TYPE,\n  STATUS_TYPE\n};\n",
        "imports": [],
        "exports": [
          "DEFAULT_REGRESSION_DATA",
          "isValidRegressionData",
          "MARKET_CLUSTER_TYPE",
          "MARKET_FLOW_TYPE",
          "MARKET_SHOCK_TYPE",
          "TIME_SERIES_TYPE",
          "GEOMETRY_TYPE",
          "MARKET_INTEGRATION_TYPE",
          "SPATIAL_AUTOCORRELATION_TYPE",
          "VISUALIZATION_DATA_TYPE",
          "STATUS_TYPE",
          "types"
        ],
        "dependencies": []
      },
      {
        "path": "utils/PrecomputedDataManager.js",
        "content": "// src/utils/PrecomputedDataManager.js\n\nimport { backgroundMonitor } from './backgroundMonitor';\nimport { pathResolver } from './pathResolver';\nimport { dataCache } from './dataCache';\nimport { validateNumber } from './numberValidation';\nimport { transformRegionName } from './spatialUtils';\nimport Papa from 'papaparse';\nimport _ from 'lodash';\n\nclass PrecomputedDataManager {\n  constructor() {\n    this.pendingRequests = new Map();\n    this.retryAttempts = 3;\n    this.retryDelay = 1000;\n  }\n\n  async loadData(commodity, date, options = {}) {\n    const metric = backgroundMonitor.startMetric('precomputed-data-load');\n    const cacheKey = `${commodity}_${date}`;\n\n    try {\n      // Check cache first\n      if (!options.forceRefresh) {\n        const cached = dataCache.get(commodity, date);\n        if (cached) {\n          metric.finish({ status: 'cache-hit' });\n          return cached;\n        }\n      }\n\n      // Deduplicate in-flight requests\n      if (this.pendingRequests.has(cacheKey)) {\n        return this.pendingRequests.get(cacheKey);\n      }\n\n      // Create request promise\n      const requestPromise = this._loadDataInternal(commodity, date, options);\n      this.pendingRequests.set(cacheKey, requestPromise);\n\n      try {\n        const data = await requestPromise;\n        dataCache.set(commodity, date, data);\n        return data;\n      } finally {\n        this.pendingRequests.delete(cacheKey);\n      }\n\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      throw error;\n    }\n  }\n\n  async _loadDataInternal(commodity, date, options) {\n    try {\n      const path = pathResolver.getCommodityFilePath(commodity);\n      let response = await this._fetchWithRetry(path);\n      \n      // Parse and validate data\n      const data = await this._parseAndValidateData(response, commodity, date);\n      \n      // Process data based on type\n      if (response.headers.get('content-type')?.includes('text/csv')) {\n        return this._processCSVData(data, commodity, date);\n      }\n      \n      return this._processJSONData(data, commodity, date);\n\n    } catch (error) {\n      backgroundMonitor.logError('data-load-error', {\n        commodity,\n        date,\n        error: error.message\n      });\n      throw error;\n    }\n  }\n\n  async _fetchWithRetry(path, attempt = 0) {\n    try {\n      const response = await fetch(path);\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      return response;\n    } catch (error) {\n      if (attempt >= this.retryAttempts) throw error;\n      \n      await new Promise(resolve => \n        setTimeout(resolve, this.retryDelay * Math.pow(2, attempt))\n      );\n      \n      return this._fetchWithRetry(path, attempt + 1);\n    }\n  }\n\n  async _parseAndValidateData(response, commodity, date) {\n    const text = await response.text();\n    \n    try {\n      if (response.headers.get('content-type')?.includes('text/csv')) {\n        return new Promise((resolve, reject) => {\n          Papa.parse(text, {\n            header: true,\n            dynamicTyping: true,\n            skipEmptyLines: true,\n            complete: results => resolve(results.data),\n            error: error => reject(error)\n          });\n        });\n      }\n      \n      return JSON.parse(text);\n    } catch (error) {\n      throw new Error(`Failed to parse data: ${error.message}`);\n    }\n  }\n\n  _processJSONData(data, commodity, date) {\n    // Validate required fields\n    const required = [\n      'timeSeriesData',\n      'marketShocks',\n      'marketClusters',\n      'flowAnalysis',\n      'spatialAutocorrelation'\n    ];\n\n    const missing = required.filter(field => !data[field]);\n    if (missing.length > 0) {\n      throw new Error(`Missing required fields: ${missing.join(', ')}`);\n    }\n\n    // Process and normalize data\n    return {\n      timeSeriesData: this._processTimeSeries(data.timeSeriesData),\n      marketShocks: this._processShocks(data.marketShocks),\n      marketClusters: this._processClusters(data.marketClusters),\n      flowAnalysis: this._processFlows(data.flowAnalysis),\n      spatialAutocorrelation: data.spatialAutocorrelation,\n      metadata: {\n        ...data.metadata,\n        commodity,\n        date,\n        processedAt: new Date().toISOString()\n      }\n    };\n  }\n\n  _processTimeSeries(data) {\n    if (!Array.isArray(data)) return [];\n\n    return data.map(entry => ({\n      date: entry.date,\n      region: transformRegionName(entry.region || entry.admin1),\n      price: validateNumber(entry.price, 0),\n      usdprice: validateNumber(entry.usdprice, 0),\n      conflict_intensity: validateNumber(entry.conflict_intensity, 0)\n    }));\n  }\n\n  _processShocks(shocks) {\n    if (!Array.isArray(shocks)) return [];\n\n    return shocks.map(shock => ({\n      date: shock.date,\n      region: transformRegionName(shock.region),\n      shock_type: shock.shock_type,\n      magnitude: validateNumber(shock.magnitude, 0),\n      current_price: validateNumber(shock.current_price, 0),\n      previous_price: validateNumber(shock.previous_price, 0)\n    }));\n  }\n\n  _processClusters(clusters) {\n    if (!Array.isArray(clusters)) return [];\n\n    return clusters.map(cluster => ({\n      cluster_id: cluster.cluster_id,\n      main_market: transformRegionName(cluster.main_market),\n      connected_markets: (cluster.connected_markets || [])\n        .map(market => transformRegionName(market)),\n      market_count: validateNumber(cluster.market_count, 0),\n      metrics: {\n        efficiency: validateNumber(cluster.metrics?.efficiency, 0),\n        connectivity: validateNumber(cluster.metrics?.connectivity, 0),\n        coverage: validateNumber(cluster.metrics?.coverage, 0)\n      }\n    }));\n  }\n\n  _processFlows(flows) {\n    if (!Array.isArray(flows)) return [];\n\n    return flows.map(flow => ({\n      source: transformRegionName(flow.source),\n      target: transformRegionName(flow.target),\n      flow_weight: validateNumber(flow.flow_weight, 0),\n      price_differential: validateNumber(flow.price_differential, 0)\n    }));\n  }\n\n  _processCSVData(data, commodity, date) {\n    // Group data by type using filename or data structure\n    const grouped = _.groupBy(data, row => {\n      if (row.shock_type) return 'marketShocks';\n      if (row.cluster_id) return 'marketClusters';\n      if (row.flow_weight) return 'flowAnalysis';\n      return 'timeSeriesData';\n    });\n\n    return this._processJSONData({\n      timeSeriesData: grouped.timeSeriesData || [],\n      marketShocks: grouped.marketShocks || [],\n      marketClusters: grouped.marketClusters || [],\n      flowAnalysis: grouped.flowAnalysis || [],\n      spatialAutocorrelation: {},\n      metadata: {\n        commodity,\n        date,\n        source: 'csv'\n      }\n    }, commodity, date);\n  }\n}\n\nexport const precomputedDataManager = new PrecomputedDataManager();",
        "imports": [
          "./backgroundMonitor",
          "./pathResolver",
          "./dataCache",
          "./numberValidation",
          "./spatialUtils",
          "papaparse",
          "lodash"
        ],
        "exports": [
          "precomputedDataManager"
        ],
        "dependencies": [
          "./backgroundMonitor",
          "./pathResolver",
          "./dataCache",
          "./numberValidation",
          "./spatialUtils",
          "papaparse",
          "lodash"
        ]
      },
      {
        "path": "utils/ReduxDebugWrapper.js",
        "content": "// src/utils/ReduxDebugWrapper.js\n\nimport React, { useEffect } from 'react';\nimport { useStore } from 'react-redux';\nimport PropTypes from 'prop-types';\n\nconst ReduxDebugWrapper = ({ children }) => {\n  const store = useStore();\n\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'development') {\n      return; // Exit if not in development mode\n    }\n\n    console.group('Redux Debug Info');\n    console.log('Initial State:', store.getState());\n    console.groupEnd();\n\n    const unsubscribe = store.subscribe(() => {\n      const state = store.getState();\n      const lastAction = state.lastAction;\n      if (lastAction) {\n        console.group('Redux State Update');\n        console.log('Action:', lastAction);\n        console.log('New State:', state);\n        console.groupEnd();\n      }\n    });\n\n    return () => {\n      unsubscribe();\n      console.log('Redux debug wrapper unmounted');\n    };\n  }, [store]);\n\n  return <>{children}</>;\n};\n\nReduxDebugWrapper.propTypes = {\n  children: PropTypes.node.isRequired,\n};\n\nexport default ReduxDebugWrapper;",
        "imports": [
          "react",
          "react-redux",
          "prop-types"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "prop-types"
        ]
      },
      {
        "path": "utils/appUtils.js",
        "content": "// src/utils/appUtils.js\n\nimport { parseISO, isValid as isValidDate, format as formatDate } from 'date-fns';\n\n// ==========================\n// Region Mapping\n// ==========================\n\n/**\n * Mapping between GeoBoundaries region identifiers and Enhanced data region identifiers.\n */\nexport const regionMapping = {\n  \"san'a'\": \"sana'a\",\n  \"san_a__governorate\": \"sana'a\",\n  \"lahij_governorate\": \"lahj\",\n  \"lahij\": \"lahj\",\n  \"_adan_governorate\": \"aden\",\n  \"al_hudaydah_governorate\": \"al hudaydah\",\n  \"ta_izz_governorate\": \"taizz\",\n  \"shabwah_governorate\": \"shabwah\",\n  \"hadhramaut\": \"hadramaut\",\n  \"abyan_governorate\": \"abyan\",\n  \"al_jawf_governorate\": \"al jawf\",\n  \"ibb_governorate\": \"ibb\",\n  \"al_bayda__governorate\": \"al bayda\",\n  \"ad_dali__governorate\": \"al dhale'e\",\n  \"al_mahwit_governorate\": \"al mahwit\",\n  \"hajjah_governorate\": \"hajjah\",\n  \"dhamar_governorate\": \"dhamar\",\n  \"_amran_governorate\": \"amran\",\n  \"al_mahrah_governorate\": \"al maharah\",\n  \"ma'rib_governorate\": \"marib\",\n  \"raymah_governorate\": \"raymah\",\n  \"amanat al asimah\": \"amanat al asimah\", // Capital Municipality\n  // Add any additional mappings if necessary\n};\n\n// ==========================\n// Excluded Regions\n// ==========================\n\n/**\n * List of regions to exclude from the mapping and merging process.\n */\nexport const excludedRegions = [\n  'sa\\'dah_governorate', // Example: Add the exact normalized region IDs\n  // Add other regions as needed\n];\n\n// ==========================\n// JSON to CSV Conversion\n// ==========================\n/**\n * Converts JSON data to CSV format.\n *\n * @param {Array<Object>} jsonData - The JSON data array.\n * @param {string} [delimiter=','] - Delimiter for the CSV file.\n * @returns {string} - The CSV formatted string.\n */\nexport const jsonToCsv = (jsonData, delimiter = ',') => {\n  if (!Array.isArray(jsonData) || jsonData.length === 0) {\n    console.warn('jsonToCsv received an empty or invalid array');\n    return '';\n  }\n\n  const headers = Object.keys(jsonData[0]);\n  const csvRows = [\n    headers.join(delimiter), // Header row\n    ...jsonData.map((row) =>\n      headers\n        .map((fieldName) => {\n          const value = row[fieldName];\n          if (typeof value === 'string') {\n            return `\"${value.replace(/\"/g, '\"\"')}\"`; // Escape double quotes\n          }\n          return value;\n        })\n        .join(delimiter)\n    ),\n  ];\n  return csvRows.join('\\n');\n};\n\n// ==========================\n// Data Processing Utilities\n// ==========================\n\n/**\n * Calculates the moving average for a dataset.\n *\n * @param {Array<number>} data - The dataset.\n * @param {number} period - The period for moving average.\n * @returns {Array<number>} - The moving average values.\n */\nconst movingAverage = (data, period) => {\n  const result = [];\n  let sum = 0;\n\n  data.forEach((value, index) => {\n    sum += value;\n    if (index >= period) {\n      sum -= data[index - period];\n    }\n    if (index >= period - 1) {\n      const average = sum / period;\n      result.push(isNaN(average) ? 0 : average);\n    } else {\n      result.push(value); // Not enough data points initially\n    }\n  });\n\n  return result;\n};\n\n/**\n * Computes seasonal indices based on detrended data.\n *\n * @param {Array<number>} detrended - The detrended dataset.\n * @param {number} period - The period for seasonal indices.\n * @returns {Array<number>} - The seasonal indices.\n */\nconst computeSeasonalIndices = (detrended, period) => {\n  const seasonalSums = Array(period).fill(0);\n  const seasonalCounts = Array(period).fill(0);\n\n  detrended.forEach((val, idx) => {\n    const seasonIdx = idx % period;\n    seasonalSums[seasonIdx] += val;\n    seasonalCounts[seasonIdx] += 1;\n  });\n\n  return seasonalSums.map((sum, idx) => sum / (seasonalCounts[idx] || 1));\n};\n\n/**\n * Applies seasonal adjustment to the data.\n *\n * @param {Array<Object>} data - The dataset to adjust.\n * @param {Array<string>} selectedRegimes - The regimes to apply adjustments to.\n * @param {number} [period=12] - The period for seasonal adjustment.\n * @param {boolean} [showLocalCurrency=true] - Flag to determine currency type.\n * @returns {Array<Object>} - The seasonally adjusted dataset.\n */\nexport const applySeasonalAdjustment = (\n  data,\n  selectedRegimes,\n  period = 12,\n  showLocalCurrency = true\n) => {\n  if (!Array.isArray(data) || data.length === 0) {\n    console.warn('applySeasonalAdjustment received an empty or invalid array');\n    return data;\n  }\n\n  const priceKey = showLocalCurrency ? 'price' : 'usdprice';\n  const adjustedData = data.map((d) => ({ ...d }));\n\n  selectedRegimes.forEach((regime) => {\n    const regimeData = adjustedData.filter((d) => d.regime === regime);\n    const prices = regimeData.map((d) => d[priceKey]);\n\n    if (prices.some((p) => p === undefined || isNaN(p))) {\n      console.warn(`Prices contain undefined or NaN values for regime \"${regime}\".`);\n      return;\n    }\n\n    const trend = movingAverage(prices, period);\n    const detrended = prices.map((p, i) => p - trend[i]);\n    const seasonalIndices = computeSeasonalIndices(detrended, period);\n\n    regimeData.forEach((d, idx) => {\n      const seasonalAdjustment = seasonalIndices[idx % period];\n      d[priceKey] = d[priceKey] - seasonalAdjustment;\n    });\n  });\n\n  return adjustedData;\n};\n\n/**\n * Applies smoothing to the data using a moving average.\n *\n * @param {Array<Object>} data - The dataset to smooth.\n * @param {Array<string>} selectedRegimes - The regimes to apply smoothing to.\n * @param {number} [period=6] - The period for smoothing.\n * @param {boolean} [showLocalCurrency=true] - Flag to determine currency type.\n * @returns {Array<Object>} - The smoothed dataset.\n */\nexport const applySmoothing = (\n  data,\n  selectedRegimes,\n  period = 6,\n  showLocalCurrency = true\n) => {\n  if (!Array.isArray(data) || data.length === 0) {\n    console.warn('applySmoothing received an empty or invalid array');\n    return data;\n  }\n\n  const priceKey = showLocalCurrency ? 'price' : 'usdprice';\n  const smoothedData = data.map((d) => ({ ...d }));\n\n  selectedRegimes.forEach((regime) => {\n    const regimeData = smoothedData.filter((d) => d.regime === regime);\n    const prices = regimeData.map((d) => d[priceKey]);\n\n    if (prices.some((p) => p === undefined || isNaN(p))) {\n      console.warn(`Prices contain undefined or NaN values for regime \"${regime}\".`);\n      return;\n    }\n\n    const smoothedPrices = movingAverage(prices, period);\n\n    regimeData.forEach((d, idx) => {\n      d[priceKey] = smoothedPrices[idx];\n    });\n  });\n\n  return smoothedData;\n};\n\n// ==========================\n// Helper Functions\n// ==========================\n\n/**\n * Normalizes a region ID by removing diacritics and replacing non-alphanumeric characters with underscores.\n *\n * @param {string} regionId - The region ID to normalize.\n * @returns {string|null} - The normalized region ID or null if input is invalid.\n */\nexport const normalizeRegionId = (regionId) => {\n  if (!regionId) return null;\n  return regionId\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '') // Remove diacritics\n    .replace(/[^a-z0-9]/g, '_'); // Replace non-alphanumeric characters with underscores\n};\n\n/**\n * Retrieves the normalized region ID from feature properties.\n *\n * @param {Object} properties - The properties of a feature.\n * @returns {string|null} - The normalized region ID or null if not found.\n */\nconst getRegionId = (properties) => {\n  if (!properties) return null;\n\n  if (properties.region_id) {\n    return normalizeRegionId(properties.region_id);\n  }\n\n  if (properties.admin1) {\n    return normalizeRegionId(properties.admin1);\n  }\n\n  if (properties.shapeName) {\n    const shapeName = properties.shapeName.toLowerCase();\n    if ([\"sana'a\", 'sanʿaʾ', 'sanaa'].includes(shapeName)) {\n      return 'sana_a';\n    }\n    const mappedId = regionMapping[shapeName];\n    return mappedId ? normalizeRegionId(mappedId) : normalizeRegionId(shapeName);\n  }\n\n  return null;\n};\n\n// ==========================\n// Merge Spatial Data with Mapping\n// ==========================\n\n/**\n * Merges spatial data with mapping and exclusion logic, handling time-series data.\n *\n * @param {Object} geoBoundariesData - The GeoJSON data for geo boundaries.\n * @param {Object} enhancedData - The enhanced data features.\n * @returns {Object} - The merged GeoJSON data.\n */\nexport const mergeSpatialDataWithMapping = (geoBoundariesData, enhancedData) => {\n  const geoBoundariesMap = new Map();\n  const unmatchedRegions = new Set();\n  const mergedFeatures = [];\n\n  // Normalize excluded regions (ensure `excludedRegions` is an array and normalize each one)\n  const normalizedExcludedRegions = Array.isArray(excludedRegions)\n    ? excludedRegions.map(normalizeRegionId)\n    : [];\n\n  // Create a map for geoBoundaries using normalized region_id\n  geoBoundariesData.features.forEach((feature) => {\n    const originalShapeName = feature.properties?.shapeName;\n    const mappedRegionId = getRegionId(feature.properties);\n\n    if (!mappedRegionId) {\n      console.warn(`Unable to determine region_id for region: \"${originalShapeName}\"`);\n      return;\n    }\n\n    // Exclude specified regions\n    if (normalizedExcludedRegions.includes(mappedRegionId)) {\n      console.info(`Excluding region: ${originalShapeName}`);\n      return;\n    }\n\n    geoBoundariesMap.set(mappedRegionId, feature);\n  });\n\n  // Process enhanced data features\n  enhancedData.features.forEach((enhancedFeature, index) => {\n    try {\n      const processedProps = processProperties(enhancedFeature.properties);\n      const { region_id, commodity, date } = processedProps;\n\n      if (!region_id) {\n        console.warn('Enhanced data feature missing region_id:', enhancedFeature);\n        return;\n      }\n\n      if (!geoBoundariesMap.has(region_id)) {\n        console.warn(`No geoBoundaries data for region_id: \"${region_id}\"`);\n        unmatchedRegions.add(region_id);\n        return;\n      }\n\n      const geoBoundaryFeature = geoBoundariesMap.get(region_id);\n      const uniqueId = `${region_id}_${commodity}_${date || 'nodate'}_${index}`;\n\n      mergedFeatures.push({\n        type: 'Feature',\n        properties: {\n          ...geoBoundaryFeature.properties,\n          ...processedProps,\n          region_id, // Ensure region_id is always present\n          id: uniqueId,\n        },\n        geometry: geoBoundaryFeature.geometry,\n      });\n    } catch (error) {\n      console.error(`Error processing feature at index ${index}:`, error);\n    }\n  });\n\n  // Handle regions without enhanced data\n  geoBoundariesMap.forEach((geoFeature, region_id) => {\n    const hasData = enhancedData.features.some(\n      (feature) => getRegionId(feature.properties) === region_id\n    );\n\n    if (!hasData) {\n      console.warn(`No enhanced data found for region_id: \"${region_id}\"`);\n\n      mergedFeatures.push({\n        type: 'Feature',\n        properties: {\n          ...geoFeature.properties,\n          region_id,\n          commodity: 'unknown',\n          date: null,\n          usdprice: null,\n          price: null,\n          conflict_intensity: null,\n          residual: null,\n          id: `${region_id}_no_data`,\n        },\n        geometry: geoFeature.geometry,\n      });\n    }\n  });\n\n  if (unmatchedRegions.size > 0) {\n    console.warn('Unmatched regions:', Array.from(unmatchedRegions));\n  }\n\n  return {\n    type: 'FeatureCollection',\n    features: mergedFeatures,\n  };\n};\n\n/**\n * Parses and validates a date string.\n *\n * @param {string} dateString - The date string to parse.\n * @returns {Date|null} - Returns a Date object if valid, otherwise null.\n */\nexport const parseAndValidateDate = (dateString) => {\n  if (!dateString || typeof dateString !== 'string') return null;\n  const parsedDate = parseISO(dateString);\n  return isValidDate(parsedDate) ? parsedDate : null;\n};\n\n/**\n * Formats a Date object into 'MMM yyyy' format.\n *\n * @param {Date} date - The Date object to format.\n * @returns {string} - The formatted date string.\n */\nexport const formatMonthYear = (date) => {\n  if (!(date instanceof Date) || !isValidDate(date)) return '';\n  return formatDate(date, 'MMM yyyy');\n};\n\n// Technical component mapping\nexport const technicalMapping = {\n  ecm: {\n    section: '2.1. Error Correction Model (ECM)',\n    equations: {\n      main: {\n        latex: '\\\\Delta Y_t = \\\\alpha \\\\beta\\' Y_{t-1} + \\\\sum_{i=1}^{p-1} \\\\Gamma_i \\\\Delta Y_{t-i} + u_t',\n        description: 'Vector Error Correction Model specification',\n        variables: {\n          '\\\\alpha': 'Speed of adjustment coefficient',\n          '\\\\beta': 'Long-run cointegration vector',\n          '\\\\Gamma_i': 'Short-run dynamics coefficients',\n          'u_t': 'Error term',\n        },\n      },\n      diagnostics: {\n        moransI: {\n          latex:\n            'I = \\\\frac{N}{\\\\sum_{i=1}^{N} \\\\sum_{j=1}^{N} w_{ij}} \\\\cdot ' +\n            '\\\\frac{\\\\sum_{i=1}^{N} \\\\sum_{j=1}^{N} w_{ij}(y_i - \\\\bar{y})(y_j - \\\\bar{y})}{\\\\sum_{i=1}^{N} (y_i - \\\\bar{y})^2}',\n          description: \"Moran's I spatial autocorrelation statistic\",\n        },\n        jarqueBera: {\n          latex: 'JB = \\\\frac{n}{6}(S^2 + \\\\frac{1}{4}(K-3)^2)',\n          description: 'Jarque-Bera normality test statistic',\n        },\n      },\n    },\n    concepts: {\n      cointegration: 'Long-run equilibrium relationship between variables',\n      errorCorrection: 'Adjustment process towards long-run equilibrium',\n      grangerCausality: 'Statistical prediction relationship between variables',\n    },\n  },\n  priceDiff: {\n    section: '2.2. Price Differential Model',\n    equations: {\n      main: {\n        latex: '\\\\Delta P_{ijt} = \\\\ln(P_{it}) - \\\\ln(P_{jt})',\n        description: 'Log price differential between markets i and j at time t',\n        variables: {\n          'P_{it}': 'Price in market i at time t',\n          'P_{jt}': 'Price in market j at time t',\n        },\n      },\n    },\n    concepts: {\n      arbitrage: 'Price convergence through market mechanisms',\n      priceTransmission: 'Speed and extent of price signal propagation',\n    },\n  },\n  spatial: {\n    section: '3. Spatial Econometric Analysis',\n    equations: {\n      weights: {\n        latex:\n          'w_{ij} = \\\\begin{cases} 1 & \\\\text{if } j \\\\text{ is one of the } k \\\\text{ nearest neighbors of } i \\\\\\\\ 0 & \\\\text{otherwise} \\\\end{cases}',\n        description: 'K-nearest neighbors spatial weights specification',\n      },\n    },\n    concepts: {\n      spatialAutocorrelation: 'Spatial dependence in price patterns',\n      marketClustering: 'Geographic clustering of similar market behaviors',\n    },\n  },\n  tvmii: {\n    section: 'Time-Varying Market Integration Index',\n    equations: {\n      index: {\n        latex: 'TVMII_{ijt} = f(\\\\rho_{ijt}, \\\\sigma_{ijt}, d_{ij})',\n        description: 'Time-varying market integration index',\n        variables: {\n          '\\\\rho_{ijt}': 'Time-varying price correlation',\n          '\\\\sigma_{ijt}': 'Time-varying volatility',\n          'd_{ij}': 'Distance between markets',\n        },\n      },\n    },\n    concepts: {\n      marketIntegration: 'Degree of price co-movement between markets',\n      timeVaryingRelationship: 'Evolution of market relationships over time',\n    },\n  },\n};\n\n// Methodology content\nexport const methodologyContent = {\n  'price-diff': {\n    section: 'price-differential',\n    tooltips: {\n      main: 'Price differential analysis examines the differences in prices between markets',\n      chart: 'Visualizes price differences over time with confidence intervals',\n      diagnostics: 'Statistical tests to validate price differential patterns',\n      market_pairs: 'Comparison of price relationships between market pairs',\n    },\n    equations: {\n      main: {\n        latex: '\\\\Delta P_{ij,t} = \\\\ln(P_{i,t}) - \\\\ln(P_{j,t})',\n        description: 'Price differential between markets i and j at time t',\n        variables: {\n          'P_{i,t}': 'Price in market i at time t',\n          'P_{j,t}': 'Price in market j at time t',\n          '\\\\Delta P_{ij,t}': 'Log price differential',\n        },\n      },\n    },\n  },\n  ecm: {\n    section: 'error-correction-model',\n    tooltips: {\n      main: 'Error Correction Model analyzes long-run equilibrium relationships',\n      diagnostics: 'Model diagnostics and statistical validation tests',\n      cointegration: 'Tests for long-run relationships between price series',\n    },\n    equations: {\n      main: {\n        latex: '\\\\Delta y_t = \\\\alpha(y_{t-1} - \\\\beta x_{t-1}) + \\\\gamma\\\\Delta x_t + \\\\epsilon_t',\n        description: 'Error correction model specification',\n        variables: {\n          '\\\\alpha': 'Speed of adjustment coefficient',\n          '\\\\beta': 'Long-run equilibrium coefficient',\n          '\\\\gamma': 'Short-run dynamics coefficient',\n        },\n      },\n    },\n  },\n  spatial: {\n    section: 'spatial-analysis',\n    tooltips: {\n      main: 'Spatial analysis examines geographic patterns in market relationships',\n      choropleth: 'Color-coded map showing spatial distribution of values',\n      flow_network: 'Network diagram showing market relationships and flows',\n      market_clustering: 'Analysis of market groupings based on spatial relationships',\n    },\n    equations: {\n      moran: {\n        latex:\n          'I = \\\\frac{n}{W} \\\\frac{\\\\sum_i \\\\sum_j w_{ij}(x_i - \\\\bar{x})(x_j - \\\\bar{x})}{\\\\sum_i (x_i - \\\\bar{x})^2}',\n        description: \"Moran's I spatial autocorrelation statistic\",\n        variables: {\n          'w_{ij}': 'Spatial weight between locations i and j',\n          'x_i': 'Variable value at location i',\n          'W': 'Sum of all spatial weights',\n        },\n      },\n    },\n  },\n  tvmii: {\n    section: 'time-varying-market-integration',\n    tooltips: {\n      main: 'Time-Varying Market Integration Index measures dynamic market relationships',\n      chart: 'Visualizes changes in market integration over time',\n      interpretation: 'Guidelines for interpreting TV-MII values',\n      market_pairs: 'Comparison of integration between market pairs',\n    },\n    equations: {\n      main: {\n        latex:\n          'TV\\\\text{-}MII_{t} = \\\\frac{\\\\text{Cov}(P_{1t}, P_{2t})}{\\\\sqrt{\\\\text{Var}(P_{1t})\\\\text{Var}(P_{2t})}}',\n        description: 'Time-Varying Market Integration Index calculation',\n        variables: {\n          'P_{1t}': 'Price in market 1 at time t',\n          'P_{2t}': 'Price in market 2 at time t',\n          'TV\\\\text{-}MII_{t}': 'Integration index at time t',\n        },\n      },\n    },\n  },\n};\n\n// Helper functions for accessing methodology\nexport const getMethodologySection = (componentType) => {\n  const mapping = technicalMapping[componentType];\n  if (!mapping) return null;\n\n  return methodologyContent[componentType] || null;\n};\n\nexport const getEquation = (componentType, equationType) => {\n  const mapping = technicalMapping[componentType];\n  return mapping?.equations[equationType] || null;\n};\n\nexport const getConcept = (componentType, conceptKey) => {\n  const mapping = technicalMapping[componentType];\n  return mapping?.concepts[conceptKey] || null;\n};\n\nexport const getMethodologyInfo = (componentType, element) => {\n  const info = methodologyContent[componentType];\n  if (!info) return null;\n\n  if (element) {\n    return {\n      tooltips: info.tooltips?.[element],\n      equations: info.equations?.[element],\n    };\n  }\n\n  return info;\n};\n\n// ==========================\n// tooltipRegistry.js\n// ==========================\n\n// src/utils/tooltipRegistry.js\n\n// Technical tooltips by component and element\nexport const tooltips = {\n  ecm: {\n    alpha: {\n      short: 'Speed of adjustment coefficient (α)',\n      detailed: 'Measures how quickly deviations from long-run equilibrium are corrected',\n      technical:\n        'Coefficient in the error correction term determining adjustment speed to equilibrium',\n    },\n    cointegration: {\n      short: 'Long-run equilibrium relationship',\n      detailed: 'Stable long-term relationship between non-stationary variables',\n      technical:\n        'Statistical property where linear combination of non-stationary series is stationary',\n    },\n    diagnostics: {\n      moransI: {\n        short: \"Moran's I statistic\",\n        detailed: 'Measures spatial autocorrelation in residuals',\n        technical:\n          'Spatial correlation coefficient ranging from -1 (dispersion) to 1 (clustering)',\n      },\n    },\n  },\n  priceDiff: {\n    spread: {\n      short: 'Price spread between markets',\n      detailed: 'Difference in log prices between two markets',\n      technical: 'Logarithmic price differential measuring relative price gaps',\n    },\n    arbitrage: {\n      short: 'Price arbitrage opportunity',\n      detailed: 'Potential profit from price differences',\n      technical: 'Price differential exceeding transaction costs',\n    },\n  },\n  spatial: {\n    weights: {\n      short: 'Spatial weights matrix',\n      detailed: 'Defines spatial relationships between markets',\n      technical: 'Row-standardized matrix of spatial connectivity',\n    },\n    clustering: {\n      short: 'Spatial clustering',\n      detailed: 'Geographic grouping of similar values',\n      technical: 'Positive spatial autocorrelation in market behavior',\n    },\n  },\n  tvmii: {\n    integration: {\n      short: 'Market integration index',\n      detailed: 'Measure of market connectedness',\n      technical: 'Time-varying coefficient of market price co-movement',\n    },\n  },\n};\n\n/**\n * Retrieves a tooltip based on component type, element, and detail level.\n *\n * @param {string} componentType - The component type (e.g., 'ecm').\n * @param {string} element - The specific element (e.g., 'alpha').\n * @param {string} [level='short'] - The detail level ('short', 'detailed', 'technical').\n * @returns {string|null} - The requested tooltip or null if not found.\n */\nexport const getTooltip = (componentType, element, level = 'short') => {\n  const componentTooltips = tooltips[componentType];\n  if (!componentTooltips) return null;\n\n  // Handle nested tooltips\n  const paths = element.split('.');\n  let tooltip = componentTooltips;\n  for (const path of paths) {\n    tooltip = tooltip[path];\n    if (!tooltip) return null;\n  }\n\n  return tooltip[level] || tooltip.short;\n};\n\n// ==========================\n// scoringFunctions.js\n// ==========================\n\n// src/utils/scoringFunctions.js\n\n/**\n * Calculates ECM score based on user answers.\n *\n * @param {Object} answers - User answers.\n * @returns {number} - The calculated score.\n */\nexport const calculateECMScore = (answers) => {\n  let score = 0;\n  if (answers.speedOfAdjustment?.trim().length > 50) score += 33;\n  if (answers.equilibriumInterpretation?.trim().length > 50) score += 33;\n  if (answers.errorCorrection?.trim().length > 50) score += 34;\n  return score;\n};\n\n/**\n * Calculates Price Differential score based on user answers.\n *\n * @param {Object} answers - User answers.\n * @returns {number} - The calculated score.\n */\nexport const calculatePriceDiffScore = (answers) => {\n  let score = 0;\n  if (\n    ['convergence', 'divergence', 'stable'].includes(answers.trendType)\n  ) score += 30;\n  if (answers.interpretation?.trim().length > 50) score += 35;\n  if (answers.marketEfficiency?.trim().length > 50) score += 35;\n  return score;\n};\n\n/**\n * Calculates Spatial Analysis score based on user answers.\n *\n * @param {Object} answers - User answers.\n * @returns {number} - The calculated score.\n */\nexport const calculateSpatialScore = (answers) => {\n  let score = 0;\n  if (\n    ['clustered', 'dispersed', 'random'].includes(answers.patternType)\n  ) score += 30;\n  if (answers.moranI?.trim().length > 50) score += 35;\n  if (answers.spatialDependence?.trim().length > 50) score += 35;\n  return score;\n};\n\n/**\n * Calculates TVMII score based on user answers.\n *\n * @param {Object} answers - User answers.\n * @returns {number} - The calculated score.\n */\nexport const calculateTVMIIScore = (answers) => {\n  let score = 0;\n  if (\n    ['high', 'moderate', 'low'].includes(answers.integrationLevel)\n  ) score += 30;\n  if (answers.timeVaryingNature?.trim().length > 50) score += 35;\n  if (answers.implications?.trim().length > 50) score += 35;\n  return score;\n};\n\n// Enhanced region mapping system with robust normalization and validation\n\n// Comprehensive mapping table for Yemen governorates\nconst enhancedRegionMapping = {\n  // Standard mappings\n  \"san'a'\": \"sana'a\",\n  \"san_a__governorate\": \"sana'a\",\n  \"sanaa\": \"sana'a\",\n  \"sanʿaʾ\": \"sana'a\",\n  \"lahij_governorate\": \"lahj\",\n  \"lahij\": \"lahj\",\n  \"_adan_governorate\": \"aden\",\n  \"al_hudaydah_governorate\": \"al hudaydah\",\n  \"ta_izz_governorate\": \"taizz\",\n  \"shabwah_governorate\": \"shabwah\",\n  \"hadhramaut\": \"hadramaut\",\n  \"hadramout\": \"hadramaut\",\n  \"abyan_governorate\": \"abyan\",\n  \"al_jawf_governorate\": \"al jawf\",\n  \"ibb_governorate\": \"ibb\",\n  \"al_bayda__governorate\": \"al bayda\",\n  \"ad_dali__governorate\": \"al dhale'e\",\n  \"al_mahwit_governorate\": \"al mahwit\",\n  \"hajjah_governorate\": \"hajjah\",\n  \"dhamar_governorate\": \"dhamar\",\n  \"_amran_governorate\": \"amran\",\n  \"al_mahrah_governorate\": \"al maharah\",\n  \"ma'rib_governorate\": \"marib\",\n  \"raymah_governorate\": \"raymah\",\n  \n  // Additional variations\n  \"sana\": \"sana'a\",\n  \"sanaa_gov\": \"sana'a\",\n  \"hudaydah\": \"al hudaydah\",\n  \"hodeidah\": \"al hudaydah\",\n  \"adan\": \"aden\",\n  \"taiz\": \"taizz\",\n  \"shabwa\": \"shabwah\",\n  \"hadramawt\": \"hadramaut\",\n  \"jawf\": \"al jawf\",\n  \"bayda\": \"al bayda\",\n  \"dhale\": \"al dhale'e\",\n  \"daleh\": \"al dhale'e\",\n  \"mahwit\": \"al mahwit\",\n  \"hodeida\": \"al hudaydah\",\n  \"capital_city\": \"amanat al asimah\",\n  \"capital\": \"amanat al asimah\",\n  \"mareb\": \"marib\",\n  \"maarib\": \"marib\"\n};\n\nconst normalizeArabicChars = (str) => {\n  return str\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')  // Remove diacritics\n    .replace(/[٠-٩]/g, d => '0123456789'['٠١٢٣٤٥٦٧٨٩'.indexOf(d)])  // Arabic numerals\n    .replace(/[اإأآ]/g, 'ا')  // Normalize Arabic alef variations\n    .replace(/[ىئي]/g, 'ي')  // Normalize Arabic yaa variations\n    .replace(/[ؤئ]/g, 'ء')  // Normalize Arabic hamza variations\n    .replace(/[ة]/g, 'ه');  // Normalize Arabic taa marbouta\n};\n\nexport const normalizeRegionName = (name) => {\n  if (!name) return null;\n\n  // Initial cleanup\n  let cleaned = name.toLowerCase()\n    .trim()\n    .replace(/^_+/, '')               // Remove leading underscores\n    .replace(/_+/g, ' ')             // Replace underscores with spaces\n    .replace(/\\s+/g, ' ')            // Normalize whitespace\n    .replace(/governorate$/i, '')     // Remove governorate suffix\n    .replace(/province$/i, '')        // Remove province suffix\n    .replace(/^gov[\\s_]+/i, '')      // Remove gov prefix\n    .replace(/^governorate[\\s_]+/i, '') // Remove governorate prefix\n    .trim();\n\n  // Check direct mapping first\n  if (REGION_MAPPINGS[cleaned]) {\n    return REGION_MAPPINGS[cleaned];\n  }\n\n  // Handle Arabic characters and diacritics\n  cleaned = cleaned\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')  // Remove diacritics\n    .replace(/[_-]+/g, ' ')           // Normalize separators\n    .replace(/ʿ/g, \"'\")               // Normalize special quotes\n    .replace(/['']/g, \"'\");           // Normalize quotes\n\n  // Check mapping again after normalization\n  if (REGION_MAPPINGS[cleaned]) {\n    return REGION_MAPPINGS[cleaned];\n  }\n\n  // Try without spaces\n  const withoutSpaces = cleaned.replace(/\\s+/g, '');\n  if (REGION_MAPPINGS[withoutSpaces]) {\n    return REGION_MAPPINGS[withoutSpaces];\n  }\n\n  return cleaned;\n};\n\nexport const validateRegionMapping = (regionName, geometryData) => {\n  const normalized = normalizeRegionName(regionName);\n  const hasGeometry = geometryData.features.some(feature => \n    normalizeRegionName(feature.properties.shapeName) === normalized\n  );\n  \n  return {\n    original: regionName,\n    normalized,\n    hasGeometry,\n    possibleMatches: !hasGeometry ? findPossibleMatches(normalized, geometryData) : []\n  };\n};\n\nconst findPossibleMatches = (normalized, geometryData) => {\n  const allRegions = geometryData.features.map(f => f.properties.shapeName);\n  return allRegions\n    .filter(region => {\n      const similarity = calculateSimilarity(normalized, normalizeRegionName(region));\n      return similarity > 0.7; // Threshold for similarity\n    })\n    .map(region => ({\n      name: region,\n      normalized: normalizeRegionName(region),\n      similarity: calculateSimilarity(normalized, normalizeRegionName(region))\n    }))\n    .sort((a, b) => b.similarity - a.similarity)\n    .slice(0, 3); // Return top 3 matches\n};\n\nconst calculateSimilarity = (str1, str2) => {\n  const longer = str1.length > str2.length ? str1 : str2;\n  const shorter = str1.length > str2.length ? str2 : str1;\n  \n  if (longer.length === 0) return 1.0;\n  \n  return (longer.length - editDistance(longer, shorter)) / longer.length;\n};\n\nconst editDistance = (str1, str2) => {\n  const matrix = Array(str2.length + 1).fill(null)\n    .map(() => Array(str1.length + 1).fill(null));\n\n  for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;\n  for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;\n\n  for (let j = 1; j <= str2.length; j++) {\n    for (let i = 1; i <= str1.length; i++) {\n      const substitutionCost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n      matrix[j][i] = Math.min(\n        matrix[j][i - 1] + 1,\n        matrix[j - 1][i] + 1,\n        matrix[j - 1][i - 1] + substitutionCost\n      );\n    }\n  }\n  \n  return matrix[str2.length][str1.length];\n};\n\n// Debug utility to check all mappings\nexport const debugMappings = (marketData, geometryData) => {\n  const results = {\n    matched: [],\n    unmatched: [],\n    summary: {\n      total: 0,\n      matched: 0,\n      unmatched: 0\n    }\n  };\n\n  const uniqueMarkets = new Set(marketData.map(m => m.market || m.region || m.admin1));\n  \n  uniqueMarkets.forEach(market => {\n    const validation = validateRegionMapping(market, geometryData);\n    \n    if (validation.hasGeometry) {\n      results.matched.push({\n        original: validation.original,\n        normalized: validation.normalized\n      });\n    } else {\n      results.unmatched.push({\n        original: validation.original,\n        normalized: validation.normalized,\n        possibleMatches: validation.possibleMatches\n      });\n    }\n  });\n\n  results.summary = {\n    total: uniqueMarkets.size,\n    matched: results.matched.length,\n    unmatched: results.unmatched.length,\n    matchRate: `${((results.matched.length / uniqueMarkets.size) * 100).toFixed(1)}%`\n  };\n\n  return results;\n};",
        "imports": [
          "date-fns"
        ],
        "exports": [
          "regionMapping",
          "excludedRegions",
          "jsonToCsv",
          "applySeasonalAdjustment",
          "applySmoothing",
          "normalizeRegionId",
          "mergeSpatialDataWithMapping",
          "parseAndValidateDate",
          "formatMonthYear",
          "technicalMapping",
          "methodologyContent",
          "getMethodologySection",
          "getEquation",
          "getConcept",
          "getMethodologyInfo",
          "tooltips",
          "getTooltip",
          "calculateECMScore",
          "calculatePriceDiffScore",
          "calculateSpatialScore",
          "calculateTVMIIScore",
          "normalizeRegionName",
          "validateRegionMapping",
          "debugMappings"
        ],
        "dependencies": [
          "date-fns"
        ]
      },
      {
        "path": "utils/backgroundMonitor.js",
        "content": "// src/utils/backgroundMonitor.js\n\nconst MAX_METRICS_LENGTH = 1000;\nconst MAX_ERRORS_LENGTH = 100;\nconst CLEANUP_INTERVAL = 60000; // 1 minute\n\nconst METRIC_TYPES = {\n  SPATIAL: {\n    DATA_LOAD: 'spatial-data-load',\n    PROCESSING: 'spatial-processing',\n    VALIDATION: 'spatial-validation'\n  },\n  FLOW: {\n    DATA_LOAD: 'flow-data-load',\n    PROCESSING: 'flow-processing',\n    VALIDATION: 'flow-validation'\n  },\n  SYSTEM: {\n    PERFORMANCE: 'performance',\n    ERROR: 'error',\n    INIT: 'initialization'\n  }\n};\n\nclass BackgroundMonitor {\n  constructor() {\n    this.metrics = [];\n    this.errors = [];\n    this.initialized = false;\n    this.observers = new Set();\n    this.cleanupInterval = null;\n    \n    // Backward compatibility\n    this.SPATIAL_METRIC_TYPES = METRIC_TYPES.SPATIAL;\n  }\n\n  async init() {\n    if (this.initialized) return;\n\n    try {\n      // Initialize error handling\n      window.addEventListener('error', this.handleGlobalError.bind(this));\n      window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));\n\n      // Initialize performance monitoring\n      await this.initializePerformanceMonitoring();\n\n      // Start cleanup interval\n      this.cleanupInterval = setInterval(this.cleanup.bind(this), CLEANUP_INTERVAL);\n      \n      this.initialized = true;\n      console.log('[BackgroundMonitor] Initialized successfully');\n      \n      return true;\n    } catch (error) {\n      console.error('[BackgroundMonitor] Initialization failed:', error);\n      this.logError('init-failed', {\n        error: error.message,\n        stack: error.stack\n      });\n      return false;\n    }\n  }\n\n  handleGlobalError(event) {\n    try {\n      this.logError('uncaught-error', {\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        stack: event.error?.stack,\n        timestamp: new Date().toISOString()\n      });\n    } catch (e) {\n      console.error('[BackgroundMonitor] Error handling failed:', e);\n    }\n  }\n\n  handleUnhandledRejection(event) {\n    try {\n      this.logError('unhandled-rejection', {\n        message: event.reason?.message || 'Unknown rejection reason',\n        stack: event.reason?.stack,\n        timestamp: new Date().toISOString()\n      });\n    } catch (e) {\n      console.error('[BackgroundMonitor] Rejection handling failed:', e);\n    }\n  }\n\n  async initializePerformanceMonitoring() {\n    if (!('PerformanceObserver' in window)) {\n      console.warn('[BackgroundMonitor] PerformanceObserver not available');\n      return;\n    }\n\n    try {\n      const perfObserver = new PerformanceObserver((list) => {\n        list.getEntries().forEach((entry) => {\n          this.logMetric(METRIC_TYPES.SYSTEM.PERFORMANCE, {\n            name: entry.name,\n            duration: entry.duration,\n            type: entry.entryType,\n            timestamp: new Date().toISOString()\n          });\n        });\n      });\n\n      perfObserver.observe({ \n        entryTypes: ['resource', 'navigation', 'longtask', 'paint', 'mark'] \n      });\n\n      this.observers.add(perfObserver);\n    } catch (error) {\n      console.warn('[BackgroundMonitor] Performance monitoring setup failed:', error);\n      throw error;\n    }\n  }\n\n  cleanup() {\n    if (this.metrics.length > MAX_METRICS_LENGTH) {\n      const excess = this.metrics.length - MAX_METRICS_LENGTH;\n      this.metrics.splice(0, excess);\n    }\n    if (this.errors.length > MAX_ERRORS_LENGTH) {\n      const excess = this.errors.length - MAX_ERRORS_LENGTH;\n      this.errors.splice(0, excess);\n    }\n  }\n\n  startMetric(name, data = {}) {\n    if (!name || typeof name !== 'string') {\n      console.warn('[BackgroundMonitor] Invalid metric name');\n      return { finish: () => {}, cancel: () => {} };\n    }\n\n    const startTime = performance.now();\n    const metricId = `${name}-${Date.now()}`;\n\n    // For debugging in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`[BackgroundMonitor] Metric started: ${name}`, { ...data, metricId });\n    }\n\n    return {\n      finish: (additionalData = {}) => {\n        try {\n          const duration = performance.now() - startTime;\n          const metricData = {\n            id: metricId,\n            ...data,\n            ...additionalData,\n            duration,\n            timestamp: new Date().toISOString(),\n          };\n          \n          this.metrics.push({ name, data: metricData });\n          \n          if (process.env.NODE_ENV === 'development') {\n            console.log(`[BackgroundMonitor] Metric finished: ${name}`, metricData);\n          }\n          \n          this.cleanup();\n          return metricData;\n        } catch (error) {\n          console.error('[BackgroundMonitor] Error finishing metric:', error);\n          return null;\n        }\n      },\n      cancel: () => {\n        if (process.env.NODE_ENV === 'development') {\n          console.log(`[BackgroundMonitor] Metric cancelled: ${name}`, { metricId });\n        }\n      }\n    };\n  }\n\n  logMetric(name, data) {\n    if (!name || typeof name !== 'string') {\n      console.warn('[BackgroundMonitor] Invalid metric name');\n      return;\n    }\n\n    try {\n      const metricData = {\n        ...data,\n        timestamp: new Date().toISOString()\n      };\n\n      this.metrics.push({ name, data: metricData });\n      \n      if (process.env.NODE_ENV === 'development') {\n        console.log(`[BackgroundMonitor] Metric logged: ${name}`, metricData);\n      }\n      \n      this.cleanup();\n    } catch (error) {\n      console.error('[BackgroundMonitor] Error logging metric:', error);\n    }\n  }\n\n  logError(name, data) {\n    if (!name || typeof name !== 'string') {\n      console.warn('[BackgroundMonitor] Invalid error name');\n      return;\n    }\n\n    try {\n      const errorData = {\n        ...data,\n        timestamp: new Date().toISOString()\n      };\n\n      this.errors.push({ name, data: errorData });\n      console.error(`[BackgroundMonitor] Error logged: ${name}`, errorData);\n      \n      this.cleanup();\n    } catch (error) {\n      console.error('[BackgroundMonitor] Error logging error:', error);\n    }\n  }\n\n  getMetrics(type = null) {\n    if (!type) {\n      return [...this.metrics];\n    }\n    return this.metrics.filter(metric => metric.name.startsWith(type));\n  }\n\n  getErrors() {\n    return [...this.errors];\n  }\n\n  clearMetrics() {\n    this.metrics = [];\n    this.errors = [];\n  }\n\n  destroy() {\n    try {\n      window.removeEventListener('error', this.handleGlobalError.bind(this));\n      window.removeEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));\n      \n      this.observers.forEach(observer => observer.disconnect());\n      this.observers.clear();\n      \n      if (this.cleanupInterval) {\n        clearInterval(this.cleanupInterval);\n        this.cleanupInterval = null;\n      }\n      \n      this.metrics = [];\n      this.errors = [];\n      this.initialized = false;\n      \n      console.log('[BackgroundMonitor] Destroyed successfully');\n    } catch (error) {\n      console.error('[BackgroundMonitor] Error during destruction:', error);\n    }\n  }\n\n  // Utility method to check monitor health\n  checkHealth() {\n    return {\n      initialized: this.initialized,\n      metricsCount: this.metrics.length,\n      errorsCount: this.errors.length,\n      observersCount: this.observers.size,\n      hasCleanupInterval: Boolean(this.cleanupInterval)\n    };\n  }\n}\n\n// Create and export the singleton instance\nexport const backgroundMonitor = new BackgroundMonitor();\n\n// Initialize in development mode\nif (process.env.NODE_ENV === 'development') {\n  backgroundMonitor.init().catch(error => {\n    console.error('[BackgroundMonitor] Auto-initialization failed:', error);\n  });\n}\n\n// Export metric types for external use\nexport const MetricTypes = METRIC_TYPES;",
        "imports": [],
        "exports": [
          "backgroundMonitor",
          "MetricTypes"
        ],
        "dependencies": []
      },
      {
        "path": "utils/colorScales.js",
        "content": "// src/utils/colorScales.js\n\nimport * as d3 from 'd3';\nimport { COLOR_SCALES } from '../constants';\n\nexport const getColorScale = (visualizationMode) => {\n  switch (visualizationMode) {\n    case 'prices':\n      return d3.scaleQuantize().domain([0, 100]).range(COLOR_SCALES.PRICES);\n    case 'integration':\n      return d3.scaleQuantize().domain([0, 1]).range(COLOR_SCALES.INTEGRATION);\n    case 'shocks':\n      return d3.scaleQuantize().domain([0, 5]).range(COLOR_SCALES.SHOCKS);\n    default:\n      return () => '#cccccc';\n  }\n};",
        "imports": [
          "d3",
          "../constants"
        ],
        "exports": [
          "getColorScale"
        ],
        "dependencies": [
          "d3",
          "../constants"
        ]
      },
      {
        "path": "utils/colorUtils.js",
        "content": "// src/utils/colorUtils.js\n\n/**\n * Calculate contrast ratio between two colors\n * @param {string} foreground - Foreground color in hex format\n * @param {string} background - Background color in hex format\n * @returns {number} Contrast ratio\n */\nexport const calculateContrast = (foreground, background) => {\n    const getLuminance = (hexColor) => {\n      const rgb = hexColor.match(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n      if (!rgb) return 0;\n      \n      const [r, g, b] = [\n        parseInt(rgb[1], 16) / 255,\n        parseInt(rgb[2], 16) / 255,\n        parseInt(rgb[3], 16) / 255\n      ].map(val => {\n        return val <= 0.03928\n          ? val / 12.92\n          : Math.pow((val + 0.055) / 1.055, 2.4);\n      });\n  \n      return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    };\n  \n    const l1 = getLuminance(foreground);\n    const l2 = getLuminance(background);\n    const brightest = Math.max(l1, l2);\n    const darkest = Math.min(l1, l2);\n    \n    return (brightest + 0.05) / (darkest + 0.05);\n  };\n  \n  /**\n   * Get appropriate text color based on background\n   * @param {string} backgroundColor - Background color in hex format\n   * @returns {string} Text color in hex format\n   */\n  export const getTextColor = (backgroundColor) => {\n    const whiteContrast = calculateContrast('#FFFFFF', backgroundColor);\n    const blackContrast = calculateContrast('#000000', backgroundColor);\n    return whiteContrast > blackContrast ? '#FFFFFF' : '#000000';\n  };\n  \n  /**\n   * Interpolate between two colors\n   * @param {string} color1 - First color in hex format\n   * @param {string} color2 - Second color in hex format\n   * @param {number} ratio - Interpolation ratio (0-1)\n   * @returns {string} Interpolated color in hex format\n   */\n  export const interpolateColor = (color1, color2, ratio) => {\n    const r1 = parseInt(color1.slice(1, 3), 16);\n    const g1 = parseInt(color1.slice(3, 5), 16);\n    const b1 = parseInt(color1.slice(5, 7), 16);\n    \n    const r2 = parseInt(color2.slice(1, 3), 16);\n    const g2 = parseInt(color2.slice(3, 5), 16);\n    const b2 = parseInt(color2.slice(5, 7), 16);\n    \n    const r = Math.round(r1 + (r2 - r1) * ratio);\n    const g = Math.round(g1 + (g2 - g1) * ratio);\n    const b = Math.round(b1 + (b2 - b1) * ratio);\n    \n    return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;\n  };\n  \n  /**\n   * Create a color scale function\n   * @param {Array} colors - Array of colors in hex format\n   * @param {Array} domain - Array of domain values\n   * @returns {Function} Color scale function\n   */\n  export const createColorScale = (colors, domain) => {\n    return (value) => {\n      // Find the segment containing the value\n      for (let i = 0; i < domain.length - 1; i++) {\n        if (value >= domain[i] && value <= domain[i + 1]) {\n          const ratio = (value - domain[i]) / (domain[i + 1] - domain[i]);\n          return interpolateColor(colors[i], colors[i + 1], ratio);\n        }\n      }\n      return value <= domain[0] ? colors[0] : colors[colors.length - 1];\n    };\n  };\n  \n  /**\n   * Adjust color brightness\n   * @param {string} color - Color in hex format\n   * @param {number} factor - Brightness adjustment factor (negative darkens, positive lightens)\n   * @returns {string} Adjusted color in hex format\n   */\n  export const adjustBrightness = (color, factor) => {\n    const r = parseInt(color.slice(1, 3), 16);\n    const g = parseInt(color.slice(3, 5), 16);\n    const b = parseInt(color.slice(5, 7), 16);\n    \n    const adjust = (value) => {\n      return Math.min(255, Math.max(0, Math.round(value * (1 + factor))));\n    };\n    \n    return `#${[r, g, b].map(x => adjust(x).toString(16).padStart(2, '0')).join('')}`;\n  };",
        "imports": [],
        "exports": [
          "calculateContrast",
          "getTextColor",
          "interpolateColor",
          "createColorScale",
          "adjustBrightness"
        ],
        "dependencies": []
      },
      {
        "path": "utils/coordinateUtils.js",
        "content": "// src/utils/coordinateUtils.js\nexport const convertUTMtoLatLng = (easting, northing) => {\n    // Constants for UTM Zone 38N to WGS84 conversion\n    const k0 = 0.9996;\n    const a = 6378137;\n    const e = 0.081819191;\n    const e1sq = 0.006739497;\n    const falseEasting = 500000;\n    const zone = 38;\n  \n    try {\n      const x = easting - falseEasting;\n      const y = northing;\n  \n      const M = y / k0;\n      const mu = M / (a * (1 - e * e / 4 - 3 * e * e * e * e / 64));\n  \n      const phi1 = mu + (3 * e1sq / 2 - 27 * Math.pow(e1sq, 3) / 32) * Math.sin(2 * mu);\n      const phi2 = phi1 + (21 * Math.pow(e1sq, 2) / 16 - 55 * Math.pow(e1sq, 4) / 32) * Math.sin(4 * mu);\n      const phi = phi2 + (151 * Math.pow(e1sq, 3) / 96) * Math.sin(6 * mu);\n  \n      const N1 = a / Math.sqrt(1 - e * e * Math.sin(phi) * Math.sin(phi));\n      const T1 = Math.tan(phi) * Math.tan(phi);\n      const C1 = (e * e * Math.cos(phi) * Math.cos(phi)) / (1 - e * e);\n      const R1 = (a * (1 - e * e)) / Math.pow(1 - e * e * Math.sin(phi) * Math.sin(phi), 1.5);\n      const D = x / (N1 * k0);\n  \n      const lat = phi - (N1 * Math.tan(phi) / R1) * (\n        (D * D) / 2 -\n        (5 + 3 * T1 + 10 * C1 - 4 * Math.pow(C1, 2) - 9 * e * e) * Math.pow(D, 4) / 24 +\n        (61 + 90 * T1 + 298 * C1 + 45 * Math.pow(T1, 2) - 252 * e * e - 3 * Math.pow(C1, 2)) * Math.pow(D, 6) / 720\n      );\n  \n      const lon = ((zone * 6 - 183) + (D - (1 + 2 * T1 + C1) * Math.pow(D, 3) / 6 +\n        (5 - 2 * C1 + 28 * T1 - 3 * Math.pow(C1, 2) + 8 * e * e + 24 * Math.pow(T1, 2)) * Math.pow(D, 5) / 120)\n      ) / Math.cos(phi) * (180 / Math.PI);\n  \n      return [\n        lon * (180 / Math.PI),\n        lat * (180 / Math.PI)\n      ];\n    } catch (error) {\n      console.error('Error converting coordinates:', error);\n      return null;\n    }\n  };\n  ",
        "imports": [],
        "exports": [
          "convertUTMtoLatLng"
        ],
        "dependencies": []
      },
      {
        "path": "utils/core/dataProcessor.js",
        "content": "// src/utils/core/dataProcessor.js\n\nimport { backgroundMonitor } from './monitoringUtils';\n\nclass DataProcessor {\n  constructor() {\n    this.cache = new Map();\n  }\n\n  // Data transformation methods\n  transformData(data, options = {}) {\n    const metric = backgroundMonitor.startMetric('data-transform');\n    try {\n      const { type, format, validate = true } = options;\n      \n      // Generate cache key\n      const cacheKey = this.getCacheKey(data, options);\n      \n      // Check cache\n      if (this.cache.has(cacheKey)) {\n        metric.finish({ status: 'cache-hit' });\n        return this.cache.get(cacheKey);\n      }\n\n      // Validate data if required\n      if (validate) {\n        this.validateData(data, type);\n      }\n\n      // Process data based on type\n      let processed;\n      switch (type) {\n        case 'spatial':\n          processed = this.processSpatialData(data, format);\n          break;\n        case 'timeSeries':\n          processed = this.processTimeSeriesData(data, format);\n          break;\n        case 'network':\n          processed = this.processNetworkData(data, format);\n          break;\n        default:\n          processed = this.processGenericData(data, format);\n      }\n\n      // Cache results\n      this.cache.set(cacheKey, processed);\n      \n      metric.finish({ status: 'success' });\n      return processed;\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      throw error;\n    }\n  }\n\n  // Data validation methods\n  validateData(data, type) {\n    if (!data) throw new Error('No data provided');\n    \n    switch (type) {\n      case 'spatial':\n        return this.validateSpatialData(data);\n      case 'timeSeries':\n        return this.validateTimeSeriesData(data);\n      case 'network':\n        return this.validateNetworkData(data);\n      default:\n        return this.validateGenericData(data);\n    }\n  }\n\n  validateSpatialData(data) {\n    if (!data.features || !Array.isArray(data.features)) {\n      throw new Error('Invalid spatial data: missing features array');\n    }\n    return true;\n  }\n\n  validateTimeSeriesData(data) {\n    if (!Array.isArray(data)) {\n      throw new Error('Invalid time series data: expected array');\n    }\n    if (!data.every(d => d.date && d.value)) {\n      throw new Error('Invalid time series data: missing required fields');\n    }\n    return true;\n  }\n\n  validateNetworkData(data) {\n    if (!data.nodes || !data.edges) {\n      throw new Error('Invalid network data: missing nodes or edges');\n    }\n    return true;\n  }\n\n  validateGenericData(data) {\n    return true;\n  }\n\n  // Data processing methods\n  processSpatialData(data, format) {\n    const processed = {\n      type: 'spatial',\n      features: data.features.map(feature => ({\n        ...feature,\n        properties: {\n          ...feature.properties,\n          processed: true,\n          timestamp: new Date().toISOString()\n        }\n      })),\n      metadata: this.extractMetadata(data)\n    };\n\n    return format ? this.formatSpatialData(processed) : processed;\n  }\n\n  processTimeSeriesData(data, format) {\n    const processed = {\n      type: 'timeSeries',\n      series: data.map(point => ({\n        ...point,\n        date: new Date(point.date),\n        value: Number(point.value)\n      })),\n      metadata: this.extractMetadata(data)\n    };\n\n    return format ? this.formatTimeSeriesData(processed) : processed;\n  }\n\n  processNetworkData(data, format) {\n    const processed = {\n      type: 'network',\n      nodes: data.nodes.map(node => ({\n        ...node,\n        id: String(node.id)\n      })),\n      edges: data.edges.map(edge => ({\n        ...edge,\n        source: String(edge.source),\n        target: String(edge.target)\n      })),\n      metadata: this.extractMetadata(data)\n    };\n\n    return format ? this.formatNetworkData(processed) : processed;\n  }\n\n  processGenericData(data, format) {\n    const processed = {\n      type: 'generic',\n      data,\n      metadata: this.extractMetadata(data)\n    };\n\n    return format ? this.formatGenericData(processed) : processed;\n  }\n\n  // Formatting methods\n  formatSpatialData(data) {\n    return {\n      ...data,\n      formatted: true,\n      features: data.features.map(feature => ({\n        ...feature,\n        properties: {\n          ...feature.properties,\n          formatted: true\n        }\n      }))\n    };\n  }\n\n  formatTimeSeriesData(data) {\n    return {\n      ...data,\n      formatted: true,\n      series: data.series.map(point => ({\n        ...point,\n        formattedDate: point.date.toISOString(),\n        formattedValue: point.value.toFixed(2)\n      }))\n    };\n  }\n\n  formatNetworkData(data) {\n    return {\n      ...data,\n      formatted: true\n    };\n  }\n\n  formatGenericData(data) {\n    return {\n      ...data,\n      formatted: true\n    };\n  }\n\n  // Helper methods\n  getCacheKey(data, options) {\n    return JSON.stringify({\n      dataHash: this.hashData(data),\n      options\n    });\n  }\n\n  hashData(data) {\n    return typeof data === 'object' ? \n      JSON.stringify(data) : \n      String(data);\n  }\n\n  extractMetadata(data) {\n    return {\n      timestamp: new Date().toISOString(),\n      recordCount: Array.isArray(data) ? data.length : 1,\n      dataType: typeof data,\n      processingTime: Date.now()\n    };\n  }\n\n  // Cache management\n  clearCache() {\n    this.cache.clear();\n  }\n\n  getCacheSize() {\n    return this.cache.size;\n  }\n\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      keys: Array.from(this.cache.keys()),\n      lastUpdated: new Date().toISOString()\n    };\n  }\n}\n\nexport default new DataProcessor();\n",
        "imports": [
          "./monitoringUtils"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "./monitoringUtils"
        ]
      },
      {
        "path": "utils/core/index.js",
        "content": "// src/utils/core/index.js\n\n// Consolidated data processing utilities\nexport { default as dataProcessor } from './dataProcessor';\nexport { default as spatialProcessor } from './spatialProcessor';\nexport { default as geometryProcessor } from './geometryProcessor';\nexport { default as timeSeriesProcessor } from './timeSeriesProcessor';\n\n// Consolidated validation utilities\nexport { default as validators } from './validators';\nexport { default as typeCheckers } from './typeCheckers';\n\n// Consolidated analysis utilities\nexport { default as analysisUtils } from './analysisUtils';\nexport { default as statisticsUtils } from './statisticsUtils';\nexport { default as spatialUtils } from './spatialUtils';\n\n// Consolidated system utilities\nexport { default as debugUtils } from './debugUtils';\nexport { default as monitoringUtils } from './monitoringUtils';\nexport { default as performanceUtils } from './performanceUtils';\n\n// Consolidated visualization utilities\nexport { default as colorUtils } from './colorUtils';\nexport { default as chartUtils } from './chartUtils';\nexport { default as mapUtils } from './mapUtils';\n\n// Consolidated worker utilities\nexport { default as workerManager } from './workerManager';\nexport { default as workerUtils } from './workerUtils';\n",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "utils/core/spatialProcessor.js",
        "content": "// src/utils/core/spatialProcessor.js\n\nimport { backgroundMonitor } from './monitoringUtils';\n\nclass SpatialProcessor {\n  constructor() {\n    this.cache = new Map();\n    this.geometryCache = new Map();\n  }\n\n  // Main processing methods\n  processSpatialData(data, options = {}) {\n    const metric = backgroundMonitor.startMetric('spatial-processing');\n    try {\n      const {\n        validate = true,\n        optimize = true,\n        cacheResults = true\n      } = options;\n\n      // Generate cache key\n      const cacheKey = this.getCacheKey(data, options);\n      \n      // Check cache\n      if (cacheResults && this.cache.has(cacheKey)) {\n        metric.finish({ status: 'cache-hit' });\n        return this.cache.get(cacheKey);\n      }\n\n      // Process data\n      let processed = data;\n\n      // Validate if required\n      if (validate) {\n        this.validateGeometry(processed);\n      }\n\n      // Transform data\n      processed = this.transformGeometry(processed);\n\n      // Optimize if required\n      if (optimize) {\n        processed = this.optimizeGeometry(processed);\n      }\n\n      // Cache results if required\n      if (cacheResults) {\n        this.cache.set(cacheKey, processed);\n      }\n\n      metric.finish({ status: 'success' });\n      return processed;\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      throw error;\n    }\n  }\n\n  // Validation methods\n  validateGeometry(data) {\n    if (!data || !data.type || !data.features) {\n      throw new Error('Invalid GeoJSON structure');\n    }\n\n    if (data.type !== 'FeatureCollection') {\n      throw new Error('Expected FeatureCollection type');\n    }\n\n    if (!Array.isArray(data.features)) {\n      throw new Error('Features must be an array');\n    }\n\n    // Validate each feature\n    data.features.forEach((feature, index) => {\n      if (!feature.type || feature.type !== 'Feature') {\n        throw new Error(`Invalid feature type at index ${index}`);\n      }\n\n      if (!feature.geometry || !feature.geometry.type || !feature.geometry.coordinates) {\n        throw new Error(`Invalid geometry at feature index ${index}`);\n      }\n\n      this.validateCoordinates(feature.geometry.coordinates, feature.geometry.type, index);\n    });\n\n    return true;\n  }\n\n  validateCoordinates(coordinates, type, featureIndex) {\n    switch (type) {\n      case 'Point':\n        this.validatePoint(coordinates, featureIndex);\n        break;\n      case 'LineString':\n        this.validateLineString(coordinates, featureIndex);\n        break;\n      case 'Polygon':\n        this.validatePolygon(coordinates, featureIndex);\n        break;\n      case 'MultiPolygon':\n        this.validateMultiPolygon(coordinates, featureIndex);\n        break;\n      default:\n        throw new Error(`Unsupported geometry type: ${type} at feature index ${featureIndex}`);\n    }\n  }\n\n  validatePoint(coordinates, featureIndex) {\n    if (!Array.isArray(coordinates) || coordinates.length !== 2) {\n      throw new Error(`Invalid point coordinates at feature index ${featureIndex}`);\n    }\n  }\n\n  validateLineString(coordinates, featureIndex) {\n    if (!Array.isArray(coordinates) || coordinates.length < 2) {\n      throw new Error(`Invalid LineString coordinates at feature index ${featureIndex}`);\n    }\n    coordinates.forEach((point, i) => this.validatePoint(point, `${featureIndex}:${i}`));\n  }\n\n  validatePolygon(coordinates, featureIndex) {\n    if (!Array.isArray(coordinates) || coordinates.length < 1) {\n      throw new Error(`Invalid Polygon coordinates at feature index ${featureIndex}`);\n    }\n    coordinates.forEach((ring, i) => this.validateLineString(ring, `${featureIndex}:${i}`));\n  }\n\n  validateMultiPolygon(coordinates, featureIndex) {\n    if (!Array.isArray(coordinates)) {\n      throw new Error(`Invalid MultiPolygon coordinates at feature index ${featureIndex}`);\n    }\n    coordinates.forEach((polygon, i) => this.validatePolygon(polygon, `${featureIndex}:${i}`));\n  }\n\n  // Transformation methods\n  transformGeometry(data) {\n    return {\n      type: 'FeatureCollection',\n      features: data.features.map(feature => this.transformFeature(feature)),\n      properties: {\n        ...data.properties,\n        transformed: true,\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n\n  transformFeature(feature) {\n    return {\n      type: 'Feature',\n      geometry: this.transformGeometryObject(feature.geometry),\n      properties: {\n        ...feature.properties,\n        transformed: true\n      },\n      id: feature.id || this.generateFeatureId()\n    };\n  }\n\n  transformGeometryObject(geometry) {\n    return {\n      type: geometry.type,\n      coordinates: this.transformCoordinates(geometry.coordinates, geometry.type)\n    };\n  }\n\n  transformCoordinates(coordinates, type) {\n    switch (type) {\n      case 'Point':\n        return this.roundCoordinates(coordinates);\n      case 'LineString':\n        return coordinates.map(point => this.roundCoordinates(point));\n      case 'Polygon':\n        return coordinates.map(ring => ring.map(point => this.roundCoordinates(point)));\n      case 'MultiPolygon':\n        return coordinates.map(polygon => \n          polygon.map(ring => ring.map(point => this.roundCoordinates(point)))\n        );\n      default:\n        return coordinates;\n    }\n  }\n\n  // Optimization methods\n  optimizeGeometry(data) {\n    return {\n      ...data,\n      features: data.features.map(feature => this.optimizeFeature(feature))\n    };\n  }\n\n  optimizeFeature(feature) {\n    const optimized = {\n      ...feature,\n      geometry: this.optimizeGeometryObject(feature.geometry)\n    };\n\n    // Cache optimized feature\n    this.geometryCache.set(feature.id || this.generateFeatureId(), optimized);\n\n    return optimized;\n  }\n\n  optimizeGeometryObject(geometry) {\n    return {\n      ...geometry,\n      coordinates: this.simplifyCoordinates(geometry.coordinates, geometry.type)\n    };\n  }\n\n  // Helper methods\n  roundCoordinates(coordinates) {\n    return coordinates.map(coord => Number(coord.toFixed(6)));\n  }\n\n  simplifyCoordinates(coordinates, type) {\n    // Implement Douglas-Peucker or similar algorithm based on type\n    return coordinates;\n  }\n\n  generateFeatureId() {\n    return `feature-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getCacheKey(data, options) {\n    return JSON.stringify({\n      dataHash: this.hashData(data),\n      options\n    });\n  }\n\n  hashData(data) {\n    return typeof data === 'object' ? \n      JSON.stringify(data) : \n      String(data);\n  }\n\n  // Cache management\n  clearCache() {\n    this.cache.clear();\n    this.geometryCache.clear();\n  }\n\n  getCacheStats() {\n    return {\n      dataCache: {\n        size: this.cache.size,\n        keys: Array.from(this.cache.keys())\n      },\n      geometryCache: {\n        size: this.geometryCache.size,\n        keys: Array.from(this.geometryCache.keys())\n      },\n      lastUpdated: new Date().toISOString()\n    };\n  }\n}\n\nexport default new SpatialProcessor();\n",
        "imports": [
          "./monitoringUtils"
        ],
        "exports": [
          "default"
        ],
        "dependencies": [
          "./monitoringUtils"
        ]
      },
      {
        "path": "utils/dataCache.js",
        "content": "// src/utils/dataCache.js\n\nimport { backgroundMonitor } from './backgroundMonitor';\n\nclass DataCache {\n  constructor() {\n    this.cache = new Map();\n    this.maxSize = 100;\n    this.ttl = 3600000; // 1 hour\n    this.priorityLevels = {\n      HIGH: new Set(['timeSeriesData', 'flowMaps']),\n      MEDIUM: new Set(['marketClusters', 'spatialAutocorrelation']),\n      LOW: new Set(['regressionAnalysis', 'seasonalAnalysis'])\n    };\n    \n    // Start cleanup interval\n    this.cleanupInterval = setInterval(() => this.cleanup(), 300000); // 5 minutes\n  }\n\n  get(commodity, date) {\n    const metric = backgroundMonitor.startMetric('cache-get');\n    const key = this._getKey(commodity, date);\n    \n    try {\n      const cached = this.cache.get(key);\n      if (!cached) {\n        metric.finish({ status: 'miss' });\n        return null;\n      }\n\n      if (Date.now() - cached.timestamp > this.ttl) {\n        this.cache.delete(key);\n        metric.finish({ status: 'expired' });\n        return null;\n      }\n\n      // Update access count and timestamp\n      cached.accessCount++;\n      cached.lastAccessed = Date.now();\n      \n      metric.finish({ status: 'hit' });\n      return cached.data;\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      return null;\n    }\n  }\n\n  set(commodity, date, data) {\n    const metric = backgroundMonitor.startMetric('cache-set');\n    const key = this._getKey(commodity, date);\n    \n    try {\n      // Implement LRU if cache is full\n      if (this.cache.size >= this.maxSize) {\n        this.evictLRU();\n      }\n\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now(),\n        lastAccessed: Date.now(),\n        accessCount: 0,\n        size: this._estimateSize(data)\n      });\n\n      metric.finish({ status: 'success' });\n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n    }\n  }\n\n  cleanup() {\n    const metric = backgroundMonitor.startMetric('cache-cleanup');\n    const now = Date.now();\n    let removedCount = 0;\n\n    for (const [key, value] of this.cache.entries()) {\n      if (now - value.timestamp > this.ttl) {\n        this.cache.delete(key);\n        removedCount++;\n      }\n    }\n\n    metric.finish({ \n      status: 'success',\n      removedEntries: removedCount\n    });\n  }\n\n  clear() {\n    this.cache.clear();\n    backgroundMonitor.logMetric('cache-clear', {\n      timestamp: Date.now()\n    });\n  }\n\n  _getKey(commodity, date) {\n    return `${commodity}_${date}`;\n  }\n\n  _estimateSize(data) {\n    try {\n      return new Blob([JSON.stringify(data)]).size;\n    } catch {\n      return 0;\n    }\n  }\n\n  evictLRU() {\n    let oldestAccess = Date.now();\n    let keyToRemove = null;\n\n    for (const [key, value] of this.cache.entries()) {\n      if (value.lastAccessed < oldestAccess) {\n        oldestAccess = value.lastAccessed;\n        keyToRemove = key;\n      }\n    }\n\n    if (keyToRemove) {\n      this.cache.delete(keyToRemove);\n      backgroundMonitor.logMetric('cache-eviction', {\n        key: keyToRemove,\n        reason: 'LRU'\n      });\n    }\n  }\n\n  getStats() {\n    return {\n      size: this.cache.size,\n      maxSize: this.maxSize,\n      totalSize: Array.from(this.cache.values())\n        .reduce((sum, item) => sum + (item.size || 0), 0),\n      hitRate: this._calculateHitRate(),\n      entries: Array.from(this.cache.entries()).map(([key, value]) => ({\n        key,\n        accessCount: value.accessCount,\n        age: Date.now() - value.timestamp,\n        size: value.size || 0\n      }))\n    };\n  }\n\n  _calculateHitRate() {\n    const total = Array.from(this.cache.values())\n      .reduce((sum, item) => sum + item.accessCount, 0);\n    return total / this.cache.size || 0;\n  }\n}\n\nexport const dataCache = new DataCache();",
        "imports": [
          "./backgroundMonitor"
        ],
        "exports": [
          "dataCache"
        ],
        "dependencies": [
          "./backgroundMonitor"
        ]
      },
      {
        "path": "utils/dataLoader.js",
        "content": "// src/utils/dataCache.js\n\nimport { backgroundMonitor } from './backgroundMonitor';\n\nclass DataCache {\n  constructor() {\n    this.cache = new Map();\n    this.maxSize = 100;\n    this.ttl = 3600000; // 1 hour\n    this.priorityLevels = {\n      HIGH: new Set(['timeSeriesData', 'flowMaps']),\n      MEDIUM: new Set(['marketClusters', 'spatialAutocorrelation']),\n      LOW: new Set(['regressionAnalysis', 'seasonalAnalysis'])\n    };\n    \n    // Start cleanup interval\n    this.cleanupInterval = setInterval(() => this.cleanup(), 300000); // 5 minutes\n  }\n\n  get(key, options = {}) {\n    const metric = backgroundMonitor.startMetric('cache-get');\n    \n    try {\n      const cached = this.cache.get(key);\n      if (!cached) {\n        metric.finish({ status: 'miss' });\n        return null;\n      }\n\n      if (Date.now() - cached.timestamp > this.ttl) {\n        this.cache.delete(key);\n        metric.finish({ status: 'expired' });\n        return null;\n      }\n\n      // Update access count and timestamp\n      cached.accessCount++;\n      cached.lastAccessed = Date.now();\n      \n      metric.finish({ status: 'hit' });\n      return cached.data;\n      \n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n      return null;\n    }\n  }\n\n  set(key, data, priority = 'MEDIUM') {\n    const metric = backgroundMonitor.startMetric('cache-set');\n    \n    try {\n      // Implement LRU if cache is full\n      if (this.cache.size >= this.maxSize) {\n        this.evictLRU(priority);\n      }\n\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now(),\n        lastAccessed: Date.now(),\n        accessCount: 0,\n        priority,\n        size: this._estimateSize(data)\n      });\n\n      metric.finish({ status: 'success' });\n      \n    } catch (error) {\n      metric.finish({ status: 'error', error: error.message });\n    }\n  }\n\n  cleanup() {\n    const metric = backgroundMonitor.startMetric('cache-cleanup');\n    const now = Date.now();\n    let removedCount = 0;\n\n    for (const [key, value] of this.cache.entries()) {\n      if (now - value.timestamp > this.ttl) {\n        this.cache.delete(key);\n        removedCount++;\n      }\n    }\n\n    metric.finish({ \n      status: 'success',\n      removedEntries: removedCount\n    });\n  }\n\n  clear() {\n    this.cache.clear();\n    backgroundMonitor.logMetric('cache-clear', {\n      timestamp: Date.now()\n    });\n  }\n\n  _estimateSize(data) {\n    try {\n      return new Blob([JSON.stringify(data)]).size;\n    } catch {\n      return 0;\n    }\n  }\n\n  evictLRU(newPriority) {\n    // Sort entries by priority and last access time\n    const entries = Array.from(this.cache.entries())\n      .map(([key, value]) => ({\n        key,\n        priority: value.priority,\n        lastAccessed: value.lastAccessed\n      }))\n      .sort((a, b) => {\n        // First compare priority levels\n        const priorityOrder = { HIGH: 3, MEDIUM: 2, LOW: 1 };\n        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n        if (priorityDiff !== 0) return priorityDiff;\n        \n        // Then compare last access times\n        return a.lastAccessed - b.lastAccessed;\n      });\n\n    // Remove the least recently used item with lowest priority\n    if (entries.length > 0) {\n      const toRemove = entries[0];\n      this.cache.delete(toRemove.key);\n      backgroundMonitor.logMetric('cache-eviction', {\n        key: toRemove.key,\n        reason: 'LRU',\n        priority: toRemove.priority\n      });\n    }\n  }\n\n  getStats() {\n    return {\n      size: this.cache.size,\n      maxSize: this.maxSize,\n      totalSize: Array.from(this.cache.values())\n        .reduce((sum, item) => sum + (item.size || 0), 0),\n      hitRate: this._calculateHitRate(),\n      entries: Array.from(this.cache.entries()).map(([key, value]) => ({\n        key,\n        accessCount: value.accessCount,\n        age: Date.now() - value.timestamp,\n        size: value.size || 0,\n        priority: value.priority\n      }))\n    };\n  }\n\n  _calculateHitRate() {\n    const total = Array.from(this.cache.values())\n      .reduce((sum, item) => sum + item.accessCount, 0);\n    return total / this.cache.size || 0;\n  }\n}\n\nexport const dataCache = new DataCache();",
        "imports": [
          "./backgroundMonitor"
        ],
        "exports": [
          "dataCache"
        ],
        "dependencies": [
          "./backgroundMonitor"
        ]
      },
      {
        "path": "utils/dataProcessingUtils.js",
        "content": "// src/utils/dataProcessingUtils.js\n\n/**\n * Process regression data into standardized format\n */\nexport const processRegressionData = (data, selectedCommodity) => {\n    if (!Array.isArray(data)) return null;\n    \n    const filteredData = data.filter(item => \n      item.commodity?.toLowerCase() === selectedCommodity?.toLowerCase()\n    )[0];\n  \n    if (!filteredData) return null;\n  \n    // Create consistent format for regression data\n    return {\n      model: {\n        coefficients: filteredData.coefficients || {},\n        intercept: filteredData.intercept || 0,\n        p_values: filteredData.p_values || {},\n        r_squared: filteredData.r_squared || 0,\n        adj_r_squared: filteredData.adj_r_squared || 0,\n        mse: filteredData.mse || 0,\n        observations: filteredData.observations || 0\n      },\n      spatial: {\n        moran_i: filteredData.moran_i || { I: 0, 'p-value': 1 },\n        vif: filteredData.vif || []\n      },\n      residuals: processResiduals(filteredData.residual || [])\n    };\n  };\n  \n  /**\n   * Process residuals with consistent formatting\n   */\n  const processResiduals = (residuals) => {\n    const processed = residuals.map(r => ({\n      region_id: r.region_id,\n      date: new Date(r.date).toISOString(),\n      residual: Number(r.residual)\n    }));\n  \n    return {\n      raw: processed,\n      byRegion: groupResidualsByRegion(processed),\n      stats: calculateResidualStats(processed)\n    };\n  };\n  \n  /**\n   * Group residuals by region\n   */\n  const groupResidualsByRegion = (residuals) => {\n    return residuals.reduce((acc, r) => {\n      if (!acc[r.region_id]) acc[r.region_id] = [];\n      acc[r.region_id].push(r);\n      return acc;\n    }, {});\n  };\n  \n  /**\n   * Calculate residual statistics\n   */\n  const calculateResidualStats = (residuals) => {\n    const values = residuals.map(r => r.residual);\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    \n    return {\n      mean,\n      variance: values.reduce((sum, val) => \n        sum + Math.pow(val - mean, 2), 0) / (values.length - 1),\n      maxAbsolute: Math.max(...values.map(Math.abs))\n    };\n  };",
        "imports": [],
        "exports": [
          "processRegressionData"
        ],
        "dependencies": []
      },
      {
        "path": "utils/dataProcessor.js",
        "content": "// src/utils/dataProcessor.js\n\nimport { normalizeRegionId } from './appUtils';\n\n/**\n * Simplified data processing utilities\n */\nexport const dataProcessor = {\n  // Normalize region names using appUtils.js\n  normalizeRegion: (name) => {\n    return normalizeRegionId(name);\n  },\n\n  // Process time series data\n  processTimeSeries: (data) => {\n    return data\n      .map((entry) => ({\n        date: entry.date,\n        price: parseFloat(entry.price) || 0,\n        usdprice: parseFloat(entry.usdprice) || 0,\n        conflict_intensity: parseFloat(entry.conflict_intensity) || 0,\n        region: dataProcessor.normalizeRegion(entry.region || entry.admin1),\n      }))\n      .sort((a, b) => new Date(a.date) - new Date(b.date));\n  },\n\n  // Process market clusters\n  processClusters: (clusters) => {\n    return clusters.map((cluster) => ({\n      cluster_id: cluster.cluster_id,\n      main_market: dataProcessor.normalizeRegion(cluster.main_market),\n      connected_markets: cluster.connected_markets.map((m) =>\n        dataProcessor.normalizeRegion(m)\n      ),\n      market_count: parseInt(cluster.market_count) || 0,\n    }));\n  },\n\n  // Validate data structure\n  validateData: (data) => {\n    const required = [\n      'time_series_data',\n      'market_clusters',\n      'flow_analysis',\n      'spatial_autocorrelation',\n    ];\n\n    const missing = required.filter((field) => !data[field]);\n    if (missing.length > 0) {\n      throw new Error(`Missing required fields: ${missing.join(', ')}`);\n    }\n\n    return true;\n  },\n};\n\nexport default dataProcessor;",
        "imports": [
          "./appUtils"
        ],
        "exports": [
          "dataProcessor",
          "default"
        ],
        "dependencies": [
          "./appUtils"
        ]
      },
      {
        "path": "utils/dataTransformations.js",
        "content": "// src/utils/dataTransformations.js\n\nimport _ from 'lodash';\nimport { validateCoordinates } from './spatialUtils';\n\n/**\n * Transform price data for visualization\n * @param {Array} timeSeriesData - Raw time series data\n * @returns {Object} Transformed price data\n */\nexport const transformPriceData = (timeSeriesData) => {\n  if (!Array.isArray(timeSeriesData)) return null;\n\n  try {\n    const byRegion = _.groupBy(timeSeriesData, 'region');\n    \n    return Object.entries(byRegion).reduce((acc, [region, data]) => {\n      const prices = data.map(d => ({\n        date: d.month,\n        price: validateNumber(d.usdPrice),\n        conflict: validateNumber(d.conflictIntensity)\n      }));\n\n      acc[region] = {\n        prices,\n        trend: calculateTrend(prices),\n        statistics: calculatePriceStatistics(prices)\n      };\n      return acc;\n    }, {});\n  } catch (error) {\n    console.error('Error transforming price data:', error);\n    return null;\n  }\n};\n\n/**\n * Calculate integration metrics\n * @param {Object} marketIntegration - Raw market integration data\n * @returns {Object} Calculated integration metrics\n */\nexport const calculateIntegrationMetrics = (marketIntegration) => {\n  if (!marketIntegration) return null;\n\n  try {\n    const { price_correlation, flow_density, accessibility } = marketIntegration;\n\n    return {\n      correlationMatrix: normalizeCorrelationMatrix(price_correlation),\n      flowDensity: validateNumber(flow_density),\n      accessibility: validateAccessibility(accessibility),\n      summary: {\n        averageCorrelation: calculateAverageCorrelation(price_correlation),\n        marketCoverage: calculateMarketCoverage(accessibility),\n        integrationScore: calculateIntegrationScore(price_correlation, flow_density)\n      }\n    };\n  } catch (error) {\n    console.error('Error calculating integration metrics:', error);\n    return null;\n  }\n};\n\n/**\n * Process cluster data for visualization\n * @param {Array} clusters - Raw cluster data\n * @returns {Object} Processed cluster data\n */\nexport const processClusterData = (clusters) => {\n  if (!Array.isArray(clusters)) return null;\n\n  try {\n    return clusters.map(cluster => ({\n      id: cluster.cluster_id,\n      mainMarket: cluster.main_market,\n      markets: cluster.connected_markets || [],\n      metrics: {\n        efficiency: validateNumber(cluster.metrics?.efficiency),\n        connectivity: validateNumber(cluster.metrics?.internal_connectivity),\n        coverage: validateNumber(cluster.metrics?.market_coverage),\n        stability: validateNumber(cluster.metrics?.stability)\n      },\n      spatialProperties: calculateSpatialProperties(cluster)\n    }));\n  } catch (error) {\n    console.error('Error processing cluster data:', error);\n    return null;\n  }\n};\n\n/**\n * Analyze shock data for visualization\n * @param {Array} shocks - Raw shock data\n * @returns {Object} Analyzed shock data\n */\nexport const analyzeShockData = (shocks) => {\n  if (!Array.isArray(shocks)) return null;\n\n  try {\n    const byRegion = _.groupBy(shocks, 'region');\n    \n    return Object.entries(byRegion).reduce((acc, [region, data]) => {\n      acc[region] = {\n        shocks: data.map(transformShock),\n        analysis: analyzeShockPatterns(data),\n        summary: calculateShockSummary(data)\n      };\n      return acc;\n    }, {});\n  } catch (error) {\n    console.error('Error analyzing shock data:', error);\n    return null;\n  }\n};\n\n/**\n * Transform geometry data\n * @param {Object} geometry - Raw geometry data\n * @returns {Object} Transformed geometry data\n */\nexport const transformGeometryData = (geometry) => {\n  if (!geometry) return null;\n\n  try {\n    return {\n      points: (geometry.points || []).map(transformPoint),\n      polygons: (geometry.polygons || []).map(transformPolygon),\n      unified: transformUnifiedGeometry(geometry.unified)\n    };\n  } catch (error) {\n    console.error('Error transforming geometry data:', error);\n    return null;\n  }\n};\n\n// Helper functions\n\nconst validateNumber = (value) => {\n  const num = Number(value);\n  return !isNaN(num) && isFinite(num) ? num : 0;\n};\n\nconst calculateTrend = (prices) => {\n  if (!prices?.length) return null;\n  \n  const xValues = Array.from({ length: prices.length }, (_, i) => i);\n  const yValues = prices.map(p => p.price);\n  \n  const { slope, intercept } = linearRegression(xValues, yValues);\n  \n  return {\n    slope,\n    intercept,\n    direction: slope > 0 ? 'increasing' : slope < 0 ? 'decreasing' : 'stable'\n  };\n};\n\nconst calculatePriceStatistics = (prices) => {\n  if (!prices?.length) return null;\n  \n  const values = prices.map(p => p.price).filter(p => !isNaN(p));\n  \n  return {\n    mean: _.mean(values),\n    median: _.sortBy(values)[Math.floor(values.length / 2)],\n    std: calculateStandardDeviation(values),\n    min: _.min(values),\n    max: _.max(values)\n  };\n};\n\nconst normalizeCorrelationMatrix = (matrix) => {\n  if (!matrix) return {};\n  \n  return Object.entries(matrix).reduce((acc, [region, correlations]) => {\n    acc[region] = Object.entries(correlations).reduce((inner, [target, value]) => {\n      inner[target] = validateNumber(value);\n      return inner;\n    }, {});\n    return acc;\n  }, {});\n};\n\nconst validateAccessibility = (accessibility) => {\n  if (!accessibility) return {};\n  \n  return Object.entries(accessibility).reduce((acc, [region, value]) => {\n    acc[region] = validateNumber(value);\n    return acc;\n  }, {});\n};\n\nconst calculateAverageCorrelation = (correlations) => {\n  if (!correlations) return 0;\n  \n  const values = Object.values(correlations).flatMap(c => \n    Object.values(c).filter(v => !isNaN(v))\n  );\n  \n  return values.length ? _.mean(values) : 0;\n};\n\nconst calculateMarketCoverage = (accessibility) => {\n  if (!accessibility) return 0;\n  \n  const values = Object.values(accessibility).filter(v => !isNaN(v));\n  return values.length ? _.mean(values) : 0;\n};\n\nconst calculateIntegrationScore = (correlations, flowDensity) => {\n  const avgCorrelation = calculateAverageCorrelation(correlations);\n  return (avgCorrelation + validateNumber(flowDensity)) / 2;\n};\n\nconst calculateSpatialProperties = (cluster) => {\n  if (!cluster?.connected_markets?.length) return null;\n  \n  const coordinates = cluster.connected_markets\n    .map(market => validateCoordinates(market))\n    .filter(Boolean);\n  \n  return {\n    center: calculateCentroid(coordinates),\n    boundingBox: calculateBoundingBox(coordinates),\n    dispersion: calculateDispersion(coordinates)\n  };\n};\n\nconst transformShock = (shock) => ({\n  date: shock.date,\n  type: shock.shock_type,\n  magnitude: validateNumber(shock.magnitude),\n  priceChange: {\n    previous: validateNumber(shock.previous_price),\n    current: validateNumber(shock.current_price)\n  }\n});\n\nconst analyzeShockPatterns = (shocks) => {\n  const byType = _.groupBy(shocks, 'shock_type');\n  \n  return Object.entries(byType).reduce((acc, [type, data]) => {\n    acc[type] = {\n      count: data.length,\n      averageMagnitude: _.meanBy(data, 'magnitude'),\n      frequency: data.length / shocks.length\n    };\n    return acc;\n  }, {});\n};\n\nconst calculateShockSummary = (shocks) => ({\n  totalShocks: shocks.length,\n  averageMagnitude: _.meanBy(shocks, 'magnitude'),\n  maxMagnitude: _.maxBy(shocks, 'magnitude')?.magnitude || 0,\n  types: _.uniq(shocks.map(s => s.shock_type))\n});\n\nconst transformPoint = (point) => ({\n  ...point,\n  coordinates: validateCoordinates(point.coordinates),\n  properties: {\n    ...point.properties,\n    normalizedName: point.properties?.normalizedName || '',\n    region_id: point.properties?.region_id || ''\n  }\n});\n\nconst transformPolygon = (polygon) => ({\n  ...polygon,\n  geometry: {\n    ...polygon.geometry,\n    coordinates: validatePolygonCoordinates(polygon.geometry?.coordinates)\n  },\n  properties: {\n    ...polygon.properties,\n    normalizedName: polygon.properties?.normalizedName || '',\n    region_id: polygon.properties?.region_id || ''\n  }\n});\n\nconst transformUnifiedGeometry = (unified) => {\n  if (!unified) return null;\n  \n  return {\n    type: unified.type || 'FeatureCollection',\n    features: (unified.features || []).map(transformPolygon),\n    properties: unified.properties || {}\n  };\n};\n\nconst validatePolygonCoordinates = (coordinates) => {\n  if (!Array.isArray(coordinates)) return [];\n  return coordinates.map(ring => \n    Array.isArray(ring) ? ring.map(coord => \n      validateCoordinates(coord)\n    ) : []\n  );\n};\n\nconst calculateCentroid = (coordinates) => {\n  if (!coordinates?.length) return null;\n  \n  const sum = coordinates.reduce((acc, coord) => ({\n    x: acc.x + coord[0],\n    y: acc.y + coord[1]\n  }), { x: 0, y: 0 });\n  \n  return [sum.x / coordinates.length, sum.y / coordinates.length];\n};\n\nconst calculateBoundingBox = (coordinates) => {\n  if (!coordinates?.length) return null;\n  \n  return coordinates.reduce((box, coord) => ({\n    minX: Math.min(box.minX, coord[0]),\n    maxX: Math.max(box.maxX, coord[0]),\n    minY: Math.min(box.minY, coord[1]),\n    maxY: Math.max(box.maxY, coord[1])\n  }), {\n    minX: coordinates[0][0],\n    maxX: coordinates[0][0],\n    minY: coordinates[0][1],\n    maxY: coordinates[0][1]\n  });\n};\n\nconst calculateDispersion = (coordinates) => {\n  if (!coordinates?.length) return 0;\n  \n  const centroid = calculateCentroid(coordinates);\n  const distances = coordinates.map(coord => \n    Math.sqrt(\n      Math.pow(coord[0] - centroid[0], 2) + \n      Math.pow(coord[1] - centroid[1], 2)\n    )\n  );\n  \n  return _.mean(distances);\n};\n\nconst calculateStandardDeviation = (values) => {\n  const mean = _.mean(values);\n  const squareDiffs = values.map(value => Math.pow(value - mean, 2));\n  return Math.sqrt(_.mean(squareDiffs));\n};\n\nconst linearRegression = (x, y) => {\n  const n = x.length;\n  const sumX = _.sum(x);\n  const sumY = _.sum(y);\n  const sumXY = _.sum(x.map((xi, i) => xi * y[i]));\n  const sumXX = _.sum(x.map(xi => xi * xi));\n  \n  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n  \n  return { slope, intercept };\n};\n\n// Export helper functions for testing\nexport const utils = {\n  validateNumber,\n  calculateTrend,\n  calculatePriceStatistics,\n  normalizeCorrelationMatrix,\n  validateAccessibility,\n  calculateAverageCorrelation,\n  calculateMarketCoverage,\n  calculateIntegrationScore,\n  calculateSpatialProperties,\n  transformShock,\n  analyzeShockPatterns,\n  calculateShockSummary,\n  transformPoint,\n  transformPolygon,\n  transformUnifiedGeometry,\n  validatePolygonCoordinates,\n  calculateCentroid,\n  calculateBoundingBox,\n  calculateDispersion,\n  calculateStandardDeviation,\n  linearRegression\n};\n",
        "imports": [
          "lodash",
          "./spatialUtils"
        ],
        "exports": [
          "transformPriceData",
          "calculateIntegrationMetrics",
          "processClusterData",
          "analyzeShockData",
          "transformGeometryData",
          "utils"
        ],
        "dependencies": [
          "lodash",
          "./spatialUtils"
        ]
      },
      {
        "path": "utils/dataUtils.js",
        "content": "import { pathResolver } from './pathResolver';\n\n// Environment Constants\nconst ENV = process.env.NODE_ENV;\nconst BASE_URL = process.env.PUBLIC_URL || '';\nconst isDev = ENV === 'development';\nconst CACHE_DURATION = parseInt(process.env.REACT_APP_CACHE_DURATION, 10) || 3600000;\nconst RETRY_ATTEMPTS = 3;\nconst RETRY_INITIAL_DELAY = 1000;\nconst RETRY_MAX_DELAY = 5000;\n\nclass DataFetchCache {\n  constructor() {\n    this.cache = new Map();\n  }\n\n  set(key, data) {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  get(key) {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n\n    if (Date.now() - cached.timestamp > CACHE_DURATION) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return cached.data;\n  }\n\n  clear() {\n    this.cache.clear();\n  }\n}\n\nconst cache = new DataFetchCache();\n\nconst cleanPath = (path) => {\n  if (!path) return '';\n  return path\n    .replace(/\\/+/g, '/')\n    .replace(/\\/$/, '')\n    .replace(/^\\/+/, '/')\n    .trim();\n};\n\nexport const getDataPath = (fileName = '') => {\n  // Determine base path based on environment and file type\n  const basePath = isDev \n    ? '/results' \n    : `${BASE_URL}/data`;\n\n  // Handle preprocessed data files\n  if (fileName.includes('preprocessed_')) {\n    const subDir = 'preprocessed_by_commodity';\n    return cleanPath(`${isDev ? `/results/${subDir}` : `${BASE_URL}/data/${subDir}`}/${fileName}`);\n  }\n\n  // Handle standard data files\n  return cleanPath(`${basePath}/${fileName}`);\n};\n\nexport const fetchWithRetry = async (url, options = {}, retries = RETRY_ATTEMPTS) => {\n  const tryPaths = async (paths) => {\n    for (const path of paths) {\n      try {\n        const response = await fetch(path, {\n          ...options,\n          headers: {\n            'Accept': 'application/json',\n            'Cache-Control': isDev ? 'no-cache' : 'max-age=3600',\n            ...options.headers\n          }\n        });\n        \n        if (response.ok) {\n          return response;\n        }\n      } catch (error) {\n        console.warn(`Failed to fetch from ${path}:`, error);\n      }\n    }\n    return null;\n  };\n\n  // Generate fallback paths\n  const paths = [url];\n  if (isDev) {\n    if (url.includes('/data/')) {\n      paths.push(url.replace('/data/', '/results/'));\n    } else if (url.includes('/results/')) {\n      paths.push(url.replace('/results/', '/data/'));\n    }\n  }\n\n  // Implement retry logic with exponential backoff\n  for (let attempt = 0; attempt < retries; attempt++) {\n    const response = await tryPaths(paths);\n    if (response) return response;\n\n    if (attempt < retries - 1) {\n      const delay = Math.min(RETRY_INITIAL_DELAY * Math.pow(2, attempt), RETRY_MAX_DELAY);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw new Error(`Failed to fetch from paths after ${retries} attempts: ${paths.join(', ')}`);\n};\n\nexport const getNetworkDataPath = (fileName) => {\n  return cleanPath(`${getDataPath('network_data')}/${fileName}`);\n};\n\nexport const getPrecomputedDataPath = (commodity) => {\n  return pathResolver.getCommodityFilePath(commodity);\n};\n\nexport const enhancedFetchJson = async (url, options = {}) => {\n  try {\n    const response = await fetchWithRetry(url, {\n      ...options,\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        ...options.headers\n      }\n    });\n\n    const text = await response.text();\n    // Handle empty responses\n    if (!text) return null;\n\n    try {\n      return JSON.parse(text);\n    } catch (parseError) {\n      console.error('JSON parse error:', parseError);\n      throw new Error(`Invalid JSON response from ${url}`);\n    }\n  } catch (error) {\n    console.error('[DataUtils] Failed to fetch:', { url, error: error.message });\n    throw error;\n  }\n};\n\nexport const getRegressionDataPath = () => {\n  const basePath = isDev ? '/data' : `${BASE_URL}/data`;\n  return `${basePath}/spatial_analysis_results.json`;\n};\n\nexport const getChoroplethDataPath = (fileName) => {\n  if (!fileName) throw new Error('Filename parameter is required');\n  return cleanPath(`${getDataPath('choropleth_data')}/${fileName}`);\n};\n\nexport const fetchAndValidateData = async (url, selectedCommodity) => {\n  try {\n    const cacheKey = `${url}_${selectedCommodity || ''}`;\n    const cachedData = cache.get(cacheKey);\n    if (cachedData) return cachedData;\n\n    const data = await enhancedFetchJson(url);\n    if (!data || !Array.isArray(data)) {\n      console.warn('Invalid spatial analysis data format');\n      return null;\n    }\n\n    // Filter for selected commodity if provided\n    if (selectedCommodity) {\n      const filteredData = data.filter(result => \n        result.commodity?.toLowerCase() === selectedCommodity.toLowerCase()\n      );\n      \n      if (filteredData.length === 0) {\n        console.warn(`No data found for commodity: ${selectedCommodity}`);\n        return null;\n      }\n      \n      cache.set(cacheKey, filteredData);\n      return filteredData;\n    }\n\n    cache.set(cacheKey, data);\n    return data;\n  } catch (error) {\n    console.error('Error fetching and validating spatial analysis data:', error);\n    throw error;\n  }\n};\n\nexport const retryWithBackoff = async (fn, options = {}) => {\n  const { \n    maxRetries = RETRY_ATTEMPTS, \n    initialDelay = RETRY_INITIAL_DELAY, \n    maxDelay = RETRY_MAX_DELAY,\n    onRetry = null\n  } = options;\n\n  let lastError;\n  \n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n      if (attempt === maxRetries - 1) throw error;\n\n      const delay = Math.min(initialDelay * Math.pow(2, attempt), maxDelay);\n      if (onRetry) onRetry(attempt, delay, error);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n};\n\nexport const clearDataCache = () => {\n  cache.clear();\n};\n\nexport const validateDataResponse = (data, schema = null) => {\n  if (!data) return false;\n  if (schema) {\n    // Add schema validation if needed\n    return true;\n  }\n  return true;\n};",
        "imports": [
          "./pathResolver"
        ],
        "exports": [
          "getDataPath",
          "fetchWithRetry",
          "getNetworkDataPath",
          "getPrecomputedDataPath",
          "enhancedFetchJson",
          "getRegressionDataPath",
          "getChoroplethDataPath",
          "fetchAndValidateData",
          "retryWithBackoff",
          "clearDataCache",
          "validateDataResponse"
        ],
        "dependencies": [
          "./pathResolver"
        ]
      },
      {
        "path": "utils/debugUtils.js",
        "content": "// Debugging and analysis utilities\n\n// ===== ReduxDebugWrapper.js =====\n\n// src/utils/ReduxDebugWrapper.js\n\nimport React, { useEffect } from 'react';\nimport { useStore } from 'react-redux';\nimport PropTypes from 'prop-types';\nimport { backgroundMonitor } from './backgroundMonitor';\nimport { isValidRegressionData, DEFAULT_REGRESSION_DATA } from '../types/dataTypes';\n\nconst ReduxDebugWrapper = ({ children }) => {\n  const store = useStore();\n\n  useEffect(() => {\n    console.group('Redux Debug Info');\n    console.log('Initial State:', store.getState());\n    console.log('Theme State:', store.getState().theme);\n    console.groupEnd();\n\n    const unsubscribe = store.subscribe(() => {\n      console.group('Redux State Update');\n      console.log('New State:', store.getState());\n      console.log('Theme State:', store.getState().theme);\n      console.log('Action:', store.getState().lastAction);\n      console.groupEnd();\n    });\n\n    return () => {\n      unsubscribe();\n      console.log('Redux debug wrapper unmounted');\n    };\n  }, [store]);\n\n  return <>{children}</>;\n};\nReduxDebugWrapper.propTypes = {\n  children: PropTypes.node.isRequired,\n};\n\nconst AnalysisWrapper = ({ children }) => {\n  return <>{children}</>; // Simply render children without additional wrappers or transitions\n};\n\nAnalysisWrapper.propTypes = {\n  children: PropTypes.node.isRequired,\n};\n\nexport const setupReduxDebugger = (store) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // Expose store to window for debugging\n    window.__REDUX_STORE__ = store;\n    \n    // Setup enhanced logging\n    window.debugSpatial = {\n      enableDebug: () => {\n        localStorage.setItem('DEBUG_SPATIAL', 'true');\n        console.log('🔍 Spatial debugging enabled');\n      },\n      \n      monitorRedux: () => {\n        console.group('🔄 Redux Spatial Actions');\n        const unsubscribe = store.subscribe(() => {\n          const state = store.getState();\n          console.log({\n            action: state.lastAction,\n            spatial: state.spatial,\n            timestamp: new Date().toISOString()\n          });\n        });\n        window.__REDUX_UNSUBSCRIBE__ = unsubscribe;\n        console.log('Redux monitoring started. Call debugSpatial.stopMonitoring() to end.');\n      },\n      \n      stopMonitoring: () => {\n        if (window.__REDUX_UNSUBSCRIBE__) {\n          window.__REDUX_UNSUBSCRIBE__();\n          console.log('Redux monitoring stopped');\n        }\n        console.groupEnd();\n      },\n      \n      monitorNetwork: () => {\n        const originalFetch = window.fetch;\n        window.fetch = async (...args) => {\n          const [url] = args;\n          console.log(`🌐 Fetch Request: ${url}`);\n          const startTime = performance.now();\n          try {\n            const response = await originalFetch(...args);\n            console.log(`✅ Fetch Complete: ${url} (${(performance.now() - startTime).toFixed(2)}ms)`);\n            return response;\n          } catch (error) {\n            console.error(`❌ Fetch Error: ${url}`, error);\n            throw error;\n          }\n        };\n        console.log('Network monitoring enabled');\n      },\n      \n      getCurrentState: () => {\n        const state = store.getState();\n        console.group('Current Redux State');\n        console.log('Full State:', state);\n        console.log('Spatial State:', state.spatial);\n        console.groupEnd();\n        return state;\n      },\n      \n      getSpatialData: () => {\n        const { spatial } = store.getState();\n        return {\n          features: spatial.geoData?.features?.length || 0,\n          flowMaps: spatial.flowMaps?.length || 0,\n          uniqueMonths: spatial.uniqueMonths?.length || 0,\n          status: spatial.status,\n          error: spatial.error\n        };\n      }\n    };\n    \n    console.log(`\n    🔧 Debug tools available:\n    - debugSpatial.enableDebug()     // Enable verbose logging\n    - debugSpatial.monitorRedux()    // Start Redux monitoring\n    - debugSpatial.stopMonitoring()  // Stop Redux monitoring\n    - debugSpatial.monitorNetwork()  // Monitor network requests\n    - debugSpatial.getCurrentState() // Get current Redux state\n    - debugSpatial.getSpatialData()  // Get spatial data summary\n    `);\n  }\n};\n\nexport const debugUtils = {\n  isEnabled: () => process.env.NODE_ENV === 'development',\n  \n  log: (message, data = {}) => {\n    if (debugUtils.isEnabled()) {\n      console.group(`[Spatial Debug] ${message}`);\n      console.log(data);\n      console.groupEnd();\n    }\n  },\n\n  logTransformation: (data, type) => {\n    if (debugUtils.isEnabled()) {\n      console.group(`Precomputed Data Transformation: ${type}`);\n      console.log('Input:', data);\n      console.timeEnd('transformation');\n      console.groupEnd();\n    }\n  },\n\n  logError: (error, context = {}) => {\n    if (debugUtils.isEnabled()) {\n      console.group('[Spatial Error]');\n      console.error(error);\n      console.log('Context:', context);\n      console.groupEnd();\n    }\n  }\n};\n\nexport const debugPrecomputedData = {\n  logTransformation: (data, type) => {\n    if (process.env.NODE_ENV === 'development') {\n      console.group(`Precomputed Data Transformation: ${type}`);\n      console.log('Input:', data);\n      console.timeEnd('transformation');\n      console.groupEnd();\n    }\n  }\n};\n\nclass RegressionDebugUtils {\n  constructor() {\n    this.debugMode = process.env.NODE_ENV === 'development';\n    this.logStack = [];\n    this.MAX_LOG_SIZE = 100;\n  }\n\n  // Initialize debugging tools\n  initDebugTools() {\n    if (!this.debugMode) return;\n\n    // Expose debug utilities to window for console access\n    window.__REGRESSION_DEBUG__ = {\n      inspectData: this.inspectRegressionData.bind(this),\n      validateData: this.validateRegressionData.bind(this),\n      getLogs: () => this.logStack,\n      clearLogs: () => this.clearLogs(),\n      testDataLoad: this.testDataLoad.bind(this),\n      monitorRegression: this.monitorRegression.bind(this)\n    };\n\n    console.log(`\n      🔍 Regression Debug Tools Available:\n      - window.__REGRESSION_DEBUG__.inspectData(data)\n      - window.__REGRESSION_DEBUG__.validateData(data)\n      - window.__REGRESSION_DEBUG__.getLogs()\n      - window.__REGRESSION_DEBUG__.clearLogs()\n      - window.__REGRESSION_DEBUG__.testDataLoad(commodity)\n      - window.__REGRESSION_DEBUG__.monitorRegression()\n    `);\n  }\n\n  // Log with timestamp and category\n  log(category, message, data = null) {\n    if (!this.debugMode) return;\n\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      category,\n      message,\n      data\n    };\n\n    console.log(`[${category}] ${message}`, data || '');\n    \n    this.logStack.push(logEntry);\n    if (this.logStack.length > this.MAX_LOG_SIZE) {\n      this.logStack.shift();\n    }\n\n    // Log to background monitor for persistence\n    backgroundMonitor.logMetric('regression-debug', logEntry);\n  }\n\n  clearLogs() {\n    this.logStack = [];\n    this.log('System', 'Logs cleared');\n  }\n\n  // Detailed regression data inspection\n  inspectRegressionData(data) {\n    if (!data) {\n      this.log('Inspection', 'No data provided');\n      return null;\n    }\n\n    const inspection = {\n      hasRequiredSections: {\n        model: Boolean(data.model),\n        spatial: Boolean(data.spatial),\n        residuals: Boolean(data.residuals)\n      },\n      modelMetrics: data.model ? {\n        hasCoefficients: Boolean(data.model.coefficients),\n        coefficientCount: Object.keys(data.model.coefficients || {}).length,\n        hasValidRSquared: typeof data.model.r_squared === 'number',\n        hasValidObservations: typeof data.model.observations === 'number'\n      } : null,\n      spatialMetrics: data.spatial ? {\n        hasMoranI: Boolean(data.spatial.moran_i),\n        hasValidVIF: Array.isArray(data.spatial.vif),\n        vifCount: (data.spatial.vif || []).length\n      } : null,\n      residualMetrics: data.residuals ? {\n        rawCount: (data.residuals.raw || []).length,\n        regionCount: Object.keys(data.residuals.byRegion || {}).length,\n        hasValidStats: Boolean(data.residuals.stats)\n      } : null,\n      comparisonWithDefault: this.compareWithDefault(data)\n    };\n\n    this.log('Inspection', 'Data inspection complete', inspection);\n    return inspection;\n  }\n\n  // Compare with default data structure\n  compareWithDefault(data) {\n    const missingKeys = [];\n    const unexpectedKeys = [];\n    const traverseObject = (actual, expected, path = '') => {\n      // Check for missing keys\n      Object.keys(expected).forEach(key => {\n        if (!(key in actual)) {\n          missingKeys.push(path ? `${path}.${key}` : key);\n        }\n      });\n\n      // Check for unexpected keys\n      Object.keys(actual).forEach(key => {\n        if (!(key in expected)) {\n          unexpectedKeys.push(path ? `${path}.${key}` : key);\n        }\n      });\n\n      // Recurse into nested objects\n      Object.keys(expected).forEach(key => {\n        if (typeof expected[key] === 'object' && expected[key] !== null &&\n            typeof actual[key] === 'object' && actual[key] !== null) {\n          traverseObject(actual[key], expected[key], path ? `${path}.${key}` : key);\n        }\n      });\n    };\n\n    traverseObject(data, DEFAULT_REGRESSION_DATA);\n\n    return {\n      missingKeys,\n      unexpectedKeys,\n      structureMatch: missingKeys.length === 0 && unexpectedKeys.length === 0\n    };\n  }\n\n  // Validate regression data structure\n  validateRegressionData(data) {\n    const validationResult = {\n      isValid: isValidRegressionData(data),\n      validationSteps: []\n    };\n\n    // Basic structure check\n    validationResult.validationSteps.push({\n      step: 'Basic Structure',\n      passed: Boolean(data && data.model && data.spatial && data.residuals),\n      details: 'Checking presence of main sections'\n    });\n\n    // Model validation\n    if (data?.model) {\n      validationResult.validationSteps.push({\n        step: 'Model Validation',\n        passed: (\n          typeof data.model.r_squared === 'number' &&\n          typeof data.model.adj_r_squared === 'number' &&\n          typeof data.model.mse === 'number' &&\n          typeof data.model.observations === 'number'\n        ),\n        details: 'Checking model metrics types and presence'\n      });\n    }\n\n    // Spatial validation\n    if (data?.spatial) {\n      validationResult.validationSteps.push({\n        step: 'Spatial Validation',\n        passed: (\n          data.spatial.moran_i &&\n          typeof data.spatial.moran_i.I === 'number' &&\n          Array.isArray(data.spatial.vif)\n        ),\n        details: 'Checking spatial statistics structure'\n      });\n    }\n\n    // Residuals validation\n    if (data?.residuals) {\n      validationResult.validationSteps.push({\n        step: 'Residuals Validation',\n        passed: (\n          Array.isArray(data.residuals.raw) &&\n          typeof data.residuals.byRegion === 'object' &&\n          typeof data.residuals.stats === 'object'\n        ),\n        details: 'Checking residuals data structure'\n      });\n    }\n\n    this.log('Validation', \n      validationResult.isValid ? 'Validation passed' : 'Validation failed',\n      validationResult\n    );\n\n    return validationResult;\n  }\n\n  // Test data loading process\n  async testDataLoad(commodity) {\n    this.log('Test', `Starting test data load for commodity: ${commodity}`);\n    const metric = backgroundMonitor.startMetric('regression-test-load');\n\n    try {\n      // Test path resolution\n      const path = getRegressionDataPath();\n      this.log('Test', 'Path resolved', { path });\n\n      // Test data fetching\n      const response = await fetch(path);\n      this.log('Test', 'Fetch response received', { \n        status: response.status,\n        ok: response.ok,\n        headers: Object.fromEntries(response.headers)\n      });\n\n      // Test data parsing\n      const text = await response.text();\n      this.log('Test', 'Response text received', { \n        length: text.length,\n        preview: text.substring(0, 100) + '...'\n      });\n\n      const data = JSON.parse(text);\n      this.log('Test', 'JSON parsing successful', { \n        entries: data.length,\n        keys: Object.keys(data[0] || {})\n      });\n\n      // Test commodity filtering\n      const normalizedCommodity = normalizeCommodityName(commodity);\n      const commodityData = data.find(\n        item => normalizeCommodityName(item.commodity) === normalizedCommodity\n      );\n      this.log('Test', 'Commodity filtering result', { \n        found: Boolean(commodityData),\n        normalizedName: normalizedCommodity\n      });\n\n      // Test data processing\n      const processed = processRegressionData(commodityData);\n      this.log('Test', 'Data processing complete', this.inspectRegressionData(processed));\n\n      metric.finish({ status: 'success' });\n      return processed;\n\n    } catch (error) {\n      this.log('Test', 'Test failed', { error: error.message, stack: error.stack });\n      metric.finish({ status: 'error', error: error.message });\n      throw error;\n    }\n  }\n\n  // Monitor regression data updates\n  monitorRegression() {\n    let previousData = null;\n\n    return (data) => {\n      if (!data) {\n        this.log('Monitor', 'No data to monitor');\n        return;\n      }\n\n      const changes = this.detectChanges(previousData, data);\n      if (changes.hasChanges) {\n        this.log('Monitor', 'Regression data changed', changes);\n      }\n\n      previousData = JSON.parse(JSON.stringify(data)); // Deep clone\n    };\n  }\n\n  // Detect changes between old and new data\n  detectChanges(oldData, newData) {\n    if (!oldData) return { hasChanges: true, changes: 'Initial data' };\n\n    const changes = {\n      hasChanges: false,\n      modelChanges: {},\n      spatialChanges: {},\n      residualChanges: {}\n    };\n\n    // Check model changes\n    if (oldData.model?.r_squared !== newData.model?.r_squared) {\n      changes.hasChanges = true;\n      changes.modelChanges.r_squared = {\n        old: oldData.model?.r_squared,\n        new: newData.model?.r_squared\n      };\n    }\n\n    // Check spatial changes\n    if (oldData.spatial?.moran_i?.I !== newData.spatial?.moran_i?.I) {\n      changes.hasChanges = true;\n      changes.spatialChanges.moran_i = {\n        old: oldData.spatial?.moran_i?.I,\n        new: newData.spatial?.moran_i?.I\n      };\n    }\n\n    // Check residuals\n    if (oldData.residuals?.raw?.length !== newData.residuals?.raw?.length) {\n      changes.hasChanges = true;\n      changes.residualChanges.count = {\n        old: oldData.residuals?.raw?.length,\n        new: newData.residuals?.raw?.length\n      };\n    }\n\n    return changes;\n  }\n}\n\nexport const regressionDebug = new RegressionDebugUtils();\n\nexport default {\n  debugUtils,\n  debugPrecomputedData,\n  setupReduxDebugger\n};\n\n// Initialize if in development\nif (process.env.NODE_ENV === 'development') {\n  regressionDebug.initDebugTools();\n}",
        "imports": [
          "react",
          "react-redux",
          "prop-types",
          "./backgroundMonitor",
          "../types/dataTypes"
        ],
        "exports": [
          "setupReduxDebugger",
          "debugUtils",
          "debugPrecomputedData",
          "regressionDebug",
          "default"
        ],
        "dependencies": [
          "react",
          "react-redux",
          "prop-types",
          "./backgroundMonitor",
          "../types/dataTypes"
        ]
      },
      {
        "path": "utils/dynamicImports.js",
        "content": "// src/utils/dynamicImports.js\n\nimport { lazy } from 'react';\n\nconst withChunkName = (promise, name) => {\n  promise.then(module => {\n    window.__loadedChunks = window.__loadedChunks || new Set();\n    window.__loadedChunks.add(name);\n  });\n  return promise;\n};\n\nexport const lazyLoadComponent = (importFn, name) => {\n  return lazy(() => {\n    if (process.env.NODE_ENV === 'development') {\n      return new Promise(resolve => {\n        // Prevent rapid re-renders in development\n        setTimeout(() => {\n          resolve(withChunkName(importFn(), name));\n        }, 100);\n      });\n    }\n    return withChunkName(importFn(), name);\n  });\n};\n\n// Pre-define chunks for better code splitting\nexport const SpatialAnalysis = lazyLoadComponent(\n  () => import(\n    /* webpackChunkName: \"spatial-analysis\" */\n    '../components/analysis/spatial-analysis/SpatialAnalysis'\n  ),\n  'spatial-analysis'\n);\n\nexport const ECMAnalysis = lazyLoadComponent(\n  () => import(\n    /* webpackChunkName: \"ecm-analysis\" */\n    '../components/analysis/ecm/ECMAnalysis'\n  ),\n  'ecm-analysis'\n);\n\nexport const PriceDifferentialAnalysis = lazyLoadComponent(\n  () => import(\n    /* webpackChunkName: \"price-differential-analysis\" */\n    '../components/analysis/price-differential/PriceDifferentialAnalysis'\n  ),\n  'price-differential-analysis'\n);\n\nexport const TVMIIAnalysis = lazyLoadComponent(\n  () => import(\n    /* webpackChunkName: \"tvmii-analysis\" */\n    '../components/analysis/tvmii/TVMIIAnalysis'\n  ),\n  'tvmii-analysis'\n);",
        "imports": [
          "react"
        ],
        "exports": [
          "lazyLoadComponent",
          "SpatialAnalysis",
          "ECMAnalysis",
          "PriceDifferentialAnalysis",
          "TVMIIAnalysis"
        ],
        "dependencies": [
          "react"
        ]
      },
      {
        "path": "utils/geoJSONProcessor.js",
        "content": "/**\n * Robust GeoJSON Preprocessor\n * Ensures consistent region identification and property mapping\n */\nimport { backgroundMonitor } from './backgroundMonitor';\n\n// Yemen's approximate bounding box\nconst YEMEN_BOUNDS = {\n  minLat: 12.0,\n  maxLat: 19.0,\n  minLon: 41.0,\n  maxLon: 54.0\n};\n\n/**\n * Validate and normalize coordinates for Yemen's geographic region\n */\nconst validateAndNormalizeCoordinates = (coordinates, type) => {\n  if (!Array.isArray(coordinates)) return null;\n\n  const isInYemenBounds = (coord) => {\n    const [lon, lat] = coord;\n    return (\n      typeof lat === 'number' &&\n      typeof lon === 'number' &&\n      lat >= YEMEN_BOUNDS.minLat &&\n      lat <= YEMEN_BOUNDS.maxLat &&\n      lon >= YEMEN_BOUNDS.minLon &&\n      lon <= YEMEN_BOUNDS.maxLon\n    );\n  };\n\n  switch (type) {\n    case 'Point':\n      if (coordinates.length === 2) {\n        const [x, y] = coordinates;\n        if (!isInYemenBounds([x, y]) && isInYemenBounds([y, x])) {\n          return [y, x]; // Swap coordinates if valid\n        }\n        if (isInYemenBounds([x, y])) {\n          return [x, y];\n        }\n      }\n      return null;\n\n    case 'Polygon':\n      if (!Array.isArray(coordinates[0])) return null;\n\n      const normalizedPolygon = coordinates.map(ring => {\n        if (!Array.isArray(ring)) return null;\n        const normalizedRing = ring.map(coord => {\n          if (!Array.isArray(coord) || coord.length !== 2) return null;\n          const [x, y] = coord;\n          if (isInYemenBounds([x, y])) return [x, y];\n          if (isInYemenBounds([y, x])) return [y, x];\n          return null;\n        });\n        return normalizedRing.every(c => c !== null) ? normalizedRing : null;\n      });\n\n      if (normalizedPolygon.every(r => r !== null)) {\n        return normalizedPolygon;\n      }\n      return null;\n\n    default:\n      return null;\n  }\n};\n\n/**\n * Convert unified geometry format to GeoJSON\n */\nconst convertUnifiedToGeoJSON = (geometry) => {\n  if (!geometry) return null;\n\n  try {\n    const features = [];\n\n    // Process polygons\n    if (Array.isArray(geometry.polygons)) {\n      geometry.polygons.forEach(polygon => {\n        if (polygon.geometry?.coordinates) {\n          const normalizedCoords = validateAndNormalizeCoordinates(\n            polygon.geometry.coordinates,\n            'Polygon'\n          );\n          if (normalizedCoords) {\n            features.push({\n              type: 'Feature',\n              geometry: {\n                type: 'Polygon',\n                coordinates: normalizedCoords\n              },\n              properties: {\n                ...polygon.properties,\n                region_id: polygon.properties?.normalizedName,\n                feature_type: 'polygon'\n              }\n            });\n          }\n        }\n      });\n    }\n\n    // Process points\n    if (Array.isArray(geometry.points)) {\n      geometry.points.forEach(point => {\n        const normalizedCoords = validateAndNormalizeCoordinates(\n          point.coordinates,\n          'Point'\n        );\n        if (normalizedCoords) {\n          features.push({\n            type: 'Feature',\n            geometry: {\n              type: 'Point',\n              coordinates: normalizedCoords\n            },\n            properties: {\n              ...point.properties,\n              region_id: point.properties?.normalizedName,\n              feature_type: 'point'\n            }\n          });\n        }\n      });\n    }\n\n    if (features.length === 0) {\n      throw new Error('No valid features after coordinate normalization');\n    }\n\n    return {\n      type: 'FeatureCollection',\n      features,\n      crs: {\n        type: 'name',\n        properties: {\n          name: 'urn:ogc:def:crs:OGC:1.3:CRS84'\n        }\n      }\n    };\n  } catch (error) {\n    backgroundMonitor.logError('unified-geojson-conversion', {\n      message: error.message,\n      stack: error.stack,\n      geometry\n    });\n    return null;\n  }\n};\n\n/**\n * Preprocess GeoJSON data\n */\nexport const preprocessGeoJSON = (geoJSON, visualizationMode = null) => {\n  const processingMetric = backgroundMonitor.startMetric('geojson-preprocessing', {\n    mode: visualizationMode,\n    hasFeatures: !!geoJSON?.features || !!(geoJSON?.points || geoJSON?.polygons)\n  });\n\n  try {\n    // Handle unified geometry format\n    if (!geoJSON?.features && (geoJSON?.points || geoJSON?.polygons)) {\n      geoJSON = convertUnifiedToGeoJSON(geoJSON);\n      if (!geoJSON) {\n        throw new Error('Failed to convert unified format');\n      }\n    }\n\n    if (!geoJSON?.features?.length) {\n      throw new Error('Invalid GeoJSON structure');\n    }\n\n    backgroundMonitor.logMetric('geojson-features', {\n      featureCount: geoJSON.features.length,\n      type: geoJSON.type,\n      mode: visualizationMode\n    });\n\n    const validFeatures = geoJSON.features.filter(feature => {\n      if (!feature?.geometry?.type) return false;\n      const normalizedCoords = validateAndNormalizeCoordinates(\n        feature.geometry.coordinates,\n        feature.geometry.type\n      );\n      if (normalizedCoords) {\n        feature.geometry.coordinates = normalizedCoords;\n        return true;\n      }\n      return false;\n    });\n\n    if (validFeatures.length === 0) {\n      throw new Error('No valid features after filtering');\n    }\n\n    const processed = {\n      ...geoJSON,\n      features: validFeatures.map(feature => {\n        // Ensure properties object exists\n        feature.properties = feature.properties || {};\n\n        // Normalize region identification\n        const regionId =\n          feature.properties.region_id ||\n          feature.properties.normalizedName ||\n          feature.properties.name ||\n          feature.id;\n\n        // Extract visualization value\n        const value = visualizationMode === 'shocks'\n          ? feature.properties.shock_magnitude || feature.properties.magnitude || 0\n          : feature.properties[`${visualizationMode}_value`] || null;\n\n        return {\n          ...feature,\n          properties: {\n            ...feature.properties,\n            region_id: regionId,\n            normalizedName: regionId,\n            originalName: feature.properties.originalName || feature.properties.name,\n            value\n          }\n        };\n      })\n    };\n\n    processingMetric.finish({\n      status: 'success',\n      inputFeatures: geoJSON.features.length,\n      outputFeatures: processed.features.length\n    });\n\n    return processed;\n\n  } catch (error) {\n    backgroundMonitor.logError('geojson-preprocessing', {\n      message: error.message,\n      stack: error.stack\n    });\n    processingMetric.finish({ status: 'failed', error: error.message });\n    return null;\n  }\n};\n\n/**\n * Validate GeoJSON structure\n */\nexport const validateGeoJSON = (geoJSON) => {\n  const validationMetric = backgroundMonitor.startMetric('geojson-validation');\n\n  try {\n    // Ensure features exist\n    if (!geoJSON?.features?.length) {\n      throw new Error('Missing GeoJSON or features array');\n    }\n\n    const isValid = geoJSON.features.every(feature => {\n      if (!feature?.geometry?.type || !feature.geometry.coordinates) {\n        return false;\n      }\n\n      const normalizedCoords = validateAndNormalizeCoordinates(\n        feature.geometry.coordinates,\n        feature.geometry.type\n      );\n\n      return normalizedCoords !== null;\n    });\n\n    validationMetric.finish({\n      status: isValid ? 'success' : 'failed',\n      featureCount: geoJSON.features.length\n    });\n\n    return isValid;\n  } catch (error) {\n    backgroundMonitor.logError('geojson-validation', {\n      message: error.message,\n      geoJSON\n    });\n    validationMetric.finish({ status: 'failed', reason: error.message });\n    return false;\n  }\n};\n\n/**\n * Error-safe GeoJSON processing\n */\nexport const safeGeoJSONProcessor = (geoJSON, visualizationMode) => {\n  const processingMetric = backgroundMonitor.startMetric('safe-geojson-processing', {\n    mode: visualizationMode,\n    hasInput: !!geoJSON\n  });\n\n  try {\n    // Handle unified format\n    if (!geoJSON?.features && (geoJSON?.points || geoJSON?.polygons)) {\n      const unified = convertUnifiedToGeoJSON(geoJSON);\n      if (!unified) {\n        throw new Error('Failed to convert unified format');\n      }\n      geoJSON = unified;\n    }\n\n    // Process GeoJSON\n    const processedGeoJSON = preprocessGeoJSON(geoJSON, visualizationMode);\n    if (!processedGeoJSON) {\n      throw new Error('Failed to process GeoJSON');\n    }\n\n    // Validate result\n    if (!validateGeoJSON(processedGeoJSON)) {\n      backgroundMonitor.logError('geojson-validation-failed', {\n        processedGeoJSON\n      });\n      processingMetric.finish({ status: 'failed', error: 'Validation failed' });\n      return null;\n    }\n\n    processingMetric.finish({\n      status: 'success',\n      inputFeatures: geoJSON?.features?.length || 0,\n      outputFeatures: processedGeoJSON.features.length\n    });\n\n    return processedGeoJSON;\n\n  } catch (error) {\n    backgroundMonitor.logError('safe-geojson-processing', {\n      message: error.message,\n      stack: error.stack,\n      input: geoJSON\n    });\n    processingMetric.finish({ status: 'failed', error: error.message });\n    return null;\n  }\n};\n",
        "imports": [
          "./backgroundMonitor"
        ],
        "exports": [
          "preprocessGeoJSON",
          "validateGeoJSON",
          "safeGeoJSONProcessor"
        ],
        "dependencies": [
          "./backgroundMonitor"
        ]
      },
      {
        "path": "utils/geometryValidation.js",
        "content": "// src/utils/geometryValidation.js\nexport const validateGeometryData = (geometry) => {\n    if (!geometry) return false;\n    \n    const validation = {\n      hasPoints: Array.isArray(geometry.points),\n      hasPolygons: Array.isArray(geometry.polygons),\n      hasUnified: Boolean(geometry.unified),\n      isValid: false\n    };\n  \n    // Check points structure\n    if (validation.hasPoints) {\n      validation.pointsValid = geometry.points.every(point => \n        Array.isArray(point.coordinates) && \n        point.coordinates.length === 2 &&\n        point.properties?.normalizedName\n      );\n    }\n  \n    // Check polygons structure\n    if (validation.hasPolygons) {\n      validation.polygonsValid = geometry.polygons.every(polygon => \n        polygon.geometry?.coordinates &&\n        polygon.properties?.normalizedName &&\n        polygon.properties?.shapeISO\n      );\n    }\n  \n    validation.isValid = validation.hasPoints && \n                        validation.hasPolygons && \n                        validation.pointsValid && \n                        validation.polygonsValid;\n  \n    return validation;\n  };",
        "imports": [],
        "exports": [
          "validateGeometryData"
        ],
        "dependencies": []
      },
      {
        "path": "utils/index.js",
        "content": "// src/utils/index.js\n\n// Core data handling\nexport { spatialDataHandler } from './spatialDataHandler';\nexport { dataProcessor } from './dataProcessor';\n\n// Map setup\nexport * from './leafletSetup';\n\n// Development utilities\nexport { debugUtils } from './debugUtils';\nexport { default as ReduxDebugWrapper } from './ReduxDebugWrapper';\n\n// Performance monitoring\nexport { backgroundMonitor } from './backgroundMonitor';\n\n// Dynamic imports\nexport * from './dynamicImports';\n\n// Basic utilities\nexport const appUtils = {\n  // Essential utility functions from appUtils.js\n  normalizeRegionName: (name) => {\n    if (!name) return '';\n    return name.toLowerCase()\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .replace(/[^a-z0-9]+/g, '_')\n      .trim();\n  },\n\n  getDataPath: (fileName) => {\n    const isGitHubPages = window.location.hostname.includes('github.io');\n    const basePath = isGitHubPages ? '/Yemen_Market_Analysis/results' : '/results';\n    return `${basePath}/${fileName}`;\n  },\n\n  formatDate: (date) => {\n    if (!date) return '';\n    const d = new Date(date);\n    return d.toISOString().split('T')[0];\n  },\n\n  // Add any other essential utility functions here\n};",
        "imports": [],
        "exports": [
          "appUtils"
        ],
        "dependencies": []
      },
      {
        "path": "utils/leafletSetup.js",
        "content": "// src/utils/leafletSetup.js\n\nimport L from 'leaflet';\nimport markerIcon2x from 'leaflet/dist/images/marker-icon-2x.png';\nimport markerIcon from 'leaflet/dist/images/marker-icon.png';\nimport markerShadow from 'leaflet/dist/images/marker-shadow.png';\n\n// Clear existing icon settings\ndelete L.Icon.Default.prototype._getIconUrl;\n\n// Set up default icon configurations\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: markerIcon2x,\n  iconUrl: markerIcon,\n  shadowUrl: markerShadow,\n  iconSize: [25, 41],\n  iconAnchor: [12, 41],\n  popupAnchor: [1, -34],\n  tooltipAnchor: [16, -28],\n  shadowSize: [41, 41],\n  shadowAnchor: [12, 41],\n});",
        "imports": [
          "leaflet",
          "leaflet/dist/images/marker-icon-2x.png",
          "leaflet/dist/images/marker-icon.png",
          "leaflet/dist/images/marker-shadow.png"
        ],
        "exports": [],
        "dependencies": [
          "leaflet",
          "leaflet/dist/images/marker-icon-2x.png",
          "leaflet/dist/images/marker-icon.png",
          "leaflet/dist/images/marker-shadow.png"
        ]
      },
      {
        "path": "utils/marketAnalysisUtils.js",
        "content": "// src/utils/marketAnalysisUtils.js\n\nimport { ANALYSIS_THRESHOLDS } from '../constants/index';\nimport _ from 'lodash';\n\n/**\n * Calculate the center of mass for a GeoJSON geometry\n * @param {Object} geometry - GeoJSON geometry object\n * @returns {Object} Center coordinates {lat, lng}\n */\nexport const calculateCenterOfMass = (geometry) => {\n  if (!geometry?.coordinates) return null;\n\n  let points = [];\n  if (geometry.type === 'Polygon') {\n    points = geometry.coordinates[0];\n  } else if (geometry.type === 'MultiPolygon') {\n    points = geometry.coordinates.flatMap(poly => poly[0]);\n  } else {\n    return null;\n  }\n\n  const total = points.reduce((acc, [lng, lat]) => ({\n    lat: acc.lat + lat,\n    lng: acc.lng + lng\n  }), { lat: 0, lng: 0 });\n\n  return {\n    lat: total.lat / points.length,\n    lng: total.lng / points.length\n  };\n};\n\n/**\n * Calculate bounding box for a GeoJSON geometry\n * @param {Object} geometry - GeoJSON geometry object\n * @returns {Object} Bounding box coordinates\n */\nexport const calculateBoundingBox = (geometry) => {\n  if (!geometry?.coordinates) return null;\n\n  let points = [];\n  if (geometry.type === 'Polygon') {\n    points = geometry.coordinates[0];\n  } else if (geometry.type === 'MultiPolygon') {\n    points = geometry.coordinates.flatMap(poly => poly[0]);\n  } else {\n    return null;\n  }\n\n  const bounds = points.reduce((acc, [lng, lat]) => ({\n    minLat: Math.min(acc.minLat, lat),\n    maxLat: Math.max(acc.maxLat, lat),\n    minLng: Math.min(acc.minLng, lng),\n    maxLng: Math.max(acc.maxLng, lng)\n  }), {\n    minLat: Infinity,\n    maxLat: -Infinity,\n    minLng: Infinity,\n    maxLng: -Infinity\n  });\n\n  return {\n    southWest: { lat: bounds.minLat, lng: bounds.minLng },\n    northEast: { lat: bounds.maxLat, lng: bounds.maxLng }\n  };\n};\n\n/**\n * Find neighboring regions based on shared boundaries\n * @param {Object} geometry - GeoJSON geometry object\n * @param {string} regionId - Current region ID\n * @param {Object} allGeometries - All region geometries\n * @returns {Array} Array of neighboring region IDs\n */\nexport const findNeighboringRegions = (geometry, regionId, allGeometries) => {\n  if (!geometry || !allGeometries) return [];\n\n  const currentBounds = calculateBoundingBox(geometry);\n  if (!currentBounds) return [];\n\n  const neighbors = [];\n  const buffer = 0.001; // ~100m buffer for boundary intersection\n\n  Object.entries(allGeometries).forEach(([id, geo]) => {\n    if (id === regionId) return;\n\n    const otherBounds = calculateBoundingBox(geo);\n    if (!otherBounds) return;\n\n    // Check if bounding boxes overlap with buffer\n    const overlaps = !(\n      otherBounds.northEast.lat + buffer < currentBounds.southWest.lat ||\n      otherBounds.southWest.lat - buffer > currentBounds.northEast.lat ||\n      otherBounds.northEast.lng + buffer < currentBounds.southWest.lng ||\n      otherBounds.southWest.lng - buffer > currentBounds.northEast.lng\n    );\n\n    if (overlaps) {\n      neighbors.push(id);\n    }\n  });\n\n  return neighbors;\n};\n\n/**\n * Calculate distance between two points\n * @param {Object} point1 - {lat, lng}\n * @param {Object} point2 - {lat, lng}\n * @returns {number} Distance in kilometers\n */\nexport const calculateDistance = (point1, point2) => {\n  if (!point1 || !point2) return 0;\n\n  const R = 6371; // Earth's radius in km\n  const dLat = toRad(point2.lat - point1.lat);\n  const dLon = toRad(point2.lng - point1.lng);\n  const lat1 = toRad(point1.lat);\n  const lat2 = toRad(point2.lat);\n\n  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n};\n\n// Convert degrees to radians\nconst toRad = (degrees) => degrees * Math.PI / 180;\n\n/**\n * Calculate market volatility metrics\n * @param {Array} timeSeriesData - Array of time series data points\n * @returns {Object} Volatility metrics\n */\nexport function calculateVolatility(timeSeriesData) {\n  if (!timeSeriesData.length) return {\n    garch: 0,\n    traditional: 0,\n    stability: 0\n  };\n\n  const latestEntry = timeSeriesData[timeSeriesData.length - 1];\n  \n  // Use precomputed metrics when available\n  const garchVolatility = latestEntry.garch_volatility ?? 0;\n  const priceStability = latestEntry.price_stability ?? 0;\n\n  // Calculate traditional volatility as backup\n  const prices = timeSeriesData.reduce((acc, d) => {\n    if (d.avgUsdPrice != null) acc.push(d.avgUsdPrice);\n    return acc;\n  }, []);\n  const mean = prices.reduce((a, b) => a + b, 0) / prices.length;\n  const traditional = Math.sqrt(\n    prices.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / prices.length\n  ) / mean;\n\n  return {\n    garch: garchVolatility,\n    traditional: traditional,\n    stability: priceStability\n  };\n}\n\n/**\n * Calculate market integration metrics\n * @param {Object} data - Spatial data object\n * @returns {Object} Integration metrics\n */\nexport function calculateMarketIntegration(data) {\n  if (!data.market_integration) return null;\n\n  const {\n    price_correlation,\n    flow_density,\n    integration_score,\n    accessibility\n  } = data.market_integration;\n\n  const spatialMetrics = data.spatial_autocorrelation?.global ?? {};\n\n  return {\n    correlationMatrix: price_correlation ?? {},\n    flowDensity: flow_density ?? 0,\n    integrationScore: integration_score ?? 0,\n    spatialDependence: spatialMetrics.moran_i ?? 0,\n    accessibility: accessibility ?? {},\n    significance: spatialMetrics.significance ?? false\n  };\n}\n\n/**\n * Calculate shock frequency\n * @param {Array} shocks - Array of shock events\n * @param {Object} timeRange - Time range object { start, end }\n * @returns {Object} Shock frequency metrics\n */\nexport function calculateShockFrequency(shocks, timeRange) {\n  if (!Array.isArray(shocks) || shocks.length === 0) return {\n    frequency: 0,\n    patterns: [],\n    average_magnitude: 0\n  };\n\n  const uniqueMonths = new Set(shocks.map(s => s.date.substring(0, 7)));\n  const frequency = shocks.length / uniqueMonths.size;\n\n  const patterns = {\n    price_surge: shocks.filter(s => s.shock_type === 'price_surge').length,\n    price_drop: shocks.filter(s => s.shock_type === 'price_drop').length,\n    average_magnitude: shocks.reduce((acc, s) => acc + s.magnitude, 0) / shocks.length\n  };\n\n  return {\n    frequency,\n    patterns,\n    average_magnitude: patterns.average_magnitude\n  };\n}\n\n/**\n * Calculate cluster efficiency metrics\n * @param {Array} clusters - Array of market clusters\n * @returns {Object} Cluster efficiency metrics\n */\nexport function calculateClusterEfficiency(clusters) {\n  if (!Array.isArray(clusters) || !clusters.length) return {\n    efficiency: 0,\n    coverage: 0,\n    stability: 0\n  };\n\n  const metrics = clusters.reduce((acc, cluster) => ({\n    efficiency: acc.efficiency + (cluster.efficiency_score ?? 0),\n    coverage: acc.coverage + (cluster.market_coverage ?? 0),\n    stability: acc.stability + (cluster.stability ?? 0)\n  }), { efficiency: 0, coverage: 0, stability: 0 });\n\n  const count = clusters.length;\n  return {\n    efficiency: metrics.efficiency / count,\n    coverage: metrics.coverage / count,\n    stability: metrics.stability / count\n  };\n}\n\n/**\n * Summarize clusters\n * @param {Array} clusters - Array of clusters\n * @returns {Object} Cluster summary\n */\nexport function summarizeClusters(clusters) {\n  if (!clusters.length) return null;\n\n  return {\n    count: clusters.length,\n    averageSize: clusters.reduce((acc, c) => acc + c.market_count, 0) / clusters.length,\n    largest: Math.max(...clusters.map((c) => c.market_count)),\n    smallest: Math.min(...clusters.map((c) => c.market_count)),\n  };\n}\n\n/**\n * Calculate overall market metrics\n * @param {Object} data - Spatial data object\n * @returns {Object} Market metrics\n */\nexport function calculateMarketMetrics(data) {\n  return {\n    marketCoverage: calculateCoverage(data.marketClusters),\n    flowDensity: calculateFlowDensity(data.flowMaps),\n    priceCorrelation: calculatePriceCorrelation(data.timeSeriesData),\n    overallVolatility: calculateVolatility(data.timeSeriesData),\n    overallIntegration: calculateIntegration(data.spatialAutocorrelation),\n    overallShockFrequency: calculateShockFrequency(data.marketShocks, null),\n    overallClusterEfficiency: calculateClusterEfficiency(data.marketClusters),\n  };\n}\n\n/**\n * Validate coordinates\n * @param {Array} coordinates - [lat, lng]\n * @returns {boolean} Validation result\n */\nexport function validateCoordinates(coordinates) {\n  if (!coordinates || !Array.isArray(coordinates)) return false;\n  const [lat, lng] = coordinates;\n  return (\n    typeof lat === 'number' && \n    typeof lng === 'number' &&\n    lat >= -90 && lat <= 90 &&\n    lng >= -180 && lng <= 180\n  );\n}\n\n/**\n * Calculate flow coverage\n * @param {Array} flows - Array of flow data\n * @returns {number} Number of unique markets\n */\nexport function calculateFlowCoverage(flows) {\n  const uniqueMarkets = new Set();\n  flows.forEach(flow => {\n    uniqueMarkets.add(flow.source);\n    uniqueMarkets.add(flow.target);\n  });\n  return uniqueMarkets.size;\n}\n\n/**\n * Calculate network efficiency\n * @param {Array} flows - Array of flow data\n * @returns {Object} Network efficiency metrics\n */\nexport function calculateNetworkEfficiency(flows) {\n  const totalFlow = flows.reduce((sum, flow) => sum + flow.flow_weight, 0);\n  const avgFlow = totalFlow / flows.length;\n  return {\n    totalFlow,\n    avgFlow,\n    flowCount: flows.length\n  };\n}\n\n/**\n * Calculate moving average\n * @param {Array} data - Array of data points\n * @param {number} window - Window size for moving average\n * @returns {Array} Moving average data\n */\nexport function calculateMovingAverage(data, window) {\n  return data.map((_, index) => {\n    const start = Math.max(0, index - window + 1);\n    const values = data.slice(start, index + 1);\n    return {\n      date: data[index].date,\n      value: _.meanBy(values, 'value')\n    };\n  });\n}\n\n/**\n * Calculate trend slope using linear regression\n * @param {Array} data - Array of data points with {date, value}\n * @returns {number} Slope of the trend\n */\nexport function calculateTrendSlope(data) {\n  const n = data.length;\n  if (n < 2) return 0;\n\n  const xMean = _.meanBy(data, (_, i) => i);\n  const yMean = _.meanBy(data, 'value');\n\n  const numerator = _.sum(data.map((point, i) => \n    (i - xMean) * (point.value - yMean)\n  ));\n\n  const denominator = _.sum(data.map((_, i) => \n    Math.pow(i - xMean, 2)\n  ));\n\n  return denominator !== 0 ? numerator / denominator : 0;\n}\n\n/**\n * Detect seasonal patterns in time series data\n * @param {Array} data - Array of data points with {date, value}\n * @returns {Object} Seasonal pattern metrics\n */\nexport function detectSeasonalPattern(data) {\n  // Simple seasonal detection: compare averages by month\n  const monthlyData = _.groupBy(data, d => d.date.getMonth());\n\n  const monthlyAverages = _.mapValues(monthlyData, monthData => _.meanBy(monthData, 'value'));\n\n  // Calculate standard deviation of monthly averages\n  const mean = _.mean(Object.values(monthlyAverages));\n  const stdDev = Math.sqrt(_.mean(Object.values(monthlyAverages).map(avg => Math.pow(avg - mean, 2))));\n\n  // Determine if seasonality is present based on variance\n  const seasonal = stdDev > 0.05 * mean; // Threshold can be adjusted\n\n  return {\n    seasonal,\n    monthlyAverages,\n    stdDev\n  };\n}\n\n/**\n * Process correlation matrix for integration analysis\n * @param {Object} matrix - Price correlation matrix\n * @returns {Object} Processed correlation metrics\n */\nexport function processCorrelationMatrix(matrix) {\n  const markets = Object.keys(matrix);\n\n  // Calculate average correlation\n  const averageCorrelation = _.mean(\n    markets.flatMap(market => Object.values(matrix[market]))\n  );\n\n  // Count strong and weak connections\n  const strongConnections = countConnections(matrix, ANALYSIS_THRESHOLDS.MARKET_INTEGRATION.HIGH);\n  const weakConnections = countConnections(matrix, ANALYSIS_THRESHOLDS.MARKET_INTEGRATION.LOW);\n\n  // Identify market clusters using threshold\n  const clusters = identifyMarketClusters(matrix, ANALYSIS_THRESHOLDS.MARKET_INTEGRATION.MODERATE);\n\n  return {\n    averageCorrelation,\n    strongConnections,\n    weakConnections,\n    clusters\n  };\n}\n\n/**\n * Count connections above a certain threshold\n * @param {Object} matrix - Correlation matrix\n * @param {number} threshold - Correlation threshold\n * @returns {number} Number of connections above threshold\n */\nfunction countConnections(matrix, threshold) {\n  const markets = Object.keys(matrix);\n  let count = 0;\n\n  markets.forEach(market => {\n    Object.values(matrix[market]).forEach(correlation => {\n      if (correlation >= threshold) count++;\n    });\n  });\n\n  // Since the matrix is symmetric, divide by 2 to get unique connections\n  return count / 2;\n}\n\n/**\n * Identify market clusters based on correlation threshold\n * @param {Object} matrix - Correlation matrix\n * @param {number} threshold - Correlation threshold\n * @returns {Array} Array of clusters\n */\nexport function identifyMarketClusters(matrix, threshold) {\n  const markets = Object.keys(matrix);\n  const visited = new Set();\n  const clusters = [];\n\n  markets.forEach(market => {\n    if (!visited.has(market)) {\n      const cluster = [];\n      const stack = [market];\n\n      while (stack.length > 0) {\n        const current = stack.pop();\n        if (!visited.has(current)) {\n          visited.add(current);\n          cluster.push(current);\n\n          Object.entries(matrix[current]).forEach(([neighbor, correlation]) => {\n            if (correlation >= threshold && !visited.has(neighbor)) {\n              stack.push(neighbor);\n            }\n          });\n        }\n      }\n\n      if (cluster.length > 1) clusters.push(cluster);\n    }\n  });\n\n  return clusters;\n}\n\n/**\n * Calculate flow-based metrics\n * @param {Array} flows - Array of flow data\n * @returns {Object} Flow metrics\n */\nexport function calculateFlowMetrics(flows) {\n  const metrics = {\n    totalFlow: _.sumBy(flows, 'total_flow'),\n    averageFlow: _.meanBy(flows, 'avg_flow'),\n    flowDensity: calculateFlowDensity(flows),\n    directionality: analyzeFlowDirectionality(flows)\n  };\n\n  const patterns = {\n    seasonal: detectFlowSeasonality(flows),\n    structural: identifyStructuralPatterns(flows),\n    anomalies: detectFlowAnomalies(flows)\n  };\n\n  return {\n    metrics,\n    patterns\n  };\n}\n\n/**\n * Calculate flow density\n * @param {Array} flows - Array of flow data\n * @returns {number} Flow density metric\n */\nexport function calculateFlowDensity(flows) {\n  if (!flows.length) return 0;\n  const totalFlow = _.sumBy(flows, 'flow_weight');\n  const uniqueConnections = flows.length;\n  return totalFlow / uniqueConnections;\n}\n\n/**\n * Analyze flow directionality\n * @param {Array} flows - Array of flow data\n * @returns {Object} Directionality metrics\n */\nexport function analyzeFlowDirectionality(flows) {\n  const totalFlows = flows.length;\n  const directionalFlows = flows.filter(flow => flow.direction === 'uni-directional').length;\n  const biDirectionalFlows = flows.filter(flow => flow.direction === 'bi-directional').length;\n\n  return {\n    totalFlows,\n    directionalFlows,\n    biDirectionalFlows,\n    directionalPercentage: totalFlows ? (directionalFlows / totalFlows) * 100 : 0,\n    biDirectionalPercentage: totalFlows ? (biDirectionalFlows / totalFlows) * 100 : 0\n  };\n}\n\n/**\n * Identify structural patterns in flows\n * @param {Array} flows - Array of flow data\n * @returns {Object} Structural patterns metrics\n */\nexport function identifyStructuralPatterns(flows) {\n  // Placeholder implementation\n  // Implement actual pattern identification logic as needed\n  return {\n    patterns: [],\n    count: 0\n  };\n}\n\n/**\n * Detect anomalies in flows\n * @param {Array} flows - Array of flow data\n * @returns {Array} Array of anomalous flows\n */\nexport function detectFlowAnomalies(flows) {\n  // Simple anomaly detection based on flow weight thresholds\n  return flows.filter(flow => flow.flow_weight > ANALYSIS_THRESHOLDS.FLOW.ANOMALY_THRESHOLD);\n}\n\n/**\n * Calculate spatial metrics\n * @param {Object} spatialAutocorrelation - Spatial autocorrelation data\n * @returns {Object} Spatial metrics\n */\nexport function calculateSpatialMetrics(spatialAutocorrelation) {\n  return {\n    moranI: spatialAutocorrelation.moran_i ?? 0,\n    pValue: spatialAutocorrelation['p-value'] ?? 1,\n    zScore: spatialAutocorrelation.z_score ?? 0\n  };\n}\n\n/**\n * Analyze internal connectivity within a cluster\n * @param {Object} cluster - Cluster data\n * @param {Array} flows - Array of flow data\n * @returns {number} Internal connectivity score\n */\nexport function calculateInternalConnectivity(cluster, flows) {\n  const clusterFlows = flows.filter(flow => \n    cluster.markets.includes(flow.source) && \n    cluster.markets.includes(flow.target)\n  );\n  const totalFlow = _.sumBy(clusterFlows, 'flow_weight');\n  const possibleFlows = cluster.markets.length * (cluster.markets.length - 1) / 2;\n  return possibleFlows ? (totalFlow / possibleFlows) : 0;\n}\n\n/**\n * Calculate price convergence within a cluster\n * @param {Object} cluster - Cluster data\n * @param {Array} flows - Array of flow data\n * @returns {number} Price convergence score\n */\nexport function calculatePriceConvergence(cluster, flows) {\n  const clusterFlows = flows.filter(flow => \n    cluster.markets.includes(flow.source) && \n    cluster.markets.includes(flow.target)\n  );\n\n  const priceDifferences = clusterFlows.map(flow => Math.abs(flow.source_price - flow.target_price));\n  const averageDifference = priceDifferences.length ? _.mean(priceDifferences) : 0;\n\n  return 1 / (1 + averageDifference); // Higher score for lower differences\n}\n\n/**\n * Calculate cluster stability\n * @param {Object} cluster - Cluster data\n * @returns {number} Stability score\n */\nexport function calculateClusterStability(cluster) {\n  return cluster.stability ?? 0;\n}\n\n/**\n * Analyze spatial distribution within a cluster\n * @param {Object} cluster - Cluster data\n * @param {Array} flows - Array of flow data\n * @returns {Object} Spatial distribution metrics\n */\nexport function analyzeSpatialDistribution(cluster, flows) {\n  const clusterFlows = flows.filter(flow => \n    cluster.markets.includes(flow.source) && \n    cluster.markets.includes(flow.target)\n  );\n\n  const distances = clusterFlows.map(flow => \n    calculateDistance(flow.source_coordinates, flow.target_coordinates)\n  );\n\n  const averageDistance = distances.length ? _.mean(distances) : 0;\n\n  return {\n    averageDistance,\n    maxDistance: distances.length ? _.max(distances) : 0,\n    minDistance: distances.length ? _.min(distances) : 0\n  };\n}\n\n/**\n * Assess cluster stability over time\n * @param {Object} cluster - Cluster data\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {number} Stability score\n */\nexport function assessClusterStability(cluster, timeSeriesData) {\n  // Placeholder implementation\n  // Implement actual stability assessment logic as needed\n  return cluster.stability ?? 0;\n}\n\n/**\n * Measure cluster resilience\n * @param {Object} cluster - Cluster data\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {number} Resilience score\n */\nexport function measureClusterResilience(cluster, timeSeriesData) {\n  // Placeholder implementation\n  // Implement actual resilience measurement logic as needed\n  return cluster.resilience ?? 0;\n}\n\n/**\n * Calculate coverage based on market clusters\n * @param {Array} marketClusters - Array of market clusters\n * @returns {number} Coverage score\n */\nexport function calculateCoverage(marketClusters) {\n  // Placeholder implementation\n  // Implement actual coverage calculation logic as needed\n  return marketClusters.length;\n}\n\n/**\n * Calculate system-wide volatility\n * @param {Array} shocks - Array of shock events\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {number} System-wide volatility metric\n */\nexport function calculateSystemVolatility(shocks, timeSeriesData) {\n  if (!timeSeriesData.length) return 0;\n\n  const volatilityMetrics = calculateVolatility(timeSeriesData);\n  return volatilityMetrics.traditional;\n}\n\n/**\n * Assess market vulnerability based on shocks\n * @param {Array} shocks - Array of shock events\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {number} Market vulnerability metric\n */\nexport function assessMarketVulnerability(shocks, timeSeriesData) {\n  if (!shocks.length) return 0;\n\n  const impactScores = shocks.map(shock => Math.abs(shock.magnitude));\n  const averageImpact = _.mean(impactScores);\n\n  // Normalize vulnerability score (higher impact -> higher vulnerability)\n  return averageImpact / 100; // Adjust denominator as needed\n}\n\n/**\n * Analyze system recovery after shocks\n * @param {Array} shocks - Array of shock events\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {Object} System recovery metrics\n */\nexport function analyzeSystemRecovery(shocks, timeSeriesData) {\n  if (!shocks.length || !timeSeriesData.length) return {\n    recoveryTime: 0,\n    recoveryRate: 0\n  };\n\n  // Placeholder implementation\n  // Implement actual recovery analysis logic as needed\n  return {\n    recoveryTime: 0, // e.g., average time to recover from shocks\n    recoveryRate: 0  // e.g., rate at which markets recover\n  };\n}\n\n/**\n * Analyze recovery patterns after shocks\n * @param {Array} shocks - Array of shock events\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {Object} Recovery patterns metrics\n */\nexport function analyzeRecoveryPatterns(shocks, timeSeriesData) {\n  // Placeholder implementation\n  // Implement actual recovery patterns analysis logic as needed\n  return {\n    patternType: null,\n    effectiveness: 0\n  };\n}\n\n/**\n * Analyze shock propagation across regions\n * @param {Array} shocks - Array of shock events\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {Object} Shock propagation metrics\n */\nexport function analyzeShockPropagation(shocks, timeSeriesData) {\n  // Placeholder implementation\n  // Implement actual shock propagation analysis logic as needed\n  return {\n    propagationSpeed: 0,\n    affectedRegions: []\n  };\n}\n\n/**\n * Detect flow seasonality\n * @param {Array} flows - Array of flow data\n * @returns {Object} Flow seasonality metrics\n */\nexport function detectFlowSeasonality(flows) {\n  // Placeholder implementation\n  // Implement actual seasonality detection logic as needed\n  return {\n    seasonal: false,\n    pattern: null,\n    strength: 0\n  };\n}\n\n/**\n * Calculate overall integration score\n * @param {Object} metrics - Integration metrics\n * @returns {number} Overall integration score\n */\nexport function calculateOverallIntegration(metrics) {\n  const { correlationMatrix, flowMetrics, spatialMetrics } = metrics;\n\n  const correlationScore = metrics.averageCorrelation || 0;\n  const flowDensity = flowMetrics.flowDensity || 0;\n  const spatialDependence = spatialMetrics.moranI || 0;\n\n  // Weighted sum of metrics\n  const weights = {\n    correlation: 0.4,\n    flowDensity: 0.3,\n    spatialDependence: 0.3\n  };\n\n  return (correlationScore * weights.correlation) +\n         (flowDensity * weights.flowDensity) +\n         (spatialDependence * weights.spatialDependence);\n}\n\n/**\n * Analyze efficiency within market clusters\n * @param {Array} clusters - Array of market clusters\n * @param {Array} flows - Array of flow data\n * @returns {Array} Clusters with efficiency metrics\n */\nexport function analyzeEfficiency(clusters, flows) {\n  return clusters.map(cluster => ({\n    ...cluster,\n    metrics: {\n      internalConnectivity: calculateInternalConnectivity(cluster, flows),\n      marketCoverage: calculateClusterCoverage(cluster),\n      priceConvergence: calculatePriceConvergence(cluster, flows),\n      stability: calculateClusterStability(cluster)\n    },\n    spatialMetrics: analyzeSpatialDistribution(cluster, flows)\n  }));\n}\n\n/**\n * Analyze cluster dynamics over time\n * @param {Array} clusters - Array of market clusters\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {Array} Clusters with dynamics metrics\n */\nexport function calculateClusterDynamics(clusters, timeSeriesData) {\n  return clusters.map(cluster => ({\n    ...cluster,\n    dynamics: {\n      stability: assessClusterStability(cluster, timeSeriesData),\n      evolution: trackClusterEvolution(cluster, timeSeriesData),\n      resilience: measureClusterResilience(cluster, timeSeriesData)\n    }\n  }));\n}\n\n/**\n * Track cluster evolution over time\n * @param {Object} cluster - Cluster data\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {Object} Evolution metrics\n */\nexport function trackClusterEvolution(cluster, timeSeriesData) {\n  // Placeholder implementation\n  // Implement actual evolution tracking logic as needed\n  return {\n    growthRate: 0,\n    contractionRate: 0,\n    expansionAreas: []\n  };\n}\n\n/**\n * Calculate market coverage based on clusters\n * @param {Object} cluster - Cluster data\n * @returns {number} Coverage score\n */\nexport function calculateClusterCoverage(cluster) {\n  return cluster.market_coverage ?? 0;\n}\n\n/**\n * Calculate price correlation metrics\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {Object} Price correlation metrics\n */\nexport function calculatePriceCorrelation(timeSeriesData) {\n  // Placeholder implementation\n  // Implement actual correlation calculation logic as needed\n  return {\n    averageCorrelation: 0,\n    highCorrelationPairs: []\n  };\n}\n\n/**\n * Calculate overall system integration score\n * @param {Object} metrics - Integration metrics\n * @returns {number} System integration score\n */\nexport function calculateSystemIntegrationScore(metrics) {\n  const { averageCorrelation, flowDensity, spatialDependence } = metrics;\n\n  // Assign weights to each metric\n  const weights = {\n    averageCorrelation: 0.4,\n    flowDensity: 0.3,\n    spatialDependence: 0.3\n  };\n\n  return (averageCorrelation * weights.averageCorrelation) +\n         (flowDensity * weights.flowDensity) +\n         (spatialDependence * weights.spatialDependence);\n}\n\n/**\n * Main function to calculate visualization metrics based on the mode\n * @param {Object} data - Spatial data object\n * @param {string} visualizationMode - Current visualization mode\n * @param {string} selectedCommodity - Selected commodity\n * @param {string} selectedDate - Selected date\n * @returns {Object} Visualization metrics\n */\nexport function calculateVisualizationMetrics(data, visualizationMode, selectedCommodity, selectedDate) {\n  switch (visualizationMode.toLowerCase()) {\n    case 'prices':\n      return calculatePricesMetrics(data, selectedCommodity, selectedDate);\n    case 'integration':\n      return calculateIntegrationMetrics(data);\n    case 'clusters':\n      return calculateClustersMetrics(data, selectedDate);\n    case 'shocks':\n      return calculateShocksMetrics(data, selectedDate);\n    default:\n      throw new Error(`Unsupported visualization mode: ${visualizationMode}`);\n  }\n}\n\n/**\n * Calculate metrics for 'prices' visualization mode\n * @param {Object} data - Spatial data object\n * @param {string} selectedCommodity - Selected commodity\n * @param {string} selectedDate - Selected date\n * @returns {Object} Prices visualization metrics\n */\nexport function calculatePricesMetrics(data, selectedCommodity, selectedDate) {\n  const filteredTimeSeries = data.timeSeriesData.filter(d => \n    d.commodity === selectedCommodity && d.month === selectedDate\n  );\n\n  const processedData = processTimeSeries(data.timeSeriesData, [new Date(selectedDate)]);\n\n  const trends = calculateTrends(processedData.timeSeriesData);\n  const volatility = calculateVolatility(processedData.timeSeriesData);\n  const seasonality = detectSeasonalPattern(processedData.timeSeriesData);\n\n  return {\n    mode: 'prices',\n    trends,\n    volatility,\n    seasonality\n  };\n}\n\n/**\n * Process time series data based on time range\n * @param {Array} timeSeriesData - Array of time series data\n * @param {Array} timeRange - Array of Date objects [start, end]\n * @returns {Object} Processed time series data\n */\nexport function processTimeSeries(timeSeriesData, timeRange = null) {\n  let processedData = timeSeriesData.map(d => ({\n    date: new Date(d.month),\n    value: d.avgUsdPrice,\n    volatility: d.volatility,\n    conflictIntensity: d.conflict_intensity\n  }));\n\n  if (timeRange) {\n    const [start, end] = timeRange;\n    processedData = processedData.filter(d => \n      d.date >= start && d.date <= end\n    );\n  }\n\n  return { timeSeriesData: processedData };\n}\n\n/**\n * Calculate trends in time series data\n * @param {Array} timeSeriesData - Array of processed time series data\n * @returns {Object} Trend metrics\n */\nexport function calculateTrends(timeSeriesData) {\n  if (!timeSeriesData.length) return null;\n\n  const prices = timeSeriesData.map(d => ({\n    date: d.date,\n    value: d.value\n  }));\n\n  // Sort by date\n  prices.sort((a, b) => a.date - b.date);\n\n  // Calculate moving averages\n  const shortTermMA = calculateMovingAverage(prices, 3);\n  const longTermMA = calculateMovingAverage(prices, 12);\n\n  // Calculate trend slopes\n  const shortTermSlope = calculateTrendSlope(shortTermMA);\n  const longTermSlope = calculateTrendSlope(longTermMA);\n\n  // Calculate volatility\n  const volatilityMetrics = calculateVolatility(timeSeriesData);\n\n  // Detect seasonality\n  const seasonalityMetrics = detectSeasonalPattern(timeSeriesData);\n\n  return {\n    shortTermSlope,\n    longTermSlope,\n    volatility: volatilityMetrics,\n    seasonality: seasonalityMetrics\n  };\n}\n\n/**\n * Calculate metrics for 'integration' visualization mode\n * @param {Object} data - Spatial data object\n * @returns {Object} Integration visualization metrics\n */\nexport function calculateIntegrationMetrics(data) {\n  const integrationMetrics = calculateMarketIntegration(data);\n  const flowMetrics = calculateFlowMetrics(data.flowMaps);\n  const spatialMetrics = calculateSpatialMetrics(data.spatialAutocorrelation);\n\n  const overallIntegration = calculateOverallIntegration({\n    correlationMatrix: integrationMetrics.correlationMatrix,\n    flowMetrics,\n    spatialMetrics\n  });\n\n  const enhancedIntegrationScore = calculateEnhancedIntegrationScore(integrationMetrics);\n\n  return {\n    mode: 'integration',\n    integrationMetrics,\n    flowMetrics,\n    spatialMetrics,\n    overallIntegration,\n    enhancedIntegrationScore\n  };\n}\n\n/**\n * Calculate metrics for 'clusters' visualization mode\n * @param {Object} data - Spatial data object\n * @param {string} selectedDate - Selected date\n * @returns {Object} Clusters visualization metrics\n */\nexport function calculateClustersMetrics(data, selectedDate) {\n  const filteredClusters = data.marketClusters.filter(cluster => cluster.date === selectedDate);\n  const analyzedClusters = analyzeEfficiency(filteredClusters, data.flowMaps);\n  const dynamics = calculateClusterDynamics(analyzedClusters, data.timeSeriesData);\n\n  return {\n    mode: 'clusters',\n    clusters: dynamics\n  };\n}\n\n/**\n * Calculate metrics for 'shocks' visualization mode\n * @param {Object} data - Spatial data object\n * @param {string} selectedDate - Selected date\n * @returns {Object} Shocks visualization metrics\n */\nexport function calculateShocksMetrics(data, selectedDate) {\n  const filteredShocks = data.marketShocks.filter(shock => shock.date === selectedDate);\n  const patterns = analyzePatterns(filteredShocks, data.timeSeriesData);\n  const systemImpact = calculateSystemwideImpact(filteredShocks, data.timeSeriesData);\n\n  return {\n    mode: 'shocks',\n    patterns,\n    systemImpact\n  };\n}\n\n/**\n * Analyze patterns in shocks data\n * @param {Array} shocks - Array of shock events\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {Object} Shocks patterns metrics\n */\nexport function analyzePatterns(shocks, timeSeriesData) {\n  const groupedShocks = _.groupBy(shocks, 'region');\n\n  const patterns = _.mapValues(groupedShocks, regionShocks => ({\n    frequency: calculateShockFrequency(regionShocks, null),\n    magnitude: calculateAverageMagnitude(regionShocks),\n    recovery: analyzeRecoveryPatterns(regionShocks, timeSeriesData),\n    propagation: analyzeShockPropagation(regionShocks, timeSeriesData)\n  }));\n\n  return patterns;\n}\n\n/**\n * Calculate average magnitude of shocks\n * @param {Array} shocks - Array of shock events\n * @returns {number} Average magnitude\n */\nexport function calculateAverageMagnitude(shocks) {\n  if (!shocks.length) return 0;\n  const totalMagnitude = _.sumBy(shocks, 'magnitude');\n  return totalMagnitude / shocks.length;\n}\n\n/**\n * Calculate system-wide impact based on shocks\n * @param {Array} shocks - Array of shock events\n * @param {Array} timeSeriesData - Array of time series data\n * @returns {Object} System-wide impact metrics\n */\nexport function calculateSystemwideImpact(shocks, timeSeriesData) {\n  const overallVolatility = calculateSystemVolatility(shocks, timeSeriesData);\n  const marketVulnerability = assessMarketVulnerability(shocks, timeSeriesData);\n  const recoveryMetrics = analyzeSystemRecovery(shocks, timeSeriesData);\n\n  return {\n    overallVolatility,\n    marketVulnerability,\n    recoveryMetrics\n  };\n}\n\nexport function calculatePriceTrend(timeSeriesData) {\n  const prices = timeSeriesData.map(d => d.usdprice).filter(p => p != null);\n  const dates = timeSeriesData.map(d => new Date(d.date).getTime());\n  if (prices.length !== dates.length || prices.length === 0) return null;\n\n  const n = prices.length;\n  const sumX = dates.reduce((a, b) => a + b, 0);\n  const sumY = prices.reduce((a, b) => a + b, 0);\n  const sumXY = dates.reduce((sum, x, i) => sum + x * prices[i], 0);\n  const sumXX = dates.reduce((sum, x) => sum + x * x, 0);\n\n  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n\n  return { slope, intercept };\n}\n\nexport function detectSeasonality(timeSeriesData) {\n  const monthlyData = _.groupBy(timeSeriesData, d => new Date(d.date).getMonth());\n  const monthlyAverages = _.mapValues(monthlyData, data => _.meanBy(data, 'usdprice'));\n\n  const mean = _.mean(Object.values(monthlyAverages));\n  const stdDev = Math.sqrt(_.mean(Object.values(monthlyAverages).map(avg => Math.pow(avg - mean, 2))));\n\n  return { seasonal: stdDev > 0.05 * mean, monthlyAverages, stdDev };\n}\n\nexport function detectOutliers(timeSeriesData) {\n  const prices = timeSeriesData.map(d => d.usdprice).filter(p => p != null);\n  const mean = prices.reduce((a, b) => a + b, 0) / prices.length;\n  const stdDev = Math.sqrt(prices.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / prices.length);\n\n  return timeSeriesData.filter(d => Math.abs(d.usdprice - mean) > 2 * stdDev);\n}",
        "imports": [
          "../constants/index",
          "lodash"
        ],
        "exports": [
          "calculateCenterOfMass",
          "calculateBoundingBox",
          "findNeighboringRegions",
          "calculateDistance",
          "calculateVolatility",
          "calculateMarketIntegration",
          "calculateShockFrequency",
          "calculateClusterEfficiency",
          "summarizeClusters",
          "calculateMarketMetrics",
          "validateCoordinates",
          "calculateFlowCoverage",
          "calculateNetworkEfficiency",
          "calculateMovingAverage",
          "calculateTrendSlope",
          "detectSeasonalPattern",
          "processCorrelationMatrix",
          "identifyMarketClusters",
          "calculateFlowMetrics",
          "calculateFlowDensity",
          "analyzeFlowDirectionality",
          "identifyStructuralPatterns",
          "detectFlowAnomalies",
          "calculateSpatialMetrics",
          "calculateInternalConnectivity",
          "calculatePriceConvergence",
          "calculateClusterStability",
          "analyzeSpatialDistribution",
          "assessClusterStability",
          "measureClusterResilience",
          "calculateCoverage",
          "calculateSystemVolatility",
          "assessMarketVulnerability",
          "analyzeSystemRecovery",
          "analyzeRecoveryPatterns",
          "analyzeShockPropagation",
          "detectFlowSeasonality",
          "calculateOverallIntegration",
          "analyzeEfficiency",
          "calculateClusterDynamics",
          "trackClusterEvolution",
          "calculateClusterCoverage",
          "calculatePriceCorrelation",
          "calculateSystemIntegrationScore",
          "calculateVisualizationMetrics",
          "calculatePricesMetrics",
          "processTimeSeries",
          "calculateTrends",
          "calculateIntegrationMetrics",
          "calculateClustersMetrics",
          "calculateShocksMetrics",
          "analyzePatterns",
          "calculateAverageMagnitude",
          "calculateSystemwideImpact",
          "calculatePriceTrend",
          "detectSeasonality",
          "detectOutliers"
        ],
        "dependencies": [
          "../constants/index",
          "lodash"
        ]
      },
      {
        "path": "utils/methodologyContent.js",
        "content": "// src/utils/methodologyContent.js\n\nconst methodologyContent = [\n    {\n      title: 'Methodology Overview',\n      content:\n        'The Yemen Market Analysis project employs a comprehensive methodological framework that integrates advanced econometric and spatial analysis techniques to examine the influence of conflict intensity on commodity prices across different regions of Yemen. This section delineates the systematic approach undertaken, encompassing data preprocessing, econometric modeling, spatial analysis, and data preparation for visualization. The methodology leverages robust statistical models, spatial econometric techniques, and parallel processing to ensure rigorous and scalable analyses.',\n    },\n    {\n      title: '1. Data Collection and Preprocessing',\n      content:\n        'This phase encompasses the acquisition, cleaning, and transformation of the data to prepare it for further analysis.',\n      children: [\n        {\n          title: '1.1. Data Loading',\n          content:\n            'The analysis begins with the acquisition of spatial and temporal data encapsulated in GeoJSON files. The primary dataset, unified_data.geojson, contains detailed records of commodity prices, conflict intensity, and other relevant variables across multiple regions and time periods in Yemen.',\n          children: [\n            {\n              title: 'Loading Mechanism',\n              content:\n                'Utilizes GeoPandas to read GeoJSON files, ensuring efficient handling of geospatial data.',\n              code: [\n                {\n                  language: 'python',\n                  code: `import geopandas as gpd\n  gdf = gpd.read_file('unified_data.geojson')`,\n                },\n              ],\n            },\n            {\n              title: 'Configuration Management',\n              content:\n                'Employs a YAML configuration file (config.yaml) to manage file paths, directories, and analysis parameters, promoting flexibility and scalability.',\n              code: [\n                {\n                  language: 'yaml',\n                  code: `directories:\n    data_dir: 'project/data/'\n    processed_data_dir: 'project/data/processed/'\n    results_dir: 'results/'\n    logs_dir: 'results/logs/'\n    external_data_dir: 'external_data/'\n  \n  files:\n    spatial_geojson: 'project/data/processed/unified_data.geojson'\n    enhanced_geojson: 'project/data/processed/enhanced_unified_data_with_residuals.geojson'\n    spatial_analysis_results: 'results/spatial_analysis_results.json'\n    ecm_results: 'results/ecm/ecm_analysis_results.json'\n    spatial_weights_json: 'results/spatial_weights/spatial_weights.json'\n    naturalearth_lowres: 'external_data/naturalearth_lowres/ne_110m_admin_0_countries.shp'\n  \n  parameters:\n    frequency: 'M'\n    initial_k: 5\n    max_k: 20\n    min_common_dates: 20\n    lag_periods: 2\n    cointegration_max_lags: 5\n    granger_max_lags: 4\n    distance_threshold: 200\n    regimes_to_unify: ['north', 'south']\n    new_regime_name: 'unified'\n    exchange_rate_regime_column: 'exchange_rate_regime'\n    region_identifier: 'admin1'\n    time_column: 'date'\n    lag_variable: 'usdprice'\n    commodities: ['commodity1', 'commodity2']\n    exchange_rate_regimes: ['north', 'south', 'unified']\n    stationarity_significance_level: 0.05\n    cointegration_significance_level: 0.05\n    ridge_alpha: 1.0\n    max_epochs: 1000\n    learning_rate: 0.01\n    min_regions: 5\n    spatial_weights:\n      threshold_multiplier: 1\n    min_neighbors: 2\n  \n  logging:\n    level: 'INFO'\n    format: '%(asctime)s - %(levelname)s - %(message)s'`,\n                },\n              ],\n            },\n          ],\n        },\n        {\n          title: '1.2. Data Cleaning and Transformation',\n          content:\n            'Ensures the quality of the data by addressing issues such as duplicates, missing values, and inconsistent formats.',\n          children: [\n            {\n              title: 'Duplicate Removal',\n              content:\n                'Eliminates duplicate records to maintain data integrity.',\n              code: [\n                {\n                  language: 'python',\n                  code: `gdf.drop_duplicates(inplace=True)`,\n                },\n              ],\n            },\n            {\n              title: 'Missing Values Handling',\n              content:\n                'Addresses missing values through imputation strategies, such as replacing with median values, to prevent skewed analyses.',\n              code: [\n                {\n                  language: 'python',\n                  code: `from sklearn.impute import SimpleImputer\n  imputer = SimpleImputer(strategy='median')\n  gdf['usdprice'] = imputer.fit_transform(gdf[['usdprice']])`,\n                },\n              ],\n            },\n            {\n              title: 'Date Processing',\n              content:\n                'Converts date columns to datetime objects to facilitate time-series analyses.',\n              code: [\n                {\n                  language: 'python',\n                  code: `gdf['date'] = pd.to_datetime(gdf['date'], errors='coerce')`,\n                },\n              ],\n            },\n            {\n              title: 'Categorical Data Encoding',\n              content:\n                \"Transforms categorical variables (e.g., commodity, exchange_rate_regime) into suitable formats for modeling, including the creation of dummy variables.\",\n              code: [\n                {\n                  language: 'python',\n                  code: `gdf = pd.get_dummies(gdf, columns=['exchange_rate_regime'], drop_first=True)`,\n                },\n              ],\n            },\n            {\n              title: 'Regime Unification',\n              content:\n                \"Consolidates specified exchange rate regimes into a unified category (unified) to streamline analyses across different economic conditions.\",\n              code: [\n                {\n                  language: 'python',\n                  code: `gdf.loc[gdf['exchange_rate_regime'].isin(['north', 'south']), 'exchange_rate_regime'] = 'unified'`,\n                },\n              ],\n            },\n          ],\n        },\n        {\n          title: '1.3. Data Resampling and Alignment',\n          content:\n            'Aligns the dataset to a consistent temporal frequency, ensuring uniformity across time-series analyses.',\n          children: [\n            {\n              title: 'Frequency Alignment',\n              content:\n                \"Resamples the dataset to a consistent temporal frequency (e.g., monthly) to ensure uniformity across time-series analyses.\",\n              code: [\n                {\n                  language: 'python',\n                  code: `gdf.set_index('date', inplace=True)\n  gdf = gdf.groupby('region_id').resample('M').mean().reset_index()`,\n                },\n              ],\n            },\n            {\n              title: 'Grouping',\n              content:\n                'Aggregates data by commodity and exchange_rate_regime to facilitate targeted analyses within specific market conditions.',\n              code: [\n                {\n                  language: 'python',\n                  code: `grouped_data = gdf.groupby(['commodity', 'exchange_rate_regime'])`,\n                },\n              ],\n            },\n            ],\n          },\n        ],\n      },\n      {\n        title: '2. Econometric Modeling',\n        content:\n          'The project integrates multiple econometric models to dissect the relationship between conflict intensity and commodity prices.',\n        children: [\n          {\n            title: '2.1. Error Correction Model (ECM)',\n            content:\n              'The ECM framework captures both short-term dynamics and long-term equilibrium relationships between variables, enabling the analysis of how deviations from equilibrium are corrected over time.',\n            children: [\n              {\n                title: 'Model Specification',\n                content:\n                  'The ECM is derived from the Vector Error Correction Model (VECM), which is suitable for multivariate time series data exhibiting cointegration.',\n                equation:\n                  '\\\\Delta Y_t = \\\\alpha \\\\beta\\' Y_{t-1} + \\\\sum_{i=1}^{p-1} \\\\Gamma_i \\\\Delta Y_{t-i} + u_t',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$\\\\Delta$ denotes the first difference operator.\\n$Y_t$ is a vector of endogenous variables (e.g., usdprice, conflict_intensity).\\n$\\\\alpha\\\\beta\\'$ captures the long-term equilibrium relationships.\\n$\\\\Gamma_i$ are short-term adjustment coefficients.\\n$u_t$ is the error term.',\n                  },\n                ],\n              },\n              {\n                title: 'Stationarity Tests',\n                content:\n                  'Conducts Augmented Dickey-Fuller (ADF) and Kwiatkowski-Phillips-Schmidt-Shin (KPSS) tests to ascertain the stationarity of time series data.',\n                equation:\n                  'ADF: \\\\Delta y_t = \\\\alpha + \\\\beta t + \\\\gamma y_{t-1} + \\\\delta_1 \\\\Delta y_{t-1} + \\\\cdots + \\\\delta_p \\\\Delta y_{t-p} + \\\\epsilon_t\\n\\nKPSS: y_t = \\\\xi t + r_t + \\\\epsilon_t',\n                children: [\n                  {\n                    title: 'ADF Hypotheses',\n                    content:\n                      '$H_0$: Unit root present (non-stationary).\\n$H_1$: No unit root (stationary).',\n                  },\n                  {\n                    title: 'KPSS Hypotheses',\n                    content:\n                      '$H_0$: Stationary.\\n$H_1$: Non-stationary.',\n                  },\n                ],\n              },\n              {\n                title: 'Cointegration Analysis',\n                content:\n                  \"Utilizes the Engle-Granger method to detect cointegrated relationships, indicating a long-term equilibrium between commodity prices and conflict intensity.\",\n                children: [\n                  {\n                    title: 'Engle-Granger Cointegration Test',\n                    content:\n                      \"Step 1: Regress $y_t$ on $x_t$:\\n$y_t = \\\\beta_0 + \\\\beta_1 x_t + u_t$\\n\\nStep 2: Test the residuals $u_t$ for stationarity using the ADF test.\\n$H_0$: Residuals have a unit root (no cointegration).\\n$H_1$: Residuals are stationary (cointegrated).\",\n                  },\n                ],\n              },\n              {\n                title: 'Model Estimation',\n                content:\n                  'Implements Vector Error Correction Models (VECM) using Statsmodels, selecting optimal lag orders based on Akaike Information Criterion (AIC).',\n                equation: 'AIC = 2k - 2\\\\ln(\\\\hat{L})',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$k$ is the number of parameters.\\n$\\\\hat{L}$ is the maximized value of the likelihood function.',\n                  },\n                ],\n              },\n              {\n                title: 'Diagnostics',\n                content:\n                  'Performs a suite of diagnostic tests to validate the ECM.',\n                children: [\n                  {\n                    title: 'Breusch-Godfrey Test for Autocorrelation',\n                    equation: 'LM = (n-p)R^2',\n                  },\n                  {\n                    title: 'ARCH Test for Heteroskedasticity',\n                    equation: 'LM = nR^2',\n                  },\n                  {\n                    title: 'Jarque-Bera Test for Normality',\n                    equation: 'JB = \\\\frac{n}{6}(S^2 + \\\\frac{1}{4}(K-3)^2)',\n                  },\n                  {\n                    title: 'Durbin-Watson Test for Residual Autocorrelation',\n                    equation:\n                      'DW = \\\\frac{\\\\sum_{t=2}^T (e_t - e_{t-1})^2}{\\\\sum_{t=1}^T e_t^2}',\n                    content:\n                      'Where $e_t$ is the autocorrelation coefficient.',\n                  },\n                ],\n              },\n              {\n                title: 'Impulse Response Functions (IRFs)',\n                content:\n                  'Generates IRFs to assess the impact of shocks in conflict intensity on commodity prices over time.',\n                equation:\n                  'IRF_{i,j,h} = \\\\frac{\\\\partial y_{i,t+h}}{\\\\partial \\\\varepsilon_{j,t}}',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$IRF_{i,j,h}$ measures the response of variable $i$ at horizon $h$ to a shock in variable $j$ at time 0.',\n                  },\n                ],\n              },\n              {\n                title: 'Spatial Autocorrelation',\n                content:\n                  \"Evaluates Moran's I to detect spatial dependencies in the residuals, ensuring the validity of the model.\",\n                equation:\n                  \"I = \\\\frac{N}{\\\\sum_{i=1}^{N} \\\\sum_{j=1}^{N} w_{ij}} \\\\cdot \\\\frac{\\\\sum_{i=1}^{N} \\\\sum_{j=1}^{N} w_{ij}(y_i - \\\\bar{y})(y_j - \\\\bar{y})}{\\\\sum_{i=1}^{N} (y_i - \\\\bar{y})^2}\",\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$N$ is the number of spatial units.\\n$w_{ij}$ is the spatial weight between units $i$ and $j$.\\n$y_i$ is the residual for unit $i$.',\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            title: '2.2. Price Differential Model',\n            content:\n              'This model examines the price disparities between different markets, considering the influence of conflict intensity and geographic factors.',\n            children: [\n              {\n                title: 'Price Differential Calculation',\n                content:\n                  'Computes log price differentials between market pairs to analyze relative price movements.',\n                equation:\n                  '\\\\Delta P_{ijt} = \\\\ln(P_{it}) - \\\\ln(P_{jt})',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$P_{it}$ is the price of commodity $i$ in market $t$.\\n$P_{jt}$ is the price of commodity $j$ in market $t$.',\n                  },\n                ],\n              },\n              {\n                title: 'Correlation Analysis',\n                content:\n                  'Assesses Pearson correlations between conflict intensities across markets to understand inter-market conflict dynamics.',\n                equation:\n                  'r = \\\\frac{\\\\sum_{i=1}^n (x_i - \\\\bar{x})(y_i - \\\\bar{y})}{\\\\sqrt{\\\\sum_{i=1}^n (x_i - \\\\bar{x})^2} \\\\sqrt{\\\\sum_{i=1}^n (y_i - \\\\bar{y})^2}}',\n              },\n              {\n                title: 'Regression Models',\n                children: [\n                  {\n                    title: 'Ordinary Least Squares (OLS)',\n                    content:\n                      'Estimates the relationship between price differentials and predictors with clustered standard errors to account for intra-group correlations.',\n                    equation:\n                      '\\\\Delta P_{ijt} = \\\\beta_0 + \\\\beta_1 Distance_{ij} + \\\\beta_2 ConflictCorr_{ijt} + \\\\alpha_i + \\\\epsilon_{ijt}',\n                    children: [\n                      {\n                        title: 'Variables',\n                        content:\n                          'Where:\\n$\\\\beta_0$ is the intercept.\\n$\\\\beta_1$ and $\\\\beta_2$ are coefficients for distance and conflict correlation, respectively.\\n$\\\\alpha_i$ captures fixed effects for entities.\\n$\\\\epsilon_{ijt}$ is the error term.',\n                      },\n                    ],\n                  },\n                  {\n                    title: 'Fixed Effects (FE) Model',\n                    content:\n                      'Controls for unobserved heterogeneity by incorporating entity-specific effects.',\n                    equation:\n                      'y_{it} = \\\\alpha_i + X_{it}\\\\beta + \\\\epsilon_{it}',\n                    children: [\n                      {\n                        title: 'Variables',\n                        content:\n                          'Where:\\n$\\\\alpha_i$ represents fixed effects for each entity (e.g., market).',\n                      },\n                    ],\n                  },\n                  {\n                    title: 'Random Effects (RE) Model',\n                    content:\n                      'Assumes random variations across entities, providing a comparison to the FE model.',\n                    equation:\n                      'y_{it} = \\\\alpha + X_{it}\\\\beta + u_i + \\\\epsilon_{it}',\n                    children: [\n                      {\n                        title: 'Variables',\n                        content:\n                          'Where:\\n$u_i$ is the random effect.',\n                      },\n                    ],\n                  },\n                  {\n                    title: 'Instrumental Variables (IV) Model (IV2SLS)',\n                    content:\n                      'Addresses potential endogeneity issues by using instrumental variables.',\n                    equation:\n                      'y = X\\\\beta + \\\\epsilon, \\\\ X = Z\\\\Pi + v',\n                    children: [\n                      {\n                        title: 'Variables',\n                        content:\n                          'Where $X$ is endogenous and instrumented by $Z$.',\n                      },\n                    ],\n                  },\n                ],\n              },\n              {\n                title: 'Diagnostics',\n                content:\n                  'Includes Variance Inflation Factor (VIF) for multicollinearity assessment, Breusch-Pagan for heteroskedasticity, Durbin-Watson for autocorrelation, Jarque-Bera for normality, and Ramsey RESET for model specification.',\n                children: [\n                  {\n                    title: 'Variance Inflation Factor (VIF)',\n                    equation:\n                      'VIF_j = \\\\frac{1}{1-R_j^2}',\n                    content:\n                      'Where $R_j^2$ is the coefficient of determination of regressing the $j$th predictor on all other predictors.',\n                  },\n                  {\n                    title: 'Breusch-Pagan Test',\n                    equation: 'BP = nR^2',\n                  },\n                  {\n                    title: 'Durbin-Watson Test',\n                    equation:\n                      'DW = \\\\frac{\\\\sum_{t=2}^T (e_t - e_{t-1})^2}{\\\\sum_{t=1}^T e_t^2}',\n                  },\n                  {\n                    title: 'Jarque-Bera Test',\n                    equation:\n                      'JB = \\\\frac{n}{6}(S^2 + \\\\frac{1}{4}(K-3)^2)',\n                    content:\n                      'Where $S$ is skewness and $K$ is kurtosis.',\n                  },\n                  {\n                    title: 'Ramsey RESET Test',\n                    equation:\n                      'RESET = \\\\frac{(RSS_1 - RSS_2) / q}{RSS_2 / (n-k-q)}',\n                  },\n                ],\n              },\n              {\n                title: 'Model Comparison',\n                content:\n                  'Evaluates models based on Akaike Information Criterion (AIC) and Bayesian Information Criterion (BIC) to determine the best-fitting model.',\n                children: [\n                  {\n                    title: 'AIC',\n                    equation: 'AIC = 2k - 2\\\\ln(\\\\hat{L})',\n                  },\n                  {\n                    title: 'BIC',\n                    equation: 'BIC = k\\\\ln(n) - 2\\\\ln(\\\\hat{L})',\n                    children: [\n                      {\n                        title: 'Variables',\n                        content:\n                          'Where:\\n$k$ is the number of parameters.\\n$\\\\hat{L}$ is the maximized value of the likelihood function.\\n$n$ is the number of observations.',\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n      {\n        title: '3. Spatial Econometric Analysis',\n        content:\n          'Spatial econometric techniques are pivotal in understanding the geographical interdependencies and spatial spillover effects in the data.',\n        children: [\n          {\n            title: '3.1. Spatial Weights Matrix Construction',\n            content:\n              'Constructs spatial weights matrices using KNN, dynamically adjusting the number of neighbors (k) to ensure full connectivity of the spatial network.',\n            children: [\n              {\n                title: 'K-Nearest Neighbors (KNN)',\n                content:\n                  'Constructs spatial weights matrices using KNN, dynamically adjusting the number of neighbors (k) to ensure full connectivity of the spatial network.',\n                equation:\n                  'w_{ij} = \\\\begin{cases} 1 & \\\\text{if } j \\\\text{ is one of the } k \\\\text{ nearest neighbors of } i \\\\\\\\ 0 & \\\\text{otherwise} \\\\end{cases}',\n              },\n              {\n                title: 'Connectivity Verification',\n                content:\n                  'Ensures that the spatial weights matrix is fully connected, preventing isolated regions from skewing the analysis.',\n                code: [\n                  {\n                    language: 'python',\n                    code: `import networkx as nx\n  G = w.to_networkx()\n  is_connected = nx.is_connected(G.to_undirected())`,\n                  },\n                ],\n              },\n              {\n                title: 'Exporting Weights',\n                content:\n                  'Saves the spatial weights matrices in JSON format for reproducibility and further analyses.',\n                code: [\n                  {\n                    language: 'python',\n                    code: `import json\n  with open('spatial_weights.json', 'w') as f:\n      json.dump(weights_dict, f, indent=2)`,\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            title: '3.2. Spatial Lag Calculation',\n            content:\n              'Computes spatial lags (e.g., spatial lag of usdprice) to incorporate the influence of neighboring regions into the regression models.',\n            equation:\n              'Wy = \\\\rho \\\\sum_{j=1}^n w_{ij}y_j',\n            children: [\n              {\n                title: 'Variables',\n                content:\n                  'Where:\\n$\\\\rho$ is the spatial autoregressive parameter.\\n$w_{ij}$ is the spatial weight between regions $i$ and $j$.',\n              },\n              {\n                title: 'Ridge Regression with Spatial Lag',\n                content:\n                  'Performs Ridge regression, including spatially lagged variables to mitigate multicollinearity and stabilize coefficient estimates.',\n                equation:\n                  '\\\\hat{\\\\beta} = (X^TX + \\\\lambda I)^{-1}X^Ty',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$\\\\lambda$ is the regularization parameter.\\n$X$ are the predictors, including spatial lags.',\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            title: '3.3. Spatial Autocorrelation Assessment',\n            content:\n              \"Calculates Moran's I statistic on residuals from regression models to detect spatial autocorrelation, ensuring that spatial dependencies are appropriately modeled.\",\n            equation:\n              \"I = \\\\frac{N}{\\\\sum_{i=1}^{N} \\\\sum_{j=1}^{N} w_{ij}} \\\\cdot \\\\frac{\\\\sum_{i=1}^{N} \\\\sum_{j=1}^{N} w_{ij}(y_i - \\\\bar{y})(y_j - \\\\bar{y})}{\\\\sum_{i=1}^{N} (y_i - \\\\bar{y})^2}\",\n            children: [\n              {\n                title: 'Interpretation',\n                content:\n                  '$I > 0$: Positive spatial autocorrelation.\\n$I < 0$: Negative spatial autocorrelation.\\n$I \\\\approx 0$: No spatial autocorrelation.',\n              },\n              {\n                title: 'Implementation',\n                code: [\n                  {\n                    language: 'python',\n                    code: `from esda.moran import Moran\n  moran = Moran(residual, w)`,\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            title: 'Network Flow Maps',\n            content:\n              'Generates flow maps representing spatial relationships and dependencies between regions, facilitating the visualization of spatial interactions.',\n            children: [\n              {\n                title: 'Flow Map Specification',\n                content:\n                  'Each flow represents the spatial interaction between a source region and its neighboring target regions, weighted by the spatial lag or other relevant metrics.',\n                code: [\n                  {\n                    language: 'python',\n                    code: `import pandas as pd\n  flow_df = pd.DataFrame(flow_data)\n  flow_df.to_csv('flow_maps.csv', index=False)`,\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n      {\n        title: '4. Data Preparation for Visualization',\n        content:\n          'Effective visualization is integral to interpreting the analytical outcomes and communicating findings.',\n        children: [\n          {\n            title: '4.1. Choropleth Maps',\n            content:\n              'Maps the mean commodity prices across regions and time periods to identify spatial price distributions.',\n            children: [\n              {\n                title: 'Average Prices',\n                equation:\n                  '\\\\text{Avg\\\\_Price}_{it} = \\\\frac{1}{N_{it}} \\\\sum_{j=1}^{N_{it}} P_{ijt}',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$\\\\text{Avg\\\\_Price}_{it}$ is the average price of commodity $i$ in region $t$.\\n$N_{it}$ is the number of observations for commodity $i$ in region $t$.\\n$P_{ijt}$ is the price of commodity $i$ in sub-region $j$ at time $t$.',\n                  },\n                ],\n              },\n              {\n                title: 'Conflict Intensity',\n                content:\n                  'Visualizes the average conflict intensity per region, highlighting areas with heightened conflict.',\n                equation:\n                  '\\\\text{Avg\\\\_Conflict}_{it} = \\\\frac{1}{N_{it}} \\\\sum_{j=1}^{N_{it}} C_{ijt}',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$C_{ijt}$ is the conflict intensity in sub-region $j$ for region $i$.',\n                  },\n                ],\n              },\n              {\n                title: 'Price Changes',\n                content:\n                  'Illustrates percentage changes in prices over time, revealing temporal trends and volatility.',\n                equation:\n                  '\\\\text{Price\\\\_Change}_{it} (\\\\%) = \\\\left( \\\\frac{P_{it} - P_{i(t-1)}}{P_{i(t-1)}} \\\\right) \\\\times 100',\n              },\n              {\n                title: 'Residuals',\n                content:\n                  'Depicts residuals from econometric models to identify unexplained variations and potential areas of interest.',\n                equation:\n                  'e_{it} = y_{it} - \\\\hat{y}_{it}',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$y_{it}$ is the observed value.\\n$\\\\hat{y}_{it}$ is the predicted value from the model.',\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            title: '4.2. Time Series Data',\n            content:\n              'Prepares time series datasets for commodity prices and conflict intensity, enabling temporal trend analyses and forecasting.',\n            children: [\n              {\n                title: 'Price Time Series',\n                equation:\n                  'P_{it} = f(t, D_{ij}, CC_{ijt})',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$D_{ij}$ is the distance metric between markets.\\n$CC_{ijt}$ is the conflict correlation.',\n                  },\n                ],\n              },\n              {\n                title: 'Conflict Intensity Time Series',\n                equation:\n                  'CI_{it} = f(t, X_{it})',\n                children: [\n                  {\n                    title: 'Variables',\n                    content:\n                      'Where:\\n$X_{it}$ represents structural variables influencing conflict intensity.',\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            title: '4.3. Network Flow Maps',\n            content:\n              'Constructs network graphs illustrating the flow of economic interactions and dependencies between regions, informed by the spatial weights matrices.',\n            children: [\n              {\n                title: 'Flow Map Construction',\n                content:\n                  'Each edge in the network represents a spatial interaction between two regions, weighted by spatial lag variables or economic metrics.',\n                code: [\n                  {\n                    language: 'python',\n                    code: `import networkx as nx\n  G = nx.from_pandas_edgelist(flow_df, 'source', 'target', ['weight'])`,\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n      {\n        title: '5. Parallel Processing and Optimization',\n        content:\n          'To handle computationally intensive tasks efficiently, the project leverages parallel processing techniques.',\n        children: [\n          {\n            title: 'Multiprocessing',\n            content:\n              \"Utilizes Python's multiprocessing and concurrent.futures modules to execute multiple analyses concurrently, significantly reducing processing time.\",\n            code: [\n              {\n                language: 'python',\n                code: `from concurrent.futures import ProcessPoolExecutor, as_completed\n  with ProcessPoolExecutor(max_workers=cpu_count()) as executor:\n      futures = [executor.submit(analyze, args) for args in analysis_args]\n      for future in as_completed(futures):\n          results.append(future.result())`,\n              },\n            ],\n          },\n          {\n            title: 'Caching Mechanisms',\n            content:\n              'Implements caching strategies using Joblib to optimize repeated data loading and processing steps.',\n            code: [\n              {\n                language: 'python',\n                code: `from joblib import Memory\n  memory = Memory(location='cache', verbose=0)\n  \n  @memory.cache\n  def load_data(file_path):\n      return pd.read_csv(file_path)`,\n              },\n            ],\n          },\n          {\n            title: 'Data Optimization',\n            content:\n              'Simplifies geometries and optimizes data types to enhance performance and minimize memory usage, ensuring scalability for large datasets.',\n            code: [\n              {\n                language: 'python',\n                code: `gdf['geometry'] = gdf['geometry'].simplify(tolerance=0.01, preserve_topology=True)\n  gdf['usdprice'] = gdf['usdprice'].astype('float32')`,\n              },\n            ],\n          },\n        ],\n      },\n      {\n        title: '6. Result Aggregation and Saving',\n        content:\n          'All analytical outcomes are systematically aggregated and stored for downstream applications and reporting.',\n        children: [\n          {\n            title: 'JSON and CSV Outputs',\n            content:\n              'Saves results in JSON and CSV formats, facilitating ease of access and integration with visualization tools.',\n            code: [\n              {\n                language: 'python',\n                code: `import json\n  with open('results.json', 'w') as f:\n      json.dump(results, f, indent=4, cls=NumpyEncoder)`,\n              },\n            ],\n          },\n          {\n            title: 'Logging',\n            content:\n              'Maintains detailed logs of all processes and analyses, ensuring transparency and facilitating debugging and reproducibility.',\n            code: [\n              {\n                language: 'python',\n                code: `import logging\n  logging.basicConfig(filename='analysis.log', level=logging.INFO)\n  logger = logging.getLogger(__name__)`,\n              },\n            ],\n          },\n        ],\n      },\n    ];\n  \n  export default methodologyContent;",
        "imports": [],
        "exports": [
          "default"
        ],
        "dependencies": []
      },
      {
        "path": "utils/networkDebug.js",
        "content": "// src/utils/networkDebug.js\n\nconst DEBUG_LEVELS = {\n  ERROR: 'error',\n  WARN: 'warn',\n  INFO: 'info',\n  DEBUG: 'debug'\n};\n\nconst DEBUG_COLORS = {\n  error: 'background: #ff5252; color: white; padding: 2px 5px; border-radius: 2px;',\n  warn: 'background: #ffd740; color: black; padding: 2px 5px; border-radius: 2px;',\n  info: 'background: #2196f3; color: white; padding: 2px 5px; border-radius: 2px;',\n  debug: 'background: #4caf50; color: white; padding: 2px 5px; border-radius: 2px;'\n};\n\nclass NetworkDebugger {\n  constructor(enabled = process.env.NODE_ENV === 'development') {\n    this.enabled = enabled;\n    this.logs = [];\n  }\n\n  log(level, component, message, data = null) {\n    if (!this.enabled) return;\n\n    const timestamp = new Date().toISOString();\n    const logEntry = {\n      timestamp,\n      level,\n      component,\n      message,\n      data\n    };\n\n    this.logs.push(logEntry);\n\n    const style = DEBUG_COLORS[level];\n    console.groupCollapsed(\n      `%c${level.toUpperCase()}%c ${component} - ${message}`,\n      style,\n      'color: inherit;'\n    );\n    \n    if (data) {\n      console.log('Data:', data);\n    }\n    console.log('Timestamp:', timestamp);\n    console.groupEnd();\n  }\n\n  error(component, message, data) {\n    this.log(DEBUG_LEVELS.ERROR, component, message, data);\n  }\n\n  warn(component, message, data) {\n    this.log(DEBUG_LEVELS.WARN, component, message, data);\n  }\n\n  info(component, message, data) {\n    this.log(DEBUG_LEVELS.INFO, component, message, data);\n  }\n\n  debug(component, message, data) {\n    this.log(DEBUG_LEVELS.DEBUG, component, message, data);\n  }\n\n  getRecentLogs(count = 10) {\n    return this.logs.slice(-count);\n  }\n\n  clearLogs() {\n    this.logs = [];\n  }\n}\n\nexport const networkDebugger = new NetworkDebugger();",
        "imports": [],
        "exports": [
          "networkDebugger"
        ],
        "dependencies": []
      },
      {
        "path": "utils/numberValidation.js",
        "content": "// src/utils/numberValidation.js\n\n/**\n * Validates numerical values and provides safe defaults\n * @param {number} value - Value to validate\n * @param {number} defaultValue - Default value if invalid\n * @param {Object} options - Additional validation options\n * @returns {number} Validated number\n */\nexport const validateNumber = (value, defaultValue = 0, options = {}) => {\n    const {\n      allowNegative = false,\n      allowZero = true,\n      min = Number.NEGATIVE_INFINITY,\n      max = Number.POSITIVE_INFINITY\n    } = options;\n  \n    // Check if value is a valid number\n    if (typeof value !== 'number' || isNaN(value) || !isFinite(value)) {\n      return defaultValue;\n    }\n  \n    // Check if value is in allowed range\n    if (value < min || value > max) {\n      return defaultValue;\n    }\n  \n    // Check for negative values\n    if (!allowNegative && value < 0) {\n      return defaultValue;\n    }\n  \n    // Check for zero values\n    if (!allowZero && value === 0) {\n      return defaultValue;\n    }\n  \n    return value;\n  };\n  \n  /**\n   * Validates array of numbers\n   * @param {Array} values - Array of numbers to validate\n   * @param {Object} options - Validation options\n   * @returns {Array} Array of validated numbers\n   */\n  export const validateNumberArray = (values, options = {}) => {\n    if (!Array.isArray(values)) {\n      return [];\n    }\n  \n    return values\n      .map(value => validateNumber(value, null, options))\n      .filter(value => value !== null);\n  };\n  \n  /**\n   * Calculates safe mean of numbers\n   * @param {Array} values - Array of numbers\n   * @returns {number} Mean value or 0 if invalid\n   */\n  export const calculateSafeMean = (values) => {\n    const validValues = validateNumberArray(values);\n    if (validValues.length === 0) return 0;\n    \n    return validValues.reduce((sum, val) => sum + val, 0) / validValues.length;\n  };\n  \n  /**\n   * Safely divides two numbers\n   * @param {number} numerator - Numerator\n   * @param {number} denominator - Denominator\n   * @param {number} defaultValue - Default value if division is invalid\n   * @returns {number} Division result or default value\n   */\n  export const safeDivide = (numerator, denominator, defaultValue = 0) => {\n    const num = validateNumber(numerator);\n    const den = validateNumber(denominator);\n  \n    if (den === 0) return defaultValue;\n    return num / den;\n  };",
        "imports": [],
        "exports": [
          "validateNumber",
          "validateNumberArray",
          "calculateSafeMean",
          "safeDivide"
        ],
        "dependencies": []
      },
      {
        "path": "utils/optimizedSelectors.js",
        "content": "// src/utils/optimizedSelectors.js\n\nimport { createSelector } from '@reduxjs/toolkit';\nimport { createSelectorCreator, defaultMemoize } from 'reselect';\nimport _ from 'lodash';\n\n// Create custom selector with deep equality check\nconst createDeepEqualSelector = createSelectorCreator(\n  defaultMemoize,\n  _.isEqual\n);\n\n// Base state selectors with safe defaults\nconst selectSpatialState = state => state.spatial || {};\nconst selectUIState = state => state.spatial?.ui || {};\nconst selectData = state => state.spatial?.data || {};\nconst selectStatus = state => state.spatial?.status || {};\n\n// Optimized UI state selectors\nexport const selectSelectedCommodity = createSelector(\n  [selectUIState],\n  ui => ui.selectedCommodity || ''\n);\n\nexport const selectSelectedDate = createSelector(\n  [selectUIState],\n  ui => ui.selectedDate || ''\n);\n\nexport const selectVisualizationMode = createSelector(\n  [selectUIState],\n  ui => ui.visualizationMode || 'prices'\n);\n\nexport const selectSelectedRegimes = createSelector(\n  [selectUIState],\n  ui => ui.selectedRegimes || ['unified']\n);\n\n// Optimized data selectors with memoization\nexport const selectTimeSeriesData = createDeepEqualSelector(\n  [selectData],\n  data => data.timeSeriesData || []\n);\n\nexport const selectMarketClusters = createDeepEqualSelector(\n  [selectData],\n  data => data.marketClusters || []\n);\n\nexport const selectFlowMaps = createDeepEqualSelector(\n  [selectData],\n  data => data.flowMaps || []\n);\n\nexport const selectMarketShocks = createDeepEqualSelector(\n  [selectData],\n  data => data.marketShocks || []\n);\n\n// Complex derived selectors\nexport const selectFilteredTimeSeriesData = createDeepEqualSelector(\n  [selectTimeSeriesData, selectSelectedRegimes, selectSelectedDate],\n  (timeSeriesData, selectedRegimes, selectedDate) => {\n    if (!timeSeriesData?.length) return [];\n    \n    return timeSeriesData.filter(data => \n      (!selectedDate || data.date === selectedDate) &&\n      (!selectedRegimes.length || selectedRegimes.includes(data.regime))\n    );\n  }\n);\n\nexport const selectClusterMetrics = createDeepEqualSelector(\n  [selectMarketClusters],\n  (clusters) => {\n    if (!clusters?.length) return null;\n\n    return {\n      totalClusters: clusters.length,\n      averageSize: _.meanBy(clusters, c => c.connected_markets.length + 1),\n      efficiencyStats: {\n        average: _.meanBy(clusters, 'metrics.efficiency'),\n        min: _.minBy(clusters, 'metrics.efficiency')?.metrics.efficiency,\n        max: _.maxBy(clusters, 'metrics.efficiency')?.metrics.efficiency\n      },\n      marketCoverage: calculateMarketCoverage(clusters)\n    };\n  }\n);\n\nexport const selectFlowAnalysis = createDeepEqualSelector(\n  [selectFlowMaps, selectSelectedDate],\n  (flows, selectedDate) => {\n    if (!flows?.length) return null;\n\n    const filteredFlows = selectedDate ? \n      flows.filter(flow => flow.date === selectedDate) : \n      flows;\n\n    return {\n      totalFlows: filteredFlows.length,\n      averageWeight: _.meanBy(filteredFlows, 'flow_weight'),\n      maxWeight: _.maxBy(filteredFlows, 'flow_weight')?.flow_weight,\n      marketConnections: calculateMarketConnections(filteredFlows)\n    };\n  }\n);\n\nexport const selectVisualizationData = createDeepEqualSelector(\n  [\n    selectFilteredTimeSeriesData,\n    selectMarketClusters,\n    selectFlowMaps,\n    selectMarketShocks,\n    selectVisualizationMode\n  ],\n  (timeSeriesData, clusters, flows, shocks, mode) => {\n    switch (mode) {\n      case 'prices':\n        return processPriceData(timeSeriesData);\n      case 'integration':\n        return processIntegrationData(clusters, flows);\n      case 'clusters':\n        return processClusterData(clusters);\n      case 'shocks':\n        return processShockData(shocks);\n      default:\n        return null;\n    }\n  }\n);\n\n// Helper functions\nconst calculateMarketCoverage = (clusters) => {\n  const uniqueMarkets = new Set();\n  clusters.forEach(cluster => {\n    uniqueMarkets.add(cluster.main_market);\n    cluster.connected_markets.forEach(market => uniqueMarkets.add(market));\n  });\n  return uniqueMarkets.size;\n};\n\nconst calculateMarketConnections = (flows) => {\n  const connections = new Map();\n  flows.forEach(flow => {\n    if (!connections.has(flow.source)) {\n      connections.set(flow.source, new Set());\n    }\n    if (!connections.has(flow.target)) {\n      connections.set(flow.target, new Set());\n    }\n    connections.get(flow.source).add(flow.target);\n    connections.get(flow.target).add(flow.source);\n  });\n  return connections;\n};\n\nconst processPriceData = (timeSeriesData) => {\n  return _.groupBy(timeSeriesData, 'region');\n};\n\nconst processIntegrationData = (clusters, flows) => {\n  return {\n    clusters: clusters.map(cluster => ({\n      id: cluster.cluster_id,\n      markets: [cluster.main_market, ...cluster.connected_markets],\n      efficiency: cluster.metrics.efficiency\n    })),\n    flows: flows.map(flow => ({\n      source: flow.source,\n      target: flow.target,\n      weight: flow.flow_weight\n    }))\n  };\n};\n\nconst processClusterData = (clusters) => {\n  return clusters.map(cluster => ({\n    id: cluster.cluster_id,\n    mainMarket: cluster.main_market,\n    connectedMarkets: cluster.connected_markets,\n    metrics: cluster.metrics\n  }));\n};\n\nconst processShockData = (shocks) => {\n  return _.groupBy(shocks, 'region');\n};",
        "imports": [
          "@reduxjs/toolkit",
          "reselect",
          "lodash"
        ],
        "exports": [
          "selectSelectedCommodity",
          "selectSelectedDate",
          "selectVisualizationMode",
          "selectSelectedRegimes",
          "selectTimeSeriesData",
          "selectMarketClusters",
          "selectFlowMaps",
          "selectMarketShocks",
          "selectFilteredTimeSeriesData",
          "selectClusterMetrics",
          "selectFlowAnalysis",
          "selectVisualizationData"
        ],
        "dependencies": [
          "@reduxjs/toolkit",
          "reselect",
          "lodash"
        ]
      },
      {
        "path": "utils/pathResolver.js",
        "content": "import Papa from 'papaparse';\n\nclass PathResolver {\n  constructor() {\n    const isDev = process.env.NODE_ENV === 'development';\n    const publicUrl = process.env.PUBLIC_URL || '/Yemen_Market_Analysis';\n\n    // Define base paths based on environment\n    this.basePaths = isDev \n      ? ['/results', '/data']\n      : [`${publicUrl}/data`];\n\n    this.cache = new Map();\n    this.successPathMap = new Map();\n    this.retryAttempts = 3;\n    this.retryDelay = 1000;\n  }\n\n  async resolveDataFile(category, filename, options = {}) {\n    const cacheKey = `${category}/${filename}`;\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached && Date.now() - cached.timestamp < 3600000) {\n      return cached.response;\n    }\n\n    const paths = this.generatePaths(category, filename);\n    let response = null;\n    let error = null;\n\n    for (let attempt = 0; attempt < this.retryAttempts; attempt++) {\n      for (const path of paths) {\n        try {\n          response = await fetch(path, {\n            ...options,\n            headers: {\n              'Accept': 'application/json, text/csv',\n              'Cache-Control': process.env.NODE_ENV === 'development' ? 'no-cache' : 'max-age=3600',\n              ...options.headers\n            }\n          });\n\n          if (response.ok) {\n            this.successPathMap.set(category, path);\n            this.cache.set(cacheKey, {\n              response: response.clone(),\n              timestamp: Date.now()\n            });\n            return response;\n          }\n        } catch (e) {\n          error = e;\n          console.warn(`Failed to fetch from ${path}:`, e);\n          continue;\n        }\n      }\n\n      if (attempt < this.retryAttempts - 1) {\n        await new Promise(resolve => \n          setTimeout(resolve, this.retryDelay * Math.pow(2, attempt))\n        );\n      }\n    }\n\n    // Try alternative path if all attempts failed\n    const altResponse = await this.tryAlternativePath(category, filename, options);\n    if (altResponse) return altResponse;\n\n    throw new Error(`Failed to load ${filename} from all paths. Last error: ${error?.message}`);\n  }\n\n  generatePaths(category, filename) {\n    const exactPaths = this.basePaths.map(base => `${base}/${category}/${filename}`);\n    const fallbackPaths = this.basePaths.map(base => `${base}/${filename}`);\n    const previousSuccessPath = this.successPathMap.get(category);\n    \n    const paths = [...exactPaths, ...fallbackPaths];\n    \n    if (previousSuccessPath) {\n      const successBase = previousSuccessPath.split('/').slice(0, -2).join('/');\n      paths.unshift(`${successBase}/${category}/${filename}`);\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      console.debug('[PathResolver] Trying paths:', paths);\n    }\n\n    return paths;\n  }\n\n  async tryAlternativePath(category, filename, options) {\n    // Try loading from alternative location based on environment\n    const isDev = process.env.NODE_ENV === 'development';\n    const altCategory = isDev ? 'data' : 'results';\n    const altPath = `${isDev ? '' : process.env.PUBLIC_URL}/${altCategory}/${category}/${filename}`;\n\n    try {\n      const response = await fetch(altPath, options);\n      if (response.ok) {\n        console.debug(`[PathResolver] Successfully loaded from alternative path: ${altPath}`);\n        return response;\n      }\n    } catch (e) {\n      console.warn(`[PathResolver] Alternative path failed: ${altPath}`, e);\n    }\n    return null;\n  }\n\n  async loadFile(category, filename, options = {}) {\n    const response = await this.resolveDataFile(category, filename, options);\n    \n    if (options.contentType === 'csv') {\n      const text = await response.text();\n      return new Promise((resolve, reject) => {\n        Papa.parse(text, {\n          header: true,\n          dynamicTyping: true,\n          skipEmptyLines: true,\n          complete: results => {\n            if (!results.data || results.data.length === 0) {\n              reject(new Error('CSV parsing resulted in empty data'));\n              return;\n            }\n            resolve(results.data);\n          },\n          error: error => reject(new Error(`CSV parsing failed: ${error.message}`))\n        });\n      });\n    }\n    \n    try {\n      const text = await response.text();\n      return JSON.parse(text);\n    } catch (error) {\n      throw new Error(`Failed to parse JSON response: ${error.message}`);\n    }\n  }\n\n  getCommodityPath(commodityName) {\n    const sanitized = this.sanitizeCommodityName(commodityName);\n    const filename = `preprocessed_yemen_market_data_${sanitized}.json`;\n    const category = 'preprocessed_by_commodity';\n    return { category, filename };\n  }\n\n  getCommodityFilePath(commodityName) {\n    const { category, filename } = this.getCommodityPath(commodityName);\n    const isDev = process.env.NODE_ENV === 'development';\n    const baseUrl = isDev ? '' : (process.env.PUBLIC_URL || '/Yemen_Market_Analysis');\n    return `${baseUrl}/${isDev ? 'results' : 'data'}/${category}/${filename}`;\n  }\n\n  sanitizeCommodityName(name) {\n    if (!name) return '';\n    return name\n      .toLowerCase()\n      .trim()\n      .replace(/[()]/g, '')\n      .replace(/\\s+/g, '_')\n      .replace(/[^a-z0-9_]/g, '')\n      .replace(/_+/g, '_')\n      .replace(/^_|_$/g, '');\n  }\n\n  clearCache() {\n    this.cache.clear();\n    this.successPathMap.clear();\n  }\n}\n\n// Initialize singleton\nexport const pathResolver = new PathResolver();",
        "imports": [
          "papaparse"
        ],
        "exports": [
          "pathResolver"
        ],
        "dependencies": [
          "papaparse"
        ]
      },
      {
        "path": "utils/pathValidator.js",
        "content": "class PathValidatorUtility {\n  constructor() {\n    const isDev = process.env.NODE_ENV === 'development';\n    const publicUrl = process.env.PUBLIC_URL || '/Yemen_Market_Analysis';\n\n    this.pathMappings = {\n      development: {\n        base: '/results',\n        api: 'http://localhost:5001/api',\n        static: '/static',\n        data: {\n          preprocessed: '/results/preprocessed_by_commodity',\n          raw: '/results'\n        }\n      },\n      production: {\n        base: publicUrl,\n        static: `${publicUrl}/static`,\n        data: {\n          preprocessed: `${publicUrl}/data/preprocessed_by_commodity`,\n          raw: `${publicUrl}/data`\n        }\n      }\n    };\n\n    this.cache = new Map();\n    this.validPaths = new Set();\n  }\n\n  normalizeCommodityName(name) {\n    if (!name) return '';\n    return name\n      .toLowerCase()\n      .trim()\n      .replace(/[()]/g, '')\n      .replace(/\\s+/g, '_')\n      .replace(/[^a-z0-9_]/g, '')\n      .replace(/_+/g, '_')\n      .replace(/^_|_$/g, '');\n  }\n\n  getCommodityFilePath(commodity, env = process.env.NODE_ENV) {\n    const normalizedName = this.normalizeCommodityName(commodity);\n    const environment = this.detectEnvironment(env);\n    const basePath = this.pathMappings[environment].data.preprocessed;\n    \n    const filePath = `${basePath}/preprocessed_yemen_market_data_${normalizedName}.json`;\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.debug('Generated commodity file path:', {\n        environment,\n        normalizedName,\n        filePath\n      });\n    }\n    \n    return filePath;\n  }\n\n  async validatePath(path) {\n    if (this.validPaths.has(path)) return true;\n    \n    try {\n      const response = await fetch(path, { method: 'HEAD' });\n      const isValid = response.ok;\n      if (isValid) this.validPaths.add(path);\n      return isValid;\n    } catch (error) {\n      console.warn(`Path validation failed for: ${path}`, error);\n      return false;\n    }\n  }\n\n  detectEnvironment(env = process.env.NODE_ENV) {\n    if (window.location.hostname.includes('github.io')) return 'production';\n    if (env === 'production') return 'production';\n    return 'development';\n  }\n\n  async validatePaths() {\n    const env = this.detectEnvironment();\n    const config = this.pathMappings[env];\n    \n    const results = {\n      environment: env,\n      baseUrl: config.base,\n      pathMappings: {},\n      validPaths: [],\n      invalidPaths: [],\n      suggestions: []\n    };\n\n    const testCommodities = ['beans (kidney red)', 'wheat_flour', 'rice_imported'];\n    \n    for (const commodity of testCommodities) {\n      const filePath = this.getCommodityFilePath(commodity, env);\n      const isValid = await this.validatePath(filePath);\n      \n      results.pathMappings[commodity] = {\n        normalized: this.normalizeCommodityName(commodity),\n        filePath,\n        valid: isValid\n      };\n\n      if (isValid) {\n        results.validPaths.push(filePath);\n      } else {\n        results.invalidPaths.push(filePath);\n        \n        // Generate alternative paths\n        const altPaths = this.generateAlternativePaths(commodity, env);\n        for (const altPath of altPaths) {\n          if (await this.validatePath(altPath)) {\n            results.suggestions.push({\n              original: filePath,\n              alternative: altPath,\n              commodity\n            });\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n  generateAlternativePaths(commodity, env) {\n    const normalizedName = this.normalizeCommodityName(commodity);\n    const environment = this.detectEnvironment(env);\n    const altPaths = [];\n\n    // Try different base paths\n    if (environment === 'development') {\n      altPaths.push(\n        `/data/preprocessed_by_commodity/preprocessed_yemen_market_data_${normalizedName}.json`,\n        `/results/preprocessed_by_commodity/preprocessed_yemen_market_data_${normalizedName}.json`\n      );\n    } else {\n      const publicUrl = process.env.PUBLIC_URL || '/Yemen_Market_Analysis';\n      altPaths.push(\n        `${publicUrl}/data/preprocessed_by_commodity/preprocessed_yemen_market_data_${normalizedName}.json`,\n        `${publicUrl}/results/preprocessed_by_commodity/preprocessed_yemen_market_data_${normalizedName}.json`\n      );\n    }\n\n    return altPaths;\n  }\n\n  async validateDataAccess(app) {\n    const results = await this.validatePaths();\n    if (results.invalidPaths.length > 0) {\n      console.warn('Invalid paths detected:', results.invalidPaths);\n      \n      if (results.suggestions.length > 0) {\n        console.info('Path suggestions available:', results.suggestions);\n        this.applyPathSuggestions(app, results.suggestions);\n      }\n    }\n    \n    return results;\n  }\n\n  applyPathSuggestions(app, suggestions) {\n    suggestions.forEach(suggestion => {\n      const { original, alternative } = suggestion;\n      \n      // Add redirect for the original path to the alternative\n      app.get(original, (req, res) => {\n        res.redirect(alternative);\n      });\n    });\n  }\n\n  getStaticPath(filename, env = process.env.NODE_ENV) {\n    const environment = this.detectEnvironment(env);\n    return `${this.pathMappings[environment].static}/${filename}`;\n  }\n\n  clearCache() {\n    this.cache.clear();\n    this.validPaths.clear();\n  }\n}\n\nexport const pathValidator = new PathValidatorUtility();",
        "imports": [],
        "exports": [
          "pathValidator"
        ],
        "dependencies": []
      },
      {
        "path": "utils/polygonNormalizer.js",
        "content": "// src/utils/polygonNormalizer.js\n\nclass PolygonNormalizer {\n  constructor() {\n    // Cache for normalized names\n    this.normalizedNameCache = new Map();\n    this._instance = null;\n  }\n\n  static getInstance() {\n    if (!this._instance) {\n      this._instance = new PolygonNormalizer();\n    }\n    return this._instance;\n  }\n\n  normalizePolygons(polygonFeatures) {\n    if (!Array.isArray(polygonFeatures)) {\n      console.warn('Invalid polygon features provided');\n      return [];\n    }\n  \n    // Add cache check\n    const cacheKey = JSON.stringify(polygonFeatures.map(f => f?.properties?.shapeName));\n    if (this.normalizedNameCache.has(cacheKey)) {\n      return this.normalizedNameCache.get(cacheKey);\n    }\n  \n    const normalized = polygonFeatures.map(feature => {\n      if (!feature?.properties?.shapeName) return feature;\n  \n      const normalizedName = this.getNormalizedName(feature.properties.shapeName);\n      \n      return {\n        ...feature,\n        properties: {\n          ...feature.properties,\n          originalName: feature.properties.shapeName,\n          normalizedName,\n          region_id: normalizedName\n        }\n      };\n    });\n  \n    // Cache the result\n    this.normalizedNameCache.set(cacheKey, normalized);\n    return normalized;\n  }\n\n  getNormalizedName(name) {\n    if (!name) return null;\n  \n    // Check cache first\n    if (this.normalizedNameCache.has(name.toLowerCase())) {\n      return this.normalizedNameCache.get(name.toLowerCase());\n    }\n  \n    // First try exact match with governorate\n    let normalized = name.toLowerCase();\n    const withGovernorate = normalized + (normalized.endsWith(' governorate') ? '' : ' governorate');\n  \n    // Check if there's an exact match in our fixes\n    const exactMatch = this.applyYemenRegionFixes(withGovernorate);\n    if (exactMatch !== withGovernorate) {\n      this.normalizedNameCache.set(name.toLowerCase(), exactMatch);\n      return exactMatch;\n    }\n  \n    // If no exact match, try basic normalization\n    normalized = normalized\n      .replace(/\\s+governorate$/i, '')\n      .replace(/[ʿʾ]/g, \"'\") // Replace both special characters with apostrophe\n      .replace(/['']/g, \"'\")\n      .trim();\n  \n    // Apply specific Yemen region fixes\n    normalized = this.applyYemenRegionFixes(normalized);\n  \n    // Cache the result\n    this.normalizedNameCache.set(name.toLowerCase(), normalized);\n    return normalized;\n  }\n\n  applyYemenRegionFixes(name) {\n    const fixes = {\n      \"'amran governorate\": \"amran\",\n      \"abyan governorate\": \"abyan\",\n      \"'adan governorate\": \"aden\",\n      \"al bayda' governorate\": \"al bayda\",\n      \"ad dali' governorate\": \"al dhale'e\",\n      \"al hudaydah governorate\": \"al hudaydah\",\n      \"al jawf governorate\": \"al jawf\",\n      \"al mahrah governorate\": \"al maharah\",\n      \"al mahwit governorate\": \"al mahwit\",\n      \"san'a'\": \"amanat al asimah\",\n      \"dhamar governorate\": \"dhamar\",\n      \"hadhraumaut\": \"hadramaut\",\n      \"hajjah governorate\": \"hajjah\",\n      \"ibb governorate\": \"ibb\",\n      \"lahij governorate\": \"lahj\",\n      \"ma'rib governorate\": \"marib\",\n      \"raymah governorate\": \"raymah\",\n      \"san'a' governorate\": \"sana'a\",\n      \"shabwah governorate\": \"shabwah\",\n      \"socotra\": \"socotra\",\n      \"ta'izz governorate\": \"taizz\"\n    };\n\n    return fixes[name] || name;\n  }\n\n  matchPolygonsWithPoints(polygons, points) {\n    if (!Array.isArray(polygons) || !Array.isArray(points)) {\n      console.warn('Invalid input for polygon-point matching');\n      return [];\n    }\n\n    const pointsByRegion = new Map();\n    points.forEach(point => {\n      const normalizedName = this.getNormalizedName(point.properties?.admin1);\n      if (normalizedName) {\n        pointsByRegion.set(normalizedName, point);\n      }\n    });\n\n    return polygons.map(polygon => {\n      const normalizedName = polygon.properties?.normalizedName;\n      if (!normalizedName) return polygon;\n\n      const matchingPoint = pointsByRegion.get(normalizedName);\n      if (!matchingPoint) return polygon;\n\n      return {\n        ...polygon,\n        properties: {\n          ...polygon.properties,\n          coordinates: matchingPoint.coordinates,\n          population: matchingPoint.properties?.population,\n          population_percentage: matchingPoint.properties?.population_percentage\n        }\n      };\n    });\n  }\n\n  // Utility method to clear the cache if needed\n  clearCache() {\n    this.normalizedNameCache.clear();\n  }\n}\n\n// Export the class and create a singleton instance using getInstance\nexport const polygonNormalizer = PolygonNormalizer.getInstance();\nexport default PolygonNormalizer;\n",
        "imports": [],
        "exports": [
          "polygonNormalizer",
          "default"
        ],
        "dependencies": []
      },
      {
        "path": "utils/regionMappingValidator.js",
        "content": "// src/utils/regionMappingValidator.js\n\n/**\n * Validate network data without region mapping\n * @param {Array} nodes - Network nodes\n * @param {Array} links - Network links\n * @returns {Object} Validation result\n */\nexport const validateNetworkData = (nodes, links) => {\n  const errors = [];\n  const warnings = [];\n\n  // Check if we have nodes and links\n  if (!nodes?.length) {\n    errors.push('No nodes available');\n  }\n\n  if (!links?.length) {\n    errors.push('No links available');\n  }\n\n  if (errors.length > 0) {\n    return {\n      isValid: false,\n      errors,\n      warnings\n    };\n  }\n\n  // Create a set of node IDs for quick lookup\n  const nodeIds = new Set(nodes.map(n => n.id));\n\n  // Validate links\n  links.forEach((link, index) => {\n    if (!link.source || !link.target) {\n      errors.push(`Link at index ${index} missing source or target`);\n      return;\n    }\n\n    if (!nodeIds.has(link.source)) {\n      warnings.push(`Source node \"${link.source}\" not found for link at index ${index}`);\n    }\n\n    if (!nodeIds.has(link.target)) {\n      warnings.push(`Target node \"${link.target}\" not found for link at index ${index}`);\n    }\n\n    if (!Number.isFinite(link.value)) {\n      warnings.push(`Invalid flow value for link at index ${index}`);\n    }\n  });\n\n  // Check for isolated nodes\n  const connectedNodes = new Set();\n  links.forEach(link => {\n    connectedNodes.add(link.source);\n    connectedNodes.add(link.target);\n  });\n\n  nodes.forEach(node => {\n    if (!connectedNodes.has(node.id)) {\n      warnings.push(`Node \"${node.id}\" is isolated (no connections)`);\n    }\n  });\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  };\n};\n",
        "imports": [],
        "exports": [
          "validateNetworkData"
        ],
        "dependencies": []
      },
      {
        "path": "utils/regressionDataProcessor.js",
        "content": "//src/utils/regressionDataProcessor.js\n\nimport _ from 'lodash';\nimport { spatialHandler } from './spatialDataHandler';\n\n/**\n * Process and validate spatial regression results\n */\nexport const processSpatialRegression = (regressionData) => {\n  return spatialHandler.processRegressionAnalysis(regressionData);\n};\n\n/**\n * Generate summary statistics for visualization\n */\nexport const generateRegressionSummary = (processedResults) => {\n  const { model, spatial, residuals } = processedResults;\n  \n  return {\n    modelFit: {\n      r2: model.statistics.r_squared,\n      adjR2: model.statistics.adj_r_squared,\n      mse: model.statistics.mse,\n      observations: model.statistics.observations,\n      spatialCoef: model.coefficients.spatial_lag_price\n    },\n    spatialDependence: {\n      moranI: spatial.moran_i.I,\n      pValue: spatial.moran_i['p-value'],\n      vifMax: _.maxBy(spatial.vif, 'VIF')?.VIF\n    },\n    residualPatterns: {\n      meanResidual: residuals.global.mean,\n      stdResidual: residuals.global.std,\n      maxAbsResidual: Math.max(\n        Math.abs(residuals.global.max),\n        Math.abs(residuals.global.min)\n      ),\n      regionsWithHighResiduals: Object.entries(residuals.stats)\n        .filter(([_, stats]) => Math.abs(stats.mean) > residuals.global.std)\n        .map(([region]) => region)\n    }\n  };\n};\n",
        "imports": [
          "lodash",
          "./spatialDataHandler"
        ],
        "exports": [
          "processSpatialRegression",
          "generateRegressionSummary"
        ],
        "dependencies": [
          "lodash",
          "./spatialDataHandler"
        ]
      },
      {
        "path": "utils/shockAnalysisDebug.js",
        "content": "// src/utils/shockAnalysisDebug.js\n\nexport const DEBUG_SHOCK_ANALYSIS = {\n  enabled: process.env.NODE_ENV === 'development',\n  \n  log: (message, data = {}) => {\n    if (!DEBUG_SHOCK_ANALYSIS.enabled) return;\n    \n    console.group(`🔍 Shock Analysis: ${message}`);\n    Object.entries(data).forEach(([key, value]) => {\n      console.log(`${key}:`, value);\n    });\n    console.groupEnd();\n  },\n\n  error: (message, error) => {\n    if (!DEBUG_SHOCK_ANALYSIS.enabled) return;\n    \n    console.group(`❌ Shock Analysis Error: ${message}`);\n    console.error(error);\n    console.groupEnd();\n  },\n\n  initializeDebugMonitor: (componentName) => {\n    if (!DEBUG_SHOCK_ANALYSIS.enabled) return { finish: () => {} };\n\n    const startTime = performance.now();\n    console.log(`🏁 ${componentName} render started`);\n\n    return {\n      finish: () => {\n        const duration = performance.now() - startTime;\n        console.log(`✅ ${componentName} render completed in ${duration.toFixed(2)}ms`);\n      }\n    };\n  }\n};\n\nexport const monitorMapPerformance = (componentName) => {\n  if (!DEBUG_SHOCK_ANALYSIS.enabled) return () => {};\n\n  const monitor = {\n    renders: 0,\n    startTime: performance.now(),\n    lastRenderTime: performance.now()\n  };\n\n  console.log(`🗺️ ${componentName} monitoring started`);\n\n  return () => {\n    const totalDuration = performance.now() - monitor.startTime;\n    const avgRenderTime = totalDuration / (monitor.renders || 1);\n\n    console.group(`🗺️ ${componentName} Performance Summary`);\n    console.log('Total renders:', monitor.renders);\n    console.log('Average render time:', avgRenderTime.toFixed(2) + 'ms');\n    console.log('Total monitoring duration:', totalDuration.toFixed(2) + 'ms');\n    console.groupEnd();\n  };\n};\n\nexport const validateShockData = (data) => {\n  if (!DEBUG_SHOCK_ANALYSIS.enabled) return true;\n\n  const issues = [];\n\n  if (!data) {\n    issues.push('Data object is null or undefined');\n    return { valid: false, issues };\n  }\n\n  // Validate required fields\n  const requiredFields = ['timeSeriesData', 'marketShocks', 'spatialAutocorrelation'];\n  requiredFields.forEach(field => {\n    if (!data[field]) {\n      issues.push(`Missing required field: ${field}`);\n    }\n  });\n\n  // Validate time series data\n  if (Array.isArray(data.timeSeriesData)) {\n    data.timeSeriesData.forEach((entry, index) => {\n      if (!entry.region || !entry.month || typeof entry.usdPrice !== 'number') {\n        issues.push(`Invalid time series entry at index ${index}`);\n      }\n    });\n  }\n\n  // Validate market shocks\n  if (Array.isArray(data.marketShocks)) {\n    data.marketShocks.forEach((shock, index) => {\n      if (!shock.region || !shock.date || typeof shock.magnitude !== 'number') {\n        issues.push(`Invalid shock entry at index ${index}`);\n      }\n    });\n  }\n\n  // Validate spatial autocorrelation\n  if (data.spatialAutocorrelation) {\n    if (!data.spatialAutocorrelation.global || !data.spatialAutocorrelation.local) {\n      issues.push('Invalid spatial autocorrelation structure');\n    }\n  }\n\n  return {\n    valid: issues.length === 0,\n    issues\n  };\n};\n\nexport default {\n  DEBUG_SHOCK_ANALYSIS,\n  monitorMapPerformance,\n  validateShockData\n};",
        "imports": [],
        "exports": [
          "DEBUG_SHOCK_ANALYSIS",
          "monitorMapPerformance",
          "validateShockData",
          "default"
        ],
        "dependencies": []
      },
      {
        "path": "utils/spatialAnalysisUtils.js",
        "content": "// src/utils/spatialAnalysisUtils.js\n\n/**\n * Calculate Moran's I spatial autocorrelation\n * @param {Array} values - Array of values\n * @param {Object} weights - Spatial weights matrix\n * @returns {Object} Moran's I statistics\n */\nexport const calculateMoranI = (values, weights) => {\n  if (!values?.length || !weights) return { moran_i: 0, p_value: 1 };\n\n  const n = values.length;\n  const mean = values.reduce((sum, val) => sum + val, 0) / n;\n  \n  let numerator = 0;\n  let denominator = 0;\n  let totalWeights = 0;\n\n  // Calculate numerator and weights sum\n  Object.entries(weights).forEach(([i, neighbors]) => {\n    Object.entries(neighbors).forEach(([j, weight]) => {\n      numerator += weight * (values[i] - mean) * (values[j] - mean);\n      totalWeights += weight;\n    });\n  });\n\n  // Calculate denominator (variance)\n  denominator = values.reduce((sum, val) => \n    sum + Math.pow(val - mean, 2), 0\n  );\n\n  const moranI = (n / totalWeights) * (numerator / denominator);\n\n  // Calculate expected value and variance for significance test\n  const expectedI = -1 / (n - 1);\n  const variance = calculateMoranVariance(weights, values, mean, expectedI);\n  const zScore = (moranI - expectedI) / Math.sqrt(variance);\n  const pValue = calculatePValue(zScore);\n\n  return {\n    moran_i: moranI,\n    expected: expectedI,\n    variance,\n    z_score: zScore,\n    p_value: pValue\n  };\n};\n\n/**\n * Calculate variance for Moran's I\n * @private\n */\nconst calculateMoranVariance = (weights, values, mean, expectedI) => {\n  const n = values.length;\n  const s2 = values.reduce((sum, val) => \n    sum + Math.pow(val - mean, 2), 0\n  ) / n;\n\n  let s0 = 0, s1 = 0, s2_w = 0;\n\n  Object.entries(weights).forEach(([i, neighbors]) => {\n    Object.entries(neighbors).forEach(([j, weight]) => {\n      s0 += weight;\n      s1 += Math.pow(weight + weights[j]?.[i] || 0, 2);\n      s2_w += weight + weights[j]?.[i] || 0;\n    });\n  });\n\n  const a = (n * ((n * n - 3 * n + 3) * s1 - n * s2_w + 3 * s0 * s0));\n  const b = (s2 * ((n * n - n) * s1 - 2 * n * s2_w + 6 * s0 * s0));\n  const c = ((n - 1) * (n - 2) * (n - 3) * s0 * s0);\n\n  return (a - b) / c - expectedI * expectedI;\n};\n\n/**\n * Calculate p-value from z-score\n * @private\n */\nconst calculatePValue = (zScore) => {\n  // Using normal distribution approximation\n  const x = Math.abs(zScore);\n  const t = 1 / (1 + 0.2316419 * x);\n  const d = 0.3989423 * Math.exp(-x * x / 2);\n  const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + \n      t * (-1.821256 + t * 1.330274))));\n  return 2 * (1 - p); // Two-tailed test\n};\n\n/**\n * Calculate local indicators of spatial association (LISA)\n * @param {Array} values - Array of values\n * @param {Object} weights - Spatial weights matrix\n * @returns {Array} LISA statistics for each location\n */\nexport const calculateLISA = (values, weights) => {\n  if (!values?.length || !weights) return [];\n\n  const n = values.length;\n  const mean = values.reduce((sum, val) => sum + val, 0) / n;\n  const variance = values.reduce((sum, val) => \n    sum + Math.pow(val - mean, 2), 0\n  ) / n;\n\n  return Object.entries(weights).map(([i, neighbors]) => {\n    const localSum = Object.entries(neighbors).reduce((sum, [j, weight]) => \n      sum + weight * (values[j] - mean), 0\n    );\n\n    const localI = ((values[i] - mean) / variance) * localSum;\n    const expectedI = -1 / (n - 1);\n    const variance_i = calculateLocalVariance(weights[i], values, mean, variance);\n    const zScore = (localI - expectedI) / Math.sqrt(variance_i);\n    const pValue = calculatePValue(zScore);\n\n    return {\n      location: i,\n      local_i: localI,\n      z_score: zScore,\n      p_value: pValue,\n      cluster_type: determineClusterType(values[i], mean, localSum, pValue)\n    };\n  });\n};\n\n/**\n * Calculate variance for local Moran's I\n * @private\n */\nconst calculateLocalVariance = (weights, values, mean, variance) => {\n  const n = values.length;\n  let w_sum = 0, w2_sum = 0;\n\n  Object.values(weights).forEach(weight => {\n    w_sum += weight;\n    w2_sum += weight * weight;\n  });\n\n  const b2 = values.reduce((sum, val) => \n    sum + Math.pow(val - mean, 4), 0\n  ) / (n * Math.pow(variance, 2));\n\n  return (w2_sum * (n - b2)) / (n - 1);\n};\n\n/**\n * Determine cluster type based on LISA statistics\n * @private\n */\nconst determineClusterType = (value, mean, localSum, pValue) => {\n  if (pValue >= 0.05) return 'not_significant';\n\n  const highLow = value > mean ? 'high' : 'low';\n  const neighborHighLow = localSum > 0 ? 'high' : 'low';\n\n  return `${highLow}-${neighborHighLow}`;\n};\n\n/**\n * Calculate market integration index\n * @param {Array} prices - Array of price time series\n * @param {Object} weights - Spatial weights matrix\n * @returns {Object} Market integration metrics\n */\nexport const calculateMarketIntegration = (prices, weights) => {\n  if (!prices?.length || !weights) return null;\n\n  // Calculate price correlations\n  const correlations = {};\n  prices.forEach((series1, i) => {\n    correlations[i] = {};\n    prices.forEach((series2, j) => {\n      if (i !== j) {\n        correlations[i][j] = calculateCorrelation(series1, series2);\n      }\n    });\n  });\n\n  // Calculate spatial price integration\n  const spatialIntegration = calculateMoranI(\n    prices.map(series => series[series.length - 1]),\n    weights\n  );\n\n  // Calculate market accessibility\n  const accessibility = calculateAccessibility(correlations, weights);\n\n  return {\n    correlations,\n    spatialIntegration,\n    accessibility,\n    overall: (\n      Object.values(accessibility).reduce((sum, val) => sum + val, 0) / \n      Object.keys(accessibility).length\n    )\n  };\n};\n\n/**\n * Calculate correlation between two time series\n * @private\n */\nconst calculateCorrelation = (series1, series2) => {\n  const n = Math.min(series1.length, series2.length);\n  const mean1 = series1.reduce((sum, val) => sum + val, 0) / n;\n  const mean2 = series2.reduce((sum, val) => sum + val, 0) / n;\n\n  let numerator = 0;\n  let denom1 = 0;\n  let denom2 = 0;\n\n  for (let i = 0; i < n; i++) {\n    const diff1 = series1[i] - mean1;\n    const diff2 = series2[i] - mean2;\n    numerator += diff1 * diff2;\n    denom1 += diff1 * diff1;\n    denom2 += diff2 * diff2;\n  }\n\n  return numerator / Math.sqrt(denom1 * denom2);\n};\n\n/**\n * Calculate market accessibility scores\n * @private\n */\nconst calculateAccessibility = (correlations, weights) => {\n  const accessibility = {};\n\n  Object.keys(correlations).forEach(market => {\n    const neighbors = weights[market] || {};\n    let weightedSum = 0;\n    let weightSum = 0;\n\n    Object.entries(neighbors).forEach(([neighbor, weight]) => {\n      weightedSum += (correlations[market]?.[neighbor] || 0) * weight;\n      weightSum += weight;\n    });\n\n    accessibility[market] = weightSum > 0 ? weightedSum / weightSum : 0;\n  });\n\n  return accessibility;\n};\n",
        "imports": [],
        "exports": [
          "calculateMoranI",
          "calculateLISA",
          "calculateMarketIntegration"
        ],
        "dependencies": []
      },
      {
        "path": "utils/spatialDataHandler.js",
        "content": "import Papa from 'papaparse';\nimport _ from 'lodash';\nimport { excludedRegions } from './appUtils';\nimport { \n  getPrecomputedDataPath, \n  getNetworkDataPath,\n  getChoroplethDataPath,\n  enhancedFetchJson,\n  getDataPath,\n  getRegressionDataPath\n} from './dataUtils';\nimport { pathResolver } from './pathResolver';\nimport { pathValidator } from './pathValidator';\nimport { DEFAULT_REGRESSION_DATA } from '../types/dataTypes';\nimport { VISUALIZATION_MODES } from '../constants/index';\nimport { workerManager } from './workerManager';\nimport { backgroundMonitor } from './backgroundMonitor';  // Add this import\nimport PolygonNormalizer, { polygonNormalizer } from './polygonNormalizer';\n\n// ===========================\n// Environment and Path Constants\n// ===========================\n\n// Environment and Path Constants\nconst isDev = process.env.NODE_ENV === 'development';\nconst BASE_URL = isDev ? '' : (process.env.PUBLIC_URL || '/Yemen_Market_Analysis');\nconst DATA_PATH = isDev ? '/results' : `${BASE_URL}/data`;\n\n// Default GeoJSON structure\nconst DEFAULT_GEOJSON = {\n  type: 'FeatureCollection',\n  features: [],\n  crs: {\n    type: 'name',\n    properties: {\n      name: 'urn:ogc:def:crs:OGC:1.3:CRS84'\n    }\n  }\n};\n\nclass SpatialDataHandler {\n  static _pendingRequests = new Map();\n  static _instance = null;\n\n  static getInstance() {\n    if (!SpatialDataHandler._instance) {\n      SpatialDataHandler._instance = new SpatialDataHandler();\n    }\n    return SpatialDataHandler._instance;\n  }\n\n  constructor() {\n    if (SpatialDataHandler._instance) {\n      return SpatialDataHandler._instance;\n    }\n\n    this.cache = new Map();\n    this.geometryCache = null;      // For polygon boundaries\n    this.pointCache = null;         // For market point locations\n    this.coordinateCache = new Map(); // For normalized coordinates\n    this.regionMappingCache = new Map();\n    this.excludedRegions = new Set(\n      excludedRegions.map((region) => polygonNormalizer.getNormalizedName(region))\n    );\n    this.defaultGeoJSON = DEFAULT_GEOJSON;\n    this.missingGeometryWarnings = new Set();\n    this.debugMode = process.env.NODE_ENV === 'development';\n    this.cacheConfig = {\n      TTL: 3600000, // 1 hour\n      maxSize: 100, // Maximum number of cached items\n      cleanupInterval: 300000 // 5 minutes\n    };\n    \n    // Start cache cleanup interval\n    if (typeof window !== 'undefined') {\n      setInterval(() => this.cleanupCache(), this.cacheConfig.cleanupInterval);\n    }\n  }\n\n  async deduplicateRequest(key, requestFn) {\n    if (SpatialDataHandler._pendingRequests.has(key)) {\n      return SpatialDataHandler._pendingRequests.get(key);\n    }\n  \n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.cacheConfig.TTL) {\n      return cached.data;\n    }\n  \n    const request = requestFn().then(data => {\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now()\n      });\n      SpatialDataHandler._pendingRequests.delete(key);\n      return data;\n    }).catch(error => {\n      SpatialDataHandler._pendingRequests.delete(key);\n      throw error;\n    });\n  \n    SpatialDataHandler._pendingRequests.set(key, request);\n    return request;\n  }\n\n  // ===========================\n  // Cache Management\n  // ===========================\n\n  cleanupCache = () => {\n    const now = Date.now();\n    for (const [key, value] of this.cache.entries()) {\n      if (now - value.timestamp > this.cacheConfig.TTL) {\n        this.cache.delete(key);\n      }\n    }\n  };\n\n  clearCache = () => {\n    this.cache.clear();\n    this.geometryCache = null;\n    this.regionMappingCache.clear();\n    this.coordinateCache.clear();\n    this.pointCache = null;\n  };\n\n  // ===========================\n  // Normalization Methods\n  // ===========================\n\n  convertUTMtoLatLng = (easting, northing) => {\n    // Constants for UTM Zone 38N to WGS84 conversion\n    const k0 = 0.9996;\n    const a = 6378137;\n    const e = 0.081819191;\n    const e1sq = 0.006739497;\n    const falseEasting = 500000;\n    const zone = 38;\n\n    const x = easting - falseEasting;\n    const y = northing;\n\n    const M = y / k0;\n    const mu = M / (a * (1 - e * e / 4 - 3 * e * e * e * e / 64));\n\n    const phi1 = mu + (3 * e1sq / 2 - 27 * Math.pow(e1sq, 3) / 32) * Math.sin(2 * mu);\n    const phi2 = phi1 + (21 * Math.pow(e1sq, 2) / 16 - 55 * Math.pow(e1sq, 4) / 32) * Math.sin(4 * mu);\n    const phi = phi2 + (151 * Math.pow(e1sq, 3) / 96) * Math.sin(6 * mu);\n\n    const N1 = a / Math.sqrt(1 - e * e * Math.sin(phi) * Math.sin(phi));\n    const T1 = Math.tan(phi) * Math.tan(phi);\n    const C1 = (e * e * Math.cos(phi) * Math.cos(phi)) / (1 - e * e);\n    const R1 = (a * (1 - e * e)) / Math.pow(1 - e * e * Math.sin(phi) * Math.sin(phi), 1.5);\n    const D = x / (N1 * k0);\n\n    const lat = phi - (N1 * Math.tan(phi) / R1) * (\n      (D * D) / 2 -\n      (5 + 3 * T1 + 10 * C1 - 4 * Math.pow(C1, 2) - 9 * e * e) * Math.pow(D, 4) / 24 +\n      (61 + 90 * T1 + 298 * C1 + 45 * Math.pow(T1, 2) - 252 * e * e - 3 * Math.pow(C1, 2)) * Math.pow(D, 6) / 720\n    );\n    const lon = ((zone * 6 - 183) + (D - (1 + 2 * T1 + C1) * Math.pow(D, 3) / 6 +\n      (5 - 2 * C1 + 28 * T1 - 3 * Math.pow(C1, 2) + 8 * e * e + 24 * Math.pow(T1, 2)) * Math.pow(D, 5) / 120)\n    ) / Math.cos(phi) * (180 / Math.PI);\n\n    return {\n      lat: lat * (180 / Math.PI),\n      lng: lon\n    };\n  };\n\n  normalizeRegionName = (name) => {\n    if (!name) return null;\n    return polygonNormalizer.getNormalizedName(name);\n  };\n\n  normalizeCommodityName = (commodity) => {\n    if (!commodity) return '';\n    return commodity.toLowerCase()\n      .replace(/[()]/g, '') \n      .replace(/\\s+/g, '_')\n      .trim();\n  };\n\n  // ===========================\n  // Validation Methods\n  // ===========================\n\n  validateGeoJSON = (data) => {\n    if (!data || typeof data !== 'object') return false;\n    if (data.type !== 'FeatureCollection') return false;\n    if (!Array.isArray(data.features)) return false;\n    if (data.features.length === 0) return false;\n\n    // Check first feature structure\n    const firstFeature = data.features[0];\n    if (!firstFeature.type || !firstFeature.properties || !firstFeature.geometry) {\n      return false;\n    }\n\n    return true;\n  };\n\n  validateFlowData = (flows) => {\n    if (!Array.isArray(flows)) return false;\n    \n    const validations = flows.map(flow => {\n      const sourceValid = this.validateMarket(flow.source);\n      const targetValid = this.validateMarket(flow.target);\n      const metricsValid = this.validateFlowMetrics(flow);\n      \n      return {\n        valid: sourceValid && targetValid && metricsValid,\n        source: sourceValid,\n        target: targetValid,\n        metrics: metricsValid,\n        messages: []\n      };\n    });\n  \n    return {\n      valid: validations.every(v => v.valid),\n      details: validations\n    };\n  };\n\n  validateMarket = (market) => {\n    const normalized = this.normalizeRegionName(market);\n    return (\n      normalized &&\n      !this.excludedRegions.has(normalized) &&\n      this.coordinateCache.has(normalized)\n    );\n  };\n\n  validateFlowMetrics = (flow) => {\n    return (\n      typeof flow.flow_weight === 'number' &&\n      flow.flow_weight >= 0 &&\n      typeof flow.flow_count === 'number' &&\n      flow.flow_count > 0\n    );\n  };\n\n  validatePreprocessedData = (data) => {\n    if (!data || typeof data !== 'object') return false;\n    \n    const required = [\n      'time_series_data',\n      'market_clusters',\n      'market_shocks',\n      'spatial_autocorrelation',\n      'market_integration'\n    ];\n  \n    // Enhanced validation\n    const validation = {\n      missingFields: required.filter(field => !data[field]),\n      invalidTypes: required.filter(field => {\n        const value = data[field];\n        switch (field) {\n          case 'time_series_data':\n            return !Array.isArray(value);\n          case 'market_clusters':\n            return !Array.isArray(value);\n          case 'market_shocks':\n            return !Array.isArray(value);\n          case 'spatial_autocorrelation':\n            return !value?.global || !value?.local;\n          case 'market_integration':\n            return !value?.price_correlation;\n          default:\n            return false;\n        }\n      })\n    };\n  \n    if (validation.missingFields.length > 0) {\n      console.warn('Missing required fields:', validation.missingFields);\n      return false;\n    }\n  \n    if (validation.invalidTypes.length > 0) {\n      console.warn('Invalid field types:', validation.invalidTypes);\n      return false;\n    }\n  \n    return true;\n  };\n\n  validateRegressionData = (data) => {\n    if (!data?.model || !data?.spatial || !data?.residuals) {\n      console.warn('Missing required regression data sections');\n      return false;\n    }\n  \n    // Validate model section\n    const modelValid = (\n      typeof data.model.r_squared === 'number' &&\n      typeof data.model.adj_r_squared === 'number' &&\n      typeof data.model.mse === 'number' &&\n      typeof data.model.intercept === 'number' &&\n      typeof data.model.observations === 'number' &&\n      data.model.coefficients &&\n      Object.keys(data.model.coefficients).length > 0\n    );\n  \n    if (!modelValid) {\n      console.warn('Invalid model structure');\n      return false;\n    }\n  \n    // Validate spatial section\n    const spatialValid = (\n      data.spatial.moran_i &&\n      typeof data.spatial.moran_i.I === 'number' &&\n      typeof data.spatial.moran_i['p-value'] === 'number' &&\n      Array.isArray(data.spatial.vif)\n    );\n  \n    if (!spatialValid) {\n      console.warn('Invalid spatial structure');\n      return false;\n    }\n  \n    // Validate residuals section\n    const residualsValid = (\n      Array.isArray(data.residuals.raw) &&\n      typeof data.residuals.byRegion === 'object' &&\n      data.residuals.stats &&\n      typeof data.residuals.stats.mean === 'number' &&\n      typeof data.residuals.stats.variance === 'number' &&\n      typeof data.residuals.stats.maxAbsolute === 'number'\n    );\n  \n    if (!residualsValid) {\n      console.warn('Invalid residuals structure');\n      return false;\n    }\n  \n    return true;\n  };\n\n  validateMarketClusters = (clusters) => {\n    return clusters.every(cluster => (\n      cluster.main_market && \n      Array.isArray(cluster.connected_markets) &&\n      this.validateMarketConnections(cluster)\n    ));\n  };\n\n  validateMarketConnections = (cluster) => {\n    // Implement specific validation logic if needed\n    return true;\n  };\n\n  // ===========================\n  // Data Initialization\n  // ===========================\n\n  initializeGeometry = async () => {\n    if (this.geometryCache && this.geometryCache.size > 0) {\n      return this.geometryCache;\n    }\n  \n    try {\n      const geojsonPath = isDev\n        ? '/results/geoBoundaries-YEM-ADM1.geojson'\n        : `${BASE_URL}/data/geoBoundaries-YEM-ADM1.geojson`;\n\n      const response = await fetch(geojsonPath);\n      if (!response.ok) {\n        // Try fallback path\n        const fallbackPath = isDev\n          ? '/data/geoBoundaries-YEM-ADM1.geojson'\n          : `${BASE_URL}/results/geoBoundaries-YEM-ADM1.geojson`;\n          \n        const fallbackResponse = await fetch(fallbackPath);\n        if (!fallbackResponse.ok) {\n          throw new Error(`Failed to load geometry from both paths: ${geojsonPath} and ${fallbackPath}`);\n        }\n        return this.processGeometryResponse(fallbackResponse);\n      }\n  \n      return this.processGeometryResponse(response);\n    } catch (error) {\n      console.error('Failed to initialize geometry:', error);\n      throw error;\n    }\n  };\n\n  processGeometryResponse = async (response) => {\n    const polygonData = await response.json();\n    if (!this.geometryCache) {\n      this.geometryCache = new Map();\n    }\n  \n    const processedFeatures = new Map();\n  \n    polygonData.features.forEach(feature => {\n      if (!feature?.properties?.shapeName) return;\n  \n      const normalizedName = polygonNormalizer.getNormalizedName(feature.properties.shapeName);\n      if (!normalizedName) {\n        console.warn('Unable to normalize region name:', feature.properties.shapeName);\n        return;\n      }\n  \n      if (!processedFeatures.has(normalizedName)) {\n        processedFeatures.set(normalizedName, {\n          type: 'polygon',\n          geometry: feature.geometry,\n          properties: {\n            originalName: feature.properties.shapeName,\n            normalizedName,\n            shapeISO: feature.properties.shapeISO,\n            region_id: normalizedName\n          },\n        });\n      }\n    });\n  \n    this.geometryCache = processedFeatures;\n    this.updateMappingCache(processedFeatures);\n    return this.geometryCache;\n  };\n\n  updateMappingCache = (processedFeatures) => {\n    processedFeatures.forEach((value, key) => {\n      this.regionMappingCache.set(value.properties.originalName.toLowerCase(), key);\n      this.regionMappingCache.set(key, key);\n    });\n  };\n\n  initializePoints = async () => {\n    if (this.pointCache) return this.pointCache;\n\n    try {\n      const pointsPath = isDev\n        ? '/results/unified_data.geojson'\n        : `${BASE_URL}/data/unified_data.geojson`;\n\n      const response = await fetch(pointsPath);\n      if (!response.ok) {\n        // Try fallback path\n        const fallbackPath = isDev\n          ? '/data/unified_data.geojson'\n          : `${BASE_URL}/results/unified_data.geojson`;\n          \n        const fallbackResponse = await fetch(fallbackPath);\n        if (!fallbackResponse.ok) {\n          throw new Error(`Failed to load points from both paths: ${pointsPath} and ${fallbackPath}`);\n        }\n        return this.processPointsResponse(fallbackResponse);\n      }\n\n      return this.processPointsResponse(response);\n\n    } catch (error) {\n      console.error('Failed to initialize points:', error);\n      throw error;\n    }\n  };\n\n  processPointsResponse = async (response) => {\n    const pointData = await response.json();\n    this.pointCache = new Map();\n\n    const processFeature = (feature) => {\n      if (!feature?.properties?.admin1) return null;\n\n      const normalizedName = this.normalizeRegionName(feature.properties.admin1);\n      if (!normalizedName) return null;\n\n      const utmCoords = feature.geometry.coordinates;\n      const latLng = this.convertUTMtoLatLng(utmCoords[0], utmCoords[1]);\n\n      return {\n        type: 'point',\n        coordinates: [latLng.lng, latLng.lat],\n        properties: {\n          originalName: feature.properties.admin1,\n          normalizedName,\n          population: feature.properties.population,\n          population_percentage: feature.properties.population_percentage\n        }\n      };\n    };\n\n    // Process features in chunks\n    const chunkSize = 1000;\n    const features = pointData.features || [];\n    \n    for (let i = 0; i < features.length; i += chunkSize) {\n      const chunk = features.slice(i, i + chunkSize);\n      chunk.forEach(feature => {\n        const processed = processFeature(feature);\n        if (processed) {\n          this.pointCache.set(processed.properties.normalizedName, processed);\n          this.coordinateCache.set(processed.properties.normalizedName, processed.coordinates);\n        }\n      });\n    }\n\n    return this.pointCache;\n  };\n\n  initializeCoordinates = async () => {\n    if (this.coordinateCache.size > 0) return;\n    \n    try {\n      const geojsonData = await this.initializeGeometry();\n      \n      // Process coordinates from GeoJSON features\n      geojsonData.forEach(feature => {\n        const regionName = this.normalizeRegionName(\n          feature.properties?.shapeName\n        );\n        if (regionName && feature.geometry?.coordinates) {\n          // Store centroid for region\n          const centroid = this.calculateCentroid(\n            feature.geometry.coordinates\n          );\n          this.coordinateCache.set(regionName, centroid);\n        }\n      });\n    } catch (error) {\n      console.error('[SpatialHandler] Failed to initialize coordinates:', error);\n      throw error;\n    }\n  };\n\n  // ===========================\n  // Centroid Calculation\n  // ===========================\n\n  calculateCentroid = (coordinates) => {\n    try {\n      if (!Array.isArray(coordinates)) {\n        console.warn('[SpatialHandler] Invalid coordinates format');\n        return null;\n      }\n\n      // MultiPolygon handling\n      if (Array.isArray(coordinates[0][0][0])) {\n        const allPoints = coordinates.flat(2);\n        const centroid = this.calculateCentroidFromPoints(allPoints);\n        return this.convertUTMtoLatLng(centroid.x, centroid.y);\n      }\n      \n      // Polygon handling\n      if (Array.isArray(coordinates[0][0])) {\n        const centroid = this.calculateCentroidFromPoints(coordinates[0]);\n        return this.convertUTMtoLatLng(centroid.x, centroid.y);\n      }\n\n      return null;\n    } catch (error) {\n      console.error('[SpatialHandler] Centroid calculation failed:', error);\n      return null;\n    }\n  };\n\n  calculateCentroidFromPoints = (points) => {\n    if (!Array.isArray(points) || points.length === 0) return null;\n\n    let sumX = 0;\n    let sumY = 0;\n    let count = 0;\n\n    for (const point of points) {\n      if (Array.isArray(point) && point.length >= 2) {\n        sumX += point[0];\n        sumY += point[1];\n        count++;\n      }\n    }\n\n    if (count === 0) return null;\n\n    return {\n      x: sumX / count,\n      y: sumY / count\n    };\n  };\n\n  // ===========================\n  // Data Loading Methods\n  // ===========================\n\n  loadPreprocessedData = async (commodity) => {\n    try {\n      const normalizedCommodity = this.normalizeCommodityName(commodity);\n      const fileName = `preprocessed_yemen_market_data_${normalizedCommodity}.json`;\n      const filePath = isDev \n        ? `/results/preprocessed_by_commodity/${fileName}`\n        : `${BASE_URL}/data/preprocessed_by_commodity/${fileName}`;\n      \n      console.debug('Loading preprocessed data from:', {\n        normalizedCommodity,\n        filePath,\n        environment: process.env.NODE_ENV\n      });\n  \n      const response = await fetch(filePath);\n      if (!response.ok) {\n        // Try fallback path if main path fails\n        const fallbackPath = isDev \n          ? `/data/preprocessed_by_commodity/${fileName}`\n          : `${BASE_URL}/results/preprocessed_by_commodity/${fileName}`;\n          \n        const fallbackResponse = await fetch(fallbackPath);\n        if (!fallbackResponse.ok) {\n          throw new Error(`Failed to load data from both paths: ${filePath} and ${fallbackPath}`);\n        }\n        return this.processPreprocessedResponse(fallbackResponse);\n      }\n      \n      return this.processPreprocessedResponse(response);\n    } catch (error) {\n      console.error('Preprocessed data load failed:', error);\n      throw error;\n    }\n  };\n\n  processPreprocessedResponse = async (response) => {\n    const text = await response.text();\n    const sanitizedText = this.sanitizeJsonText(text);\n    \n    try {\n      const data = JSON.parse(sanitizedText);\n      if (!this.validatePreprocessedData(data)) {\n        throw new Error('Invalid data structure');\n      }\n      return this.enhanceWithRealtimeMetrics(data);\n    } catch (parseError) {\n      console.error('JSON parse error:', parseError);\n      throw new Error('Failed to parse data: ' + parseError.message);\n    }\n  };\n  \n  loadFlowDataWithRecovery = async (commodity) => {\n    try {\n      const data = await this.loadFlowData(commodity);\n      return data;\n    } catch (error) {\n      console.error('[SpatialHandler] Flow data load failed:', error);\n      \n      // Attempt recovery from backup or alternative source\n      try {\n        const backupData = await this.loadBackupFlowData(commodity);\n        return backupData;\n      } catch (backupError) {\n        console.error('[SpatialHandler] Backup flow data load failed:', backupError);\n        return [];\n      }\n    }\n  };\n  \n  loadFlowData = async (commodity) => {\n    try {\n      // Get precomputed data path\n      const preprocessedPath = getPrecomputedDataPath(commodity);\n      \n      // Use the cache if available\n      const cacheKey = `flow_${commodity}`;\n      const cachedData = this.cache.get(cacheKey);\n      if (cachedData) {\n        return cachedData.data;\n      }\n      \n      const response = await fetch(preprocessedPath);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      \n      if (!data.flow_analysis) {\n        throw new Error('Flow analysis data not found in preprocessed file');\n      }\n      \n      // Process flow data\n      const processedFlows = this.processFlowAnalysis(data.flow_analysis);\n      \n      // Cache the results\n      this.cache.set(cacheKey, {\n        data: processedFlows,\n        timestamp: Date.now()\n      });\n      \n      return processedFlows;\n      \n    } catch (error) {\n      console.error('[SpatialHandler] Failed to load flow data:', error);\n      throw error;\n    }\n  };\n  \n  loadBackupFlowData = async (commodity) => {\n    try {\n      const normalizedCommodity = this.normalizeCommodityName(commodity);\n      const fileName = `backup_flow_data_${normalizedCommodity}.json`;\n      const backupPath = `${DATA_PATH}/backup_flow_data/${fileName}`;\n      \n      const response = await fetch(backupPath);\n      if (!response.ok) {\n        throw new Error(`Backup HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      return this.processFlowAnalysis(data.flow_analysis);\n    } catch (error) {\n      console.error('[SpatialHandler] Failed to load backup flow data:', error);\n      throw error;\n    }\n  };\n\n  async loadRegressionAnalysis(selectedCommodity) {\n    let metric;\n    try {\n      if (!selectedCommodity) {\n        console.warn('No commodity selected for regression analysis');\n        return DEFAULT_REGRESSION_DATA;\n      }\n      \n      metric = backgroundMonitor.startMetric('regression-data-fetch', {\n        commodity: selectedCommodity,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Get the cache key\n      const cacheKey = `regression_${selectedCommodity}`;\n      const cached = this.cache.get(cacheKey);\n      \n      if (cached?.data) {\n        console.debug('Using cached regression data for:', selectedCommodity);\n        metric?.finish({ status: 'cache-hit' });\n        return cached.data;\n      }\n      \n      // Define the path to spatial_analysis_results.json\n      const analysisPath = isDev\n        ? '/data/spatial_analysis_results.json'\n        : `${BASE_URL}/data/spatial_analysis_results.json`;\n      \n      console.debug('Loading regression data from:', analysisPath);\n      \n      // Fetch the data\n      const response = await fetch(analysisPath);\n      if (!response.ok) {\n        throw new Error(`Failed to load spatial analysis data: ${response.statusText}`);\n      }\n      \n      const text = await response.text();\n      \n      // Parse the JSON text\n      let parsedData;\n      try {\n        parsedData = JSON.parse(text);\n        if (!Array.isArray(parsedData)) {\n          throw new Error('Invalid data format: expected array');\n        }\n      } catch (parseError) {\n        console.error('JSON parse error:', parseError);\n        backgroundMonitor.logError('regression-parse-error', {\n          error: parseError.message,\n          commodity: selectedCommodity,\n          path: analysisPath\n        });\n        throw parseError;\n      }\n      \n      // Find matching commodity data\n      const commodityAnalysis = parsedData.find(item => \n        this.normalizeCommodityName(item.commodity) === this.normalizeCommodityName(selectedCommodity)\n      );\n      \n      if (!commodityAnalysis) {\n        throw new Error(`No analysis found for commodity: ${selectedCommodity}`);\n      }\n      \n      // Transform the data to match our expected format\n      const processedAnalysis = {\n        model: {\n          coefficients: commodityAnalysis.coefficients || {},\n          intercept: this.sanitizeNumericValue(commodityAnalysis.intercept),\n          p_values: commodityAnalysis.p_values || {},\n          r_squared: this.sanitizeNumericValue(commodityAnalysis.r_squared),\n          adj_r_squared: this.sanitizeNumericValue(commodityAnalysis.adj_r_squared),\n          mse: this.sanitizeNumericValue(commodityAnalysis.mse),\n          observations: commodityAnalysis.observations || 0\n        },\n        spatial: {\n          moran_i: commodityAnalysis.moran_i || { I: 0, 'p-value': 1 },\n          vif: Array.isArray(commodityAnalysis.vif) ? commodityAnalysis.vif : []\n        },\n        residuals: {\n          raw: commodityAnalysis.residual || [],\n          byRegion: this.processResidualsByRegion(commodityAnalysis.residual || []),\n          stats: this.calculateResidualStats(commodityAnalysis.residual || [])\n        },\n        metadata: {\n          commodity: selectedCommodity,\n          regime: commodityAnalysis.regime || 'unified',\n          timestamp: new Date().toISOString(),\n          version: \"1.0\"\n        }\n      };\n      \n      // Validate before caching\n      if (!this.validateRegressionData(processedAnalysis)) {\n        throw new Error('Invalid regression data structure after processing');\n      }\n      \n      // Cache the valid results\n      this.cache.set(cacheKey, {\n        data: processedAnalysis,\n        timestamp: Date.now()\n      });\n      \n      metric?.finish({ \n        status: 'success',\n        dataPoints: processedAnalysis.model.observations,\n        hasResiduals: processedAnalysis.residuals.raw.length > 0\n      });\n      \n      return processedAnalysis;\n      \n    } catch (error) {\n      console.error('Failed to load regression analysis:', error);\n      backgroundMonitor.logError('regression-load-error', {\n        error: error.message,\n        commodity: selectedCommodity,\n        stack: error.stack\n      });\n      metric?.finish({ \n        status: 'error', \n        error: error.message,\n        commodity: selectedCommodity\n      });\n      return DEFAULT_REGRESSION_DATA;\n    }\n  }\n  \n  // Helper function to process residuals by region\n  processResidualsByRegion(residuals) {\n    return residuals.reduce((acc, residual) => {\n      const region = residual.region_id;\n      if (!acc[region]) {\n        acc[region] = [];\n      }\n      acc[region].push({\n        date: residual.date,\n        residual: residual.residual\n      });\n      return acc;\n    }, {});\n  }\n  \n  // Helper function to calculate residual statistics\n  calculateResidualStats(residuals) {\n    if (!residuals.length) {\n      return { mean: 0, variance: 0, maxAbsolute: 0 };\n    }\n  \n    const values = residuals.map(r => r.residual);\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\n    const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;\n    const maxAbsolute = Math.max(...values.map(Math.abs));\n  \n    return {\n      mean,\n      variance,\n      maxAbsolute\n    };\n  }\n\n  // ===========================\n  // Data Processing Methods\n  // ===========================\n\n  processFlowDataSafely = (data) => {\n    return data.map(row => {\n      try {\n        return this.processFlowRow(row);\n      } catch (error) {\n        console.warn('[SpatialHandler] Error processing flow row:', error);\n        return null;\n      }\n    }).filter(Boolean);\n  };\n\n  processFlowRow = (row) => {\n    if (!row || typeof row !== 'object') return null;\n    \n    const source = this.normalizeRegionName(row.source);\n    const target = this.normalizeRegionName(row.target);\n    \n    // Skip excluded regions\n    if (this.excludedRegions.has(source) || this.excludedRegions.has(target)) {\n      return null;\n    }\n    \n    return {\n      source,\n      target,\n      commodity: row.commodity?.trim?.(),\n      price_differential: Number(row.price_differential) || 0,\n      source_price: Number(row.source_price) || 0,\n      target_price: Number(row.target_price) || 0,\n      flow_weight: Number(row.flow_weight) || 0\n    };\n  };\n\n  processFlowAnalysis = (flows) => {\n    if (!Array.isArray(flows)) {\n      console.warn('[SpatialHandler] Invalid flow data structure');\n      return { flows: [], byDate: {}, metadata: {} };\n    }\n    \n    try {\n      // Process basic flow data\n      const validatedFlows = flows.map(flow => {\n        const source = this.normalizeRegionName(flow.source);\n        const target = this.normalizeRegionName(flow.target);\n        \n        // Skip invalid flows\n        if (!source || !target || \n            this.excludedRegions.has(source) || \n            this.excludedRegions.has(target)) {\n          return null;\n        }\n  \n        // Get coordinates for visualization\n        const sourceCoords = this.coordinateCache.get(source);\n        const targetCoords = this.coordinateCache.get(target);\n        \n        if (!sourceCoords || !targetCoords) {\n          console.warn(`Missing coordinates for flow: ${source} -> ${target}`);\n          return null;\n        }\n  \n        // Handle missing date by assigning to default time period\n        let flowDate = '2020-10'; // Default to October 2020 if no date provided\n        if (flow.date || flow.month) {\n          flowDate = (flow.date || flow.month).substring(0, 7);\n          if (!flowDate.match(/^\\d{4}-\\d{2}$/)) {\n            console.debug('Invalid date format, using default:', flow);\n            flowDate = '2020-10';\n          }\n        }\n  \n        return {\n          source,\n          target,\n          date: flowDate,\n          total_flow: this.sanitizeNumericValue(flow.total_flow || flow.flow_weight),\n          avg_flow: this.sanitizeNumericValue(flow.avg_flow || flow.total_flow || flow.flow_weight),\n          flow_count: flow.flow_count || 1,\n          price_differential: this.sanitizeNumericValue(flow.price_differential),\n          source_price: this.sanitizeNumericValue(flow.source_price),\n          target_price: this.sanitizeNumericValue(flow.target_price),\n          coordinates: {\n            source: sourceCoords,\n            target: targetCoords\n          }\n        };\n      }).filter(Boolean);\n  \n      // Group flows by date\n      const flowsByDate = validatedFlows.reduce((acc, flow) => {\n        if (!acc[flow.date]) {\n          acc[flow.date] = [];\n        }\n        acc[flow.date].push(flow);\n        return acc;\n      }, {});\n  \n      // Calculate normalized values for each date group\n      Object.keys(flowsByDate).forEach(date => {\n        const dateFlows = flowsByDate[date];\n        const maxFlow = Math.max(...dateFlows.map(f => f.total_flow || 0));\n        const maxPriceDiff = Math.max(...dateFlows.map(f => Math.abs(f.price_differential || 0)));\n  \n        // Add normalized values\n        dateFlows.forEach(flow => {\n          flow.normalized = {\n            flow: maxFlow > 0 ? (flow.total_flow || 0) / maxFlow : 0,\n            priceDiff: maxPriceDiff > 0 ? Math.abs(flow.price_differential || 0) / maxPriceDiff : 0\n          };\n        });\n      });\n  \n      const datesSorted = Object.keys(flowsByDate).sort();\n      \n      return {\n        flows: validatedFlows,\n        byDate: flowsByDate,\n        metadata: {\n          totalFlows: validatedFlows.length,\n          dateRange: {\n            start: datesSorted[0],\n            end: datesSorted[datesSorted.length - 1]\n          },\n          uniqueDates: datesSorted.length,\n          lastUpdated: new Date().toISOString()\n        }\n      };\n    } catch (error) {\n      console.error('[SpatialHandler] Error processing flows:', error);\n      return { flows: [], byDate: {}, metadata: {} };\n    }\n  };\n  \n  \n  processFlowData = (data, date) => {\n    if (!Array.isArray(data)) {\n      throw new Error('Invalid flow data structure: expected array');\n    }\n  \n    // Filter by date if provided\n    const filteredData = date ? \n      data.filter(row => row.date?.startsWith(date) || row.month?.startsWith(date)) : \n      data;\n    \n    return filteredData.map(row => {\n      const source = this.normalizeRegionName(row.source);\n      const target = this.normalizeRegionName(row.target);\n      \n      // Get coordinates from cache\n      const sourceCoords = this.coordinateCache.get(source);\n      const targetCoords = this.coordinateCache.get(target);\n      \n      if (!sourceCoords || !targetCoords) {\n        console.warn(`Missing coordinates for flow: ${source} -> ${target}`);\n        return null;\n      }\n      \n      return {\n        source,\n        target,\n        date: row.date || row.month,\n        source_lat: sourceCoords[1],\n        source_lng: sourceCoords[0],\n        target_lat: targetCoords[1],\n        target_lng: targetCoords[0],\n        flow_weight: Number(row.flow_weight) || 0,\n        price_differential: Number(row.price_differential) || 0,\n        source_price: Number(row.source_price) || 0,\n        target_price: Number(row.target_price) || 0\n      };\n    }).filter(flow => \n      flow && \n      !this.excludedRegions.has(flow.source) &&\n      !this.excludedRegions.has(flow.target)\n    );\n  };\n\n  async processTimeSeriesData(data) {\n    try {\n      // Validate input data structure\n      if (!data?.features || !Array.isArray(data.features)) {\n        console.error('Invalid data format: Expected \"features\" array');\n        return [];\n      }\n  \n      console.debug('Starting timeSeriesData processing:', {\n        featureCount: data.features.length,\n        firstFeature: data.features?.[0]?.properties,\n      });\n  \n      // Process each feature\n      const timeSeriesData = data.features.map((feature) => {\n        try {\n          // **Updated Validation Check**\n          if (!feature?.properties?.date || (!feature.properties.region_id && !feature.properties.admin1)) {\n            console.warn('Feature missing required properties:', feature);\n            return null;\n          }\n  \n          // Parse date and generate month string\n          const date = new Date(feature.properties.date);\n          if (isNaN(date.getTime())) {\n            console.warn('Invalid date format for feature:', feature);\n            return null;\n          }\n          const month = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n  \n          // Normalize region ID\n          const region_id = this.normalizeRegionName(\n            feature.properties.region_id || feature.properties.admin1\n          );\n  \n          // Construct the processed entry\n          return {\n            region: region_id, // Use normalized region ID\n            month,\n            usdPrice: feature.properties.usdprice ?? null,\n            conflictIntensity: feature.properties.conflict_intensity ?? null,\n            additionalProperties: {\n              ...feature.properties,\n              region: region_id, // Keep normalized region ID consistent\n              population: feature.properties.population ?? null,\n              conflict_intensity: feature.properties.conflict_intensity ?? null,\n              commodity: feature.properties.commodity ?? null,\n              regime: feature.properties.exchange_rate_regime || 'unified',\n            },\n          };\n        } catch (featureError) {\n          console.warn('Error processing feature:', feature, featureError);\n          return null; // Skip invalid feature\n        }\n      }).filter(Boolean); // Remove null entries\n\n      // Validate and filter processed data\n      const validData = timeSeriesData.filter((entry) => {\n        const isValid = Boolean(\n          entry.region &&\n          entry.usdPrice !== null &&\n          !isNaN(entry.usdPrice)\n        );\n\n        if (!isValid) {\n          console.warn('Invalid time series entry:', entry);\n        }\n\n        return isValid;\n      });\n\n      // Sort by region and month for consistent output\n      const sortedData = _.sortBy(validData, ['region', 'month']);\n\n      // Log summary\n      console.debug('Time series processing complete:', {\n        inputFeatures: data.features.length,\n        outputEntries: sortedData.length,\n        uniqueRegions: new Set(sortedData.map((d) => d.region)).size,\n        uniqueMonths: new Set(sortedData.map((d) => d.month)).size,\n        sampleEntries: sortedData.slice(0, 3),\n      });\n\n      return sortedData;\n    } catch (error) {\n      console.error('Error processing time series data:', error);\n      throw error;\n    }\n  }\n\n  processMarketShocks(shocks) {\n    if (!Array.isArray(shocks)) return [];\n    \n    return shocks.map(shock => ({\n      region: this.normalizeRegionName(shock.region),\n      date: shock.date,\n      shock_type: shock.shock_type,\n      magnitude: this.sanitizeNumericValue(shock.magnitude),\n      previous_price: this.sanitizeNumericValue(shock.previous_price),\n      current_price: this.sanitizeNumericValue(shock.current_price)\n    })).filter(shock => shock.region && shock.magnitude);\n  }\n\n  processClusterEfficiency(efficiency) {\n    if (!Array.isArray(efficiency)) return [];\n    \n    return efficiency.map(cluster => ({\n      cluster_id: cluster.cluster_id,\n      internal_connectivity: this.sanitizeNumericValue(cluster.internal_connectivity),\n      market_coverage: this.sanitizeNumericValue(cluster.market_coverage),\n      price_convergence: this.sanitizeNumericValue(cluster.price_convergence),\n      stability: this.sanitizeNumericValue(cluster.stability),\n      efficiency_score: this.sanitizeNumericValue(cluster.efficiency_score)\n    }));\n  }\n\n  processSpatialAutocorrelation(autocorrelation) {\n    if (!autocorrelation?.global || !autocorrelation?.local) {\n      return { global: null, local: null };\n    }\n    \n    const processedGlobal = {\n      moran_i: this.sanitizeNumericValue(autocorrelation.global.moran_i),\n      p_value: autocorrelation.global.p_value,\n      z_score: autocorrelation.global.z_score,\n      significance: autocorrelation.global.significance\n    };\n    \n    const processedLocal = {};\n    for (const [region, values] of Object.entries(autocorrelation.local)) {\n      const normalizedRegion = this.normalizeRegionName(region);\n      processedLocal[normalizedRegion] = {\n        local_i: this.sanitizeNumericValue(values.local_i),\n        p_value: values.p_value,\n        cluster_type: values.cluster_type\n      };\n    }\n    \n    return {\n      global: processedGlobal,\n      local: processedLocal\n    };\n  }\n\n  processSeasonalAnalysis(seasonal) {\n    if (!seasonal?.seasonal_pattern) return null;\n    \n    return {\n      seasonal_strength: this.sanitizeNumericValue(seasonal.seasonal_strength),\n      trend_strength: this.sanitizeNumericValue(seasonal.trend_strength),\n      peak_month: seasonal.peak_month,\n      trough_month: seasonal.trough_month,\n      seasonal_pattern: seasonal.seasonal_pattern.map(value => \n        this.sanitizeNumericValue(value)\n      )\n    };\n  }\n\n  processConflictMetrics(metrics) {\n    if (!Array.isArray(metrics)) return [];\n    \n    return metrics.map(metric => ({\n      month: metric.month,\n      adjusted_price: this.sanitizeNumericValue(metric.adjusted_price)\n    }));\n  }\n\n  processMarketIntegration(integration) {\n    if (!integration?.price_correlation) return null;\n    \n    const processedCorrelation = {};\n    for (const [region, correlations] of Object.entries(integration.price_correlation)) {\n      const normalizedRegion = this.normalizeRegionName(region);\n      processedCorrelation[normalizedRegion] = {};\n      \n      for (const [r, value] of Object.entries(correlations)) {\n        const normalizedR = this.normalizeRegionName(r);\n        processedCorrelation[normalizedRegion][normalizedR] = \n          this.sanitizeNumericValue(value);\n      }\n    }\n    \n    return {\n      price_correlation: processedCorrelation,\n      flow_density: this.sanitizeNumericValue(integration.flow_density),\n      accessibility: integration.accessibility,\n      integration_score: this.sanitizeNumericValue(integration.integration_score)\n    };\n  }\n\n  processRegressionAnalysis(data) {\n    if (!data) return DEFAULT_REGRESSION_DATA;\n    \n    try {\n      return {\n        model: {\n          coefficients: data.coefficients || {},\n          intercept: this.sanitizeNumericValue(data.intercept),\n          p_values: data.p_values || {},\n          r_squared: this.sanitizeNumericValue(data.r_squared),\n          adj_r_squared: this.sanitizeNumericValue(data.adj_r_squared),\n          mse: this.sanitizeNumericValue(data.mse),\n          observations: data.observations || 0\n        },\n        spatial: {\n          moran_i: {\n            I: this.sanitizeNumericValue(data.moran_i?.I),\n            'p-value': this.sanitizeNumericValue(data.moran_i?.['p-value'])\n          },\n          vif: Array.isArray(data.vif) ? data.vif.map(v => ({\n            Variable: v.Variable,\n            VIF: this.sanitizeNumericValue(v.VIF)\n          })) : []\n        },\n        residuals: this.processResiduals(data.residual || [])\n      };\n    } catch (error) {\n      console.error('[SpatialHandler] Error processing regression analysis:', error);\n      return DEFAULT_REGRESSION_DATA;\n    }\n  }\n\n  processResiduals(residualData) {\n    if (!Array.isArray(residualData)) return { raw: [], byRegion: {}, stats: {} };\n    \n    const rawResiduals = residualData.map(r => ({\n      region_id: r.region_id,\n      date: new Date(r.date).toISOString(),\n      residual: Number(r.residual)\n    }));\n    \n    // Group residuals by region\n    const byRegion = _.groupBy(rawResiduals, 'region_id');\n    \n    // Calculate statistics\n    const residualValues = rawResiduals.map(r => r.residual);\n    const stats = {\n      mean: _.mean(residualValues) || 0,\n      variance: this.calculateVariance(residualValues),\n      maxAbsolute: Math.max(...residualValues.map(Math.abs)) || 0\n    };\n    \n    return { raw: rawResiduals, byRegion, stats };\n  }\n\n  calculateVariance(values) {\n    if (!values.length) return 0;\n    const mean = _.mean(values);\n    return _.sum(values.map(v => Math.pow(v - mean, 2))) / values.length;\n  }\n\n  async processVisualizationData(data, mode, filters = {}) {\n    try {\n      const visualData = await workerManager.calculateVisualization(data, {\n        mode,\n        filters\n      });\n      return visualData;\n    } catch (error) {\n      console.error('Error calculating visualization:', error);\n      throw error;\n    }\n  }\n\n  async processPriceVisualization(data, filters) {\n    const { timeSeriesData } = data;\n    if (!timeSeriesData?.length) return null;\n    \n    // Process time series data for price visualization\n    const processedData = {\n      timeSeries: this.processTimeSeriesForVisualization(timeSeriesData),\n      metrics: calculateVisualizationMetrics.calculatePriceMetrics(timeSeriesData),\n      trends: this.calculatePriceTrends(timeSeriesData),\n      statistics: {\n        volatility: this.calculateVolatilityMetrics(timeSeriesData),\n        seasonality: this.detectSeasonalPatterns(timeSeriesData)\n      }\n    };\n    \n    if (filters.timeRange) {\n      processedData.timeSeries = this.filterTimeSeriesData(\n        processedData.timeSeries,\n        filters.timeRange\n      );\n    }\n    \n    return processedData;\n  }\n\n  async processIntegrationVisualization(data, filters) {\n    const {\n      marketIntegration,\n      flowAnalysis,\n      spatialAutocorrelation\n    } = data;\n    \n    return {\n      correlationMatrix: this.processCorrelationMatrix(\n        marketIntegration.price_correlation,\n        filters\n      ),\n      flowMetrics: this.processFlowMetrics(flowAnalysis, filters),\n      spatialMetrics: {\n        moran: spatialAutocorrelation.global.moran_i,\n        clusters: this.processSpatialClusters(\n          spatialAutocorrelation.local,\n          filters\n        )\n      },\n      integrationScores: this.calculateIntegrationScores(data)\n    };\n  }\n\n  async processClusterVisualization(data, filters) {\n    const { marketClusters, clusterEfficiency } = data;\n    \n    return {\n      clusters: this.processMarketClusters(marketClusters, filters),\n      efficiency: this.processClusterEfficiency(clusterEfficiency),\n      metrics: {\n        coverage: this.calculateMarketCoverage(marketClusters),\n        stability: this.calculateClusterStability(marketClusters),\n        connectivity: this.calculateClusterConnectivity(marketClusters)\n      },\n      spatialDistribution: this.analyzeClusterDistribution(marketClusters)\n    };\n  }\n\n  async processShockVisualization(data, filters) {\n    const { marketShocks, timeSeriesData } = data;\n    \n    return {\n      shocks: this.processMarketShocks(marketShocks, filters),\n      patterns: this.analyzeShockPatterns(marketShocks),\n      impact: this.calculateShockImpact(marketShocks, timeSeriesData),\n      propagation: this.analyzeShockPropagation(marketShocks),\n      riskMetrics: this.calculateMarketRiskMetrics(marketShocks)\n    };\n  }\n\n  async createUnifiedGeoJSON(timeSeriesData) {\n    await Promise.all([\n      this.initializeGeometry(),\n      this.initializePoints()\n    ]);\n    \n    const features = [];\n    \n    // Create features combining polygons and points\n    for (const [regionName, polygonData] of this.geometryCache.entries()) {\n      const pointData = this.pointCache.get(regionName);\n      const timeSeriesForRegion = timeSeriesData.find(d => \n        this.normalizeRegionName(d.region || d.admin1) === regionName\n      ) || {};\n      \n      features.push({\n        type: 'Feature',\n        geometry: polygonData.geometry,\n        properties: {\n          region_id: regionName,\n          originalName: polygonData.properties.originalName,\n          normalizedName: regionName,\n          shapeISO: polygonData.properties.shapeISO,\n          center: pointData ? pointData.coordinates : null,\n          population: pointData ? pointData.properties.population : null,\n          data: timeSeriesForRegion || {}\n        }\n      });\n    }\n    \n    return {\n      type: 'FeatureCollection',\n      features,\n      crs: {\n        type: 'name',\n        properties: { name: 'urn:ogc:def:crs:OGC:1.3:CRS84' }\n      }\n    };\n  }\n\n  // ===========================\n  // Data Enhancement Methods\n  // ===========================\n\n  async enhanceWithRealtimeMetrics(data) {\n    try {\n      // Deep clone the data to avoid mutations\n      const enhancedData = _.cloneDeep(data);\n      \n      // Check if we need to enhance the data\n      if (this.shouldEnhanceData(enhancedData)) {\n        // Add GARCH volatility if missing\n        if (!enhancedData.time_series_data?.[0]?.garch_volatility) {\n          enhancedData.time_series_data = this.addGarchVolatility(enhancedData.time_series_data);\n        }\n      \n        // Add price stability if missing\n        if (!enhancedData.time_series_data?.[0]?.price_stability) {\n          enhancedData.time_series_data = this.addPriceStability(enhancedData.time_series_data);\n        }\n      \n        // Enhance market integration metrics if needed\n        if (!enhancedData.market_integration?.integration_score) {\n          enhancedData.market_integration = await this.enhanceMarketIntegration(enhancedData.market_integration);\n        }\n      \n        // Add metadata about enhancement\n        enhancedData.metadata = {\n          ...enhancedData.metadata,\n          enhanced: true,\n          enhancement_date: new Date().toISOString(),\n          enhancement_version: '1.0'\n        };\n      }\n      \n      return enhancedData;\n    } catch (error) {\n      console.warn('Error enhancing data:', error);\n      // Return original data if enhancement fails\n      return data;\n    }\n  }\n\n  shouldEnhanceData(data) {\n    // Check if data needs enhancement based on missing metrics\n    return !data.time_series_data?.[0]?.garch_volatility ||\n         !data.time_series_data?.[0]?.price_stability ||\n         !data.market_integration?.integration_score;\n  }\n\n  addGarchVolatility(timeSeriesData) {\n    if (!Array.isArray(timeSeriesData)) return timeSeriesData;\n    \n    return timeSeriesData.map(entry => ({\n      ...entry,\n      garch_volatility: entry.garch_volatility ?? this.calculateGarchVolatility(entry)\n    }));\n  }\n\n  calculateGarchVolatility(entry) {\n    // Simple volatility calculation as fallback\n    const price = entry.avgUsdPrice;\n    if (!price) return 0;\n    return Math.abs(price - (entry.previous_price ?? price)) / price;\n  }\n\n  addPriceStability(timeSeriesData) {\n    if (!Array.isArray(timeSeriesData)) return timeSeriesData;\n    \n    return timeSeriesData.map((entry, index) => ({\n      ...entry,\n      price_stability: entry.price_stability ?? this.calculatePriceStability(timeSeriesData, index)\n    }));\n  }\n\n  calculatePriceStability(timeSeriesData, currentIndex) {\n    // Simple rolling stability calculation\n    const windowSize = 3;\n    const startIndex = Math.max(0, currentIndex - windowSize + 1);\n    const window = timeSeriesData.slice(startIndex, currentIndex + 1);\n    \n    const prices = window.map(d => d.avgUsdPrice).filter(p => p != null);\n    if (prices.length < 2) return 1;\n    \n    const std = Math.sqrt(\n      prices.reduce((sum, price) => sum + Math.pow(price - prices[0], 2), 0) / prices.length\n    );\n    \n    return 1 / (1 + std);\n  }\n\n  async enhanceMarketIntegration(marketIntegration) {\n    if (!marketIntegration) return {};\n    \n    return {\n      ...marketIntegration,\n      integration_score: marketIntegration.integration_score ?? \n        this.calculateIntegrationScore(marketIntegration)\n    };\n  }\n\n  calculateIntegrationScore(marketIntegration) {\n    const weights = {\n      price_correlation: 0.4,\n      flow_density: 0.3,\n      accessibility: 0.3\n    };\n    \n    // Calculate weighted average of available metrics\n    let score = 0;\n    let totalWeight = 0;\n    \n    if (marketIntegration.price_correlation) {\n      score += weights.price_correlation * this.calculateAverageCorrelation(marketIntegration.price_correlation);\n      totalWeight += weights.price_correlation;\n    }\n    \n    if (typeof marketIntegration.flow_density === 'number') {\n      score += weights.flow_density * marketIntegration.flow_density;\n      totalWeight += weights.flow_density;\n    }\n    \n    if (marketIntegration.accessibility) {\n      score += weights.accessibility * this.calculateAverageAccessibility(marketIntegration.accessibility);\n      totalWeight += weights.accessibility;\n    }\n    \n    return totalWeight > 0 ? score / totalWeight : 0;\n  }\n\n  calculateAverageCorrelation(correlationMatrix) {\n    if (!correlationMatrix || typeof correlationMatrix !== 'object') return 0;\n    \n    let sum = 0;\n    let count = 0;\n    \n    Object.values(correlationMatrix).forEach(correlations => {\n      if (typeof correlations === 'object') {\n        Object.values(correlations).forEach(value => {\n          if (typeof value === 'number' && !isNaN(value)) {\n            sum += value;\n            count++;\n          }\n        });\n      }\n    });\n    \n    return count > 0 ? sum / count : 0;\n  }\n\n  calculateAverageAccessibility(accessibility) {\n    if (!accessibility || typeof accessibility !== 'object') return 0;\n    \n    const values = Object.values(accessibility)\n      .filter(value => typeof value === 'number' && !isNaN(value));\n    \n    return values.length > 0 ? \n      values.reduce((sum, val) => sum + val, 0) / values.length : 0;\n  }\n\n  // ===========================\n  // Data Sanitization Methods\n  // ===========================\n\n  sanitizeNumericValues(data) {\n    if (!data || typeof data !== 'object') return;\n    \n    for (const [key, value] of Object.entries(data)) {\n      if (value && typeof value === 'object') {\n        // Recursively process nested objects and arrays\n        this.sanitizeNumericValues(value);\n      } else if (typeof value === 'number') {\n        // Replace invalid numeric values with null\n        if (Number.isNaN(value) || !Number.isFinite(value)) {\n          data[key] = null;\n        }\n      }\n    }\n  }\n\n  sanitizeNumericValue(value) {\n    if (value === null || value === undefined || Number.isNaN(value)) {\n      return null;\n    }\n    return typeof value === 'number' ? value : Number(value);\n  }\n\n  sanitizeJsonText(text) {\n    if (!text) return '';\n    \n    return text\n      // Replace NaN values with null\n      .replace(/:\\s*NaN/g, ': null')\n      // Replace Infinity values with null\n      .replace(/:\\s*Infinity/g, ': null')\n      .replace(/:\\s*-Infinity/g, ': null')\n      // Handle undefined values\n      .replace(/:\\s*undefined/g, ': null')\n      // Clean up any potential invalid numeric strings\n      .replace(/:\\s*\"(NaN|Infinity|-Infinity)\"/g, ': null')\n      // Handle empty values\n      .replace(/:\\s*\"\"/g, ': null')\n      // Clean up any trailing commas in arrays or objects\n      .replace(/,(\\s*[}\\]])/g, '$1');\n  }\n\n  // ===========================\n  // Utility Methods\n  // ===========================\n\n  cleanShapeName(name) {\n    if (!name) return '';\n    return name\n      .replace(/_governorate$/i, '')\n      .replace(/\\s+governorate$/i, '')\n      .replace(/^_+/, '')\n      .replace(/_+/g, ' ')\n      .trim();\n  }\n\n  filterFlowsByCommodity(data, commodity) {\n    const normalizedCommodity = commodity.toLowerCase().trim();\n    return data.filter(row => {\n      const rowCommodity = row.commodity?.toLowerCase?.()?.trim?.();\n      return rowCommodity === normalizedCommodity;\n    });\n  }\n\n  filterByDate = (data, targetDate) => {\n    if (!targetDate || !Array.isArray(data)) return data;\n    \n    try {\n      // Normalize target date to YYYY-MM format \n      const normalizedTarget = targetDate.substring(0, 7);\n  \n      return data.filter(item => {\n        const itemDate = (item.date || item.month || '').substring(0, 7);\n        return itemDate === normalizedTarget;\n      });\n    } catch (error) {\n      console.error('[SpatialHandler] Error filtering by date:', error);\n      return [];\n    }\n  };\n\n  // ===========================\n  // Data Processing Pipeline\n  // ===========================\n\n  processAllData(geometryData, preprocessed, flows, date) {\n    if (!preprocessed?.time_series_data) {\n      throw new Error('Missing time series data');\n    }\n    const filteredFlows = this.filterByDate(flows, date);\n    const processedData = this.processMarketClusters(\n      preprocessed.market_clusters,\n      preprocessed.time_series_data,\n      date\n    );\n    \n    return {\n      timeSeriesData: preprocessed.time_series_data,\n      marketClusters: preprocessed.market_clusters,\n      marketShocks: preprocessed.market_shocks,\n      clusterEfficiency: preprocessed.cluster_efficiency,\n      flowAnalysis: preprocessed.flow_analysis,\n      spatialAutocorrelation: preprocessed.spatial_autocorrelation,\n      seasonalAnalysis: preprocessed.seasonal_analysis,\n      marketIntegration: preprocessed.market_integration,\n      metadata: preprocessed.metadata,\n      geoJSON: this.createGeoJSON(processedData.features),\n      flowMaps: flows\n    };\n  }\n\n  processMarketClusters(clusters, timeData, date) {\n    if (!Array.isArray(clusters) || !Array.isArray(timeData)) {\n      throw new Error('Invalid clusters or time data');\n    }\n    \n    const features = [];\n    const processedClusters = [];\n    const relevantTimeData = this.filterByDate(timeData, date);\n    \n    for (const cluster of clusters) {\n      try {\n        const clusterFeatures = this.processClusterFeatures(cluster, relevantTimeData);\n        features.push(...clusterFeatures);\n      \n        const mainMarketFeature = clusterFeatures.find(\n          (f) => f.properties.isMainMarket && \n                 f.properties.region_id === this.normalizeRegionName(cluster.main_market)\n        );\n      \n        const mainMarketCoordinates = mainMarketFeature?.geometry?.coordinates;\n      \n        processedClusters.push({\n          ...cluster,\n          processed_markets: clusterFeatures.map((f) => f.properties.region_id),\n          main_market_coordinates: mainMarketCoordinates\n            ? { lat: mainMarketCoordinates[1], lng: mainMarketCoordinates[0] }\n            : null,\n        });\n      } catch (error) {\n        console.warn(`[SpatialHandler] Error processing cluster:`, { \n          cluster_id: cluster.cluster_id,\n          error: error.message \n        });\n      }\n    }\n    \n    return {\n      clusters: processedClusters,\n      features,\n      timeData: relevantTimeData,\n    };\n  }\n\n  processClusterFeatures(cluster, timeData) {\n    if (!cluster?.main_market || !Array.isArray(cluster.connected_markets)) {\n      throw new Error('Invalid cluster structure');\n    }\n    \n    const features = [];\n    const processedMarkets = new Set();\n    \n    const addFeature = (marketId, isMain) => {\n      if (!marketId || processedMarkets.has(marketId)) return;\n      \n      const normalizedMarketId = this.normalizeRegionName(marketId);\n      if (!normalizedMarketId) return;\n      \n      const geometry = this.geometryCache.get(normalizedMarketId);\n      if (!geometry) {\n        console.warn(`[SpatialHandler] No geometry found for market: \"${marketId}\" (normalized: \"${normalizedMarketId}\")`);\n        return;\n      }\n      \n      const marketData = timeData.find(d => \n        this.normalizeRegionName(d.region || d.admin1) === normalizedMarketId\n      ) || {};\n      \n      features.push({\n        type: 'Feature',\n        properties: {\n          region_id: normalizedMarketId,\n          originalName: geometry.properties.originalName,\n          isMainMarket: isMain,\n          cluster_id: cluster.cluster_id,\n          market_count: cluster.market_count,\n          ...marketData,\n        },\n        geometry: geometry.geometry\n      });\n      \n      processedMarkets.add(marketId);\n    };\n    \n    // Process main market first\n    addFeature(cluster.main_market, true);\n    \n    // Process connected markets\n    cluster.connected_markets.forEach(market => {\n      addFeature(market, false);\n    });\n    \n    return features;\n  }\n\n  createGeoJSON(features) {\n    if (!Array.isArray(features)) {\n      throw new Error('Invalid features array');\n    }\n    \n    return {\n      type: 'FeatureCollection',\n      features: features\n        .filter((f) => f && f.geometry)\n        .map((f) => {\n          const properties = {\n            ...f.properties,\n            region_id: this.normalizeRegionName(\n              f.properties.region_id || f.properties.admin1 || f.properties.region\n            ),\n            date: f.properties.date || f.properties.month || null,\n            commodity: f.properties.commodity || null,\n          };\n      \n          let geometry = { ...f.geometry };\n          if (geometry.type === 'Point') {\n            const [lng, lat] = geometry.coordinates;\n            geometry.coordinates = [lat, lng];\n          }\n      \n          return {\n            type: 'Feature',\n            properties,\n            geometry,\n          };\n        }),\n    };\n  }\n\n  // ===========================\n  // Additional Helper Methods\n  // ===========================\n\n  processTimeSeriesForVisualization(timeSeriesData) {\n    return timeSeriesData.map(entry => ({\n      date: entry.month,\n      value: entry.avgUsdPrice,\n      volatility: entry.volatility,\n      conflictIntensity: entry.conflict_intensity,\n      sampleSize: entry.sampleSize\n    }));\n  }\n\n  processCorrelationMatrix(correlationData, filters) {\n    const matrix = { ...correlationData };\n    const minCorrelation = filters.minCorrelation || 0;\n    \n    // Filter correlations based on threshold\n    Object.keys(matrix).forEach(market => {\n      matrix[market] = Object.fromEntries(\n        Object.entries(matrix[market]).filter(\n          ([_, value]) => Math.abs(value) >= minCorrelation\n        )\n      );\n    });\n    \n    return matrix;\n  }\n\n  processFlowMetrics(flowData, filters) {\n    const minFlow = filters.minFlowWeight || 0;\n    \n    const filteredFlows = flowData.filter(flow => \n      flow.total_flow >= minFlow\n    );\n    \n    return {\n      flows: filteredFlows,\n      summary: this.calculateFlowSummaryStats(filteredFlows),\n      intensity: this.calculateFlowIntensityMatrix(filteredFlows)\n    };\n  }\n\n  calculateIntegrationScores(data) {\n    const {\n      marketIntegration,\n      flowAnalysis,\n      spatialAutocorrelation\n    } = data;\n    \n    return {\n      overall: marketIntegration.integration_score,\n      byMarket: this.calculateMarketSpecificScores(data),\n      temporal: this.analyzeTemporalIntegration(data),\n      spatial: this.analyzeSpatialIntegration(\n        spatialAutocorrelation,\n        flowAnalysis\n      )\n    };\n  }\n\n  getCoordinates(location) {\n    const normalizedLocation = this.normalizeRegionName(location);\n    const coordinates = this.geometryCache?.get(normalizedLocation) || this.pointCache?.get(normalizedLocation);\n    return coordinates ? coordinates : null;\n  }\n\n  // ===========================\n  // Data Retrieval Methods\n  // ===========================\n\n  async getSpatialData(selectedCommodity, date) {\n    const commodity = selectedCommodity?.toLowerCase().trim() || 'beans (kidney red)';\n    const cacheKey = `spatial_${commodity}_${date || 'all'}`;\n  \n    return this.deduplicateRequest(cacheKey, async () => {\n      try {\n        console.debug('Loading spatial data:', { commodity, date, cacheKey });\n\n        // Load enhanced unified data\n        const dataPath = isDev\n          ? '/results/enhanced_unified_data_with_residual.geojson'\n          : `${BASE_URL}/data/enhanced_unified_data_with_residual.geojson`;\n\n        const response = await fetch(dataPath, {\n          headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json',\n          },\n          credentials: 'same-origin',\n        });\n\n        if (!response.ok) {\n          // Try fallback path\n          const fallbackPath = isDev\n            ? '/data/enhanced_unified_data_with_residual.geojson'\n            : `${BASE_URL}/results/enhanced_unified_data_with_residual.geojson`;\n          \n          const fallbackResponse = await fetch(fallbackPath);\n          if (!fallbackResponse.ok) {\n            throw new Error(`Failed to load enhanced data from both paths: ${dataPath} and ${fallbackPath}`);\n          }\n          response = fallbackResponse;\n        }\n\n        const enhancedData = await response.json();\n\n        // Filter data for the selected commodity\n        const filteredData = {\n          ...enhancedData,\n          features: enhancedData.features.filter((feature) => {\n            const featureCommodity = this.normalizeCommodityName(feature.properties?.commodity || '');\n            const targetCommodity = this.normalizeCommodityName(commodity);\n            return featureCommodity === targetCommodity;\n          }),\n        };\n\n        // Log filtering stats\n        console.debug('Filtered data stats:', {\n          originalCount: enhancedData.features.length,\n          filteredCount: filteredData.features.length,\n          commodity: this.normalizeCommodityName(commodity),\n        });\n\n        if (!filteredData.features || filteredData.features.length === 0) {\n          console.warn(`No features found for commodity: ${commodity}`);\n          return {\n            flowMaps: [],\n            timeSeriesData: [],\n            marketClusters: [],\n            marketShocks: [],\n            spatialAutocorrelation: {},\n            commodities: [], // Return an empty commodities array\n            metadata: {\n              commodity,\n              date: date || 'all',\n              timestamp: new Date().toISOString(),\n            },\n          };\n        }\n\n        // Extract commodities from the data\n        const commodities = this.extractCommodities(enhancedData);\n\n        // Process time series data from enhanced data\n        const timeSeriesData = await this.processTimeSeriesData(filteredData);\n\n        // Log processed time series data summary\n        console.debug('Time series data processed:', {\n          entries: timeSeriesData.length,\n          uniqueRegions: new Set(timeSeriesData.map((d) => d.region)).size,\n          uniqueMonths: new Set(timeSeriesData.map((d) => d.month)).size,\n          firstEntry: timeSeriesData[0],\n          lastEntry: timeSeriesData[timeSeriesData.length - 1],\n        });\n\n        // Load preprocessed data for other analyses\n        const preprocessed = await this.loadPreprocessedData(commodity);\n\n        // Process flows with date handling\n        const processedFlows = preprocessed.flow_analysis\n          ? this.processFlowAnalysis(preprocessed.flow_analysis)\n          : { flows: [], byDate: {}, metadata: {} };\n  \n        // Get date-specific flows or fall back to all flows\n        const relevantFlows = date && processedFlows.byDate[date]\n          ? processedFlows.byDate[date]\n          : processedFlows.flows;\n  \n        const result = {\n          flowMaps: relevantFlows,\n          timeSeriesData, // Use time series data from enhanced data\n          marketClusters: preprocessed.market_clusters || [],\n          marketShocks: preprocessed.market_shocks || [],\n          spatialAutocorrelation: preprocessed.spatial_autocorrelation || {},\n          commodities,\n          metadata: {\n            commodity,\n            date: date || 'all',\n            timestamp: new Date().toISOString(),\n            flows: {\n              total: processedFlows.metadata.totalFlows,\n              filtered: relevantFlows.length,\n              dateRange: processedFlows.metadata.dateRange\n            }\n          }\n        };\n  \n        // Debug logging\n        console.debug('Processed flow data:', {\n          totalFlows: processedFlows.flows.length,\n          dateSpecificFlows: relevantFlows.length,\n          availableDates: Object.keys(processedFlows.byDate).length,\n          selectedDate: date\n        });\n  \n        return result;\n  \n      } catch (error) {\n        console.error('[SpatialHandler] Failed to get spatial data:', error);\n        throw error;\n      }\n    });\n  }\n\n  validateFlow = (flow) => {\n    return Boolean(\n      flow &&\n      flow.source &&\n      flow.target &&\n      typeof flow.total_flow === 'number' &&\n      !isNaN(flow.total_flow) &&\n      (flow.date || flow.month)\n    );\n  };\n  \n  // Add helper method to process a single flow\n  processFlow = (flow) => {\n    const source = this.normalizeRegionName(flow.source);\n    const target = this.normalizeRegionName(flow.target);\n    \n    if (!this.validateFlow(flow) || !source || !target) {\n      return null;\n    }\n  \n    const sourceCoords = this.coordinateCache.get(source);\n    const targetCoords = this.coordinateCache.get(target);\n    \n    if (!sourceCoords || !targetCoords) {\n      return null;\n    }\n  \n    return {\n      source,\n      target,\n      date: (flow.date || flow.month).substring(0, 7),\n      total_flow: this.sanitizeNumericValue(flow.total_flow || flow.flow_weight),\n      avg_flow: this.sanitizeNumericValue(flow.avg_flow),\n      price_differential: this.sanitizeNumericValue(flow.price_differential),\n      coordinates: { source: sourceCoords, target: targetCoords }\n    };\n  };\n\n  extractCommodities(data) {\n    const commoditiesSet = new Set();\n    if (data.features && Array.isArray(data.features)) {\n      data.features.forEach((feature) => {\n        if (feature.properties && feature.properties.commodity) {\n          commoditiesSet.add(feature.properties.commodity.toLowerCase());\n        }\n      });\n    }\n    return Array.from(commoditiesSet);\n  }\n\n  async getDefaultGeoJSON() {\n    try {\n      const geometry = await this.initializeGeometry();\n      if (!geometry) {\n        return this.defaultGeoJSON;\n      }\n      return this.createGeoJSON(Array.from(geometry.values()));\n    } catch (error) {\n      console.warn('[SpatialHandler] Failed to get default GeoJSON:', error);\n      return this.defaultGeoJSON;\n    }\n  }\n\n  // ===========================\n  // Regression Data Handling\n  // ===========================\n\n  async retryRegressionLoad(commodity, attempts = 3) {\n    for (let i = 0; i < attempts; i++) {\n      try {\n        const data = await this.loadRegressionAnalysis(commodity);\n        if (data !== DEFAULT_REGRESSION_DATA) {\n          return data;\n        }\n      } catch (error) {\n        console.warn(`Retry ${i + 1}/${attempts} failed for commodity \"${commodity}\":`, error);\n      }\n    }\n    // After all retries, return default data\n    return DEFAULT_REGRESSION_DATA;\n  }\n\n  // ===========================\n  // Market Clusters Validation\n  // ===========================\n\n  validateMarketConnections(cluster) {\n    // Implement validation logic for market connections if needed\n    // Placeholder implementation\n    return true;\n  }\n\n  // ===========================\n  // GeoJSON Creation (Duplicate Method Removed)\n  // ===========================\n\n  // Note: Removed duplicate `createGeoJSON` method to avoid conflicts.\n\n  // ===========================\n  // Worker Path Resolution\n  // ===========================\n\n  // Assuming workerManager handles worker paths correctly using pathResolver,\n  // ensure that pathResolver is correctly set up to use BASE_URL.\n\n  // If additional path resolution is needed, implement it here.\n}\n\nexport const spatialHandler = SpatialDataHandler.getInstance();\nexport default SpatialDataHandler;",
        "imports": [
          "papaparse",
          "lodash",
          "./appUtils",
          "./dataUtils",
          "./pathResolver",
          "./pathValidator",
          "../types/dataTypes",
          "../constants/index",
          "./workerManager",
          "./backgroundMonitor",
          "./polygonNormalizer"
        ],
        "exports": [
          "spatialHandler",
          "default"
        ],
        "dependencies": [
          "papaparse",
          "lodash",
          "./appUtils",
          "./dataUtils",
          "./pathResolver",
          "./pathValidator",
          "../types/dataTypes",
          "../constants/index",
          "./workerManager",
          "./backgroundMonitor",
          "./polygonNormalizer"
        ]
      },
      {
        "path": "utils/spatialDataOptimizer.js",
        "content": "// src/utils/spatialDataOptimizer.js\n\nimport { backgroundMonitor } from './backgroundMonitor';\nimport { workerManager } from './workerManager';\n\nclass SpatialDataOptimizer {\n    constructor() {\n        this.pendingRequests = new Map();\n        this.dataCache = new Map();\n        this.abortControllers = new Map();\n        this.worker = workerManager.getWorker('spatial');\n    }\n\n    // Request deduplication and caching\n    async deduplicateRequest(key, requestFn) {\n        // Check for pending request\n        if (this.pendingRequests.has(key)) {\n            return this.pendingRequests.get(key);\n        }\n\n        // Check cache\n        const cached = this.dataCache.get(key);\n        if (cached && Date.now() - cached.timestamp < 300000) { // 5 minute cache\n            return cached.data;\n        }\n\n        // Cancel any existing request\n        if (this.abortControllers.has(key)) {\n            this.abortControllers.get(key).abort();\n            this.abortControllers.delete(key);\n        }\n\n        // Create new abort controller\n        const controller = new AbortController();\n        this.abortControllers.set(key, controller);\n\n        // Create and store the request promise\n        const promise = (async () => {\n            try {\n                const data = await requestFn(controller.signal);\n                this.dataCache.set(key, {\n                    data,\n                    timestamp: Date.now()\n                });\n                return data;\n            } finally {\n                this.pendingRequests.delete(key);\n                this.abortControllers.delete(key);\n            }\n        })();\n\n        this.pendingRequests.set(key, promise);\n        return promise;\n    }\n\n    // Batch process data using web worker\n    async batchProcessData(data, options = {}) {\n        const metric = backgroundMonitor.startMetric('batch-process');\n        \n        try {\n            const result = await this.worker.processData({\n                data,\n                options,\n                type: 'batch-process'\n            });\n            \n            metric.finish({ status: 'success' });\n            return result;\n        } catch (error) {\n            metric.finish({ status: 'error', error: error.message });\n            throw error;\n        }\n    }\n\n    // Optimize data loading sequence\n    async optimizeDataLoading(requests) {\n        const metric = backgroundMonitor.startMetric('optimize-loading');\n\n        try {\n            // Group similar requests\n            const groupedRequests = this.groupRequests(requests);\n\n            // Process groups in parallel where possible\n            const results = await Promise.all(\n                groupedRequests.map(group => \n                    this.processBatchGroup(group)\n                )\n            );\n\n            metric.finish({ status: 'success' });\n            return this.mergeResults(results);\n        } catch (error) {\n            metric.finish({ status: 'error', error: error.message });\n            throw error;\n        }\n    }\n\n    // Group similar requests for batch processing\n    groupRequests(requests) {\n        return Object.values(\n            requests.reduce((groups, request) => {\n                const key = this.getGroupKey(request);\n                if (!groups[key]) {\n                    groups[key] = [];\n                }\n                groups[key].push(request);\n                return groups;\n            }, {})\n        );\n    }\n\n    // Get group key for request batching\n    getGroupKey(request) {\n        return `${request.type}_${request.commodity}_${request.date || 'all'}`;\n    }\n\n    // Process a group of similar requests\n    async processBatchGroup(group) {\n        const metric = backgroundMonitor.startMetric('process-group');\n\n        try {\n            const batchData = await this.batchProcessData(group);\n            metric.finish({ status: 'success' });\n            return batchData;\n        } catch (error) {\n            metric.finish({ status: 'error', error: error.message });\n            throw error;\n        }\n    }\n\n    // Merge results from different batches\n    mergeResults(results) {\n        return results.reduce((merged, result) => {\n            Object.entries(result).forEach(([key, value]) => {\n                if (!merged[key]) {\n                    merged[key] = Array.isArray(value) ? [] : {};\n                }\n                if (Array.isArray(value)) {\n                    merged[key].push(...value);\n                } else {\n                    Object.assign(merged[key], value);\n                }\n            });\n            return merged;\n        }, {});\n    }\n\n    // Clear all caches\n    clearCaches() {\n        this.dataCache.clear();\n        this.pendingRequests.clear();\n        this.abortControllers.forEach(controller => controller.abort());\n        this.abortControllers.clear();\n    }\n}\n\nexport const spatialOptimizer = new SpatialDataOptimizer();\n",
        "imports": [
          "./backgroundMonitor",
          "./workerManager"
        ],
        "exports": [
          "spatialOptimizer"
        ],
        "dependencies": [
          "./backgroundMonitor",
          "./workerManager"
        ]
      },
      {
        "path": "utils/spatialUtils.js",
        "content": "// src/utils/spatialUtils.js\n\nimport _ from 'lodash';\n\n/**\n * Transform region name to normalized format\n * @param {string} name - Region name to transform\n * @returns {string} Normalized region name\n */\nexport const transformRegionName = (name) => {\n  if (!name) return '';\n  return name.toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s]/g, '')\n    .replace(/\\s+/g, '_');\n};\n\n/**\n * Get coordinates for a region\n * @param {string} region - Region name\n * @returns {Array} [longitude, latitude]\n */\nexport const getRegionCoordinates = (region) => {\n  const YEMEN_COORDINATES = {\n    'abyan': [45.83, 13.58],\n    'aden': [45.03, 12.77],\n    'al_bayda': [45.57, 14.17],\n    'al_dhalee': [44.73, 13.70],\n    'al_hudaydah': [42.95, 14.80],\n    'al_jawf': [45.50, 16.60],\n    'al_maharah': [51.83, 16.52],\n    'al_mahwit': [43.55, 15.47],\n    'amanat_al_asimah': [44.21, 15.35],\n    'amran': [43.94, 15.66],\n    'dhamar': [44.24, 14.54],\n    'hadramaut': [48.78, 15.93],\n    'hajjah': [43.60, 15.63],\n    'ibb': [44.18, 13.97],\n    'lahj': [44.88, 13.03],\n    'marib': [45.32, 15.47],\n    'raymah': [43.71, 14.68],\n    'sanaa': [44.21, 15.35],\n    'shabwah': [47.01, 14.53],\n    'taizz': [44.02, 13.58],\n    'socotra': [53.87, 12.47]\n  };\n\n  const normalizedRegion = transformRegionName(region);\n  return YEMEN_COORDINATES[normalizedRegion] || [0, 0];\n};\n\n/**\n * Calculate center point from array of coordinates\n * @param {Array} coordinates - Array of [lon, lat] coordinates\n * @returns {Array} Center [longitude, latitude]\n */\nexport const calculateCenter = (coordinates) => {\n  if (!Array.isArray(coordinates) || !coordinates.length) {\n    return [0, 0];\n  }\n\n  const validCoords = coordinates.filter(coord => \n    Array.isArray(coord) && coord.length === 2 &&\n    !isNaN(coord[0]) && !isNaN(coord[1])\n  );\n\n  if (!validCoords.length) return [0, 0];\n\n  const sum = validCoords.reduce((acc, coord) => ({\n    lon: acc.lon + coord[0],\n    lat: acc.lat + coord[1]\n  }), { lon: 0, lat: 0 });\n\n  return [\n    sum.lon / validCoords.length,\n    sum.lat / validCoords.length\n  ];\n};\n\n/**\n * Validate coordinates\n * @param {Array} coordinates - [longitude, latitude] coordinates\n * @returns {Array|null} Validated coordinates or null\n */\nexport const validateCoordinates = (coordinates) => {\n  if (!Array.isArray(coordinates) || coordinates.length !== 2) {\n    return null;\n  }\n\n  const [lon, lat] = coordinates.map(Number);\n\n  if (isNaN(lon) || isNaN(lat) ||\n      Math.abs(lat) > 90 || Math.abs(lon) > 180) {\n    return null;\n  }\n\n  return [lon, lat];\n};\n\n/**\n * Calculate bounding box for array of coordinates\n * @param {Array} coordinates - Array of [lon, lat] coordinates\n * @returns {Object} Bounding box {minLon, maxLon, minLat, maxLat}\n */\nexport const calculateBoundingBox = (coordinates) => {\n  if (!Array.isArray(coordinates) || !coordinates.length) {\n    return {\n      minLon: 0, maxLon: 0,\n      minLat: 0, maxLat: 0\n    };\n  }\n\n  const validCoords = coordinates\n    .map(validateCoordinates)\n    .filter(Boolean);\n\n  if (!validCoords.length) {\n    return {\n      minLon: 0, maxLon: 0,\n      minLat: 0, maxLat: 0\n    };\n  }\n\n  return validCoords.reduce((box, [lon, lat]) => ({\n    minLon: Math.min(box.minLon, lon),\n    maxLon: Math.max(box.maxLon, lon),\n    minLat: Math.min(box.minLat, lat),\n    maxLat: Math.max(box.maxLat, lat)\n  }), {\n    minLon: validCoords[0][0],\n    maxLon: validCoords[0][0],\n    minLat: validCoords[0][1],\n    maxLat: validCoords[0][1]\n  });\n};\n\n/**\n * Calculate distance between two coordinates\n * @param {Array} coord1 - [lon1, lat1] coordinates\n * @param {Array} coord2 - [lon2, lat2] coordinates\n * @returns {number} Distance in kilometers\n */\nexport const calculateDistance = (coord1, coord2) => {\n  const valid1 = validateCoordinates(coord1);\n  const valid2 = validateCoordinates(coord2);\n\n  if (!valid1 || !valid2) return 0;\n\n  const [lon1, lat1] = valid1;\n  const [lon2, lat2] = valid2;\n\n  const R = 6371; // Earth's radius in kilometers\n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n\n  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n           Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * \n           Math.sin(dLon/2) * Math.sin(dLon/2);\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  return R * c;\n};\n\n/**\n * Convert degrees to radians\n * @param {number} degrees - Angle in degrees\n * @returns {number} Angle in radians\n */\nconst toRad = (degrees) => degrees * Math.PI / 180;\n\n/**\n * Find neighboring regions based on distance threshold\n * @param {Array} regions - Array of region objects with coordinates\n * @param {number} threshold - Distance threshold in kilometers\n * @returns {Object} Map of region to array of neighboring regions\n */\nexport const findNeighbors = (regions, threshold = 100) => {\n  if (!Array.isArray(regions)) return {};\n\n  const neighbors = {};\n\n  regions.forEach(region => {\n    const regionCoords = validateCoordinates(region.coordinates);\n    if (!regionCoords) return;\n\n    neighbors[region.id] = regions\n      .filter(other => other.id !== region.id)\n      .filter(other => {\n        const otherCoords = validateCoordinates(other.coordinates);\n        if (!otherCoords) return false;\n\n        const distance = calculateDistance(regionCoords, otherCoords);\n        return distance <= threshold;\n      })\n      .map(other => other.id);\n  });\n\n  return neighbors;\n};\n\n/**\n * Convert UTM coordinates to [longitude, latitude]\n * @param {number} easting - UTM easting coordinate\n * @param {number} northing - UTM northing coordinate\n * @param {number} zone - UTM zone (default: 38 for Yemen)\n * @returns {Array} [longitude, latitude] coordinates\n */\nexport const convertUTMtoLatLon = (easting, northing, zone = 38) => {\n  const k0 = 0.9996;\n  const a = 6378137;\n  const e = 0.081819191;\n  const e1sq = 0.006739497;\n  const falseEasting = 500000;\n\n  const x = easting - falseEasting;\n  const y = northing;\n\n  const M = y / k0;\n  const mu = M / (a * (1 - e * e / 4 - 3 * e * e * e * e / 64));\n\n  const phi1 = mu + (3 * e1sq / 2 - 27 * Math.pow(e1sq, 3) / 32) * Math.sin(2 * mu);\n  const phi2 = phi1 + (21 * Math.pow(e1sq, 2) / 16 - 55 * Math.pow(e1sq, 4) / 32) * Math.sin(4 * mu);\n  const phi = phi2 + (151 * Math.pow(e1sq, 3) / 96) * Math.sin(6 * mu);\n\n  const N1 = a / Math.sqrt(1 - e * e * Math.sin(phi) * Math.sin(phi));\n  const T1 = Math.tan(phi) * Math.tan(phi);\n  const C1 = (e * e * Math.cos(phi) * Math.cos(phi)) / (1 - e * e);\n  const R1 = (a * (1 - e * e)) / Math.pow(1 - e * e * Math.sin(phi) * Math.sin(phi), 1.5);\n  const D = x / (N1 * k0);\n\n  const lat = phi - (N1 * Math.tan(phi) / R1) * (\n    (D * D) / 2 -\n    (5 + 3 * T1 + 10 * C1 - 4 * Math.pow(C1, 2) - 9 * e * e) * Math.pow(D, 4) / 24 +\n    (61 + 90 * T1 + 298 * C1 + 45 * Math.pow(T1, 2) - 252 * e * e - 3 * Math.pow(C1, 2)) * Math.pow(D, 6) / 720\n  );\n\n  const lon = ((zone * 6 - 183) + (D - (1 + 2 * T1 + C1) * Math.pow(D, 3) / 6 +\n    (5 - 2 * C1 + 28 * T1 - 3 * Math.pow(C1, 2) + 8 * e * e + 24 * Math.pow(T1, 2)) * Math.pow(D, 5) / 120)\n  ) / Math.cos(phi) * (180 / Math.PI);\n\n  return validateCoordinates([lon, lat * 180 / Math.PI]) || [0, 0];\n};\n\n// Export all utilities for testing\nexport const utils = {\n  transformRegionName,\n  getRegionCoordinates,\n  calculateCenter,\n  validateCoordinates,\n  calculateBoundingBox,\n  calculateDistance,\n  findNeighbors,\n  convertUTMtoLatLon,\n  toRad\n};\n",
        "imports": [
          "lodash"
        ],
        "exports": [
          "transformRegionName",
          "getRegionCoordinates",
          "calculateCenter",
          "validateCoordinates",
          "calculateBoundingBox",
          "calculateDistance",
          "findNeighbors",
          "convertUTMtoLatLon",
          "utils"
        ],
        "dependencies": [
          "lodash"
        ]
      },
      {
        "path": "utils/workerManager.js",
        "content": "// Worker Manager for handling Web Worker communication\nclass WorkerManager {\n  constructor() {\n    this.workers = new Map();\n    this.taskQueue = new Map();\n    this.activeWorkers = 0;\n    this.maxWorkers = navigator.hardwareConcurrency || 4;\n  }\n\n  async getWorker() {\n    // Reuse existing idle worker if available\n    for (const [id, worker] of this.workers.entries()) {\n      if (!this.taskQueue.has(id)) {\n        return { worker, id };\n      }\n    }\n\n    // Create new worker if under limit\n    if (this.workers.size < this.maxWorkers) {\n      const id = this.workers.size;\n      const worker = new Worker(new URL('../workers/spatialWorker.js', import.meta.url), {\n        type: 'module'\n      });\n      this.workers.set(id, worker);\n      return { worker, id };\n    }\n\n    // Wait for next available worker\n    return new Promise(resolve => {\n      const checkInterval = setInterval(() => {\n        for (const [id, worker] of this.workers.entries()) {\n          if (!this.taskQueue.has(id)) {\n            clearInterval(checkInterval);\n            resolve({ worker, id });\n            return;\n          }\n        }\n      }, 100);\n    });\n  }\n\n  async processData(type, data, options = {}) {\n    const { worker, id } = await this.getWorker();\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        this.taskQueue.delete(id);\n        reject(new Error(`Worker task timed out: ${type}`));\n      }, 30000); // 30 second timeout\n\n      const messageHandler = (event) => {\n        if (event.data.type === 'success') {\n          cleanup();\n          resolve(event.data.result);\n        } else if (event.data.type === 'error') {\n          cleanup();\n          reject(new Error(event.data.error));\n        }\n      };\n\n      const errorHandler = (error) => {\n        cleanup();\n        reject(error);\n      };\n\n      const cleanup = () => {\n        clearTimeout(timeoutId);\n        this.taskQueue.delete(id);\n        worker.removeEventListener('message', messageHandler);\n        worker.removeEventListener('error', errorHandler);\n      };\n\n      worker.addEventListener('message', messageHandler);\n      worker.addEventListener('error', errorHandler);\n\n      this.taskQueue.set(id, { type, startTime: Date.now() });\n      worker.postMessage({ type, data, options });\n    });\n  }\n\n  async processFlowData(data) {\n    return this.processData('processFlowData', data);\n  }\n\n  async processTimeSeriesData(data) {\n    return this.processData('processTimeSeriesData', data);\n  }\n\n  async processMarketClusters(data, options) {\n    return this.processData('processMarketClusters', data, options);\n  }\n\n  terminateAll() {\n    for (const worker of this.workers.values()) {\n      worker.terminate();\n    }\n    this.workers.clear();\n    this.taskQueue.clear();\n  }\n}\n\nexport const workerManager = new WorkerManager();\n",
        "imports": [],
        "exports": [
          "workerManager"
        ],
        "dependencies": []
      },
      {
        "path": "utils/workerPool.js",
        "content": "// src/utils/workerPool.js\n\nimport { backgroundMonitor } from './backgroundMonitor';\n\nclass WorkerPool {\n  constructor() {\n    this.maxWorkers = Math.min(navigator.hardwareConcurrency - 1, 4);\n    this.workers = new Map();\n    this.taskQueue = [];\n    this.processing = new Set();\n    this.stats = {\n      totalTasks: 0,\n      completedTasks: 0,\n      failedTasks: 0,\n      averageProcessingTime: 0\n    };\n  }\n\n  async processTask(type, data, options = {}) {\n    const metric = backgroundMonitor.startMetric('worker-task', { type });\n    const startTime = performance.now();\n\n    try {\n      // Get available worker\n      const worker = await this.getWorker();\n      const taskId = this._generateTaskId();\n      \n      const result = await new Promise((resolve, reject) => {\n        // Set task timeout\n        const timeoutId = setTimeout(() => {\n          this.handleTaskFailure(taskId, worker, 'Task timeout');\n          reject(new Error('Task timeout'));\n        }, options.timeout || 30000);\n\n        // Set up message handler\n        worker.onmessage = (event) => {\n          clearTimeout(timeoutId);\n          this.stats.completedTasks++;\n          this.updateAverageTime(performance.now() - startTime);\n          resolve(event.data);\n        };\n\n        // Set up error handler\n        worker.onerror = (error) => {\n          clearTimeout(timeoutId);\n          this.handleTaskFailure(taskId, worker, error);\n          reject(error);\n        };\n\n        // Track task\n        this.processing.add(taskId);\n        this.stats.totalTasks++;\n\n        // Send task to worker\n        worker.postMessage({ type, data, taskId });\n      });\n\n      this.releaseWorker(worker);\n      metric.finish({ status: 'success' });\n      return result;\n\n    } catch (error) {\n      this.stats.failedTasks++;\n      metric.finish({ status: 'error', error: error.message });\n      throw error;\n    }\n  }\n\n  async getWorker() {\n    // Reuse available worker\n    for (const [worker, busy] of this.workers.entries()) {\n      if (!busy) {\n        this.workers.set(worker, true);\n        return worker;\n      }\n    }\n\n    // Create new worker if under limit\n    if (this.workers.size < this.maxWorkers) {\n      const worker = new Worker(new URL('../workers/dataWorker.js', import.meta.url));\n      this.workers.set(worker, true);\n      return worker;\n    }\n\n    // Wait for available worker\n    return new Promise(resolve => {\n      this.taskQueue.push(resolve);\n    });\n  }\n\n  releaseWorker(worker) {\n    this.workers.set(worker, false);\n    \n    // Process next queued task\n    if (this.taskQueue.length > 0) {\n      const nextTask = this.taskQueue.shift();\n      this.workers.set(worker, true);\n      nextTask(worker);\n    }\n  }\n\n  handleTaskFailure(taskId, worker, error) {\n    this.processing.delete(taskId);\n    this.releaseWorker(worker);\n    this.stats.failedTasks++;\n    \n    backgroundMonitor.logError('worker-task-failure', {\n      taskId,\n      error: error.message || error,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  updateAverageTime(processingTime) {\n    this.stats.averageProcessingTime = (\n      (this.stats.averageProcessingTime * (this.stats.completedTasks - 1) + \n       processingTime) / this.stats.completedTasks\n    );\n  }\n\n  _generateTaskId() {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getStats() {\n    return {\n      ...this.stats,\n      activeWorkers: Array.from(this.workers.values()).filter(Boolean).length,\n      totalWorkers: this.workers.size,\n      queuedTasks: this.taskQueue.length,\n      processingTasks: this.processing.size\n    };\n  }\n\n  terminate() {\n    this.workers.forEach((_, worker) => worker.terminate());\n    this.workers.clear();\n    this.taskQueue = [];\n    this.processing.clear();\n    \n    backgroundMonitor.logMetric('worker-pool-terminated', {\n      timestamp: Date.now(),\n      stats: this.getStats()\n    });\n  }\n}\n\n// Create singleton instance\nexport const workerPool = new WorkerPool();\n\n// Export task types\nexport const TaskTypes = {\n  PROCESS_SPATIAL: 'PROCESS_SPATIAL',\n  PROCESS_FLOW: 'PROCESS_FLOW',\n  PROCESS_CLUSTERS: 'PROCESS_CLUSTERS',\n  PROCESS_SHOCKS: 'PROCESS_SHOCKS',\n  PROCESS_TIME_SERIES: 'PROCESS_TIME_SERIES'\n};",
        "imports": [
          "./backgroundMonitor"
        ],
        "exports": [
          "workerPool",
          "TaskTypes"
        ],
        "dependencies": [
          "./backgroundMonitor"
        ]
      },
      {
        "path": "workers/enhancedWorkerSystem.js",
        "content": "// src/workers/enhancedWorkerSystem.js\n\n/**\n * Enhanced worker system with centralized management, better error handling,\n * progress tracking using a worker pool, and support for transferable objects.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport EventEmitter from 'eventemitter3';\nimport { useCallback } from 'react'; // Ensure useCallback is imported\n\nexport const WorkerMessageTypes = {\n  PROCESS_SPATIAL: 'PROCESS_SPATIAL',\n  PROCESS_GEOJSON: 'PROCESS_GEOJSON',\n  PROCESS_FLOW_DATA: 'PROCESS_FLOW_DATA',\n  GENERATE_CSV: 'GENERATE_CSV',\n  CALCULATE_STATISTICS: 'CALCULATE_STATISTICS',\n  PROCESS_CLUSTERS: 'PROCESS_CLUSTERS',\n  PROCESS_SHOCKS: 'PROCESS_SHOCKS',\n  ERROR: 'ERROR',\n  PROGRESS: 'PROGRESS',\n  PROCESS_TIME_SERIES: 'PROCESS_TIME_SERIES'\n};\n\n// Singleton instance handling\nlet instance = null;\n\nclass WorkerManager extends EventEmitter {\n  constructor() {\n    if (instance) {\n      return instance;\n    }\n    super();\n    this.workers = [];\n    this.taskQueue = [];\n    this.maxWorkers = navigator.hardwareConcurrency || 4;\n    this.isInitialized = false;\n    this.workerURL = null;\n    this.initializationPromise = null;\n    instance = this;\n    return instance;\n  }\n\n  async initialize() {\n    // If already initialized, return existing promise\n    if (this.initializationPromise) {\n      return this.initializationPromise;\n    }\n\n    // If already initialized, return immediately\n    if (this.isInitialized) {\n      return Promise.resolve();\n    }\n\n    // Create initialization promise\n    this.initializationPromise = new Promise((resolve, reject) => {\n      try {\n        this.initializeWorkerPool();\n        this.isInitialized = true;\n        console.log('WorkerManager initialized.');\n        resolve();\n      } catch (error) {\n        console.error('Failed to initialize WorkerManager:', error);\n        reject(error);\n      }\n    });\n\n    return this.initializationPromise;\n  }\n\n  initializeWorkerPool() {\n    const workerCode = `\n      const CHUNK_SIZE = 500000;\n\n      function processInChunks(data, processor) {\n        const chunks = [];\n        for (let i = 0; i < data.length; i += CHUNK_SIZE) {\n          chunks.push(data.slice(i, i + CHUNK_SIZE));\n        }\n        return chunks.map(processor).flat();\n      }\n\n      function reportProgress(progress) {\n        self.postMessage({\n          type: 'PROGRESS',\n          data: { progress }\n        });\n      }\n\n      self.onmessage = async (event) => {\n        const { type, data, taskId } = event.data;\n        \n        try {\n          let result;\n          switch (type) {\n            case 'PROCESS_SPATIAL':\n              result = await processSpatialData(data, taskId);\n              break;\n            case 'PROCESS_GEOJSON':\n              result = processGeoJSON(data, taskId);\n              break;\n            case 'PROCESS_FLOW_DATA':\n              result = processFlowData(data, taskId);\n              break;\n            case 'GENERATE_CSV':\n              result = generateCSV(data, taskId);\n              break;\n            case 'CALCULATE_STATISTICS':\n              result = calculateStatistics(data, taskId);\n              break;\n            case 'PROCESS_CLUSTERS':\n              result = processClusters(data, taskId);\n              break;\n            case 'PROCESS_SHOCKS':\n              result = processShocks(data, taskId);\n              break;\n            case 'PROCESS_TIME_SERIES':\n              result = await processTimeSeries(data);\n              break;\n            default:\n              throw new Error(\\`Unknown message type: \\${type}\\`);\n          }\n          \n          self.postMessage({ type, data: result, taskId });\n        } catch (error) {\n          self.postMessage({ \n            type: 'ERROR', \n            error: error.message, \n            taskId \n          });\n        }\n      };\n\n      async function processSpatialData(data) {\n        const { geoData, flows, weights } = data;\n        let progress = 0;\n\n        try {\n          const processedFeatures = processInChunks(\n            geoData.features,\n            (chunk) => chunk.map(processFeature)\n          );\n          progress = 33;\n          reportProgress(progress);\n\n          const processedFlows = processInChunks(\n            flows,\n            (chunk) => chunk.map(processFlow)\n          );\n          progress = 66;\n          reportProgress(progress);\n\n          const processedWeights = processWeights(weights);\n          progress = 100;\n          reportProgress(progress);\n\n          return {\n            geoData: { ...geoData, features: processedFeatures },\n            flows: processedFlows,\n            weights: processedWeights\n          };\n        } catch (error) {\n          throw error;\n        }\n      }\n\n      function processFeature(feature) {\n        return {\n          ...feature,\n          properties: {\n            ...feature.properties,\n            price: parseFloat(feature.properties.price) || 0,\n            date: new Date(feature.properties.date).toISOString()\n          }\n        };\n      }\n\n      function processFlow(flow) {\n        return {\n          ...flow,\n          flow_weight: parseFloat(flow.flow_weight) || 0,\n          date: new Date(flow.date).toISOString()\n        };\n      }\n\n      function processWeights(weights) {\n        const processed = {};\n        for (const [region, data] of Object.entries(weights)) {\n          processed[region] = {\n            neighbors: Array.isArray(data.neighbors) ? data.neighbors : [],\n            weight: parseFloat(data.weight) || 0\n          };\n        }\n        return processed;\n      }\n\n      function processGeoJSON(data) {\n        return data; // Stub processing for example\n      }\n\n      function processFlowData(data) {\n        return data; // Stub processing for example\n      }\n\n      function generateCSV(data) {\n        return data; // Stub CSV generation\n      }\n\n      function calculateStatistics(data) {\n        return data; // Stub statistics calculation\n      }\n\n      function processClusters(data) {\n        const { geoData, flows, weights } = data;\n        const clusters = [];\n        geoData.features.forEach((feature, idx) => {\n          clusters.push({\n            mainMarket: feature.properties.region || feature.properties.region_id,\n            connectedMarkets: new Set(weights[feature.properties.region_id]?.neighbors || []),\n            totalFlow: flows.reduce((sum, flow) => {\n              if (flow.source === feature.properties.region_id || flow.target === feature.properties.region_id) {\n                return sum + flow.flow_weight;\n              }\n              return sum;\n            }, 0),\n            avgFlow: flows.length > 0 ? flows.reduce((sum, flow) => sum + flow.flow_weight, 0) / flows.length : 0,\n            marketCount: weights[feature.properties.region_id]?.neighbors?.length || 1,\n            lat: feature.geometry?.coordinates?.[1] || 0,\n            lng: feature.geometry?.coordinates?.[0] || 0,\n            color: '#FF5733' \n          });\n        });\n        return clusters;\n      }\n\n      function processShocks(data) {\n        const { geoData, date } = data;\n        const shocks = [];\n        geoData.features.forEach((feature) => {\n          if (Math.random() < 0.05) { \n            shocks.push({\n              region: feature.properties.region || feature.properties.region_id,\n              type: Math.random() > 0.5 ? 'price_surge' : 'price_drop',\n              magnitude: Math.random() * 0.2,\n              severity: Math.random() > 0.7 ? 'high' : 'medium',\n              lat: feature.geometry?.coordinates?.[1] || 0,\n              lng: feature.geometry?.coordinates?.[0] || 0,\n              month: date\n            });\n          }\n        });\n        return shocks;\n      }\n\n      async function processTimeSeries(data) {\n        const { features, commodity, selectedDate } = data;\n        let progress = 0;\n        reportProgress(progress);\n\n        try {\n          // Group features by month\n          const monthlyData = features.reduce((acc, feature) => {\n            const { properties } = feature;\n            if (!properties?.date) return acc;\n\n            const date = new Date(properties.date);\n            if (isNaN(date.getTime())) return acc;\n\n            const month = date.toISOString().slice(0, 7);\n            \n            if (!acc[month]) {\n              acc[month] = {\n                prices: [],\n                conflictIntensity: [],\n                usdPrices: [],\n                count: 0\n              };\n            }\n\n            // Validate and add numerical values\n            if (!isNaN(properties.price)) {\n              acc[month].prices.push(properties.price);\n            }\n            if (!isNaN(properties.conflict_intensity)) {\n              acc[month].conflictIntensity.push(properties.conflict_intensity);\n            }\n            if (!isNaN(properties.usdprice)) {\n              acc[month].usdPrices.push(properties.usdprice);\n            }\n            \n            acc[month].count++;\n            return acc;\n          }, {});\n\n          progress = 50;\n          reportProgress(progress);\n\n          // Calculate statistics for each month\n          const timeSeriesData = Object.entries(monthlyData)\n            .filter(([_, data]) => data.count >= 3) // Minimum data points threshold\n            .map(([month, data]) => {\n              const stats = calculateMonthlyStats(data);\n              return {\n                month,\n                ...stats,\n                sampleSize: data.count\n              };\n            })\n            .sort((a, b) => a.month.localeCompare(b.month));\n\n          progress = 100;\n          reportProgress(progress);\n\n          return timeSeriesData;\n        } catch (error) {\n          throw new Error(\\`Time series processing error: \\${error.message}\\`);\n        }\n      }\n\n      function calculateMonthlyStats(data) {\n        const stats = {\n          avgPrice: null,\n          volatility: null,\n          avgConflictIntensity: null,\n          avgUsdPrice: null,\n          priceRange: { min: null, max: null }\n        };\n\n        try {\n          if (data.prices.length > 0) {\n            const cleanPrices = removeOutliers(data.prices);\n            stats.avgPrice = calculateMean(cleanPrices);\n            const stdDev = calculateStandardDeviation(cleanPrices);\n            stats.volatility = (stdDev / stats.avgPrice) * 100;\n            stats.priceRange = {\n              min: Math.min(...cleanPrices),\n              max: Math.max(...cleanPrices)\n            };\n          }\n\n          if (data.conflictIntensity.length > 0) {\n            stats.avgConflictIntensity = calculateMean(data.conflictIntensity);\n          }\n\n          if (data.usdPrices.length > 0) {\n            const cleanUsdPrices = removeOutliers(data.usdPrices);\n            stats.avgUsdPrice = calculateMean(cleanUsdPrices);\n          }\n\n          return stats;\n        } catch (error) {\n          console.error('Error calculating monthly statistics:', error);\n          return stats;\n        }\n      }\n\n      function calculateMean(values) {\n        if (!values?.length) return null;\n        return values.reduce((sum, val) => sum + val, 0) / values.length;\n      }\n\n      function calculateStandardDeviation(values) {\n        if (!values?.length) return null;\n        const mean = calculateMean(values);\n        const squaredDiffs = values.map(val => Math.pow(val - mean, 2));\n        const variance = calculateMean(squaredDiffs);\n        return Math.sqrt(variance);\n      }\n\n      function removeOutliers(values) {\n        if (!values?.length) return [];\n        const mean = calculateMean(values);\n        const stdDev = calculateStandardDeviation(values);\n        const maxDeviations = 3;\n        \n        return values.filter(value => \n          Math.abs(value - mean) <= maxDeviations * stdDev\n        );\n      }\n    `;\n\n    const blob = new Blob([workerCode], { type: 'application/javascript' });\n    this.workerURL = URL.createObjectURL(blob);\n\n    for (let i = 0; i < this.maxWorkers; i++) {\n      try {\n        const worker = new Worker(this.workerURL);\n        worker.isBusy = false;\n        worker.currentTask = null;\n        worker.onmessage = this.handleWorkerMessage.bind(this, worker);\n        worker.onerror = this.handleWorkerError.bind(this, worker);\n        this.workers.push(worker);\n      } catch (error) {\n        console.error(`Failed to create worker ${i}:`, error);\n      }\n    }\n\n    URL.revokeObjectURL(this.workerURL);\n  }\n\n  handleWorkerMessage(worker, event) {\n    const { type, data, error, taskId } = event.data;\n\n    if (type === WorkerMessageTypes.ERROR) {\n      const task = worker.currentTask;\n      if (task) {\n        task.reject(new Error(error));\n        this.emit('error', { taskId, error });\n        worker.currentTask = null;\n      }\n    } else if (type === WorkerMessageTypes.PROGRESS) {\n      const task = worker.currentTask;\n      if (task && task.onProgress) {\n        task.onProgress(data.progress);\n      }\n      this.emit('progress', { taskId, progress: data.progress });\n    } else {\n      const task = worker.currentTask;\n      if (task) {\n        task.resolve(data);\n        this.emit('complete', { taskId, data });\n        worker.currentTask = null;\n      }\n    }\n\n    worker.isBusy = false;\n    this.processNextTask();\n  }\n\n  handleWorkerError(worker, error) {\n    console.error(`Worker encountered an error:`, error);\n    if (worker.currentTask) {\n      worker.currentTask.reject(new Error(error.message));\n      this.emit('error', { taskId: worker.currentTask.taskId, error: error.message });\n      worker.currentTask = null;\n    }\n    worker.isBusy = false;\n    this.restartWorker(worker);\n    this.processNextTask();\n  }\n\n  restartWorker(worker) {\n    const newWorker = new Worker(this.workerURL);\n    newWorker.isBusy = false;\n    newWorker.currentTask = null;\n    newWorker.onmessage = this.handleWorkerMessage.bind(this, newWorker);\n    newWorker.onerror = this.handleWorkerError.bind(this, newWorker);\n\n    const index = this.workers.indexOf(worker);\n    if (index !== -1) {\n      this.workers[index] = newWorker;\n    } else {\n      this.workers.push(newWorker);\n    }\n  }\n\n  processNextTask() {\n    if (this.taskQueue.length === 0) return;\n\n    const availableWorker = this.workers.find(worker => !worker.isBusy);\n    if (!availableWorker) return;\n\n    const nextTask = this.taskQueue.shift();\n    this.executeTask(availableWorker, nextTask);\n  }\n\n  processData(type, data, onProgress = null) {\n    if (!this.isInitialized) {\n      return Promise.reject(new Error('WorkerManager is not initialized. Call initialize() before processing tasks.'));\n    }\n\n    return new Promise((resolve, reject) => {\n      const taskId = uuidv4();\n      const task = { type, data, taskId, resolve, reject, onProgress };\n\n      const availableWorker = this.workers.find(worker => !worker.isBusy);\n      if (availableWorker) {\n        this.executeTask(availableWorker, task);\n      } else {\n        this.taskQueue.push(task);\n      }\n    });\n  }\n\n  executeTask(worker, task) {\n    worker.isBusy = true;\n    worker.currentTask = task;\n    worker.postMessage({ type: task.type, data: task.data, taskId: task.taskId }, this.getTransferable(task.data));\n  }\n\n  getTransferable(data) {\n    const transferable = [];\n    function extractTransferable(obj) {\n      if (obj instanceof ArrayBuffer) {\n        transferable.push(obj);\n      } else if (Array.isArray(obj)) {\n        obj.forEach(item => extractTransferable(item));\n      } else if (obj && typeof obj === 'object') {\n        Object.values(obj).forEach(value => extractTransferable(value));\n      }\n    }\n    extractTransferable(data);\n    return transferable;\n  }\n\n  handleProgress(taskId, progress) {\n    this.emit('taskProgress', { taskId, progress });\n  }\n\n  terminate() {\n    this.workers.forEach(worker => worker.terminate());\n    this.workers = [];\n    this.taskQueue = [];\n    this.isInitialized = false;\n    console.log('WorkerManager terminated and cleaned up.');\n  }\n}\n\nexport const workerManager = new WorkerManager();\n\n// Don't automatically initialize - let the system handle it\nexport const initializeWorkerManager = async () => {\n  if (!workerManager.isInitialized) {\n    await workerManager.initialize();\n  }\n};\n\nexport const useWorkerManager = () => {\n  const initialize = useCallback(async () => {\n    try {\n      if (!workerManager.isInitialized) {\n        await workerManager.initialize();\n      }\n      return true;\n    } catch (error) {\n      console.error('Worker initialization failed:', error);\n      throw error;\n    }\n  }, []);\n\n  const ensureInitialized = useCallback(async () => {\n    if (!workerManager.isInitialized) {\n      await initialize();\n    }\n  }, [initialize]);\n\n  const processGeoJSON = useCallback(async (data, onProgress) => {\n    await ensureInitialized();\n    return workerManager.processData(WorkerMessageTypes.PROCESS_GEOJSON, data, onProgress);\n  }, [ensureInitialized]);\n\n  const processFlowData = useCallback(async (data, onProgress) => {\n    await ensureInitialized();\n    return workerManager.processData(WorkerMessageTypes.PROCESS_FLOW_DATA, data, onProgress);\n  }, [ensureInitialized]);\n\n  const processSpatialData = useCallback(async (data, onProgress) => {\n    await ensureInitialized();\n    return workerManager.processData(WorkerMessageTypes.PROCESS_SPATIAL, data, onProgress);\n  }, [ensureInitialized]);\n\n  const generateCSV = useCallback(async (data, onProgress) => {\n    await ensureInitialized();\n    return workerManager.processData(WorkerMessageTypes.GENERATE_CSV, data, onProgress);\n  }, [ensureInitialized]);\n\n  const calculateStatistics = useCallback(async (data, onProgress) => {\n    await ensureInitialized();\n    return workerManager.processData(WorkerMessageTypes.CALCULATE_STATISTICS, data, onProgress);\n  }, [ensureInitialized]);\n\n  const processClusters = useCallback(async (data, onProgress) => {\n    await ensureInitialized();\n    return workerManager.processData(WorkerMessageTypes.PROCESS_CLUSTERS, data, onProgress);\n  }, [ensureInitialized]);\n\n  const processShocks = useCallback(async (data, onProgress) => {\n    await ensureInitialized();\n    return workerManager.processData(WorkerMessageTypes.PROCESS_SHOCKS, data, onProgress);\n  }, [ensureInitialized]);\n\n  const processTimeSeries = useCallback(async (data, onProgress) => {\n    await ensureInitialized();\n    return workerManager.processData(WorkerMessageTypes.PROCESS_TIME_SERIES, data, onProgress);\n  }, [ensureInitialized]);\n\n  const subscribeToProgress = useCallback((callback) => {\n    const handleProgress = ({ taskId, progress }) => {\n      callback(taskId, progress);\n    };\n    workerManager.on('taskProgress', handleProgress);\n    return () => {\n      workerManager.off('taskProgress', handleProgress);\n    };\n  }, []);\n\n  const subscribeToCompletion = useCallback((callback) => {\n    const handleComplete = ({ taskId, data }) => {\n      callback(taskId, data);\n    };\n    workerManager.on('complete', handleComplete);\n    return () => {\n      workerManager.off('complete', handleComplete);\n    };\n  }, []);\n\n  const subscribeToError = useCallback((callback) => {\n    const handleError = ({ taskId, error }) => {\n      callback(taskId, error);\n    };\n    workerManager.on('error', handleError);\n    return () => {\n      workerManager.off('error', handleError);\n    };\n  }, []);\n\n  const terminate = useCallback(() => {\n    if (workerManager.isInitialized) {\n      workerManager.terminate();\n    }\n  }, []);\n\n  const isInitialized = useCallback(() => {\n    return workerManager.isInitialized;\n  }, []);\n\n  return {\n    initialize,\n    terminate,\n    isInitialized,\n    processGeoJSON,\n    processFlowData,\n    processSpatialData,\n    generateCSV,\n    calculateStatistics,\n    processClusters,\n    processShocks,\n    processTimeSeries,\n    subscribeToProgress,\n    subscribeToCompletion,\n    subscribeToError\n  };\n};",
        "imports": [
          "uuid",
          "eventemitter3",
          "react"
        ],
        "exports": [
          "WorkerMessageTypes",
          "workerManager",
          "initializeWorkerManager",
          "useWorkerManager"
        ],
        "dependencies": [
          "uuid",
          "eventemitter3",
          "react"
        ]
      },
      {
        "path": "workers/processTimeSeriesData.js",
        "content": "// src/workers/timeSeriesWorker.js\nconst processTimeSeriesData = (data) => {\n    // Process time series calculations\n    const processed = data.map(entry => {\n      const volatility = calculateVolatility(entry);\n      const trends = calculateTrends(entry);\n      return {\n        ...entry,\n        volatility,\n        trends,\n        processed: true\n      };\n    });\n  \n    return processed;\n  };\n  \n  const calculateVolatility = (entry) => {\n    if (!entry.prices || !entry.prices.length) return 0;\n    \n    const prices = entry.prices;\n    const mean = prices.reduce((a, b) => a + b, 0) / prices.length;\n    const variance = prices.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / prices.length;\n    return Math.sqrt(variance);\n  };\n  \n  const calculateTrends = (entry) => {\n    // Implement trend calculations\n    return {\n      shortTerm: calculateShortTermTrend(entry),\n      longTerm: calculateLongTermTrend(entry),\n      seasonal: detectSeasonality(entry)\n    };\n  };\n  \n  const calculateShortTermTrend = (entry) => {\n    // Short term trend logic\n  };\n  \n  const calculateLongTermTrend = (entry) => {\n    // Long term trend logic\n  };\n  \n  const detectSeasonality = (entry) => {\n    // Seasonality detection logic\n  };\n  \n  self.onmessage = async (e) => {\n    const { type, payload } = e.data;\n  \n    switch (type) {\n      case 'PROCESS_TIME_SERIES':\n        try {\n          const result = processTimeSeriesData(payload.data);\n          self.postMessage({\n            type: 'TIME_SERIES_COMPLETE',\n            payload: {\n              data: result,\n              metadata: {\n                commodity: payload.commodity,\n                processedAt: new Date().toISOString()\n              }\n            }\n          });\n        } catch (error) {\n          self.postMessage({\n            type: 'TIME_SERIES_ERROR',\n            error: error.message\n          });\n        }\n        break;\n  \n      case 'CALCULATE_VISUALIZATION':\n        try {\n          // Handle visualization calculations\n          const visualData = calculateVisualizationData(payload);\n          self.postMessage({\n            type: 'VISUALIZATION_COMPLETE',\n            payload: visualData\n          });\n        } catch (error) {\n          self.postMessage({\n            type: 'VISUALIZATION_ERROR',\n            error: error.message\n          });\n        }\n        break;\n    }\n  };",
        "imports": [],
        "exports": [],
        "dependencies": []
      },
      {
        "path": "workers/spatialWorker.js",
        "content": "// Web Worker for heavy spatial computations\nimport { \n  processTimeSeries,\n  calculateFlowMetrics,\n  calculateClustersMetrics,\n  calculateMarketMetrics\n} from '../utils/marketAnalysisUtils';\n\n// Handle messages from main thread\nself.onmessage = async (event) => {\n  const { type, data, options } = event.data;\n\n  try {\n    let result;\n    \n    switch (type) {\n      case 'processFlowData':\n        result = calculateFlowMetrics(data, options);\n        break;\n        \n      case 'processTimeSeriesData':\n        result = processTimeSeries(data, options);\n        break;\n        \n      case 'processMarketClusters':\n        result = calculateClustersMetrics(data, options);\n        break;\n\n      case 'processMarketMetrics':\n        result = calculateMarketMetrics(data, options);\n        break;\n        \n      default:\n        throw new Error(`Unknown computation type: ${type}`);\n    }\n\n    // Send result back to main thread\n    self.postMessage({\n      type: 'success',\n      result\n    });\n  } catch (error) {\n    // Send error back to main thread\n    self.postMessage({\n      type: 'error',\n      error: error.message\n    });\n  }\n};\n",
        "imports": [
          "../utils/marketAnalysisUtils"
        ],
        "exports": [],
        "dependencies": [
          "../utils/marketAnalysisUtils"
        ]
      }
    ],
    "dependencies": [
      "react",
      "leaflet/dist/leaflet.css",
      "@mui/material/styles",
      "@mui/material",
      "@mui/icons-material/Menu",
      "@mui/material/AppBar",
      "./slices/themeSlice",
      "./slices/flowSlice",
      "./components/common/Header",
      "./components/common/Navigation",
      "./Dashboard",
      "./components/common/LoadingSpinner",
      "./components/common/ErrorDisplay",
      "./components/common/EnhancedErrorBoundary",
      "./components/methodology/MethodologyModal",
      "./components/common/WelcomeModal",
      "./components/utils/StateExporter",
      "./store/welcomeModalSlice",
      "./hooks",
      "./utils/backgroundMonitor",
      "./slices/spatialSlice",
      "./hooks/useAppState",
      "./store",
      "@testing-library/react",
      "prop-types",
      "./hooks/useUnifiedData",
      "./components/interactive_graph/InteractiveChart",
      "./components/common/ErrorMessage",
      "./components/common/AnalysisWrapper",
      "./components/spatialAnalysis",
      "lodash",
      "chart.js",
      "chartjs-adapter-date-fns",
      "recharts",
      "@mui/icons-material",
      "file-saver",
      "react-katex",
      "katex/dist/katex.min.css",
      "../../../hooks/dataHooks",
      "./IRFChart",
      "./ACFPlot",
      "./PACFPlot",
      "./InterpretationSection",
      "../../../styles/analysisStyles",
      "jstat",
      "./PriceDifferentialChart",
      "./MarketPairInfo",
      "./CointegrationAnalysis",
      "./StationarityTest",
      "./PriceDifferentialFramework",
      "react-redux",
      "../../../selectors/optimizedSelectors",
      "../../../slices/spatialSlice",
      "./SpatialRegressionResults",
      "./SpatialMap",
      "./SpatialFramework",
      "react-leaflet",
      "./utils/mapUtils",
      "./components/Legend",
      "./components/ResidualsChart",
      "../utils/mapUtils",
      "chroma-js",
      "../../../hooks",
      "./TVMIIChart",
      "./TVMIIMarketPairsChart",
      "./TVMIIInterpretation",
      "./TVMIIFramework",
      "@/hooks",
      "../../styles/analysisStyles",
      "lucide-react",
      "@mui/icons-material/Refresh",
      "@mui/icons-material/BugReport",
      "@mui/icons-material/Brightness4",
      "@mui/icons-material/Brightness7",
      "../methodology/MethodologySection",
      "@mui/icons-material/Info",
      "../../slices/spatialSlice",
      "../../hooks/useDashboardData",
      "../common/EquationWithHelp",
      "../common/TechnicalTooltip",
      "../common/MethodologyLink",
      "react-chartjs-2",
      "../../utils/appUtils",
      "../../hooks/useWindowWidth",
      "react-syntax-highlighter",
      "react-syntax-highlighter/dist/esm/styles/prism",
      "@mui/icons-material/ContentCopy",
      "@mui/icons-material/Check",
      "./MethodologySection",
      "../../utils/methodologyContent",
      "@mui/icons-material/Close",
      "./MethodologyContentWrapper",
      "./CodeBlock",
      "@mui/icons-material/Map",
      "@mui/icons-material/Timeline",
      "@mui/icons-material/Hub",
      "@mui/icons-material/TrendingUp",
      "@mui/icons-material/Warning",
      "@mui/icons-material/CalendarToday",
      "@mui/icons-material/HealthAndSafety",
      "./features/clusters",
      "./features/autocorrelation",
      "./features/flows",
      "./features/shocks",
      "./features/conflict",
      "./features/seasonal",
      "./features/health",
      "../../slices/flowSlice",
      "../common/ErrorBoundary",
      "../common/LoadingIndicator",
      "../../selectors/optimizedSelectors",
      "@mui/icons-material/TrendingDown",
      "@mui/icons-material/InfoOutlined",
      "@mui/icons-material/ExpandMore",
      "@mui/icons-material/ExpandLess",
      "./types",
      "d3-scale",
      "d3-array",
      "@mui/icons-material/ScatterPlot",
      "@mui/icons-material/TableChart",
      "./LISAMap",
      "./MoranScatterPlot",
      "./SpatialAnalysisPanel",
      "./ClusterMatrix",
      "./components/SpatialAnalysisErrorBoundary",
      "./components/SpatialAnalysisOptimizer",
      "./hooks/useSpatialAutocorrelation",
      "@mui/icons-material/ErrorOutline",
      "../../../../../selectors/optimizedSelectors",
      "../utils/spatialCalculations",
      "../types",
      "./SpatialAutocorrelationAnalysis",
      "./utils/spatialCalculations",
      "@reduxjs/toolkit",
      "../spatialCalculations",
      "@mui/icons-material/Mouse",
      "../../organisms/ClusterMap",
      "../../atoms/MetricCard",
      "../../molecules/MetricProgress",
      "../../../../hooks/useSpatialSelectors",
      "../../../../selectors/optimizedSelectors",
      "../../hooks/useClusterAnalysis",
      "../../../utils/spatialUtils",
      "@mui/icons-material/Assessment",
      "./ConflictMap",
      "./ConflictMetricsPanel",
      "../../molecules/TimeControl",
      "../../../../slices/spatialSlice",
      "../../../../selectors/dateSpecificSelectors",
      "../../atoms/Legend",
      "../../atoms/Tooltip",
      "../../molecules/MapControls",
      "../../molecules/BaseMap",
      "../../utils/geoJSONProcessor",
      "../../utils/spatialUtils",
      "@mui/icons-material/PlayArrow",
      "@mui/icons-material/Pause",
      "@mui/icons-material/SkipPrevious",
      "@mui/icons-material/SkipNext",
      "@mui/icons-material/Speed",
      "leaflet",
      "react-transition-group",
      "../../../../slices/flowSlice",
      "./FlowMapTransitions.css",
      "./FlowMap",
      "./FlowMetricsPanel",
      "./FlowDateControl",
      "../../../../hooks/useFlowDataManager",
      "react-force-graph",
      "../../utils/networkAnalysis",
      "@mui/icons-material/CalendarViewMonth",
      "./SeasonalMap",
      "./SeasonalLegend",
      "./ShockMap",
      "./ShockLegend",
      "../../../utils/backgroundMonitor",
      "../features/clusters/utils/clusterCalculations",
      "../../../selectors/spatialAnalysisSelectors",
      "../../../slices/flowSlice",
      "../features/flows/types",
      "./SpatialAnalysis",
      "@mui/icons-material/Add",
      "@mui/icons-material/Remove",
      "@mui/icons-material/CenterFocusStrong",
      "./ClusterMap.css",
      "../../../hooks/useWindowWidth",
      "../atoms/Legend",
      "../atoms/Tooltip",
      "../molecules/MapControls",
      "../utils/spatialUtils",
      "./spatialUtils",
      "@mui/icons-material/Download",
      "../slices/spatialSlice",
      "../utils/backgroundMonitor",
      "../slices/ecmSlice",
      "../types/dataTypes",
      "../utils/dataUtils",
      "../utils/dataCache",
      "./dataHooks",
      "./uiHooks",
      "uuid",
      "../utils/appUtils",
      "./useDashboardData",
      "../store/welcomeModalSlice",
      "../styles/theme",
      "../components/analysis/spatial-analysis/utils/clusterAnalysis",
      "../slices/flowSlice",
      "../utils/numberValidation",
      "../utils/PrecomputedDataManager",
      "../utils/spatialAnalysis",
      "../../../../utils/backgroundMonitor",
      "../store",
      "../utils/dataLoader",
      "../selectors/optimizedSelectors",
      "react-dom/client",
      "./store/configureStore",
      "./App",
      "./utils/ReduxDebugWrapper",
      "./utils/debugUtils",
      "./utils/spatialDataHandler",
      "./utils/leafletSetup",
      "./styles/leaflet-overrides.css",
      "leaflet.markercluster/dist/MarkerCluster.css",
      "leaflet.markercluster/dist/MarkerCluster.Default.css",
      "../components/spatialAnalysis/features/flows/types",
      "reselect",
      "lodash/isEqual",
      "../components/spatialAnalysis/utils/spatialUtils",
      "./optimizedSelectors",
      "../components/spatialAnalysis/types",
      "@testing-library/jest-dom",
      "jest-styled-components",
      "papaparse",
      "../utils/coordinateUtils",
      "../utils/spatialDataHandler",
      "../workers/enhancedWorkerSystem",
      "../utils/marketAnalysisUtils",
      "../constants/index",
      "../slices/themeSlice",
      "./welcomeModalSlice",
      "../middleware/batchMiddleware",
      "../middleware/spatialMiddleware",
      "redux-logger",
      "./createStore",
      "./backgroundMonitor",
      "./pathResolver",
      "./dataCache",
      "./numberValidation",
      "date-fns",
      "d3",
      "../constants",
      "./monitoringUtils",
      "./appUtils",
      "leaflet/dist/images/marker-icon-2x.png",
      "leaflet/dist/images/marker-icon.png",
      "leaflet/dist/images/marker-shadow.png",
      "./spatialDataHandler",
      "./dataUtils",
      "./pathValidator",
      "./workerManager",
      "./polygonNormalizer",
      "eventemitter3"
    ],
    "structure": {
      "bootstrap": 3,
      "config": 118,
      "providers": 3,
      "app": 3,
      "ecm": 10,
      "price-differential": 17,
      "components": 122,
      "utils": 200,
      "spatial": 123,
      "tvmii": 30,
      "analysis": 123,
      "common": 44,
      "debug": 44,
      "documentation": 45,
      "interactive_graph": 46,
      "methodology": 50,
      "atoms": 54,
      "hooks": 136,
      "selectors": 145,
      "__tests__": 67,
      "autocorrelation": 68,
      "clusters": 72,
      "conflict": 76,
      "flows": 82,
      "health": 84,
      "network": 86,
      "seasonal": 90,
      "shocks": 95,
      "features": 122,
      "molecules": 107,
      "organisms": 110,
      "styles": 160,
      "types": 161,
      "spatialAnalysis": 116,
      "constants": 119,
      "context": 122,
      "middleware": 141,
      "store": 157,
      "workers": 203,
      "core": 171,
      "market": 122,
      "data": 123,
      "domains": 123,
      "api": 137,
      "monitoring": 137,
      "persistence": 137,
      "infrastructure": 137,
      "routes": 142,
      "slices": 153
    },
    "imports": {
      ".": [
        {
          "file": "App.js",
          "imports": [
            "react",
            "leaflet/dist/leaflet.css",
            "@mui/material/styles",
            "@mui/material",
            "@mui/icons-material/Menu",
            "@mui/material/styles",
            "@mui/material/AppBar",
            "./slices/themeSlice",
            "./slices/flowSlice",
            "./components/common/Header",
            "./components/common/Navigation",
            "./Dashboard",
            "./components/common/LoadingSpinner",
            "./components/common/ErrorDisplay",
            "./components/common/EnhancedErrorBoundary",
            "./components/methodology/MethodologyModal",
            "./components/common/WelcomeModal",
            "./components/utils/StateExporter",
            "./store/welcomeModalSlice",
            "./hooks",
            "./utils/backgroundMonitor",
            "./slices/spatialSlice",
            "./hooks/useAppState",
            "./store"
          ]
        },
        {
          "file": "App.test.js",
          "imports": [
            "react",
            "@testing-library/react"
          ]
        },
        {
          "file": "Dashboard.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "./hooks/useUnifiedData",
            "./components/interactive_graph/InteractiveChart",
            "./components/common/LoadingSpinner",
            "./components/common/ErrorMessage",
            "./components/common/AnalysisWrapper",
            "./components/spatialAnalysis",
            "./utils/backgroundMonitor",
            "lodash",
            "chart.js",
            "chartjs-adapter-date-fns"
          ]
        },
        {
          "file": "index.js",
          "imports": [
            "react",
            "react-dom/client",
            "react-redux",
            "prop-types",
            "./store/configureStore",
            "./App",
            "./utils/ReduxDebugWrapper",
            "./utils/debugUtils",
            "./utils/backgroundMonitor",
            "./utils/spatialDataHandler",
            "./slices/spatialSlice",
            "./slices/flowSlice",
            "./utils/leafletSetup",
            "leaflet/dist/leaflet.css",
            "./styles/leaflet-overrides.css",
            "leaflet.markercluster/dist/MarkerCluster.css",
            "leaflet.markercluster/dist/MarkerCluster.Default.css"
          ]
        },
        {
          "file": "setupPolyfills.js",
          "imports": []
        },
        {
          "file": "setupTests.js",
          "imports": [
            "@testing-library/jest-dom",
            "jest-styled-components",
            "prop-types",
            "react"
          ]
        }
      ],
      "components/analysis/ecm": [
        {
          "file": "ACFPlot.js",
          "imports": [
            "react",
            "prop-types",
            "recharts",
            "@mui/material"
          ]
        },
        {
          "file": "ECMAnalysis.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "file-saver",
            "react-katex",
            "katex/dist/katex.min.css",
            "../../../hooks/dataHooks",
            "./IRFChart",
            "./ACFPlot",
            "./PACFPlot",
            "./InterpretationSection"
          ]
        },
        {
          "file": "ECMResultsEnhanced.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "../../../styles/analysisStyles",
            "react-katex",
            "katex/dist/katex.min.css"
          ]
        },
        {
          "file": "IRFChart.js",
          "imports": [
            "react",
            "prop-types",
            "recharts",
            "@mui/material"
          ]
        },
        {
          "file": "InterpretationSection.js",
          "imports": [
            "react",
            "@mui/material",
            "prop-types",
            "@mui/icons-material"
          ]
        },
        {
          "file": "PACFPlot.js",
          "imports": [
            "react",
            "prop-types",
            "recharts",
            "@mui/material"
          ]
        },
        {
          "file": "QQPlot.js",
          "imports": [
            "react",
            "prop-types",
            "recharts",
            "jstat",
            "@mui/material"
          ]
        }
      ],
      "components/analysis/price-differential": [
        {
          "file": "CointegrationAnalysis.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material"
          ]
        },
        {
          "file": "InterpretationSection.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material"
          ]
        },
        {
          "file": "MarketPairInfo.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material"
          ]
        },
        {
          "file": "PriceDifferentialAnalysis.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "file-saver",
            "../../../hooks/dataHooks",
            "./PriceDifferentialChart",
            "./MarketPairInfo",
            "./CointegrationAnalysis",
            "./StationarityTest",
            "./PriceDifferentialFramework",
            "./InterpretationSection"
          ]
        },
        {
          "file": "PriceDifferentialChart.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "recharts",
            "@mui/icons-material"
          ]
        },
        {
          "file": "PriceDifferentialFramework.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "react-katex",
            "katex/dist/katex.min.css"
          ]
        },
        {
          "file": "StationarityTest.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material"
          ]
        }
      ],
      "components/analysis/spatial": [
        {
          "file": "SpatialAnalysis.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "file-saver",
            "@mui/material/styles",
            "react-redux",
            "../../../selectors/optimizedSelectors",
            "../../../slices/spatialSlice",
            "./SpatialRegressionResults",
            "./SpatialMap",
            "./SpatialFramework"
          ]
        },
        {
          "file": "SpatialFramework.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "react-katex",
            "katex/dist/katex.min.css"
          ]
        },
        {
          "file": "SpatialMap.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "react-leaflet",
            "react-redux",
            "../../../selectors/optimizedSelectors",
            "./utils/mapUtils",
            "./components/Legend"
          ]
        },
        {
          "file": "SpatialRegressionResults.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "./components/ResidualsChart"
          ]
        }
      ],
      "components/analysis/spatial/components": [
        {
          "file": "Legend.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "../utils/mapUtils"
          ]
        },
        {
          "file": "ResidualsChart.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "recharts"
          ]
        },
        {
          "file": "StatCard.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "../utils/mapUtils"
          ]
        }
      ],
      "components/analysis/spatial/utils": [
        {
          "file": "mapUtils.js",
          "imports": [
            "chroma-js"
          ]
        }
      ],
      "components/analysis/tvmii": [
        {
          "file": "TVMIIAnalysis.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "file-saver",
            "../../../hooks",
            "./TVMIIChart",
            "./TVMIIMarketPairsChart",
            "./TVMIIInterpretation",
            "./TVMIIFramework",
            "../../../styles/analysisStyles"
          ]
        },
        {
          "file": "TVMIIChart.js",
          "imports": [
            "react",
            "prop-types",
            "recharts",
            "@mui/material",
            "@mui/icons-material",
            "@/hooks"
          ]
        },
        {
          "file": "TVMIIFramework.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "react-katex",
            "katex/dist/katex.min.css"
          ]
        },
        {
          "file": "TVMIIInterpretation.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "@/hooks",
            "recharts"
          ]
        },
        {
          "file": "TVMIIMarketPairsChart.js",
          "imports": [
            "react",
            "prop-types",
            "recharts",
            "@mui/material",
            "@mui/icons-material",
            "../../../hooks"
          ]
        }
      ],
      "components/common": [
        {
          "file": "AnalysisContainer.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material",
            "@mui/material/styles",
            "../../styles/analysisStyles"
          ]
        },
        {
          "file": "AnalysisWrapper.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material"
          ]
        },
        {
          "file": "ChartContainer.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "../../styles/analysisStyles"
          ]
        },
        {
          "file": "EnhancedErrorBoundary.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material",
            "lucide-react"
          ]
        },
        {
          "file": "EquationWithHelp.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "lucide-react",
            "react-katex",
            "katex/dist/katex.min.css"
          ]
        },
        {
          "file": "ErrorBoundary.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material/Refresh",
            "@mui/icons-material/BugReport"
          ]
        },
        {
          "file": "ErrorDisplay.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "lucide-react",
            "@mui/material/styles"
          ]
        },
        {
          "file": "ErrorMessage.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material"
          ]
        },
        {
          "file": "Header.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material/Brightness4",
            "@mui/icons-material/Brightness7",
            "@mui/material/styles"
          ]
        },
        {
          "file": "LoadingIndicator.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles"
          ]
        },
        {
          "file": "LoadingSpinner.js",
          "imports": [
            "react",
            "@mui/material"
          ]
        },
        {
          "file": "MethodologyLink.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "lucide-react",
            "@/hooks",
            "../methodology/MethodologySection"
          ]
        },
        {
          "file": "Navigation.js",
          "imports": [
            "react",
            "react-redux",
            "prop-types",
            "@mui/material",
            "@mui/icons-material/Info",
            "lodash",
            "../../slices/spatialSlice",
            "../../hooks/useDashboardData",
            "../../slices/spatialSlice"
          ]
        },
        {
          "file": "WelcomeModal.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles"
          ]
        }
      ],
      "components/documentation": [
        {
          "file": "TechnicalReference.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@/hooks",
            "../common/EquationWithHelp",
            "../common/TechnicalTooltip",
            "../common/MethodologyLink"
          ]
        }
      ],
      "components/interactive_graph": [
        {
          "file": "InteractiveChart.js",
          "imports": [
            "react",
            "react-chartjs-2",
            "chart.js",
            "chartjs-adapter-date-fns",
            "prop-types",
            "@mui/material/styles",
            "@mui/material",
            "../../utils/appUtils",
            "../../hooks/useWindowWidth"
          ]
        }
      ],
      "components/methodology": [
        {
          "file": "CodeBlock.js",
          "imports": [
            "react",
            "prop-types",
            "react-syntax-highlighter",
            "react-syntax-highlighter/dist/esm/styles/prism",
            "@mui/material",
            "@mui/icons-material/ContentCopy",
            "@mui/icons-material/Check"
          ]
        },
        {
          "file": "MethodologyContentWrapper.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "./MethodologySection",
            "@mui/material/styles",
            "../../utils/methodologyContent"
          ]
        },
        {
          "file": "MethodologyModal.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/icons-material/Close",
            "./MethodologyContentWrapper",
            "@mui/material/styles"
          ]
        },
        {
          "file": "MethodologySection.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "./CodeBlock",
            "katex/dist/katex.min.css",
            "react-katex",
            "@mui/material/styles"
          ]
        }
      ],
      "components/spatialAnalysis": [
        {
          "file": "SpatialAnalysis.js",
          "imports": [
            "react",
            "react-redux",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/Map",
            "@mui/icons-material/Timeline",
            "@mui/icons-material/Hub",
            "@mui/icons-material/TrendingUp",
            "@mui/icons-material/Warning",
            "@mui/icons-material/CalendarToday",
            "@mui/icons-material/HealthAndSafety",
            "./features/clusters",
            "./features/autocorrelation",
            "./features/flows",
            "./features/shocks",
            "./features/conflict",
            "./features/seasonal",
            "./features/health",
            "../../slices/flowSlice",
            "../common/ErrorBoundary",
            "../common/LoadingIndicator",
            "../../selectors/optimizedSelectors"
          ]
        },
        {
          "file": "index.js",
          "imports": [
            "./SpatialAnalysis"
          ]
        }
      ],
      "components/spatialAnalysis/atoms": [
        {
          "file": "Legend.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles"
          ]
        },
        {
          "file": "MetricCard.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/Info",
            "@mui/icons-material/TrendingUp",
            "@mui/icons-material/TrendingDown"
          ]
        },
        {
          "file": "Tooltip.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles"
          ]
        }
      ],
      "components/spatialAnalysis/features/autocorrelation": [
        {
          "file": "ClusterMatrix.js",
          "imports": [
            "react",
            "@mui/material",
            "@mui/icons-material/InfoOutlined",
            "@mui/icons-material/ExpandMore",
            "@mui/icons-material/ExpandLess",
            "./types"
          ]
        },
        {
          "file": "LISAMap.js",
          "imports": [
            "react",
            "@mui/material",
            "react-leaflet",
            "leaflet/dist/leaflet.css",
            "./types"
          ]
        },
        {
          "file": "MoranScatterPlot.js",
          "imports": [
            "react",
            "@mui/material",
            "d3-scale",
            "d3-array",
            "./types"
          ]
        },
        {
          "file": "SpatialAnalysisPanel.js",
          "imports": [
            "react",
            "@mui/material",
            "@mui/icons-material/ExpandMore",
            "@mui/icons-material/ExpandLess",
            "@mui/icons-material/InfoOutlined",
            "./types"
          ]
        },
        {
          "file": "SpatialAutocorrelationAnalysis.js",
          "imports": [
            "react",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/Map",
            "@mui/icons-material/ScatterPlot",
            "@mui/icons-material/TableChart",
            "./LISAMap",
            "./MoranScatterPlot",
            "./SpatialAnalysisPanel",
            "./ClusterMatrix",
            "./components/SpatialAnalysisErrorBoundary",
            "./components/SpatialAnalysisOptimizer",
            "./hooks/useSpatialAutocorrelation"
          ]
        },
        {
          "file": "index.js",
          "imports": [
            "./SpatialAutocorrelationAnalysis",
            "./LISAMap",
            "./MoranScatterPlot",
            "./ClusterMatrix",
            "./SpatialAnalysisPanel",
            "./hooks/useSpatialAutocorrelation",
            "./components/SpatialAnalysisOptimizer",
            "./components/SpatialAnalysisErrorBoundary",
            "./types",
            "./utils/spatialCalculations"
          ]
        },
        {
          "file": "types.js",
          "imports": [
            "prop-types"
          ]
        },
        {
          "file": "types.ts",
          "imports": []
        }
      ],
      "components/spatialAnalysis/features/autocorrelation/components": [
        {
          "file": "SpatialAnalysisErrorBoundary.js",
          "imports": [
            "react",
            "@mui/material",
            "@mui/icons-material/Refresh",
            "@mui/icons-material/ExpandMore",
            "@mui/icons-material/ExpandLess",
            "@mui/icons-material/ErrorOutline"
          ]
        },
        {
          "file": "SpatialAnalysisOptimizer.js",
          "imports": [
            "react"
          ]
        }
      ],
      "components/spatialAnalysis/features/autocorrelation/hooks": [
        {
          "file": "useSpatialAutocorrelation.js",
          "imports": [
            "react",
            "react-redux",
            "../../../../../selectors/optimizedSelectors",
            "../utils/spatialCalculations",
            "../types"
          ]
        }
      ],
      "components/spatialAnalysis/features/autocorrelation/selectors": [
        {
          "file": "autocorrelationSelectors.js",
          "imports": [
            "@reduxjs/toolkit"
          ]
        }
      ],
      "components/spatialAnalysis/features/autocorrelation/utils/__tests__": [
        {
          "file": "spatialCalculations.test.js",
          "imports": [
            "../spatialCalculations"
          ]
        }
      ],
      "components/spatialAnalysis/features/autocorrelation/utils": [
        {
          "file": "spatialCalculations.js",
          "imports": [
            "d3-array"
          ]
        }
      ],
      "components/spatialAnalysis/features/clusters": [
        {
          "file": "ClusterAnalysis.js",
          "imports": [
            "react",
            "@mui/material",
            "react-redux",
            "@mui/icons-material/Mouse",
            "@mui/icons-material/InfoOutlined",
            "@mui/icons-material/ExpandMore",
            "@mui/icons-material/ExpandLess",
            "../../organisms/ClusterMap",
            "../../atoms/MetricCard",
            "../../molecules/MetricProgress",
            "../../../../hooks/useSpatialSelectors",
            "../../../../selectors/optimizedSelectors",
            "../../hooks/useClusterAnalysis"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        },
        {
          "file": "types.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/features/clusters/utils": [
        {
          "file": "clusterCalculations.js",
          "imports": [
            "../../../utils/spatialUtils",
            "../types"
          ]
        }
      ],
      "components/spatialAnalysis/features/conflict": [
        {
          "file": "ConflictImpactDashboard.js",
          "imports": [
            "react",
            "react-redux",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/Timeline",
            "@mui/icons-material/Map",
            "@mui/icons-material/Assessment",
            "./ConflictMap",
            "./ConflictMetricsPanel",
            "../../molecules/TimeControl",
            "../../atoms/MetricCard",
            "../../../../slices/spatialSlice",
            "../../../../selectors/dateSpecificSelectors"
          ]
        },
        {
          "file": "ConflictMap.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "react-leaflet",
            "chroma-js",
            "../../atoms/Legend",
            "../../atoms/Tooltip",
            "../../molecules/MapControls",
            "../../molecules/BaseMap",
            "../../utils/geoJSONProcessor",
            "../../utils/spatialUtils"
          ]
        },
        {
          "file": "ConflictMetricsPanel.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/TrendingUp",
            "@mui/icons-material/TrendingDown",
            "@mui/icons-material/Warning",
            "../../atoms/MetricCard",
            "../../molecules/MetricProgress"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/features/flows": [
        {
          "file": "FlowDateControl.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/PlayArrow",
            "@mui/icons-material/Pause",
            "@mui/icons-material/SkipPrevious",
            "@mui/icons-material/SkipNext",
            "@mui/icons-material/Speed",
            "lodash"
          ]
        },
        {
          "file": "FlowMap.js",
          "imports": [
            "react",
            "prop-types",
            "react-redux",
            "@mui/material",
            "react-leaflet",
            "leaflet",
            "chroma-js",
            "leaflet/dist/leaflet.css",
            "react-transition-group",
            "../../atoms/Legend",
            "../../molecules/MapControls",
            "./types",
            "../../../../selectors/optimizedSelectors",
            "../../../../slices/flowSlice",
            "./FlowMapTransitions.css"
          ]
        },
        {
          "file": "FlowMetricsPanel.js",
          "imports": [
            "react",
            "prop-types",
            "react-redux",
            "@mui/material",
            "@mui/icons-material/InfoOutlined",
            "@mui/icons-material/ExpandMore",
            "@mui/icons-material/ExpandLess",
            "../../atoms/MetricCard",
            "../../molecules/MetricProgress",
            "./types",
            "../../../../slices/flowSlice"
          ]
        },
        {
          "file": "FlowNetworkAnalysis.js",
          "imports": [
            "react",
            "react-redux",
            "@mui/material",
            "@mui/icons-material/InfoOutlined",
            "@mui/icons-material/ExpandMore",
            "@mui/icons-material/ExpandLess",
            "./FlowMap",
            "./FlowMetricsPanel",
            "./FlowDateControl",
            "../../atoms/MetricCard",
            "../../../../slices/spatialSlice",
            "../../../../hooks/useFlowDataManager",
            "../../../../slices/flowSlice",
            "./types"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        },
        {
          "file": "types.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/features/health": [
        {
          "file": "MarketHealthMetrics.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "../../atoms/MetricCard",
            "../../molecules/MetricProgress"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/features/network": [
        {
          "file": "NetworkGraph.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "react-force-graph",
            "chroma-js",
            "../../utils/networkAnalysis",
            "../../utils/spatialUtils"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/features/seasonal": [
        {
          "file": "SeasonalLegend.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/TrendingUp",
            "@mui/icons-material/TrendingDown",
            "@mui/icons-material/CalendarToday",
            "react"
          ]
        },
        {
          "file": "SeasonalMap.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "react-leaflet",
            "chroma-js",
            "../../atoms/Legend",
            "../../atoms/Tooltip",
            "../../molecules/MapControls",
            "../../molecules/BaseMap",
            "../../utils/geoJSONProcessor",
            "../../utils/spatialUtils"
          ]
        },
        {
          "file": "SeasonalPriceMap.js",
          "imports": [
            "react",
            "react-redux",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/CalendarViewMonth",
            "@mui/icons-material/Timeline",
            "@mui/icons-material/Assessment",
            "./SeasonalMap",
            "./SeasonalLegend",
            "../../atoms/MetricCard",
            "../../molecules/TimeControl",
            "../../../../slices/spatialSlice",
            "../../../../selectors/dateSpecificSelectors"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/features/shocks": [
        {
          "file": "ShockLegend.js",
          "imports": [
            "react",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/TrendingUp",
            "@mui/icons-material/TrendingDown",
            "./types"
          ]
        },
        {
          "file": "ShockMap.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "react-leaflet",
            "chroma-js",
            "../../atoms/Tooltip",
            "../../molecules/MapControls",
            "../../molecules/BaseMap",
            "../../utils/geoJSONProcessor",
            "../../utils/spatialUtils",
            "./types"
          ]
        },
        {
          "file": "ShockPropagationMap.js",
          "imports": [
            "react",
            "react-redux",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/InfoOutlined",
            "@mui/icons-material/ExpandMore",
            "@mui/icons-material/ExpandLess",
            "./ShockMap",
            "./ShockLegend",
            "../../molecules/TimeControl",
            "../../atoms/MetricCard",
            "../../../../slices/spatialSlice",
            "../../../../selectors/dateSpecificSelectors",
            "./types"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        },
        {
          "file": "types.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/hooks": [
        {
          "file": "useClusterAnalysis.js",
          "imports": [
            "react",
            "react-redux",
            "../../../utils/backgroundMonitor",
            "../features/clusters/utils/clusterCalculations"
          ]
        },
        {
          "file": "useConflictAnalysis.js",
          "imports": [
            "react",
            "react-redux",
            "../../../utils/backgroundMonitor",
            "../../../selectors/spatialAnalysisSelectors"
          ]
        },
        {
          "file": "useFlowAnalysis.js",
          "imports": [
            "react",
            "react-redux",
            "../../../utils/backgroundMonitor",
            "../../../slices/flowSlice",
            "../features/flows/types"
          ]
        },
        {
          "file": "useMarketHealth.js",
          "imports": [
            "react",
            "react-redux",
            "../../../utils/backgroundMonitor",
            "../../../selectors/spatialAnalysisSelectors"
          ]
        },
        {
          "file": "useSeasonalAnalysis.js",
          "imports": [
            "react",
            "react-redux",
            "../../../utils/backgroundMonitor",
            "../../../selectors/spatialAnalysisSelectors"
          ]
        },
        {
          "file": "useShockAnalysis.js",
          "imports": [
            "react",
            "react-redux",
            "../../../utils/backgroundMonitor",
            "../../../selectors/spatialAnalysisSelectors"
          ]
        },
        {
          "file": "useSpatialAutocorrelation.js",
          "imports": [
            "react",
            "react-redux",
            "../../../utils/backgroundMonitor",
            "../../../selectors/spatialAnalysisSelectors",
            "../../../selectors/optimizedSelectors"
          ]
        }
      ],
      "components/spatialAnalysis/molecules": [
        {
          "file": "BaseMap.js",
          "imports": [
            "react",
            "prop-types",
            "react-leaflet"
          ]
        },
        {
          "file": "MapControls.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/Add",
            "@mui/icons-material/Remove",
            "@mui/icons-material/Refresh",
            "@mui/icons-material/CenterFocusStrong"
          ]
        },
        {
          "file": "MetricProgress.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/TrendingUp",
            "@mui/icons-material/TrendingDown",
            "@mui/icons-material/Info"
          ]
        },
        {
          "file": "TimeControl.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material",
            "@mui/material/styles",
            "@mui/icons-material/PlayArrow",
            "@mui/icons-material/Pause",
            "@mui/icons-material/SkipPrevious",
            "@mui/icons-material/SkipNext",
            "@mui/icons-material/Speed",
            "lodash"
          ]
        }
      ],
      "components/spatialAnalysis/organisms": [
        {
          "file": "ClusterMap.js",
          "imports": [
            "react",
            "prop-types",
            "@mui/material/styles",
            "@mui/material",
            "react-leaflet",
            "leaflet",
            "./ClusterMap.css",
            "../../../hooks/useWindowWidth"
          ]
        },
        {
          "file": "FlowMap.js",
          "imports": [
            "react",
            "prop-types",
            "react-leaflet",
            "@mui/material",
            "@mui/material/styles",
            "chroma-js",
            "leaflet",
            "../atoms/Legend",
            "../atoms/Tooltip",
            "../molecules/MapControls",
            "../utils/spatialUtils",
            "../features/flows/types"
          ]
        },
        {
          "file": "LISAMap.js",
          "imports": [
            "react",
            "prop-types",
            "react-leaflet",
            "@mui/material",
            "@mui/material/styles",
            "leaflet",
            "../atoms/Legend",
            "../atoms/Tooltip",
            "../molecules/MapControls",
            "../utils/spatialUtils"
          ]
        }
      ],
      "components/spatialAnalysis/styles": [
        {
          "file": "spatialAnalysisStyles.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/types": [
        {
          "file": "index.js",
          "imports": []
        }
      ],
      "components/spatialAnalysis/utils": [
        {
          "file": "clusterUtils.js",
          "imports": [
            "../types"
          ]
        },
        {
          "file": "geoJSONProcessor.js",
          "imports": [
            "./spatialUtils"
          ]
        },
        {
          "file": "networkAnalysis.js",
          "imports": [
            "./spatialUtils"
          ]
        },
        {
          "file": "spatialUtils.js",
          "imports": []
        }
      ],
      "components/utils": [
        {
          "file": "StateExporter.js",
          "imports": [
            "react",
            "react-redux",
            "@mui/material",
            "@mui/icons-material/Download"
          ]
        }
      ],
      "config": [
        {
          "file": "appConfig.js",
          "imports": []
        }
      ],
      "constants": [
        {
          "file": "index.js",
          "imports": []
        }
      ],
      "context": [
        {
          "file": "DataContext.js",
          "imports": [
            "react",
            "prop-types"
          ]
        },
        {
          "file": "SpatialDataContext.js",
          "imports": [
            "react",
            "prop-types",
            "react-redux",
            "../slices/spatialSlice",
            "../utils/backgroundMonitor"
          ]
        },
        {
          "file": "WorkerContext.js",
          "imports": [
            "react",
            "@/hooks"
          ]
        }
      ],
      "hooks": [
        {
          "file": "dataHooks.js",
          "imports": [
            "react",
            "react-redux",
            "../slices/spatialSlice",
            "../slices/ecmSlice",
            "../types/dataTypes",
            "../utils/backgroundMonitor",
            "../utils/dataUtils",
            "../utils/dataCache"
          ]
        },
        {
          "file": "index.js",
          "imports": [
            "./dataHooks",
            "./uiHooks"
          ]
        },
        {
          "file": "uiHooks.js",
          "imports": [
            "react",
            "uuid",
            "../utils/appUtils"
          ]
        },
        {
          "file": "useAppState.js",
          "imports": [
            "react-redux",
            "react",
            "lodash",
            "../slices/spatialSlice",
            "./useDashboardData",
            "../store/welcomeModalSlice",
            "../styles/theme"
          ]
        },
        {
          "file": "useClusterEfficiency.js",
          "imports": [
            "react",
            "react-redux",
            "../components/analysis/spatial-analysis/utils/clusterAnalysis"
          ]
        },
        {
          "file": "useDashboardData.js",
          "imports": [
            "react",
            "react-redux",
            "../slices/spatialSlice",
            "../utils/backgroundMonitor",
            "lodash"
          ]
        },
        {
          "file": "useFlowDataManager.js",
          "imports": [
            "react",
            "react-redux",
            "../slices/flowSlice"
          ]
        },
        {
          "file": "useMarketAnalysis.js",
          "imports": [
            "react",
            "lodash",
            "../utils/backgroundMonitor",
            "../utils/numberValidation",
            "../utils/spatialUtils"
          ]
        },
        {
          "file": "usePrecomputedData.js",
          "imports": [
            "react",
            "react-redux",
            "../utils/PrecomputedDataManager",
            "../utils/backgroundMonitor",
            "../slices/spatialSlice"
          ]
        },
        {
          "file": "useSpatialAutocorrelation.js",
          "imports": [
            "react",
            "react-redux",
            "../../../../selectors/optimizedSelectors",
            "../utils/spatialAnalysis",
            "../../../../utils/backgroundMonitor"
          ]
        },
        {
          "file": "useSpatialData.js",
          "imports": [
            "react",
            "react-redux",
            "../store",
            "../utils/dataLoader",
            "../slices/spatialSlice"
          ]
        },
        {
          "file": "useSpatialSelectors.js",
          "imports": [
            "react-redux",
            "../selectors/optimizedSelectors"
          ]
        },
        {
          "file": "useUnifiedData.js",
          "imports": [
            "react",
            "../utils/dataUtils",
            "lodash"
          ]
        },
        {
          "file": "useWindowWidth.js",
          "imports": [
            "react"
          ]
        }
      ],
      "middleware": [
        {
          "file": "batchMiddleware.js",
          "imports": [
            "lodash"
          ]
        },
        {
          "file": "optimizedMiddleware.js",
          "imports": [
            "../utils/backgroundMonitor",
            "lodash"
          ]
        },
        {
          "file": "requestMiddleware.js",
          "imports": [
            "../utils/backgroundMonitor"
          ]
        },
        {
          "file": "spatialMiddleware.js",
          "imports": [
            "../utils/backgroundMonitor"
          ]
        }
      ],
      "routes": [
        {
          "file": "AnalysisRoutes.js",
          "imports": [
            "react",
            "./components/common/LoadingSpinner"
          ]
        }
      ],
      "selectors": [
        {
          "file": "dateSpecificSelectors.js",
          "imports": [
            "@reduxjs/toolkit",
            "../components/spatialAnalysis/features/flows/types"
          ]
        },
        {
          "file": "optimizedSelectors.js",
          "imports": [
            "@reduxjs/toolkit",
            "reselect",
            "lodash/isEqual",
            "lodash",
            "../components/spatialAnalysis/utils/spatialUtils"
          ]
        },
        {
          "file": "spatialAnalysisSelectors.js",
          "imports": [
            "@reduxjs/toolkit",
            "./optimizedSelectors",
            "../components/spatialAnalysis/types"
          ]
        }
      ],
      "slices": [
        {
          "file": "ecmSlice.js",
          "imports": [
            "@reduxjs/toolkit",
            "reselect",
            "lodash",
            "../utils/dataUtils",
            "../utils/backgroundMonitor"
          ]
        },
        {
          "file": "flowSlice.js",
          "imports": [
            "@reduxjs/toolkit",
            "reselect",
            "papaparse",
            "lodash",
            "../utils/backgroundMonitor",
            "../utils/coordinateUtils",
            "../utils/dataUtils"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        },
        {
          "file": "priceDiffSlice.js",
          "imports": [
            "@reduxjs/toolkit",
            "../utils/dataUtils"
          ]
        },
        {
          "file": "spatialSlice.js",
          "imports": [
            "@reduxjs/toolkit",
            "reselect",
            "lodash",
            "../utils/spatialDataHandler",
            "../types/dataTypes",
            "../utils/backgroundMonitor",
            "../workers/enhancedWorkerSystem",
            "../utils/marketAnalysisUtils",
            "../constants/index"
          ]
        },
        {
          "file": "themeSlice.js",
          "imports": [
            "@reduxjs/toolkit"
          ]
        }
      ],
      "store": [
        {
          "file": "configureStore.js",
          "imports": [
            "@reduxjs/toolkit",
            "../slices/spatialSlice",
            "../slices/themeSlice",
            "./welcomeModalSlice",
            "../slices/ecmSlice",
            "../slices/flowSlice",
            "../middleware/batchMiddleware",
            "../middleware/spatialMiddleware",
            "../utils/spatialDataHandler",
            "../utils/backgroundMonitor"
          ]
        },
        {
          "file": "createStore.js",
          "imports": [
            "@reduxjs/toolkit",
            "redux-logger",
            "../slices/themeSlice",
            "./welcomeModalSlice",
            "../utils/backgroundMonitor"
          ]
        },
        {
          "file": "index.js",
          "imports": [
            "./createStore",
            "../utils/backgroundMonitor",
            "../slices/themeSlice"
          ]
        },
        {
          "file": "welcomeModalSlice.js",
          "imports": [
            "@reduxjs/toolkit"
          ]
        }
      ],
      "styles": [
        {
          "file": "LayoutStyles.js",
          "imports": [
            "@mui/material/styles",
            "@mui/material"
          ]
        },
        {
          "file": "analysisStyles.js",
          "imports": [
            "@mui/material/styles"
          ]
        },
        {
          "file": "theme.js",
          "imports": [
            "@mui/material/styles"
          ]
        }
      ],
      "types": [
        {
          "file": "dataTypes.js",
          "imports": []
        }
      ],
      "utils": [
        {
          "file": "PrecomputedDataManager.js",
          "imports": [
            "./backgroundMonitor",
            "./pathResolver",
            "./dataCache",
            "./numberValidation",
            "./spatialUtils",
            "papaparse",
            "lodash"
          ]
        },
        {
          "file": "ReduxDebugWrapper.js",
          "imports": [
            "react",
            "react-redux",
            "prop-types"
          ]
        },
        {
          "file": "appUtils.js",
          "imports": [
            "date-fns"
          ]
        },
        {
          "file": "backgroundMonitor.js",
          "imports": []
        },
        {
          "file": "colorScales.js",
          "imports": [
            "d3",
            "../constants"
          ]
        },
        {
          "file": "colorUtils.js",
          "imports": []
        },
        {
          "file": "coordinateUtils.js",
          "imports": []
        },
        {
          "file": "dataCache.js",
          "imports": [
            "./backgroundMonitor"
          ]
        },
        {
          "file": "dataLoader.js",
          "imports": [
            "./backgroundMonitor"
          ]
        },
        {
          "file": "dataProcessingUtils.js",
          "imports": []
        },
        {
          "file": "dataProcessor.js",
          "imports": [
            "./appUtils"
          ]
        },
        {
          "file": "dataTransformations.js",
          "imports": [
            "lodash",
            "./spatialUtils"
          ]
        },
        {
          "file": "dataUtils.js",
          "imports": [
            "./pathResolver"
          ]
        },
        {
          "file": "debugUtils.js",
          "imports": [
            "react",
            "react-redux",
            "prop-types",
            "./backgroundMonitor",
            "../types/dataTypes"
          ]
        },
        {
          "file": "dynamicImports.js",
          "imports": [
            "react"
          ]
        },
        {
          "file": "geoJSONProcessor.js",
          "imports": [
            "./backgroundMonitor"
          ]
        },
        {
          "file": "geometryValidation.js",
          "imports": []
        },
        {
          "file": "index.js",
          "imports": []
        },
        {
          "file": "leafletSetup.js",
          "imports": [
            "leaflet",
            "leaflet/dist/images/marker-icon-2x.png",
            "leaflet/dist/images/marker-icon.png",
            "leaflet/dist/images/marker-shadow.png"
          ]
        },
        {
          "file": "marketAnalysisUtils.js",
          "imports": [
            "../constants/index",
            "lodash"
          ]
        },
        {
          "file": "methodologyContent.js",
          "imports": []
        },
        {
          "file": "networkDebug.js",
          "imports": []
        },
        {
          "file": "numberValidation.js",
          "imports": []
        },
        {
          "file": "optimizedSelectors.js",
          "imports": [
            "@reduxjs/toolkit",
            "reselect",
            "lodash"
          ]
        },
        {
          "file": "pathResolver.js",
          "imports": [
            "papaparse"
          ]
        },
        {
          "file": "pathValidator.js",
          "imports": []
        },
        {
          "file": "polygonNormalizer.js",
          "imports": []
        },
        {
          "file": "regionMappingValidator.js",
          "imports": []
        },
        {
          "file": "regressionDataProcessor.js",
          "imports": [
            "lodash",
            "./spatialDataHandler"
          ]
        },
        {
          "file": "shockAnalysisDebug.js",
          "imports": []
        },
        {
          "file": "spatialAnalysisUtils.js",
          "imports": []
        },
        {
          "file": "spatialDataHandler.js",
          "imports": [
            "papaparse",
            "lodash",
            "./appUtils",
            "./dataUtils",
            "./pathResolver",
            "./pathValidator",
            "../types/dataTypes",
            "../constants/index",
            "./workerManager",
            "./backgroundMonitor",
            "./polygonNormalizer"
          ]
        },
        {
          "file": "spatialDataOptimizer.js",
          "imports": [
            "./backgroundMonitor",
            "./workerManager"
          ]
        },
        {
          "file": "spatialUtils.js",
          "imports": [
            "lodash"
          ]
        },
        {
          "file": "workerManager.js",
          "imports": []
        },
        {
          "file": "workerPool.js",
          "imports": [
            "./backgroundMonitor"
          ]
        }
      ],
      "utils/core": [
        {
          "file": "dataProcessor.js",
          "imports": [
            "./monitoringUtils"
          ]
        },
        {
          "file": "index.js",
          "imports": []
        },
        {
          "file": "spatialProcessor.js",
          "imports": [
            "./monitoringUtils"
          ]
        }
      ],
      "workers": [
        {
          "file": "enhancedWorkerSystem.js",
          "imports": [
            "uuid",
            "eventemitter3",
            "react"
          ]
        },
        {
          "file": "processTimeSeriesData.js",
          "imports": []
        },
        {
          "file": "spatialWorker.js",
          "imports": [
            "../utils/marketAnalysisUtils"
          ]
        }
      ]
    },
    "exports": {}
  },
  "summary": {
    "totalFiles": 203,
    "totalDependencies": 262,
    "directories": [
      "bootstrap",
      "config",
      "providers",
      "app",
      "ecm",
      "price-differential",
      "components",
      "utils",
      "spatial",
      "tvmii",
      "analysis",
      "common",
      "debug",
      "documentation",
      "interactive_graph",
      "methodology",
      "atoms",
      "hooks",
      "selectors",
      "__tests__",
      "autocorrelation",
      "clusters",
      "conflict",
      "flows",
      "health",
      "network",
      "seasonal",
      "shocks",
      "features",
      "molecules",
      "organisms",
      "styles",
      "types",
      "spatialAnalysis",
      "constants",
      "context",
      "middleware",
      "store",
      "workers",
      "core",
      "market",
      "data",
      "domains",
      "api",
      "monitoring",
      "persistence",
      "infrastructure",
      "routes",
      "slices"
    ]
  }
}